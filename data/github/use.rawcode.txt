public boolean containsKey ( Name key ) { return containsKey ( "" + key ) ; } 
public final void store ( OutputStream stream , char [ ] password ) throws KeyStoreException , IOException , NoSuchAlgorithmException , CertificateException { if ( ! isInit ) { throwNotInitialized ( ) ; } implSpi . engineStore ( stream , password ) ; } 
@ SuppressWarnings ( "unchecked" ) public RegistryContext ( String host , int port , Hashtable < ? , ? > env ) throws NamingException { environment = ( env == null ) ? new Hashtable < String , Object > ( 5 ) : ( Hashtable < String , Object > ) env ; if ( environment . get ( SECURITY_MGR ) != null ) { installSecurityMgr ( ) ; } if ( ( host != null ) && ( host . charAt ( 0 ) == '[' ) ) { host = host . substring ( 1 , host . length ( ) - 1 ) ; } RMIClientSocketFactory socketFactory = ( RMIClientSocketFactory ) environment . get ( SOCKET_FACTORY ) ; registry = getRegistry ( host , port , socketFactory ) ; this . host = host ; this . port = port ; } 
public int singleNumberWithMap ( int [ ] nums ) { Map < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i : nums ) { if ( map . containsKey ( i ) ) { map . put ( i , map . get ( i ) + 1 ) ; } else { map . put ( i , 1 ) ; } } for ( Map . Entry < Integer , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) < 3 ) { return entry . getKey ( ) ; } } for ( Map . Entry < Integer , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) < 3 ) { return entry . getKey ( ) ; } } for ( Object o : map . entrySet ( ) ) { Map . Entry entry = ( Map . Entry ) o ; if ( ( Integer ) entry . getValue ( ) == 1 ) { return ( Integer ) entry . getKey ( ) ; } } return 0 ; } 
public void setActions ( Action [ ] actions ) { this . actions = ( actions == null ) ? null : actions . clone ( ) ; } 
public void pauseProcessing ( final double time ) { Vector < Core > cores = this . getCores ( ) ; Iterator < Core > iter = cores . iterator ( ) ; while ( iter . hasNext ( ) ) { Core core = iter . next ( ) ; core . pauseProcessing ( time ) ; } } 
public float bottom ( float margin ) { return pageSize . bottom ( marginBottom + margin ) ; } 
public Icon getIconForButton ( String buttonName ) { String fileName = ( String ) BUTTON_NAMES . get ( buttonName ) ; if ( fileName == null ) return null ; ImageIcon icon = ( ImageIcon ) BUTTON_CACHE . get ( fileName ) ; if ( icon == NULL ) return null ; if ( icon != null ) return icon ; try { String retrieveName ; if ( UISettings . SMALL_ICONS . getValue ( ) ) retrieveName = fileName + "_small" ; else retrieveName = fileName + "_large" ; icon = ResourceManager . getThemeImage ( retrieveName ) ; BUTTON_CACHE . put ( fileName , icon ) ; } catch ( MissingResourceException mre ) { try { icon = ResourceManager . getThemeImage ( fileName ) ; BUTTON_CACHE . put ( fileName , icon ) ; } catch ( MissingResourceException mre2 ) { BUTTON_CACHE . put ( fileName , NULL ) ; } } return icon ; } 
public static String encodeObject ( java . io . Serializable serializableObject ) { return encodeObject ( serializableObject , NO_OPTIONS ) ; } 
public void unparsedEntityDecl ( String name , XMLResourceIdentifier identifier , String notation , Augmentations augs ) throws XNIException { if ( fValidation ) { fNDataDeclNotations . put ( name , notation ) ; } if ( fDTDGrammar != null ) fDTDGrammar . unparsedEntityDecl ( name , identifier , notation , augs ) ; if ( fDTDHandler != null ) { fDTDHandler . unparsedEntityDecl ( name , identifier , notation , augs ) ; } } 
@ Override public void close ( ) throws IOException { synchronized ( lock ) { if ( decoder != null ) { decoder . reset ( ) ; } decoder = null ; if ( in != null ) { in . close ( ) ; in = null ; } } } 
public RGBColor toGreyScale ( ) { return new RGBColor ( 0.30 * getRed ( ) + 0.59 * getGreen ( ) + 0.11 * getBlue ( ) ) ; } 
public Builder before ( Animator anim ) { Node node = mNodeMap . get ( anim ) ; if ( node == null ) { node = new Node ( anim ) ; mNodeMap . put ( anim , node ) ; mNodes . add ( node ) ; } Dependency dependency = new Dependency ( mCurrentNode , Dependency . AFTER ) ; node . addDependency ( dependency ) ; return this ; } 
final void runWorker ( Worker w ) { Thread wt = Thread . currentThread ( ) ; Runnable task = w . firstTask ; w . firstTask = null ; w . unlock ( ) ; boolean completedAbruptly = true ; try { while ( task != null || ( task = getTask ( ) ) != null ) { w . lock ( ) ; if ( ( runStateAtLeast ( ctl . get ( ) , STOP ) || ( Thread . interrupted ( ) && runStateAtLeast ( ctl . get ( ) , STOP ) ) ) && ! wt . isInterrupted ( ) ) wt . interrupt ( ) ; try { beforeExecute ( wt , task ) ; Throwable thrown = null ; try { runTask ( task ) ; } catch ( RuntimeException x ) { thrown = x ; throw x ; } catch ( Error x ) { thrown = x ; throw x ; } catch ( Throwable x ) { thrown = x ; throw new Error ( x ) ; } finally { afterExecute ( task , thrown ) ; } } finally { task = null ; w . completedTasks ++ ; w . unlock ( ) ; } } completedAbruptly = false ; } finally { processWorkerExit ( w , completedAbruptly ) ; } } 
public Package getPackage ( ) { return Package . getPackage ( this ) ; } 
public void doPostSubmitCall ( Item submitItem , HtmlForm form ) { if ( form == null ) { return ; } StringBuffer sb = new StringBuffer ( ) ; Hashtable elements = form . getFormElements ( this . formListener , submitItem ) ; Enumeration enumeration = elements . keys ( ) ; while ( enumeration . hasMoreElements ( ) ) { String name = ( String ) enumeration . nextElement ( ) ; String value = ( String ) elements . get ( name ) ; value = TextUtil . encodeUrl ( value ) ; sb . append ( name ) . append ( '=' ) . append ( value ) ; if ( enumeration . hasMoreElements ( ) ) { sb . append ( '&' ) ; } } this . browser . go ( this . browser . makeAbsoluteURL ( form . getAction ( ) ) , sb . toString ( ) ) ; } 
public static String getNextTag ( String xmlData , int position ) { String nextTag = null ; if ( xmlData != null && ! xmlData . isEmpty ( ) && position < xmlData . length ( ) && xmlData . substring ( position ) . contains ( "<" ) ) { while ( xmlData . charAt ( position ) != '<' ) { position ++ ; } int startIndex = position ; if ( xmlData . substring ( position ) . contains ( ">" ) ) { while ( xmlData . charAt ( position ) != '>' ) { position ++ ; } nextTag = xmlData . substring ( startIndex , position + 1 ) ; } } return nextTag ; } 
public Date engineGetCreationDate ( String alias ) { KeyEntry entry = entries . get ( alias . toLowerCase ( ) ) ; if ( entry != null ) { return new Date ( entry . date . getTime ( ) ) ; } else { return null ; } } 
public static String encode ( String p ) { if ( p == null ) { return "" ; } if ( ! "1.0" . equals ( outVersion ) ) { return p ; } try { String p1 = URLEncoder . encode ( p , CHAR_SET ) ; return p1 ; } catch ( UnsupportedEncodingException e ) { log . warn ( "System-doesn't-support-" + CHAR_SET , e ) ; return p ; } } 
public double dotProduct ( OpenMapRealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; boolean thisIsSmaller = entries . size ( ) < v . entries . size ( ) ; Iterator iter = thisIsSmaller ? entries . iterator ( ) : v . entries . iterator ( ) ; OpenIntToDoubleHashMap larger = thisIsSmaller ? v . entries : entries ; double d = 0 ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; d += iter . value ( ) * larger . get ( iter . key ( ) ) ; } return d ; } 
public void addClientSocketListener ( ClientSocketListener listener ) { if ( listener == null ) throw new NullPointerException ( ) ; listeners . add ( listener ) ; } 
public static void addURL ( URL u ) throws IOException { ClassloaderUtil clu = new ClassloaderUtil ( ) ; URLClassLoader sysLoader = ( URLClassLoader ) clu . getClass ( ) . getClassLoader ( ) ; URL urls [ ] = sysLoader . getURLs ( ) ; for ( URL url : urls ) { if ( url . toString ( ) . toLowerCase ( ) . equals ( u . toString ( ) . toLowerCase ( ) ) ) { System . err . println ( "URL-" + u + "-is-already-in-the-CLASSPATH" ) ; return ; } } Class < ? > sysclass = URLClassLoader . class ; try { Method method = sysclass . getDeclaredMethod ( "addURL" , parameters ) ; method . setAccessible ( true ) ; method . invoke ( sysLoader , new Object [ ] { u } ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; throw new IOException ( "Error,-could-not-add-URL-to-system-classloader" ) ; } } 
final void addProcessToGcListLocked ( ProcessRecord proc ) { boolean added = false ; for ( int i = mProcessesToGc . size ( ) - 1 ; i >= 0 ; i -- ) { if ( mProcessesToGc . get ( i ) . lastRequestedGc < proc . lastRequestedGc ) { added = true ; mProcessesToGc . add ( i + 1 , proc ) ; break ; } } if ( ! added ) { mProcessesToGc . add ( 0 , proc ) ; } } 
public static void snapshot ( ) { Dimension dim = getInstance ( ) . component . getPreferredSize ( ) ; java . awt . Rectangle rect = new java . awt . Rectangle ( 0 , 0 , dim . width , dim . height ) ; BufferedImage image = new BufferedImage ( rect . width , rect . height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = image . getGraphics ( ) ; g . setColor ( java . awt . Color . WHITE ) ; g . fillRect ( 0 , 0 , rect . width , rect . height ) ; g . setColor ( java . awt . Color . BLACK ) ; getInstance ( ) . component . paintComponent ( g ) ; float factor = 0.8f ; float base = 255f * ( 1f - factor ) ; RescaleOp op = new RescaleOp ( factor , base , null ) ; BufferedImage filteredImage = new BufferedImage ( image . getWidth ( ) , image . getHeight ( ) , image . getType ( ) ) ; op . filter ( image , filteredImage ) ; getInstance ( ) . background = filteredImage ; getInstance ( ) . component . repaint ( ) ; } 
public static SecureRandom getInstance ( String algorithm ) throws NoSuchAlgorithmException { if ( algorithm == null ) { throw new NullPointerException ( ) ; } synchronized ( engine ) { engine . getInstance ( algorithm , null ) ; return new SecureRandom ( ( SecureRandomSpi ) engine . spi , engine . provider , algorithm ) ; } } 
static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { final int lastDot = className . lastIndexOf ( "." ) ; String packageName = className ; if ( lastDot != - 1 ) packageName = className . substring ( 0 , lastDot ) ; security . checkPackageAccess ( packageName ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } 
@ Override public java . lang . String getProjetoTag ( ) { return _template . getProjetoTag ( ) ; } 
@ Override public XMLEventReader createXMLEventReader ( Source source ) throws XMLStreamException { try { if ( source instanceof StreamSource ) { StreamSource ss = ( StreamSource ) source ; return new WbXmlEventReader ( ss . getInputStream ( ) , ( WbXmlDefinition ) props . get ( DEFINITION_PROPERTY ) ) ; } else { throw new XMLStreamException ( "WBXML-only-support-StreamSource-with-InputStream!" ) ; } } catch ( IOException e ) { throw new XMLStreamException ( e ) ; } } 
private void sendError ( String status , String msg ) throws InterruptedException { sendResponse ( status , MIME_PLAINTEXT , null , new ByteArrayInputStream ( msg . getBytes ( ) ) ) ; throw new InterruptedException ( ) ; } 
protected java . util . Vector _getLinks ( ) { java . util . Vector links = new java . util . Vector ( ) ; return links ; } 
public void saveOffsets ( Context context ) { String str = "" ; for ( Map . Entry < Integer , Long > entry : _monitor . getOffsets ( ) . entrySet ( ) ) str += entry . getKey ( ) + "-" + entry . getValue ( ) + "," ; Utils . saveString ( PREF_OFFSETS , str , context ) ; } 
public static String createGetUsersResponse ( final List < User > userList , final String nonce , final ICryptoUtils cryptoUtils ) throws ParserConfigurationException , TransformerException { final Document xmlResponse = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . newDocument ( ) ; Element root = null ; Element users = null ; Element user = null ; Element leaf = null ; User userObject = null ; xmlResponse . setXmlStandalone ( true ) ; root = xmlResponse . createElementNS ( NS_URI , PREFIX + RESPONSE ) ; xmlResponse . appendChild ( root ) ; users = xmlResponse . createElement ( PREFIX + USERS ) ; root . appendChild ( users ) ; if ( userList != null ) { for ( int i = 0 ; i < userList . size ( ) ; i ++ ) { userObject = userList . get ( i ) ; user = xmlResponse . createElement ( PREFIX + USER ) ; users . appendChild ( user ) ; leaf = xmlResponse . createElement ( PREFIX + USER_ID ) ; leaf . setTextContent ( cryptoUtils . encodeBase64 ( userObject . getUserID ( ) ) ) ; user . appendChild ( leaf ) ; leaf = xmlResponse . createElement ( PREFIX + EMAIL ) ; leaf . setTextContent ( userObject . getEmailAddress ( ) ) ; user . appendChild ( leaf ) ; } } leaf = xmlResponse . createElement ( PREFIX + NONCE ) ; leaf . setTextContent ( nonce ) ; root . appendChild ( leaf ) ; xmlResponse . normalizeDocument ( ) ; return convertDomToString ( new DOMSource ( xmlResponse ) ) ; } 
public T createElement ( String token ) throws IOException , IllegalArgumentException , JFugueException , ParserError { return createElement ( new PushbackReader ( new StringReader ( token ) ) , Environment . getInstance ( ) ) ; } 
public boolean isFocused ( ) { if ( m_Control == null ) return false ; return m_Control . isFocusControl ( ) ; } 
private static void notifyUserDataHandlers ( short operation , Node source , NodeImpl destination ) { if ( ! ( source instanceof NodeImpl ) ) { return ; } NodeImpl srcImpl = ( NodeImpl ) source ; if ( srcImpl . document == null ) { return ; } for ( Map . Entry < String , UserData > entry : srcImpl . document . getUserDataMapForRead ( srcImpl ) . entrySet ( ) ) { UserData userData = entry . getValue ( ) ; if ( userData . handler != null ) { userData . handler . handle ( operation , entry . getKey ( ) , userData . value , source , destination ) ; } } } 
public static long getFreeDiskSpace ( boolean checkInternal ) { String status = Environment . getExternalStorageState ( ) ; long freeSpace = 0 ; if ( status . equals ( Environment . MEDIA_MOUNTED ) ) { freeSpace = freeSpaceCalculation ( Environment . getExternalStorageDirectory ( ) . getPath ( ) ) ; } else if ( checkInternal ) { freeSpace = freeSpaceCalculation ( "/" ) ; } else { return - 1 ; } return freeSpace ; } 
public synchronized void setLocaleProvider ( LocaleProvider provider ) { if ( provider != this . localeProvider ) { this . localeProvider = provider ; localeCollectorCache . clear ( ) ; } } 
public void removePropertyChangeListener ( String name , PropertyChangeListener pcl ) { m_bcSupport . removePropertyChangeListener ( name , pcl ) ; } 
public void setMaximumPoolSize ( int maximumPoolSize ) { if ( maximumPoolSize <= 0 || maximumPoolSize < corePoolSize ) throw new IllegalArgumentException ( ) ; final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { int extra = this . maximumPoolSize - maximumPoolSize ; this . maximumPoolSize = maximumPoolSize ; if ( extra > 0 && poolSize > maximumPoolSize ) { Iterator < Worker > it = workers . iterator ( ) ; while ( it . hasNext ( ) && extra > 0 && poolSize > maximumPoolSize ) { it . next ( ) . interruptIfIdle ( ) ; -- extra ; } } } finally { mainLock . unlock ( ) ; } } 
public void incDfsUsed ( long value ) { used . addAndGet ( value ) ; } 
public Object getValue ( ) { loadFromStore ( ) ; return super . getValue ( ) ; } 
public static boolean hasRotated ( Location first , Location second ) { return first . getPitch ( ) != second . getPitch ( ) || first . getYaw ( ) != second . getYaw ( ) ; } 
public static double [ ] copyOfRange ( double [ ] original , int from , int to ) { int newLength = to - from ; if ( newLength < 0 ) throw new IllegalArgumentException ( from + "->-" + to ) ; double [ ] copy = new double [ newLength ] ; System . arraycopy ( original , from , copy , 0 , Math . min ( original . length - from , newLength ) ) ; return copy ; } 
protected void registerTypeface ( String family , File file ) { try { Method method = Typeface . class . getMethod ( "registerTypeface" , String . class , File . class ) ; method . invoke ( null , family , file ) ; } catch ( NoSuchMethodException e ) { Log . i ( TAG , "registerTypeface-is-not-available-on-non-Spot-Labs-devices." ) ; } catch ( InvocationTargetException e ) { Log . w ( TAG , "Error-registering-typeface" , e ) ; } catch ( IllegalAccessException e ) { Log . w ( TAG , "Error-registering-typeface" , e ) ; } } 
private static String translate ( final String s , final Locale locale ) { try { ResourceBundle bundle = ResourceBundle . getBundle ( "org.apache.commons.math.MessagesResources" , locale ) ; if ( bundle . getLocale ( ) . getLanguage ( ) . equals ( locale . getLanguage ( ) ) ) { return bundle . getString ( s ) ; } } catch ( MissingResourceException mre ) { } return s ; } 
public static String getProperty ( String name ) { if ( manager == null ) { synchronized ( managerLock ) { if ( manager == null ) { manager = new PropertyManager ( propsName ) ; } } } String props = manager . getProp ( name ) ; if ( props == null ) return null ; try { props = new String ( props . getBytes ( "ISO-8859-1" ) ) ; } catch ( Exception e ) { } return props ; } 
public String getGameState ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( mazeIndex + "," + totalTime + "," + score + "," + currentLevelTime + "," + levelCount + "," + pacman . currentNodeIndex + "," + pacman . lastMoveMade + "," + pacman . numberOfLivesRemaining + "," + pacman . hasReceivedExtraLife + "," ) ; for ( Ghost ghost : ghosts . values ( ) ) sb . append ( ghost . currentNodeIndex + "," + ghost . edibleTime + "," + ghost . lairTime + "," + ghost . lastMoveMade + "," ) ; for ( int i = 0 ; i < currentMaze . pillIndices . length ; i ++ ) if ( pills . get ( i ) ) sb . append ( "1" ) ; else sb . append ( "0" ) ; sb . append ( "," ) ; for ( int i = 0 ; i < currentMaze . powerPillIndices . length ; i ++ ) if ( powerPills . get ( i ) ) sb . append ( "1" ) ; else sb . append ( "0" ) ; sb . append ( "," ) ; sb . append ( timeOfLastGlobalReversal ) ; sb . append ( "," ) ; sb . append ( pacmanWasEaten ) ; sb . append ( "," ) ; for ( GHOST ghost : GHOST . values ( ) ) { sb . append ( ghostsEaten . get ( ghost ) ) ; sb . append ( "," ) ; } sb . append ( pillWasEaten ) ; sb . append ( "," ) ; sb . append ( powerPillWasEaten ) ; return sb . toString ( ) ; } 
public static float [ ] trimToCapacity ( float [ ] array , int maxCapacity ) { if ( array . length > maxCapacity ) { float [ ] oldArray = array ; array = new float [ maxCapacity ] ; System . arraycopy ( oldArray , 0 , array , 0 , maxCapacity ) ; } return array ; } 
public void removeElements ( List elements ) { if ( elements . size ( ) > 0 ) { fElements . removeAll ( elements ) ; if ( fTable != null ) { fTable . remove ( elements . toArray ( ) ) ; } dialogFieldChanged ( ) ; } } 
public Accessible getAccessibleChild ( JComponent a , int b ) { Accessible returnValue = ( ( ComponentUI ) ( uis . elementAt ( 0 ) ) ) . getAccessibleChild ( a , b ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . getAccessibleChild ( a , b ) ; } return returnValue ; } 
public static boolean equals ( Locator lhs , Locator rhs ) { return lhs . getLineNumber ( ) == rhs . getLineNumber ( ) && lhs . getColumnNumber ( ) == rhs . getColumnNumber ( ) && equals ( lhs . getSystemId ( ) , rhs . getSystemId ( ) ) && equals ( lhs . getPublicId ( ) , rhs . getPublicId ( ) ) ; } 
public boolean setError ( ) { boolean result = errorState . compareAndSet ( 0 , 1 ) ; if ( result ) { Wrapper wrapper = getRequest ( ) . getWrapper ( ) ; if ( wrapper != null ) { wrapper . incrementErrorCount ( ) ; } } return result ; } 
public void reset ( ) { mDisabled = ! Log . isLoggable ( mTag , Log . VERBOSE ) ; if ( mDisabled ) return ; if ( mSplits == null ) { mSplits = new ArrayList < Long > ( ) ; mSplitLabels = new ArrayList < String > ( ) ; } else { mSplits . clear ( ) ; mSplitLabels . clear ( ) ; } addSplit ( null ) ; } 
public java . sql . ResultSetMetaData getMetaData ( ) throws java . sql . SQLException { checkClosed ( ) ; return new com . mysql . jdbc . ResultSetMetaData ( fields ) ; } 
public static List < Integer > getSubListIndex ( Object [ ] tofind , Object [ ] tokens ) { if ( tofind . length > tokens . length ) return null ; List < Integer > allIndices = new ArrayList < Integer > ( ) ; boolean matched = false ; int index = - 1 ; int lastUnmatchedIndex = 0 ; for ( int i = 0 ; i < tokens . length ; ) { for ( int j = 0 ; j < tofind . length ; ) { if ( tofind [ j ] . equals ( tokens [ i ] ) ) { index = i ; i ++ ; j ++ ; if ( j == tofind . length ) { matched = true ; break ; } } else { j = 0 ; i = lastUnmatchedIndex + 1 ; lastUnmatchedIndex = i ; index = - 1 ; if ( lastUnmatchedIndex == tokens . length ) break ; } if ( i >= tokens . length ) { index = - 1 ; break ; } } if ( i == tokens . length || matched ) { if ( index >= 0 ) allIndices . add ( index - tofind . length + 1 ) ; matched = false ; lastUnmatchedIndex = index ; } } return allIndices ; } 
public final void wait ( long timeout , int nanos ) throws InterruptedException { if ( timeout < 0 ) { throw new IllegalArgumentException ( "timeout-value-is-negative" ) ; } if ( nanos < 0 || nanos > 999999 ) { throw new IllegalArgumentException ( "nanosecond-timeout-value-out-of-range" ) ; } if ( nanos > 0 ) { timeout ++ ; } wait ( timeout ) ; } 
private static void warning ( String string ) { Log . warning . println ( string ) ; Log . warning . println ( "Unexpected-behavior-may-follow!" ) ; if ( ! java . awt . GraphicsEnvironment . isHeadless ( ) && System . getProperty ( "no.beast.popup" ) == null ) { JOptionPane . showMessageDialog ( null , string + "-Unexpected-behavior-may-follow!" ) ; } } 
@ XmlElementDecl ( namespace = "http://docs.oasis-open.org/wsn/b-2" , name = "NoCurrentMessageOnTopicFault" ) public JAXBElement < NoCurrentMessageOnTopicFaultType > createNoCurrentMessageOnTopicFault ( NoCurrentMessageOnTopicFaultType value ) { return new JAXBElement < NoCurrentMessageOnTopicFaultType > ( _NoCurrentMessageOnTopicFault_QNAME , NoCurrentMessageOnTopicFaultType . class , null , value ) ; } 
public int getPartIndex ( PduPart part ) { return mParts . indexOf ( part ) ; } 
ListDecor ( final Object obj ) throws DecorException { if ( obj == null || obj instanceof Collection ) { this . list = Collection . class . cast ( obj ) ; } else if ( obj instanceof Object [ ] ) { this . list = Arrays . asList ( ( Object [ ] ) obj ) ; } else { throw new DecorException ( String . format ( "Collection-or-array-required,-while-%s-provided" , obj . getClass ( ) . getName ( ) ) ) ; } } 
public DbfFile ( String file , Charset charset ) throws java . io . IOException , DbfFileException { this . charset = charset ; if ( DEBUG ) { System . out . println ( "---->uk.ac.leeds.ccg.dbffile.DbfFile-constructed.-Will-identify-itself-as-DbFi>" ) ; } InputStream in = new FileInputStream ( file ) ; EndianDataInputStream sfile = new EndianDataInputStream ( in ) ; rFile = new RandomAccessFile ( new File ( file ) , "r" ) ; if ( DEBUG ) { System . out . println ( "Dbf-file-has-initinalized" ) ; } init ( sfile ) ; } 
public Values values ( ) { if ( values1 == null ) { values1 = new Values ( this ) ; values2 = new Values ( this ) ; } if ( ! values1 . valid ) { values1 . reset ( ) ; values1 . valid = true ; values2 . valid = false ; return values1 ; } values2 . reset ( ) ; values2 . valid = true ; values1 . valid = false ; return values2 ; } 
private boolean canOwnInitializer ( Symbol sym ) { return ( sym . kind & ( VAR | TYP ) ) != 0 || ( sym . kind == MTH && ( sym . flags ( ) & BLOCK ) != 0 ) ; } 
protected final SerializerFactory findSerializerFactory ( ) { SerializerFactory factory = _serializerFactory ; if ( factory == null ) { factory = SerializerFactory . createDefault ( ) ; _defaultSerializerFactory = factory ; _serializerFactory = factory ; } return factory ; } 
public void xor ( OpenBitSet other ) { int newLen = Math . max ( wlen , other . wlen ) ; ensureCapacityWords ( newLen ) ; assert ( numBits = Math . max ( other . numBits , numBits ) ) >= 0 ; long [ ] thisArr = this . bits ; long [ ] otherArr = other . bits ; int pos = Math . min ( wlen , other . wlen ) ; while ( -- pos >= 0 ) { thisArr [ pos ] ^= otherArr [ pos ] ; } if ( this . wlen < newLen ) { System . arraycopy ( otherArr , this . wlen , thisArr , this . wlen , newLen - this . wlen ) ; } this . wlen = newLen ; } 
public void agregarReserva ( Reserva reserva ) { reservas . add ( reserva ) ; } 
public String getStepLocalName ( int opPosOfStep ) { int argLenOfStep = getArgLengthOfStep ( opPosOfStep ) ; int index ; switch ( argLenOfStep ) { case 0 : index = OpCodes . EMPTY ; break ; case 1 : index = OpCodes . ELEMWILDCARD ; break ; case 2 : index = m_opMap . elementAt ( opPosOfStep + 4 ) ; break ; case 3 : index = m_opMap . elementAt ( opPosOfStep + 5 ) ; break ; default : index = OpCodes . EMPTY ; break ; } if ( index >= 0 ) return ( String ) m_tokenQueue . elementAt ( index ) . toString ( ) ; else if ( OpCodes . ELEMWILDCARD == index ) return NodeTest . WILD ; else return null ; } 
protected static String [ ] stripFROMKeyword ( String query ) throws OdaException { char [ ] chars = query . toCharArray ( ) ; List < Integer > indiceList = new ArrayList < Integer > ( ) ; boolean inQuote = false ; boolean isEscaped = false ; LookAheadMacher matcher = new LookAheadMacher ( "FROM-" , "-" , true ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( chars [ i ] == '"' ) { if ( ! isEscaped ) inQuote = ! inQuote ; else isEscaped = ! isEscaped ; } else if ( chars [ i ] == '|' ) { isEscaped = ! isEscaped ; } else if ( inQuote ) { continue ; } else { if ( matcher . match ( chars , i ) ) { indiceList . add ( i - 1 ) ; } } } String [ ] result = new String [ 2 ] ; if ( indiceList . size ( ) > 0 ) { int splitInd = indiceList . get ( indiceList . size ( ) - 1 ) ; result [ 0 ] = query . substring ( 0 , splitInd ) ; result [ 1 ] = getUnQuotedName ( query . substring ( splitInd + matcher . getPatternLength ( ) ) ) ; } else throw new OdaException ( Messages . getString ( "query_COMMAND_NOT_VALID" ) ) ; return result ; } 
public void set ( int row , int col , Number value ) { if ( value == null ) { synchronized ( data ) { data [ row ] [ col ] = - 99 ; } } else { synchronized ( data ) { data [ row ] [ col ] = value . shortValue ( ) ; } } } 
public static String eclipseUrlToVm ( String url ) { if ( url == null ) { return null ; } if ( url . startsWith ( ECLIPSE_FORMAT ) ) { URI uri = URI . create ( url ) ; url = uri . getScheme ( ) + "://" + uri . getPath ( ) ; } return url ; } 
public void addXTextLabel ( double x , String text ) { mXTextLabels . put ( x , text ) ; } 
private String readString ( ) { final byte [ ] stream_ = this . stream ; int parenLevel = 0 ; final StringBuffer sb = new StringBuffer ( ) ; for ( int to = stream_ . length ; loc < to ; ) { int c = stream_ [ loc ++ ] ; if ( c == ')' ) { if ( parenLevel -- == 0 ) { break ; } } else if ( c == '(' ) { parenLevel ++ ; } else if ( c == '|' ) { c = stream_ [ loc ++ ] ; if ( c >= '0' && c < '8' ) { int val = 0 ; for ( int count = 0 ; c >= '0' && c < '8' && count < 3 ; ++ count ) { val = ( val << 3 ) + c - '0' ; c = stream_ [ loc ++ ] ; } loc -- ; c = val ; } else if ( c == 'n' ) { c = '|n' ; } else if ( c == 'r' ) { c = '|r' ; } else if ( c == 't' ) { c = '|t' ; } else if ( c == 'b' ) { c = '|b' ; } else if ( c == 'f' ) { c = '|f' ; } } sb . append ( ( char ) c ) ; } return sb . toString ( ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public static String asHex ( byte hash [ ] ) { char buf [ ] = new char [ hash . length * 2 ] ; for ( int i = 0 , x = 0 ; i < hash . length ; i ++ ) { buf [ x ++ ] = HEX_CHARS [ ( hash [ i ] >>> 4 ) & 0xf ] ; buf [ x ++ ] = HEX_CHARS [ hash [ i ] & 0xf ] ; } return new String ( buf ) ; } 
public String getToolTipText ( MouseEvent evt ) { if ( highlights != null ) return highlights . getToolTipText ( evt ) ; else return null ; } 
public void arcTo ( float left , float top , float right , float bottom , float startAngle , float sweepAngle , boolean forceMoveTo ) { isSimplePath = false ; native_arcTo ( mNativePath , left , top , right , bottom , startAngle , sweepAngle , forceMoveTo ) ; } 
public void set ( int index , E e ) { if ( index >= data . length ) { grow ( index * 2 ) ; } size = index + 1 ; data [ index ] = e ; } 
public boolean remove ( Object e ) { if ( e == null ) return false ; Class eClass = e . getClass ( ) ; if ( eClass != elementType && eClass . getSuperclass ( ) != elementType ) return false ; long oldElements = elements ; elements &= ~ ( 1L << ( ( Enum ) e ) . ordinal ( ) ) ; return elements != oldElements ; } 
protected static EventListener removeInternal ( EventListener l , EventListener oldl ) { if ( l == oldl || l == null ) { return null ; } else if ( l instanceof AWTEventMulticaster ) { return ( ( AWTEventMulticaster ) l ) . remove ( oldl ) ; } else { return l ; } } 
protected void checkLocked ( ) { if ( isLocked ( ) ) { throw new UnsupportedOperationException ( "Cannot-modify-a-FixedOrderComparator-after-a-comparison" ) ; } } 
public void addPEPListener ( PEPListener pepListener ) { synchronized ( pepListeners ) { if ( ! pepListeners . contains ( pepListener ) ) { pepListeners . add ( pepListener ) ; } } } 
public void jsxSet_borderTopStyle ( final String borderTopStyle ) { setStyleAttribute ( "borderTopStyle" , borderTopStyle ) ; } 
public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; if ( null != m_arg2 ) m_arg2 . fixupVariables ( vars , globalsSize ) ; } 
public String getCanonicalPath ( ) throws IOException { return realpath ( getAbsolutePath ( ) ) ; } 
public void dispatchMessage ( Message msg ) { if ( msg . callback != null ) { handleCallback ( msg ) ; } else { if ( mCallback != null ) { if ( mCallback . handleMessage ( msg ) ) { return ; } } handleMessage ( msg ) ; } } 
public static boolean isFileExist ( String filePath ) { if ( StringUtils . isBlank ( filePath ) ) { return false ; } File file = new File ( filePath ) ; return ( file . exists ( ) && file . isFile ( ) ) ; } 
public void finishedPaintingChildren ( JSplitPane pane , Graphics g ) { Iterator iterator = uis . iterator ( ) ; while ( iterator . hasNext ( ) ) { SplitPaneUI ui = ( SplitPaneUI ) iterator . next ( ) ; ui . finishedPaintingChildren ( pane , g ) ; } } 
public void addLine ( String line ) { int index = line . indexOf ( ":" , 1 ) ; if ( index != - 1 ) { addLenient ( line . substring ( 0 , index ) , line . substring ( index + 1 ) ) ; } else if ( line . startsWith ( ":" ) ) { addLenient ( "" , line . substring ( 1 ) ) ; } else { addLenient ( "" , line ) ; } } 
public static DynamicMessage parseFrom ( Descriptor type , CodedInputStream input ) throws IOException { return newBuilder ( type ) . mergeFrom ( input ) . buildParsed ( ) ; } 
public void uninstallUI ( JComponent c ) { editor . removePropertyChangeListener ( updateHandler ) ; editor . getDocument ( ) . removeDocumentListener ( updateHandler ) ; painted = false ; uninstallDefaults ( ) ; rootView . setView ( null ) ; c . removeAll ( ) ; LayoutManager lm = c . getLayout ( ) ; if ( lm instanceof UIResource ) { c . setLayout ( null ) ; } uninstallKeyboardActions ( ) ; uninstallListeners ( ) ; editor = null ; } 
public long search ( int from , int to ) { result . set ( 0 ) ; countDown = new CountDownLatch ( threadCounter ) ; threadPool = Executors . newCachedThreadPool ( ) ; for ( Range range : splitter . split ( new Range ( from , to ) , threadCounter ) ) threadPool . execute ( new Search ( range ) ) ; try { countDown . await ( ) ; } catch ( InterruptedException e ) { } threadPool . shutdown ( ) ; return result . get ( ) ; } 
public static String buildQueryString ( Map < String , Object > queryParams ) { StringBuffer buf = new StringBuffer ( ) ; boolean firstParam = true ; try { for ( Map . Entry < String , Object > entry : queryParams . entrySet ( ) ) { if ( entry . getValue ( ) == null ) continue ; if ( entry . getValue ( ) instanceof List < ? > ) { List < ? > values = ( List < ? > ) entry . getValue ( ) ; for ( Object value : values ) { if ( ! firstParam ) { buf . append ( '&' ) ; } buf . append ( entry . getKey ( ) ) ; buf . append ( '=' ) ; buf . append ( java . net . URLEncoder . encode ( value . toString ( ) , "utf-8" ) ) ; firstParam = false ; } } else { if ( ! firstParam ) { buf . append ( '&' ) ; } buf . append ( entry . getKey ( ) ) ; buf . append ( '=' ) ; buf . append ( java . net . URLEncoder . encode ( entry . getValue ( ) . toString ( ) , "utf-8" ) ) ; firstParam = false ; } } } catch ( UnsupportedEncodingException ex ) { ex . printStackTrace ( ) ; } return buf . toString ( ) ; } 
public static final NumberFormat getInstance ( ) { return getNumberInstance ( ) ; } 
public static Deque < Float > toDeque ( float ... array ) { PreCon . notNull ( array ) ; Deque < Float > result = new ArrayDeque < > ( array . length ) ; for ( float b : array ) { result . add ( b ) ; } return result ; } 
public void setInsertDate_FromTo ( java . util . Date fromDatetime , java . util . Date toDatetime , FromToOption fromToOption ) { regFTQ ( ( fromDatetime != null ? new java . sql . Timestamp ( fromDatetime . getTime ( ) ) : null ) , ( toDatetime != null ? new java . sql . Timestamp ( toDatetime . getTime ( ) ) : null ) , getCValueInsertDate ( ) , "INSERTDATE" , fromToOption ) ; } 
public double nextCauchy ( double median , double scale ) { return delegate . nextCauchy ( median , scale ) ; } 
public int executeUpdate ( String sql , int autoGeneratedKeys ) throws SQLException { throw Util . notSupported ( ) ; } 
public void print ( ) { String result = "" ; for ( Path p = this ; p != null ; p = p . next ) { result += p . word + "," ; } if ( result . endsWith ( "," ) ) result = result . substring ( 0 , result . length ( ) - 1 ) ; System . out . println ( result ) ; } 
protected void onAttachedToWindow ( ) { if ( ( mPrivateFlags & REQUEST_TRANSPARENT_REGIONS ) != 0 ) { mParent . requestTransparentRegion ( this ) ; } if ( ( mPrivateFlags & AWAKEN_SCROLL_BARS_ON_ATTACH ) != 0 ) { initialAwakenScrollBars ( ) ; mPrivateFlags &= ~ AWAKEN_SCROLL_BARS_ON_ATTACH ; } jumpDrawablesToCurrentState ( ) ; resolveLayoutDirection ( ) ; resolvePadding ( ) ; resolveTextDirection ( ) ; resolveTextAlignment ( ) ; clearAccessibilityFocus ( ) ; if ( isFocused ( ) ) { InputMethodManager imm = InputMethodManager . peekInstance ( ) ; imm . focusIn ( this ) ; } if ( mAttachInfo != null && mDisplayList != null ) { mAttachInfo . mViewRootImpl . dequeueDisplayList ( mDisplayList ) ; } } 
public byte [ ] toBinary ( ) { int maxIndex = 1 << BITS_PER_INDEX ; byte [ ] bin1 = ArrayEncoder . encodeModQ ( ones , maxIndex ) ; byte [ ] bin2 = ArrayEncoder . encodeModQ ( negOnes , maxIndex ) ; byte [ ] bin = Arrays . copyOf ( bin1 , bin1 . length + bin2 . length ) ; System . arraycopy ( bin2 , 0 , bin , bin1 . length , bin2 . length ) ; return bin ; } 
@ Override public int getNrOfRequiredSuccessfullyStoredFragments ( ) { return potentialStorageDirectories . size ( ) ; } 
public void setMessage ( String msg ) { message . setText ( msg ) ; } 
public static Document parseXML ( String xml ) throws WizardException { try { DocumentBuilder b = getDocumentBuilder ( false ) ; StringReader reader = new StringReader ( xml ) ; return b . parse ( new InputSource ( reader ) ) ; } catch ( Exception e ) { throw new WizardException ( "Could-not-parse-schema-xml-file.-xml:" + xml + "-" + Logging . stackTrace ( e ) ) ; } } 
public Builder setHostURL ( java . lang . String value ) { if ( value == null ) { throw new NullPointerException ( ) ; } bitField0_ |= 0x00000400 ; hostURL_ = value ; onChanged ( ) ; return this ; } 
public void connect ( SocketAddress endpoint ) throws IOException { connect ( endpoint , 0 ) ; } 
public void endValueScopeFor ( IdentityConstraint identityConstraint , int initialDepth ) { ValueStoreBase valueStore = fValueStoreCache . getValueStoreFor ( identityConstraint , initialDepth ) ; valueStore . endValueScope ( ) ; } 
protected final void encodeCIIBuiltInAlgorithmDataAsCDATA ( char [ ] ch , int offset , int length ) throws FastInfosetException , IOException { write ( EncodingConstants . CHARACTER_CHUNK | EncodingConstants . CHARACTER_CHUNK_ENCODING_ALGORITHM_FLAG ) ; _b = EncodingAlgorithmIndexes . CDATA << 2 ; length = encodeUTF8String ( ch , offset , length ) ; encodeNonZeroOctetStringLengthOnSenventhBit ( length ) ; write ( _encodingBuffer , length ) ; } 
public Painter getBackgroundPainter ( SynthContext ctx ) { Values v = getValues ( ctx ) ; int xstate = getExtendedState ( ctx , v ) ; Painter p = null ; tmpKey . init ( "backgroundPainter$$instance" , xstate ) ; p = ( Painter ) v . cache . get ( tmpKey ) ; if ( p != null ) return p ; RuntimeState s = null ; int [ ] lastIndex = new int [ ] { - 1 } ; while ( ( s = getNextState ( v . states , lastIndex , xstate ) ) != null ) { if ( s . backgroundPainter != null ) { p = s . backgroundPainter ; break ; } } if ( p == null ) p = ( Painter ) get ( ctx , "backgroundPainter" ) ; if ( p != null ) { v . cache . put ( new CacheKey ( "backgroundPainter$$instance" , xstate ) , p ) ; } return p ; } 
@ Override public AttributedCharacterIterator formatToCharacterIterator ( Object object ) { if ( object == null ) { throw new NullPointerException ( ) ; } StringBuffer buffer = new StringBuffer ( ) ; Vector < FieldContainer > fields = new Vector < FieldContainer > ( ) ; formatImpl ( ( Object [ ] ) object , buffer , new FieldPosition ( 0 ) , fields ) ; AttributedString as = new AttributedString ( buffer . toString ( ) ) ; for ( int i = 0 ; i < fields . size ( ) ; i ++ ) { FieldContainer fc = fields . elementAt ( i ) ; as . addAttribute ( fc . attribute , fc . value , fc . start , fc . end ) ; } return as . getIterator ( ) ; } 
public void setKeepAlive ( boolean keepAlive ) throws SocketException { if ( impl != null ) { checkOpenAndCreate ( true ) ; impl . setOption ( SocketOptions . SO_KEEPALIVE , Boolean . valueOf ( keepAlive ) ) ; } } 
public void setDenominatorDegreesOfFreedom ( double degreesOfFreedom ) { if ( degreesOfFreedom <= 0.0 || Double . isNaN ( degreesOfFreedom ) ) { throw new IllegalArgumentException ( "degrees-of-freedom-must-be-positive." ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; } 
protected Collection < ? extends CRL > getCRLs ( String crlf ) throws IOException , CRLException , CertificateException { File crlFile = new File ( crlf ) ; if ( ! crlFile . isAbsolute ( ) ) { crlFile = new File ( System . getProperty ( Constants . CATALINA_BASE_PROP ) , crlf ) ; } Collection < ? extends CRL > crls = null ; InputStream is = null ; try { CertificateFactory cf = CertificateFactory . getInstance ( "X.509" ) ; is = new FileInputStream ( crlFile ) ; crls = cf . generateCRLs ( is ) ; } catch ( IOException iex ) { throw iex ; } catch ( CRLException crle ) { throw crle ; } catch ( CertificateException ce ) { throw ce ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( Exception ex ) { } } } return crls ; } 
public int readUnsignedByte ( ) throws IOException { return primitiveTypes . readUnsignedByte ( ) ; } 
public int getLineNumber ( ) { return ( null == m_locator ) ? super . getLineNumber ( ) : m_locator . getLineNumber ( ) ; } 
public Object call ( Context context , List args ) throws FunctionCallException { if ( args . size ( ) == 1 ) { return evaluate ( args . get ( 0 ) , context . getNavigator ( ) ) ; } throw new FunctionCallException ( "ceiling()-requires-one-argument." ) ; } 
public String encodeBody ( ) { return encodeBody ( new StringBuffer ( ) ) . toString ( ) ; } 
void registerCallback ( BluetoothCallback callback ) { synchronized ( mCallbacks ) { mCallbacks . add ( callback ) ; } } 
private void postInitORBInitializers ( ORBInitInfoImpl info ) { info . setStage ( ORBInitInfoImpl . STAGE_POST_INIT ) ; for ( int i = 0 ; i < orbInitializers . length ; i ++ ) { ORBInitializer init = orbInitializers [ i ] ; if ( init != null ) { try { init . post_init ( info ) ; } catch ( Exception e ) { } } } } 
public List < Provenance > getProvenance ( ) { if ( provenance == null ) { provenance = new ArrayList < Provenance > ( ) ; } return this . provenance ; } 
public long getOutgoingMessageCount ( boolean resetAfter ) { if ( resetAfter ) { return outMessages . getAndSet ( 0 ) ; } else { return outMessages . get ( ) ; } } 
protected void complete ( ) { if ( ! isTimeSet ) updateTime ( ) ; if ( ! areFieldsSet || ! areAllFieldsSet ) { computeFields ( ) ; areAllFieldsSet = areFieldsSet = true ; } } 
public void startQuery ( int token , Object cookie , Uri uri , String [ ] projection , String selection , String [ ] selectionArgs , String orderBy ) { Message msg = mWorkerThreadHandler . obtainMessage ( token ) ; msg . arg1 = EVENT_ARG_QUERY ; WorkerArgs args = new WorkerArgs ( ) ; args . handler = this ; args . uri = uri ; args . projection = projection ; args . selection = selection ; args . selectionArgs = selectionArgs ; args . orderBy = orderBy ; args . cookie = cookie ; msg . obj = args ; mWorkerThreadHandler . sendMessage ( msg ) ; } 
public synchronized int getPort ( ) { if ( adaptor != null ) return adaptor . getPort ( ) ; return 0 ; } 
public < T > Parameter < T > getParameter ( String name , Class < T > type ) { Parameter < ? > param = getParameter ( name ) ; if ( param . getParameterType ( ) . isAssignableFrom ( type ) ) throw new IllegalArgumentException ( param + "-does-not-match-the-requested-type-" + type ) ; return ( Parameter < T > ) param ; } 
private String loadFile ( File file ) { StringBuffer sb = new StringBuffer ( ) ; char [ ] buffer = new char [ 1024 ] ; BufferedReader br = null ; try { br = new BufferedReader ( new FileReader ( file ) ) ; int readChar = br . read ( buffer ) ; while ( readChar != - 1 ) { sb . append ( buffer , 0 , readChar ) ; readChar = br . read ( buffer ) ; } } catch ( Exception e ) { Logger . getInstance ( ) . logError ( "Error-loading-source-file" , e ) ; } finally { if ( br != null ) { try { br . close ( ) ; } catch ( IOException e ) { Logger . getInstance ( ) . logError ( "Closing-stream" , e ) ; } } } return sb . toString ( ) ; } 
private static int startViaZygote ( final String processClass , final String niceName , final int uid , final int gid , final int [ ] gids , int debugFlags , String [ ] extraArgs ) throws ZygoteStartFailedEx { int pid ; synchronized ( Process . class ) { ArrayList < String > argsForZygote = new ArrayList < String > ( ) ; argsForZygote . add ( "--runtime-init" ) ; argsForZygote . add ( "--setuid=" + uid ) ; argsForZygote . add ( "--setgid=" + gid ) ; if ( gids != null && gids . length > 0 ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "--setgroups=" ) ; int sz = gids . length ; for ( int i = 0 ; i < sz ; i ++ ) { if ( i != 0 ) { sb . append ( ',' ) ; } sb . append ( gids [ i ] ) ; } argsForZygote . add ( sb . toString ( ) ) ; } if ( niceName != null ) { argsForZygote . add ( "--nice-name=" + niceName ) ; } argsForZygote . add ( processClass ) ; if ( extraArgs != null ) { for ( String arg : extraArgs ) { argsForZygote . add ( arg ) ; } } pid = zygoteSendArgsAndGetPid ( argsForZygote ) ; } if ( pid <= 0 ) { throw new ZygoteStartFailedEx ( "zygote-start-failed:" + pid ) ; } return pid ; } 
public void adjustmentValueChanged ( AdjustmentEvent e ) { System . out . println ( "Adjusted!" ) ; fanThread . setDelay ( scrollBar . getMaximum ( ) - e . getValue ( ) ) ; } 
public String toString ( ) { StringBuffer output = new StringBuffer ( ) ; output . append ( currentTileKey ) . append ( "/" ) ; if ( ( nextTileID != - 1 ) && ( nextTileKey != - 1 ) ) { output . append ( nextTileID ) . append ( "," ) ; output . append ( nextTileKey ) ; } return output . toString ( ) ; } 
public boolean isDeleted ( Clustering clustering , Cell cell ) { int idx = searchInternal ( clustering , 0 , size ) ; return idx >= 0 && ( cell . isCounterCell ( ) || markedAts [ idx ] >= cell . timestamp ( ) ) ; } 
public byte [ ] decode ( byte [ ] pArray ) { return decodeBase64 ( pArray ) ; } 
public StringBuilder insert ( int offset , char [ ] ch ) { insert0 ( offset , ch ) ; return this ; } 
public InputStream newInputStream ( int index ) throws IOException { synchronized ( DiskLruCache . this ) { if ( entry . currentEditor != this ) { throw new IllegalStateException ( ) ; } if ( ! entry . readable ) { return null ; } try { return new FileInputStream ( entry . getCleanFile ( index ) ) ; } catch ( FileNotFoundException e ) { return null ; } } } 
public List < Extension > getExtension ( ) { if ( extension == null ) { extension = new ArrayList < Extension > ( ) ; } return this . extension ; } 
private Iterator < Map . Entry < K , V >> getOverflowIterator ( ) { if ( lazyOverflowIterator == null ) { lazyOverflowIterator = overflowEntries . entrySet ( ) . iterator ( ) ; } return lazyOverflowIterator ; } 
private int endPositionOfParameterDeclaration ( int beginIndex , String procedureDef , String quoteChar ) throws SQLException { int currentPos = beginIndex + 1 ; int parenDepth = 1 ; while ( parenDepth > 0 && currentPos < procedureDef . length ( ) ) { int closedParenIndex = StringUtils . indexOfIgnoreCaseRespectQuotes ( currentPos , procedureDef , ")" , quoteChar . charAt ( 0 ) , ! this . conn . isNoBackslashEscapesSet ( ) ) ; if ( closedParenIndex != - 1 ) { int nextOpenParenIndex = StringUtils . indexOfIgnoreCaseRespectQuotes ( currentPos , procedureDef , "(" , quoteChar . charAt ( 0 ) , ! this . conn . isNoBackslashEscapesSet ( ) ) ; if ( nextOpenParenIndex != - 1 && nextOpenParenIndex < closedParenIndex ) { parenDepth ++ ; currentPos = closedParenIndex + 1 ; } else { parenDepth -- ; currentPos = closedParenIndex ; } } else { throw SQLError . createSQLException ( "Internal-error-when-parsing-callable-statement-metadata" , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } } return currentPos ; } 
@ Override public void initInstance ( Env env , Value value , boolean isInitFieldValues ) { if ( value instanceof ObjectValue ) { ObjectValue object = ( ObjectValue ) value ; if ( __destruct != null ) { env . addObjectCleanup ( object ) ; } } } 
private static void deleteFolder ( Configuration conf , String folderPath ) throws IOException { FileSystem fs = FileSystem . get ( conf ) ; Path path = new Path ( folderPath ) ; if ( fs . exists ( path ) ) { fs . delete ( path , true ) ; } } 
public static final void reloadBundle ( Locale key ) { try { Class type = ResourceBundle . class ; Field cacheList = type . getDeclaredField ( "cacheList" ) ; synchronized ( cacheList ) { cacheList . setAccessible ( true ) ; ( ( Map ) cacheList . get ( ResourceBundle . class ) ) . clear ( ) ; } clearTomcatCache ( ) ; messagesMap . remove ( key ) ; } catch ( Exception e ) { LOG . error ( "Error-clearing-message-resource-bundles" , e ) ; } } 
public static LocPathIterator createUnionIterator ( Compiler compiler , int opPos ) throws javax . xml . transform . TransformerException { UnionPathIterator upi = new UnionPathIterator ( compiler , opPos ) ; int nPaths = upi . m_exprs . length ; boolean isAllChildIterators = true ; for ( int i = 0 ; i < nPaths ; i ++ ) { LocPathIterator lpi = upi . m_exprs [ i ] ; if ( lpi . getAxis ( ) != Axis . CHILD ) { isAllChildIterators = false ; break ; } else { if ( HasPositionalPredChecker . check ( lpi ) ) { isAllChildIterators = false ; break ; } } } if ( isAllChildIterators ) { UnionChildIterator uci = new UnionChildIterator ( ) ; for ( int i = 0 ; i < nPaths ; i ++ ) { PredicatedNodeTest lpi = upi . m_exprs [ i ] ; uci . addNodeTest ( lpi ) ; } return uci ; } else return upi ; } 
public void add ( int index , E element ) { insertElementAt ( element , index ) ; } 
public int relativeCCW ( double px , double py ) { return relativeCCW ( getX1 ( ) , getY1 ( ) , getX2 ( ) , getY2 ( ) , px , py ) ; } 
public boolean isVarArgs ( ) { return method . isVarArgs ( ) ; } 
public void removeLineWidthPanelListeners ( ) { listeners . clear ( ) ; } 
public int quantityDropped ( Random par1Random ) { int i = par1Random . nextInt ( 10 ) - 7 ; if ( i < 0 ) { i = 0 ; } return i ; } 
public static DirectMessage createDirectMessage ( String rawJSON ) throws TwitterException { try { JSONObject json = new JSONObject ( rawJSON ) ; return directMessageConstructor . newInstance ( json ) ; } catch ( InstantiationException e ) { throw new TwitterException ( e ) ; } catch ( IllegalAccessException e ) { throw new AssertionError ( e ) ; } catch ( InvocationTargetException e ) { throw new TwitterException ( e ) ; } catch ( JSONException e ) { throw new TwitterException ( e ) ; } } 
protected void isElementWellFormed ( Node node ) { boolean isNameWF = false ; if ( ( fFeatures & NAMESPACES ) != 0 ) { isNameWF = isValidQName ( node . getPrefix ( ) , node . getLocalName ( ) , fIsXMLVersion11 ) ; } else { isNameWF = isXMLName ( node . getNodeName ( ) , fIsXMLVersion11 ) ; } if ( ! isNameWF ) { String msg = Utils . messages . createMessage ( MsgKey . ER_WF_INVALID_CHARACTER_IN_NODE_NAME , new Object [ ] { "Element" , node . getNodeName ( ) } ) ; if ( fErrorHandler != null ) { fErrorHandler . handleError ( new DOMErrorImpl ( DOMError . SEVERITY_FATAL_ERROR , msg , MsgKey . ER_WF_INVALID_CHARACTER_IN_NODE_NAME , null , null , null ) ) ; } } } 
public synchronized ArrayList < SearchableInfo > getSearchablesList ( ) { ArrayList < SearchableInfo > result = new ArrayList < SearchableInfo > ( mSearchablesList ) ; return result ; } 
public static String decode ( final String segments ) { try { return URLDecoder . decode ( segments , Prop . ENCODING ) ; } catch ( final UnsupportedEncodingException ex ) { throw new IllegalArgumentException ( ex ) ; } } 
@ XmlElementDecl ( namespace = "http://www.cisco.com/AXL/API/10.5" , name = "removeMeetMeResponse" ) public JAXBElement < StandardResponse > createRemoveMeetMeResponse ( StandardResponse value ) { return new JAXBElement < StandardResponse > ( new QName ( "http://www.cisco.com/AXL/API/10.5" , "removeMeetMeResponse" ) , StandardResponse . class , null , value ) ; } 
public void addAuditory ( int id ) { mAuditoryFeedback . add ( id ) ; } 
@ ZAttr ( id = 26 ) public void setLmtpNumThreads ( int zimbraLmtpNumThreads ) throws com . zimbra . common . service . ServiceException { HashMap < String , Object > attrs = new HashMap < String , Object > ( ) ; attrs . put ( Provisioning . A_zimbraLmtpNumThreads , Integer . toString ( zimbraLmtpNumThreads ) ) ; getProvisioning ( ) . modifyAttrs ( this , attrs ) ; } 
public void addSequence ( Sequence sequence ) { sequences . add ( sequence ) ; } 
public void unlock ( ) { sync . releaseShared ( 1 ) ; } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; if ( localNameTracker ) { elementList . add ( new javax . xml . namespace . QName ( "http://services.equifax.com/eport/ws/schemas/1.0" , "Name" ) ) ; if ( localName != null ) { elementList . add ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( localName ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "Name-cannot-be-null!!" ) ; } } if ( localRelationTypeTracker ) { elementList . add ( new javax . xml . namespace . QName ( "http://services.equifax.com/eport/ws/schemas/1.0" , "RelationType" ) ) ; if ( localRelationType != null ) { elementList . add ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( localRelationType ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "RelationType-cannot-be-null!!" ) ; } } return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
public static void disposeFonts ( ) { for ( Font font : m_fontMap . values ( ) ) { font . dispose ( ) ; } m_fontMap . clear ( ) ; for ( Font font : m_fontToBoldFontMap . values ( ) ) { font . dispose ( ) ; } m_fontToBoldFontMap . clear ( ) ; } 
public BufferedImage getArrowSprite ( ) { if ( arrowFlying ) return spriteSheet . getSubimage ( 456 , 32 , 20 , 100 ) ; return null ; } 
private static AncestorListener createAncestorListener ( JComponent component , final WindowListener windowListener ) { final WeakReference < JComponent > weakReference = new WeakReference < JComponent > ( component ) ; return new AncestorListener ( ) { public void ancestorAdded ( AncestorEvent event ) { Window window = weakReference . get ( ) == null ? null : SwingUtilities . getWindowAncestor ( weakReference . get ( ) ) ; if ( window != null ) { window . removeWindowListener ( windowListener ) ; window . addWindowListener ( windowListener ) ; } } public void ancestorRemoved ( AncestorEvent event ) { Window window = weakReference . get ( ) == null ? null : SwingUtilities . getWindowAncestor ( weakReference . get ( ) ) ; if ( window != null ) { window . removeWindowListener ( windowListener ) ; } } public void ancestorMoved ( AncestorEvent event ) { } } ; } 
protected boolean hasUncompressedStrip ( ) { return mStripBytes . size ( ) != 0 ; } 
Iterable < String > getPrefixes ( ) { if ( prefixTable == null ) { return EMPTY_ENUMERATION ; } else { return prefixTable . keySet ( ) ; } } 
public EntityMappings < T > removeAllNamedNativeQuery ( ) { childNode . removeChildren ( "named-native-query" ) ; return this ; } 
public int engineSize ( ) { return entries . size ( ) ; } 
public PolynomialSplineFunction interpolate ( double x [ ] , double y [ ] ) throws DimensionMismatchException , NumberIsTooSmallException , NonMonotonicSequenceException { if ( x . length != y . length ) { throw new DimensionMismatchException ( x . length , y . length ) ; } if ( x . length < 2 ) { throw new NumberIsTooSmallException ( LocalizedFormats . NUMBER_OF_POINTS , x . length , 2 , true ) ; } int n = x . length - 1 ; MathArrays . checkOrder ( x ) ; final double m [ ] = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { m [ i ] = ( y [ i + 1 ] - y [ i ] ) / ( x [ i + 1 ] - x [ i ] ) ; } final PolynomialFunction polynomials [ ] = new PolynomialFunction [ n ] ; final double coefficients [ ] = new double [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { coefficients [ 0 ] = y [ i ] ; coefficients [ 1 ] = m [ i ] ; polynomials [ i ] = new PolynomialFunction ( coefficients ) ; } return new PolynomialSplineFunction ( x , polynomials ) ; } 
protected Entry ( int numberDimensions , ClusKernel cluster , long currentTime , Entry parentEntry , Node containerNode ) { this ( numberDimensions ) ; this . parentEntry = parentEntry ; this . data . add ( cluster ) ; this . node = containerNode ; this . timestamp = currentTime ; } 
@ Override protected void onDraw ( Canvas canvas ) { for ( int i = 0 ; i < getChildCount ( ) ; ++ i ) { View child = getChildAt ( i ) ; if ( child . getVisibility ( ) != View . VISIBLE || child . getAlpha ( ) == 0 ) { continue ; } int depthFactor = ( int ) ( 80 * mShadowDepth ) ; canvas . save ( ) ; canvas . translate ( child . getLeft ( ) + depthFactor , child . getTop ( ) + depthFactor ) ; canvas . concat ( child . getMatrix ( ) ) ; tempShadowRectF . right = child . getWidth ( ) ; tempShadowRectF . bottom = child . getHeight ( ) ; canvas . drawBitmap ( mShadowBitmap , sShadowRect , tempShadowRectF , mShadowPaint ) ; canvas . restore ( ) ; } } 
public < V > StrSubstitutor ( final Map < String , V > valueMap ) { this ( StrLookup . mapLookup ( valueMap ) , DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ESCAPE ) ; } 
public void queueEvent ( Runnable r ) { synchronized ( this ) { mEventQueue . add ( r ) ; } } 
public Map < String , List < String >> getHeaderFields ( ) { return delegate . getHeaderFields ( ) ; } 
public static void registerSecurityProviders ( ) { if ( Config . isJavaVersionAtLeast15 ( ) ) { Service service = com . sun . deploy . services . ServiceManager . getService ( ) ; if ( service . isIExplorer ( ) ) { try { Class providerClass = Class . forName ( "com.sun.deploy.security.MSCryptoProvider" , true , ClassLoader . getSystemClassLoader ( ) ) ; if ( providerClass != null ) { Provider provider = ( Provider ) providerClass . newInstance ( ) ; Security . insertProviderAt ( provider , Security . getProviders ( ) . length + 1 ) ; } } catch ( Throwable e ) { } } if ( service . isNetscape ( ) ) { if ( isJSSCryptoConfigured ( ) ) { Trace . msgSecurityPrintln ( "browserkeystore.jss.config" ) ; try { Class providerClass = Class . forName ( "com.sun.deploy.security.MozillaJSSProvider" , true , ClassLoader . getSystemClassLoader ( ) ) ; if ( providerClass != null ) { Provider provider = ( Provider ) providerClass . newInstance ( ) ; Security . insertProviderAt ( provider , Security . getProviders ( ) . length + 1 ) ; } } catch ( Throwable e ) { Trace . msgSecurityPrintln ( "browserkeystore.jss.notconfig" ) ; } } else { Trace . msgSecurityPrintln ( "browserkeystore.jss.notconfig" ) ; } } } } 
public void setSelectionInterval ( int index0 , int index1 ) { if ( index0 == - 1 || index1 == - 1 ) { return ; } if ( getSelectionMode ( ) == SINGLE_SELECTION ) { index0 = index1 ; } updateLeadAnchorIndices ( index0 , index1 ) ; int clearMin = minIndex ; int clearMax = maxIndex ; int setMin = Math . min ( index0 , index1 ) ; int setMax = Math . max ( index0 , index1 ) ; changeSelection ( clearMin , clearMax , setMin , setMax ) ; } 
private void adjustCaret ( MouseEvent e ) { if ( ( e . getModifiers ( ) & ActionEvent . SHIFT_MASK ) != 0 && getDot ( ) != - 1 ) { moveCaret ( e ) ; } else if ( ! e . isPopupTrigger ( ) ) { positionCaret ( e ) ; } } 
public Set < Map . Entry < String , Object >> valueSet ( ) { return mValues . entrySet ( ) ; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData , boolean isChunked , boolean urlSafe ) { return encodeBase64 ( binaryData , isChunked , urlSafe , Integer . MAX_VALUE ) ; } 
public List < GlobalDiscountRowDTO > getGlobaldiscountrow ( ) { if ( globaldiscountrow == null ) { globaldiscountrow = new ArrayList < GlobalDiscountRowDTO > ( ) ; } return this . globaldiscountrow ; } 
public Component getGlassPane ( ) { return getRootPane ( ) . getGlassPane ( ) ; } 
private static int getBrightness ( Context context ) { try { int brightness = Settings . System . getInt ( context . getContentResolver ( ) , Settings . System . SCREEN_BRIGHTNESS ) ; return brightness ; } catch ( Exception e ) { } return 0 ; } 
int getTabCount ( ) { return mTabs . size ( ) ; } 
public String [ ] getIds ( ) { String [ ] a = new String [ _t . size ( ) ] ; for ( int i = 0 ; i < _t . size ( ) ; i ++ ) { a [ i ] = _t . get ( i ) . textureId ; } return a ; } 
public static File createTempFile ( String prefix , String suffix , String path ) { assert path != null ; if ( prefix == null || prefix . length ( ) < 3 ) prefix = DEFAULT_PREFIX ; File dir = new File ( path ) ; if ( ! dir . exists ( ) ) { if ( dir . mkdirs ( ) == false ) { logger . log ( Level . SEVERE , "[FileUtil]-Cannot-create-directory." ) ; return null ; } } try { File newFile = File . createTempFile ( prefix , suffix , dir ) ; return newFile ; } catch ( IOException e ) { logger . log ( Level . SEVERE , e . getMessage ( ) , e ) ; return null ; } } 
public void write ( ) throws IOException { corruptPreUpgradeStorage ( root ) ; write ( getVersionFile ( ) ) ; } 
public String toString ( ) { StringBuffer sb = toStringNoData ( ) ; sb . append ( "<unknown-format>" ) ; return sb . toString ( ) ; } 
public static void setInputCQLPageRowSize ( Configuration conf , String cqlPageRowSize ) { if ( cqlPageRowSize == null ) { throw new UnsupportedOperationException ( "cql-page-row-size-may-not-be-null" ) ; } conf . set ( INPUT_CQL_PAGE_ROW_SIZE_CONFIG , cqlPageRowSize ) ; } 
void addPower ( Integer power , Prefix result ) { _powerMap . put ( power , result ) ; } 
public Complex asin ( ) { if ( isNaN ( ) ) { return Complex . NaN ; } return sqrt1z ( ) . add ( this . multiply ( Complex . I ) ) . log ( ) . multiply ( Complex . I . negate ( ) ) ; } 
public static int rapidParseInt ( final String input ) { final int len = input . length ( ) ; int val = 0 ; int i = 0 ; boolean isNegative = false ; if ( 0 < len && '-' == input . charAt ( 0 ) ) { i = 1 ; isNegative = true ; } for ( ; i < len ; ++ i ) { final char ch = input . charAt ( i ) ; if ( Character . isDigit ( ch ) ) { val = ( val * 10 ) + ( ch - 48 ) ; } else { break ; } } if ( isNegative ) val = - val ; return val ; } 
private int getSCFromCGIStatusHeader ( String value ) { if ( value . length ( ) < 3 ) { log ( "runCGI:-invalid-status-value:" + value ) ; return HttpServletResponse . SC_INTERNAL_SERVER_ERROR ; } String status = value . substring ( 0 , 3 ) ; int statusCode ; try { statusCode = Integer . parseInt ( status ) ; } catch ( NumberFormatException nfe ) { log ( "runCGI:-invalid-status-code:" + status ) ; return HttpServletResponse . SC_INTERNAL_SERVER_ERROR ; } return statusCode ; } 
public static IOFileFilter asFileFilter ( FilenameFilter filter ) { return new DelegateFileFilter ( filter ) ; } 
public int hashCode ( ) { if ( hashCode == null ) hashCode = Integer . valueOf ( getClassName ( ) . hashCode ( ) + new HashSet ( Arrays . asList ( getAttributes ( ) ) ) . hashCode ( ) + new HashSet ( Arrays . asList ( getConstructors ( ) ) ) . hashCode ( ) + new HashSet ( Arrays . asList ( getNotifications ( ) ) ) . hashCode ( ) + new HashSet ( Arrays . asList ( getOperations ( ) ) ) . hashCode ( ) ) ; return hashCode . intValue ( ) ; } 
public String printFlags ( ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < 16 ; i ++ ) if ( validFlag ( i ) && getFlag ( i ) ) { sb . append ( Flags . string ( i ) ) ; sb . append ( "-" ) ; } return sb . toString ( ) ; } 
public < P extends LocaleServiceProvider , S > S getLocalizedObject ( LocalizedObjectGetter < P , S > getter , Locale locale , Object ... params ) { return getLocalizedObjectImpl ( getter , locale , true , null , params ) ; } 
public String printPath ( final Vertex < T > vertex ) { String str = "" ; if ( vertex != null ) { str = "[" + vertex . getValue ( ) + "]" + "-->" + printPath ( vertex . getParent ( ) ) ; } return str ; } 
public void addVirtualSensorName ( java . lang . String param ) { if ( localVirtualSensorName == null ) { localVirtualSensorName = new java . lang . String [ ] { } ; } localVirtualSensorNameTracker = true ; java . util . List list = org . apache . axis2 . databinding . utils . ConverterUtil . toList ( localVirtualSensorName ) ; list . add ( param ) ; this . localVirtualSensorName = ( java . lang . String [ ] ) list . toArray ( new java . lang . String [ list . size ( ) ] ) ; } 
public void testSerialization ( ) { SpiderWebPlot p1 = new SpiderWebPlot ( new DefaultCategoryDataset ( ) ) ; SpiderWebPlot p2 = null ; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; ObjectOutput out = new ObjectOutputStream ( buffer ) ; out . writeObject ( p1 ) ; out . close ( ) ; ObjectInput in = new ObjectInputStream ( new ByteArrayInputStream ( buffer . toByteArray ( ) ) ) ; p2 = ( SpiderWebPlot ) in . readObject ( ) ; in . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } assertEquals ( p1 , p2 ) ; } 
public List < String > getKeepTogether ( ) { if ( keepTogether == null ) { keepTogether = new ArrayList < String > ( ) ; } return this . keepTogether ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
protected void updateInsertionLocation ( JComponent comp , Point p ) { JTable table = ( JTable ) comp ; int row = table . rowAtPoint ( p ) ; int col = table . columnAtPoint ( p ) ; if ( row != - 1 ) { table . setRowSelectionInterval ( row , row ) ; } if ( col != - 1 ) { table . setColumnSelectionInterval ( col , col ) ; } } 
@ Override public boolean isSelectAllEnabled ( ) { if ( text == null || text . isDisposed ( ) ) { return false ; } return text . getCharCount ( ) > 0 ; } 
public void error ( TransformerException exception ) throws TransformerException { if ( m_throwExceptionOnError ) throw exception ; else { printLocation ( m_pw , exception ) ; m_pw . println ( exception . getMessage ( ) ) ; } } 
@ XmlElementDecl ( namespace = "" , name = "last-name" ) public JAXBElement < String > createLastName ( String value ) { return new JAXBElement < String > ( _LastName_QNAME , String . class , null , value ) ; } 
public void removeChangeListener ( ChangeListener l ) { listenerList . remove ( ChangeListener . class , l ) ; } 
public static final Set < Method > findMethod ( Class clazz , Class < ? extends Annotation > annotationType ) { Method [ ] declaredMethods = org . springframework . util . ReflectionUtils . getAllDeclaredMethods ( clazz ) ; Set < Method > results = new HashSet < Method > ( ) ; for ( Method curMethod : declaredMethods ) { Annotation annotation = AnnotationUtils . findAnnotation ( curMethod , annotationType ) ; if ( annotation != null ) { results . add ( curMethod ) ; } } return results ; } 
public static void gc ( ) { Runtime . getRuntime ( ) . gc ( ) ; } 
public static boolean isWhitespace ( final CharSequence cs ) { if ( cs == null ) { return false ; } final int sz = cs . length ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { if ( Character . isWhitespace ( cs . charAt ( i ) ) == false ) { return false ; } } return true ; } 
private static void setMaxFraudReportDays ( String asMaxFraudReportDays ) { try { siMaxFraudReportDays = Integer . parseInt ( asMaxFraudReportDays . trim ( ) ) ; } catch ( Throwable aeThrowable ) { siMaxFraudReportDays = DEFAULT_MAX_FRAUD_REPORT_DAYS ; System . out . println ( DEFAULT_MAX_FRAUD_REPORT_DAYS_MSG ) ; } } 
public static void repaintSelection ( JTree tree ) { int [ ] selectedRows = tree . getSelectionRows ( ) ; if ( selectedRows != null && selectedRows . length > 0 ) { Rectangle firstSelectedCell = tree . getRowBounds ( selectedRows [ 0 ] ) ; Rectangle lastSelectedCell = tree . getRowBounds ( selectedRows [ selectedRows . length - 1 ] ) ; Rectangle repaintRectangle = firstSelectedCell . union ( lastSelectedCell ) ; repaintRectangle . x = 0 ; repaintRectangle . width = tree . getWidth ( ) ; tree . repaint ( repaintRectangle ) ; } } 
public boolean intersects ( Range range ) { return intersects ( range . getLowerBound ( ) , range . getUpperBound ( ) ) ; } 
public void removeComponent ( String subdomain ) { List < Component > componentsToRemove = new ArrayList < Component > ( routables . get ( subdomain ) . getComponents ( ) ) ; for ( Component component : componentsToRemove ) { removeComponent ( subdomain , component ) ; } } 
public boolean isValid ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; int numDiscarded = copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return numDiscarded == 0 ; } 
public void setLabelAngle ( double angle ) { this . labelAngle = angle ; fireChangeEvent ( ) ; } 
public Properties getProperties ( int globalID ) { return ( Properties ) props . get ( new Integer ( globalID ) ) ; } 
public static String getDefaultSelectedTalendType ( String dbmsId , String dbmsType , int length , int precison ) { if ( dbmsId == null || "" . equals ( dbmsId ) || dbmsType == null || "" . equals ( dbmsType ) ) { return "id_String" ; } loadAll ( ) ; if ( DB_TO_TALEND_TYPES . get ( dbmsId . toLowerCase ( ) ) != null ) { return DB_TO_TALEND_TYPES . get ( dbmsId . toLowerCase ( ) ) . get ( dbmsType ) ; } return "id_String" ; } 
public String getStoreUri ( ) { String security ; switch ( mFlags & ( FLAG_SSL | FLAG_TLS | FLAG_TRUST_ALL_CERTIFICATES ) ) { case FLAG_SSL : security = "+ssl+" ; break ; case FLAG_SSL | FLAG_TRUST_ALL_CERTIFICATES : security = "+ssl+trustallcerts" ; break ; case FLAG_TLS : security = "+tls+" ; break ; case FLAG_TLS | FLAG_TRUST_ALL_CERTIFICATES : security = "+tls+trustallcerts" ; break ; default : security = "" ; break ; } String userInfo = null ; if ( ( mFlags & FLAG_AUTHENTICATE ) != 0 ) { String trimUser = ( mLogin != null ) ? mLogin . trim ( ) : "" ; String password = ( mPassword != null ) ? mPassword : "" ; userInfo = trimUser + ":" + password ; } String address = ( mAddress != null ) ? mAddress . trim ( ) : null ; String path = ( mDomain != null ) ? "/" + mDomain : null ; URI uri ; try { uri = new URI ( mProtocol + security , userInfo , address , mPort , path , null , null ) ; return uri . toString ( ) ; } catch ( URISyntaxException e ) { return null ; } } 
public void setEnabled ( boolean flag ) { enabled = flag ; if ( ! flag ) { hideTipWindow ( ) ; } } 
public static void forEachRemaining ( Spliterator . OfLong this_ , LongConsumer action ) { do { } while ( this_ . tryAdvance ( action ) ) ; } 
public static Preferences systemRoot ( ) { return factory . systemRoot ( ) ; } 
void loadSynchronousMessages ( ) { if ( DebugFlags . LOAD_LISTENER && ! mSynchronous ) { throw new AssertionError ( ) ; } while ( ! mMessageQueue . isEmpty ( ) ) { handleMessage ( mMessageQueue . remove ( 0 ) ) ; } } 
public void obtainQueryTerms ( MatchingQueryTerms terms ) { for ( Query child : v ) { child . obtainQueryTerms ( terms , true ) ; } ArrayList < Query > alist = new ArrayList < Query > ( ) ; this . getTerms ( alist ) ; terms . addDocumentScoreModifier ( new PhraseScoreModifier ( alist , proximityDistance ) ) ; } 
public String [ ] getPropertyNames ( ) { String [ ] statsNames = new String [ ] { ZonalStatsDescriptor . ZS_PROPERTY } ; String [ ] superNames = super . getPropertyNames ( ) ; if ( superNames == null ) { return statsNames ; } List extraNames = new ArrayList ( ) ; for ( int i = 0 ; i < statsNames . length ; i ++ ) { String prefix = statsNames [ i ] ; String [ ] names = PropertyUtil . getPropertyNames ( superNames , prefix ) ; if ( names != null ) { for ( int j = 0 ; j < names . length ; j ++ ) { if ( names [ j ] . equalsIgnoreCase ( prefix ) ) { extraNames . add ( prefix ) ; } } } } if ( extraNames . size ( ) == 0 ) { return superNames ; } String [ ] propNames = new String [ superNames . length + extraNames . size ( ) ] ; System . arraycopy ( superNames , 0 , propNames , 0 , superNames . length ) ; int offset = superNames . length ; for ( int i = 0 ; i < extraNames . size ( ) ; i ++ ) { propNames [ offset ++ ] = ( String ) extraNames . get ( i ) ; } return propNames ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public static boolean isValidIPV4Address ( String value ) { int periods = 0 ; int i = 0 ; int length = value . length ( ) ; if ( length > 15 ) return false ; char c = 0 ; String word = "" ; for ( i = 0 ; i < length ; i ++ ) { c = value . charAt ( i ) ; if ( c == '.' ) { periods ++ ; if ( periods > 3 ) return false ; if ( word == "" ) return false ; if ( Integer . parseInt ( word ) > 255 ) return false ; word = "" ; } else if ( ! ( Character . isDigit ( c ) ) ) return false ; else { if ( word . length ( ) > 2 ) return false ; word += c ; } } if ( word == "" || Integer . parseInt ( word ) > 255 ) return false ; if ( periods != 3 ) return false ; return true ; } 
private int findPrecedingOrAncestorOrSelf ( XPathContext xctxt , XPath fromMatchPattern , XPath countMatchPattern , int context , ElemNumber namespaceContext ) throws javax . xml . transform . TransformerException { DTM dtm = xctxt . getDTM ( context ) ; while ( DTM . NULL != context ) { if ( null != fromMatchPattern ) { if ( fromMatchPattern . getMatchScore ( xctxt , context ) != XPath . MATCH_SCORE_NONE ) { context = DTM . NULL ; break ; } } if ( null != countMatchPattern ) { if ( countMatchPattern . getMatchScore ( xctxt , context ) != XPath . MATCH_SCORE_NONE ) { break ; } } int prevSibling = dtm . getPreviousSibling ( context ) ; if ( DTM . NULL == prevSibling ) { context = dtm . getParent ( context ) ; } else { context = dtm . getLastChild ( prevSibling ) ; if ( context == DTM . NULL ) context = prevSibling ; } } return context ; } 
public final Script compileString ( String source , String sourceName , int lineno , Object securityDomain ) { if ( lineno < 0 ) { lineno = 0 ; } return compileString ( source , null , null , sourceName , lineno , securityDomain ) ; } 
public void setArc ( Point2D p , Dimension2D d , double start , double extent , int type ) { setArc ( p . getX ( ) , p . getY ( ) , d . getWidth ( ) , d . getHeight ( ) , start , extent , type ) ; } 
public static DocumentBuilder getValidatingXmlParser ( File schemaFile ) { DocumentBuilder db = null ; try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; SchemaFactory factory = SchemaFactory . newInstance ( XMLConstants . W3C_XML_SCHEMA_NS_URI ) ; Schema schema = factory . newSchema ( schemaFile ) ; dbf . setSchema ( schema ) ; db = dbf . newDocumentBuilder ( ) ; db . setErrorHandler ( new SAXErrorHandler ( ) ) ; } catch ( ParserConfigurationException e ) { System . err . printf ( "%s:-Unable-to-create-XML-parser-" , XMLUtils . class . getName ( ) ) ; e . printStackTrace ( ) ; } catch ( SAXException e ) { System . err . printf ( "%s:-XML-parsing-exception-while-loading-schema-%s-" , XMLUtils . class . getName ( ) , schemaFile . getPath ( ) ) ; e . printStackTrace ( ) ; } catch ( UnsupportedOperationException e ) { System . err . printf ( "%s:-API-error-while-setting-up-XML-parser.-Check-your-JAXP-version-" , XMLUtils . class . getName ( ) ) ; e . printStackTrace ( ) ; } return db ; } 
public final ScriptableObject initStandardObjects ( ) { return initStandardObjects ( null , false ) ; } 
public static String convertFrameID22To23 ( String identifier ) { if ( identifier . length ( ) < 3 ) { return null ; } return ID3Frames . convertv22Tov23 . get ( identifier . subSequence ( 0 , 3 ) ) ; } 
public void onRestoreInstanceState ( Bundle savedInstanceState ) { final Bundle dialogHierarchyState = savedInstanceState . getBundle ( DIALOG_HIERARCHY_TAG ) ; if ( dialogHierarchyState == null ) { return ; } dispatchOnCreate ( savedInstanceState ) ; mWindow . restoreHierarchyState ( dialogHierarchyState ) ; if ( savedInstanceState . getBoolean ( DIALOG_SHOWING_TAG ) ) { show ( ) ; } } 
private void setHeadAndPropagate ( Node node , int propagate ) { Node h = head ; setHead ( node ) ; if ( propagate > 0 || h == null || h . waitStatus < 0 ) { Node s = node . next ; if ( s == null || s . isShared ( ) ) doReleaseShared ( ) ; } } 
public void addCategory ( String name , Rights rights ) { Iterator < Song > it = library . iterator ( ) ; while ( it . hasNext ( ) ) { Song song = it . next ( ) ; song . updateCategory ( name , rights ) ; } } 
public static Set < String > getStopWords ( ) throws IOException { Set < String > stopWords = new LinkedHashSet < String > ( ) ; BufferedReader br = new BufferedReader ( new FileReader ( STOPWORDS_FILE ) ) ; for ( String line ; ( line = br . readLine ( ) ) != null ; ) stopWords . add ( line . trim ( ) ) ; br . close ( ) ; return stopWords ; } 
@ Override protected String toExternalForm ( URL url ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "jar:" ) ; sb . append ( url . getFile ( ) ) ; String ref = url . getRef ( ) ; if ( ref != null ) { sb . append ( ref ) ; } return sb . toString ( ) ; } 
public static List < Runnable > shutdownNow ( ExecutorService executorService ) { List < Runnable > answer = null ; if ( ! executorService . isShutdown ( ) ) { LOG . debug ( "Forcing-shutdown-of-ExecutorService:-{}" , executorService ) ; answer = executorService . shutdownNow ( ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "Shutdown-of-ExecutorService:-{}-is-shutdown:-{}-and-terminated:-{}." , new Object [ ] { executorService , executorService . isShutdown ( ) , executorService . isTerminated ( ) } ) ; } } return answer ; } 
static void setOnPreferenceTreeClickListener ( PreferenceManager manager , final OnPreferenceTreeClickListener listener ) { try { Field onPreferenceTreeClickListener = PreferenceManager . class . getDeclaredField ( "mOnPreferenceTreeClickListener" ) ; onPreferenceTreeClickListener . setAccessible ( true ) ; if ( listener != null ) { Object proxy = Proxy . newProxyInstance ( onPreferenceTreeClickListener . getType ( ) . getClassLoader ( ) , new Class [ ] { onPreferenceTreeClickListener . getType ( ) } , new InvocationHandler ( ) { public Object invoke ( Object proxy , Method method , Object [ ] args ) { if ( method . getName ( ) . equals ( "onPreferenceTreeClick" ) ) { return Boolean . valueOf ( listener . onPreferenceTreeClick ( ( PreferenceScreen ) args [ 0 ] , ( Preference ) args [ 1 ] ) ) ; } else { return null ; } } } ) ; onPreferenceTreeClickListener . set ( manager , proxy ) ; } else { onPreferenceTreeClickListener . set ( manager , null ) ; } } catch ( Exception e ) { Log . w ( TAG , "Couldn't-set-PreferenceManager.mOnPreferenceTreeClickListener-by-reflection" , e ) ; } } 
public synchronized void reset ( ) throws IOException { getBufIfOpen ( ) ; if ( markpos < 0 ) throw new IOException ( "Resetting-to-invalid-mark" ) ; pos = markpos ; } 
public Graph convertBuchi ( gov . nasa . ltl . graph . Graph < String > buchi ) { Graph graph = new Graph ( ) ; for ( gov . nasa . ltl . graph . Node < String > node : buchi . getNodes ( ) ) { Node state = new Node ( node . getBooleanAttribute ( "accepting" ) , node . getId ( ) ) ; if ( ! graph . contains ( node . getId ( ) ) ) graph . addNode ( state , node . getId ( ) ) ; for ( gov . nasa . ltl . graph . Edge < String > edge : node . getOutgoingEdges ( ) ) { Edge transition = new Edge ( ) ; gov . nasa . ltl . graph . Guard < String > buchiGuard = edge . getGuard ( ) ; Guard guard = new Guard ( buchiGuard ) ; transition . addGuard ( guard ) ; state . addOutgoingEdge ( transition ) ; transition . setSource ( state ) ; gov . nasa . ltl . graph . Node < String > nextNode = edge . getNext ( ) ; Node nextState = graph . getNode ( nextNode . getId ( ) ) ; if ( nextState == null ) { nextState = new Node ( nextNode . getBooleanAttribute ( "accepting" ) , nextNode . getId ( ) ) ; graph . addNode ( nextState , nextNode . getId ( ) ) ; } nextState . addIncomingEdge ( transition ) ; transition . setNext ( nextState ) ; } } return graph ; } 
private Entry < K , V > removeEntryForKey ( K key ) { int hash = hash ( key ) ; int i = hashIndex ( hash , entries . length ) ; Entry < K , V > prev = entries [ i ] ; Entry < K , V > e = prev ; while ( e != null ) { Entry < K , V > next = e . next ; if ( e . hash == hash && isEqual ( key , e . key ) ) { size -- ; if ( prev == e ) { entries [ i ] = next ; } else { prev . next = next ; } Entry < K , V > prevPtr = e . getPrevPtr ( ) ; Entry < K , V > nextPtr = e . getNextPtr ( ) ; if ( prevPtr != null && nextPtr != null ) { prevPtr . setNextPtr ( nextPtr ) ; nextPtr . setPrevPtr ( prevPtr ) ; } else if ( prevPtr != null ) { tailPtr = prevPtr ; prevPtr . setNextPtr ( null ) ; } else if ( nextPtr != null ) { headPtr = nextPtr ; nextPtr . setPrevPtr ( null ) ; } return e ; } prev = e ; e = next ; } return e ; } 
void write ( DataOutput par1DataOutput ) throws IOException { par1DataOutput . writeFloat ( this . data ) ; } 
public static boolean getBoolean ( ) { boolean ans = false ; while ( true ) { String s = getWord ( ) ; if ( s . equalsIgnoreCase ( "true" ) || s . equalsIgnoreCase ( "t" ) || s . equalsIgnoreCase ( "yes" ) || s . equalsIgnoreCase ( "y" ) || s . equals ( "1" ) ) { ans = true ; break ; } else if ( s . equalsIgnoreCase ( "false" ) || s . equalsIgnoreCase ( "f" ) || s . equalsIgnoreCase ( "no" ) || s . equalsIgnoreCase ( "n" ) || s . equals ( "0" ) ) { ans = false ; break ; } else errorMessage ( "Illegal-boolean-input-value." , "one-of:-true,-false,-t,-f,-yes,-no,-y,-n,-0,-or-1" ) ; } inputErrorCount = 0 ; return ans ; } 
public static Rectangle getLocalBounds ( Component aComponent ) { Rectangle b = new Rectangle ( aComponent . getBounds ( ) ) ; b . x = b . y = 0 ; return b ; } 
private static String getTranslation ( String [ ] p_74299_0_ , int p_74299_1_ ) { if ( p_74299_1_ < 0 || p_74299_1_ >= p_74299_0_ . length ) { p_74299_1_ = 0 ; } return I18n . format ( p_74299_0_ [ p_74299_1_ ] , new Object [ 0 ] ) ; } 
public String readLine ( ) throws IOException { synchronized ( in ) { if ( buf == null ) { throw new IOException ( "LineReader-is-closed" ) ; } if ( pos >= end ) { fillBuf ( ) ; } for ( int i = pos ; i != end ; ++ i ) { if ( buf [ i ] == LF ) { int lineEnd = ( i != pos && buf [ i - 1 ] == CR ) ? i - 1 : i ; String res = new String ( buf , pos , lineEnd - pos , charset . name ( ) ) ; pos = i + 1 ; return res ; } } ByteArrayOutputStream out = new ByteArrayOutputStream ( end - pos + 80 ) { @ Override public String toString ( ) { int length = ( count > 0 && buf [ count - 1 ] == CR ) ? count - 1 : count ; try { return new String ( buf , 0 , length , charset . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( e ) ; } } } ; while ( true ) { out . write ( buf , pos , end - pos ) ; end = - 1 ; fillBuf ( ) ; for ( int i = pos ; i != end ; ++ i ) { if ( buf [ i ] == LF ) { if ( i != pos ) { out . write ( buf , pos , i - pos ) ; } pos = i + 1 ; return out . toString ( ) ; } } } } } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; if ( localItemTracker ) { if ( localItem != null ) { for ( int i = 0 ; i < localItem . length ; i ++ ) { if ( localItem [ i ] != null ) { elementList . add ( new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2012-08-15/" , "item" ) ) ; elementList . add ( localItem [ i ] ) ; } else { } } } else { throw new org . apache . axis2 . databinding . ADBException ( "item-cannot-be-null!!" ) ; } } return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
public static WritableRaster createInterleavedRaster ( DataBuffer dataBuffer , int w , int h , int scanlineStride , int pixelStride , int bandOffsets [ ] , Point location ) { if ( w <= 0 || h <= 0 ) { throw new RasterFormatException ( Messages . getString ( "awt.22E" ) ) ; } if ( location == null ) { location = new Point ( 0 , 0 ) ; } if ( ( long ) location . x + w > Integer . MAX_VALUE || ( long ) location . y + h > Integer . MAX_VALUE ) { throw new RasterFormatException ( Messages . getString ( "awt.276" ) ) ; } if ( dataBuffer == null ) { throw new NullPointerException ( Messages . getString ( "awt.278" ) ) ; } int dataType = dataBuffer . getDataType ( ) ; if ( dataType != DataBuffer . TYPE_BYTE && dataType != DataBuffer . TYPE_USHORT ) { throw new IllegalArgumentException ( Messages . getString ( "awt.230" ) ) ; } if ( dataBuffer . getNumBanks ( ) > 1 ) { throw new RasterFormatException ( Messages . getString ( "awt.27A" ) ) ; } if ( bandOffsets == null ) { throw new NullPointerException ( Messages . getString ( "awt.27B" ) ) ; } PixelInterleavedSampleModel sampleModel = new PixelInterleavedSampleModel ( dataType , w , h , pixelStride , scanlineStride , bandOffsets ) ; return new OrdinaryWritableRaster ( sampleModel , dataBuffer , location ) ; } 
public static double utcOffset ( ) { Calendar cal = Calendar . getInstance ( ) ; return 4 * 60 * 60 - ( cal . get ( Calendar . ZONE_OFFSET ) + cal . get ( Calendar . DST_OFFSET ) ) / 1000 ; } 
public AttributeSet getCharacterAttribute ( int i ) { if ( model instanceof StyledDocument ) { StyledDocument doc = ( StyledDocument ) model ; Element elem = doc . getCharacterElement ( i ) ; if ( elem != null ) { return elem . getAttributes ( ) ; } } return null ; } 
public static Rect getFrameForView ( View v ) { int location [ ] = new int [ 2 ] ; v . getLocationOnScreen ( location ) ; Rect viewRect = new Rect ( location [ 0 ] , location [ 1 ] , location [ 0 ] + v . getWidth ( ) , location [ 1 ] + v . getHeight ( ) ) ; return viewRect ; } 
SimpleTerminologyAccess ( String id ) { this . id = id ; this . groups = new HashMap < String , Set < CodePhrase >> ( ) ; this . groupLangNameToId = new HashMap < String , Map < String , String >> ( ) ; this . codeRubrics = new HashMap < String , Map < String , String >> ( ) ; } 
public void setLocations ( ArrayList < Location > locations ) { this . locations = locations ; pathLength = 0.0 ; for ( int i = 0 ; i < locations . size ( ) - 1 ; ++ i ) { Location l1 = locations . get ( i ) ; Location l2 = locations . get ( i + 1 ) ; pathLength += l1 . distance ( l2 ) ; } } 
public static String decodeEncodedWords ( String body , Message message ) { if ( body . indexOf ( "=?" ) == - 1 ) { return body ; } int previousEnd = 0 ; boolean previousWasEncoded = false ; StringBuilder sb = new StringBuilder ( ) ; while ( true ) { int begin = body . indexOf ( "=?" , previousEnd ) ; int endScan = begin + 2 ; if ( begin != - 1 ) { int qm1 = body . indexOf ( '?' , endScan + 2 ) ; int qm2 = body . indexOf ( '?' , qm1 + 1 ) ; if ( qm2 != - 1 ) { endScan = qm2 + 1 ; } } int end = begin == - 1 ? - 1 : body . indexOf ( "?=" , endScan ) ; if ( end == - 1 ) { if ( previousEnd == 0 ) return body ; sb . append ( body . substring ( previousEnd ) ) ; return sb . toString ( ) ; } end += 2 ; String sep = body . substring ( previousEnd , begin ) ; String decoded = decodeEncodedWord ( body , begin , end , message ) ; if ( decoded == null ) { sb . append ( sep ) ; sb . append ( body . substring ( begin , end ) ) ; } else { if ( ! previousWasEncoded || ! CharsetUtil . isWhitespace ( sep ) ) { sb . append ( sep ) ; } sb . append ( decoded ) ; } previousEnd = end ; previousWasEncoded = decoded != null ; } } 
public static String getMessage ( final int code , int subCode , final Object [ ] add ) { String message = getResourceString ( code ) ; if ( subCode != 0 ) { message += getResourceString ( subCode ) ; } if ( add != null ) { message = insertStrings ( message , add ) ; } return message ; } 
public float getFloat ( String name , String category , float defaultValue , float minValue , float maxValue , String comment ) { return getFloat ( name , category , defaultValue , minValue , maxValue , comment , name ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public final static < T1 , T2 , R > Observable < R > zip ( Observable < ? extends T1 > o1 , Observable < ? extends T2 > o2 , final Func2 < ? super T1 , ? super T2 , ? extends R > zipFunction ) { return just ( new Observable < ? > [ ] { o1 , o2 } ) . lift ( new OperatorZip < R > ( zipFunction ) ) ; } 
public static void configureVertica ( Configuration conf , String [ ] hostnames , String database , String username , String password ) { conf . setStrings ( HOSTNAMES_PROP , hostnames ) ; conf . set ( DATABASE_PROP , database ) ; conf . set ( USERNAME_PROP , username ) ; conf . set ( PASSWORD_PROP , password ) ; } 
public void add ( String name , T val ) { nvPairs . add ( name ) ; nvPairs . add ( val ) ; } 
public CharSequence subSequence ( int start , int end ) { return substring ( start , end ) ; } 
public void removeActivationName ( String name ) { if ( sealed ) onSealedMutation ( ) ; if ( activationNames != null ) activationNames . remove ( name ) ; } 
public int numUniqueTokens ( ) { return tokenSet . size ( ) ; } 
public void endElement ( QName element , Augmentations augs ) throws XNIException { if ( fNamespaces ) { handleEndElement ( element , augs , false ) ; } else if ( fDocumentHandler != null ) { fDocumentHandler . endElement ( element , augs ) ; } } 
public static final String getBluetoothHeadsetPriorityKey ( String address ) { return ( "bluetooth_headset_priority_" + address . toUpperCase ( ) ) ; } 
public static void extractURL ( String request , int beginIndex , final Map < Integer , RequestComponent > requestComponents ) { logger . debug ( "extractURL-called..." ) ; logger . debug ( "request=" + request ) ; logger . debug ( "beginIndex=" + beginIndex ) ; if ( StringUtils . isEmpty ( request ) ) { return ; } if ( beginIndex >= request . length ( ) ) { return ; } if ( requestComponents == null ) { logger . error ( "requestComponents-cannot-be-null" ) ; throw new SVNTechnicalException ( "requestComponents-cannot-be-null" ) ; } final String urlToken = "svn+ssh" ; String temp = request . substring ( beginIndex ) ; logger . debug ( "extractURL-in-" + temp ) ; if ( temp . contains ( urlToken ) ) { int indexCommand = temp . indexOf ( urlToken ) ; if ( indexCommand >= 0 ) { temp = temp . substring ( indexCommand ) ; int index = temp . indexOf ( "-" ) ; if ( index > 1 ) { temp = temp . substring ( 0 , index ) ; } RequestComponent component = new RequestComponentUrl ( request , temp ) ; requestComponents . put ( ( indexCommand + beginIndex ) , component ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "extracted=" + component . toString ( ) ) ; } extractURL ( request , indexCommand + beginIndex + 1 , requestComponents ) ; } } } 
public double getTotalResponseTime ( ) { if ( exitTimes == null || entryTimes == null ) { return 0 ; } double time = 0 ; try { double startTime = exitTimes . firstElement ( ) . doubleValue ( ) ; double receiveTime = entryTimes . lastElement ( ) . doubleValue ( ) ; time = receiveTime - startTime ; } catch ( Exception e ) { time = 0 ; } return time ; } 
public Period match ( SortedMap < Period , ZoneStatus > zoneSchedule , long time ) { NDC . push ( "match" ) ; try { Stack < Period > stack = new Stack < Period > ( ) ; Date currentDate = new Date ( time ) ; logger . debug ( "Matching-" + currentDate ) ; SortedMap < Period , ZoneStatus > today = getToday ( zoneSchedule , currentDate ) ; for ( Iterator < Period > i = today . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Period p = i . next ( ) ; if ( p . includes ( currentDate ) ) { logger . debug ( "Included-" + p ) ; stack . push ( p ) ; } } return stack . pop ( ) ; } finally { NDC . pop ( ) ; } } 
public void println ( double x ) { out . println ( x ) ; } 
public final void load ( InputStream stream , char [ ] password ) throws IOException , NoSuchAlgorithmException , CertificateException { implSpi . engineLoad ( stream , password ) ; isInit = true ; } 
@ Override public boolean containsValue ( Object value ) { HashMapEntry [ ] tab = table ; int len = tab . length ; if ( value == null ) { for ( int i = 0 ; i < len ; i ++ ) { for ( HashMapEntry e = tab [ i ] ; e != null ; e = e . next ) { if ( e . value == null ) { return true ; } } } return entryForNullKey != null && entryForNullKey . value == null ; } for ( int i = 0 ; i < len ; i ++ ) { for ( HashMapEntry e = tab [ i ] ; e != null ; e = e . next ) { if ( value . equals ( e . value ) ) { return true ; } } } return entryForNullKey != null && value . equals ( entryForNullKey . value ) ; } 
public static < K extends Comparable < ? > , V > Builder < K , V > builder ( ) { return new Builder < K , V > ( ) ; } 
public List < Double > getVelocity ( ) { if ( velocity == null ) { velocity = new ArrayList < Double > ( ) ; } return this . velocity ; } 
public Value setAuthorityValue ( ) throws WingException { return setAuthorityValue ( "" , "UNSET" ) ; } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; elementList . add ( new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2012-08-15/" , "snapshotId" ) ) ; if ( localSnapshotId != null ) { elementList . add ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( localSnapshotId ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "snapshotId-cannot-be-null!!" ) ; } return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
void setCacheColorHint ( int color ) { if ( mViewTypeCount == 1 ) { final ArrayList < View > scrap = mCurrentScrap ; final int scrapCount = scrap . size ( ) ; for ( int i = 0 ; i < scrapCount ; i ++ ) { scrap . get ( i ) . setDrawingCacheBackgroundColor ( color ) ; } } else { final int typeCount = mViewTypeCount ; for ( int i = 0 ; i < typeCount ; i ++ ) { final ArrayList < View > scrap = mScrapViews [ i ] ; final int scrapCount = scrap . size ( ) ; for ( int j = 0 ; j < scrapCount ; j ++ ) { scrap . get ( j ) . setDrawingCacheBackgroundColor ( color ) ; } } } final View [ ] activeViews = mActiveViews ; final int count = activeViews . length ; for ( int i = 0 ; i < count ; ++ i ) { final View victim = activeViews [ i ] ; if ( victim != null ) { victim . setDrawingCacheBackgroundColor ( color ) ; } } } 
public SelectionBuilder where ( String selection , String ... selectionArgs ) { if ( TextUtils . isEmpty ( selection ) ) { if ( selectionArgs != null && selectionArgs . length > 0 ) { throw new IllegalArgumentException ( "Valid-selection-required-when-including-arguments=" ) ; } return this ; } if ( mSelection . length ( ) > 0 ) { mSelection . append ( "-AND-" ) ; } mSelection . append ( "(" ) . append ( selection ) . append ( ")" ) ; if ( selectionArgs != null ) { Collections . addAll ( mSelectionArgs , selectionArgs ) ; } return this ; } 
private void killTasksWithMaxRssMemory ( long rssMemoryInUsage ) { List < TaskAttemptID > tasksToKill = new ArrayList < TaskAttemptID > ( ) ; List < TaskAttemptID > allTasks = new ArrayList < TaskAttemptID > ( ) ; allTasks . addAll ( processTreeInfoMap . keySet ( ) ) ; Collections . sort ( allTasks , new Comparator < TaskAttemptID > ( ) { public int compare ( TaskAttemptID tid1 , TaskAttemptID tid2 ) { return getTaskCumulativeRssmem ( tid1 ) < getTaskCumulativeRssmem ( tid2 ) ? - 1 : 1 ; } } ) ; while ( rssMemoryInUsage > maxRssMemoryAllowedForAllTasks && ! allTasks . isEmpty ( ) ) { TaskAttemptID tid = allTasks . remove ( allTasks . size ( ) - 1 ) ; if ( ! isKillable ( tid ) ) { continue ; } long rssmem = getTaskCumulativeRssmem ( tid ) ; if ( rssmem == 0 ) { break ; } tasksToKill . add ( tid ) ; rssMemoryInUsage -= rssmem ; } if ( ! tasksToKill . isEmpty ( ) ) { for ( TaskAttemptID tid : tasksToKill ) { String msg = "Killing-one-of-the-memory-consuming-tasks---" + tid + ",-as-the-cumulative-RSS-memory-usage-of-all-the-tasks-on-" + "the-TaskTracker-exceeds-physical-memory-limit-" + maxRssMemoryAllowedForAllTasks + "." ; LOG . warn ( msg ) ; killTask ( tid , msg ) ; } } else { LOG . info ( "The-total-physical-memory-usage-is-overflowing-TTs-limits.-" + "But-found-no-alive-task-to-kill-for-freeing-memory." ) ; } } 
public java . lang . Boolean isVisible ( ) { return visible == null ? Boolean . valueOf ( true ) : visible ; } 
public boolean equalsIgnoreCase ( String anotherString ) { return ( this == anotherString ) ? true : ( anotherString != null ) && ( anotherString . count == count ) && regionMatches ( true , 0 , anotherString , 0 , count ) ; } 
public < T > T setDisabledColor ( String strColor , Class < T > returnType ) { String extension = "setDisabledColor("" + strColor + "")." ; try { java . lang . reflect . Constructor < T > ctor = returnType . getConstructor ( Context . class , String . class ) ; return ctor . newInstance ( this , extension ) ; } catch ( Exception ex ) { throw new IllegalArgumentException ( "Unsupported-return-type:-" + returnType . getName ( ) ) ; } } 
public final Collection < ? extends CRL > getCRLs ( CRLSelector selector ) throws CertStoreException { return spiImpl . engineGetCRLs ( selector ) ; } 
public static int printUsage ( String [ ] args , String usage ) { err . println ( "args-=-" + Arrays . asList ( args ) ) ; err . println ( ) ; err . println ( "Usage:-java-" + usage ) ; err . println ( ) ; ToolRunner . printGenericCommandUsage ( err ) ; return - 1 ; } 
public void add ( int el ) { int n = wordNumber ( el ) ; if ( n >= bits . length ) { growToInclude ( el ) ; } bits [ n ] |= bitMask ( el ) ; } 
public Builder withMarshallerNoNamespaceSchemaLocation ( String value ) { properties . put ( Marshaller . JAXB_NO_NAMESPACE_SCHEMA_LOCATION , value ) ; return this ; } 
public NamedObject ( String objectName , DynamicMBean object ) throws MalformedObjectNameException { ObjectName objName = new ObjectName ( objectName ) ; if ( objName . isPattern ( ) ) { throw new RuntimeOperationsException ( new IllegalArgumentException ( "Invalid-name->" + objName . toString ( ) ) ) ; } this . name = objName ; this . object = object ; } 
public static String numberToString ( Number number ) throws JSONException { if ( number == null ) { throw new JSONException ( "Null-pointer" ) ; } testValidity ( number ) ; String string = number . toString ( ) ; if ( string . indexOf ( '.' ) > 0 && string . indexOf ( 'e' ) < 0 && string . indexOf ( 'E' ) < 0 ) { while ( string . endsWith ( "0" ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . endsWith ( "." ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; } 
public Object clone ( ) { ChoiceFormat other = ( ChoiceFormat ) super . clone ( ) ; other . choiceLimits = ( double [ ] ) choiceLimits . clone ( ) ; other . choiceFormats = ( String [ ] ) choiceFormats . clone ( ) ; return other ; } 
public static BufferedReader openFileForBufferedUtf8Reading ( final File file ) { return new BufferedReader ( new InputStreamReader ( openFileForReading ( file ) , Charset . forName ( "UTF-8" ) ) ) ; } 
public Rectangle2D getScreenDataArea ( ) { Rectangle2D dataArea = this . info . getPlotInfo ( ) . getDataArea ( ) ; Insets insets = getInsets ( ) ; double x = dataArea . getX ( ) * this . scaleX + insets . left ; double y = dataArea . getY ( ) * this . scaleY + insets . top ; double w = dataArea . getWidth ( ) * this . scaleX ; double h = dataArea . getHeight ( ) * this . scaleY ; return new Rectangle2D . Double ( x , y , w , h ) ; } 
@ Override public void drawRangeLine ( Graphics2D g2 , XYPlot plot , ValueAxis axis , Rectangle2D dataArea , double value , Paint paint , Stroke stroke ) { Range range = axis . getRange ( ) ; if ( ! range . contains ( value ) ) { return ; } PlotOrientation orientation = plot . getOrientation ( ) ; Line2D line = null ; double v = axis . valueToJava2D ( value , dataArea , plot . getRangeAxisEdge ( ) ) ; if ( orientation == PlotOrientation . HORIZONTAL ) { line = new Line2D . Double ( v , dataArea . getMinY ( ) , v , dataArea . getMaxY ( ) ) ; } else if ( orientation == PlotOrientation . VERTICAL ) { line = new Line2D . Double ( dataArea . getMinX ( ) , v , dataArea . getMaxX ( ) , v ) ; } g2 . setPaint ( paint ) ; g2 . setStroke ( stroke ) ; g2 . draw ( line ) ; } 
public static boolean isFilenameSafe ( File file ) { return SAFE_FILENAME_PATTERN . matcher ( file . getPath ( ) ) . matches ( ) ; } 
public float getTextRunAdvances ( char [ ] chars , int index , int count , int contextIndex , int contextCount , int flags , float [ ] advances , int advancesIndex ) { if ( chars == null ) { throw new IllegalArgumentException ( "text-cannot-be-null" ) ; } if ( flags != DIRECTION_LTR && flags != DIRECTION_RTL ) { throw new IllegalArgumentException ( "unknown-flags-value:-" + flags ) ; } if ( ( index | count | contextIndex | contextCount | advancesIndex | ( index - contextIndex ) | ( contextCount - count ) | ( ( contextIndex + contextCount ) - ( index + count ) ) | ( chars . length - ( contextIndex + contextCount ) ) | ( advances == null ? 0 : ( advances . length - ( advancesIndex + count ) ) ) ) < 0 ) { throw new IndexOutOfBoundsException ( ) ; } if ( chars . length == 0 || count == 0 ) { return 0f ; } if ( ! mHasCompatScaling ) { return native_getTextRunAdvances ( mNativePaint , chars , index , count , contextIndex , contextCount , flags , advances , advancesIndex ) ; } final float oldSize = getTextSize ( ) ; setTextSize ( oldSize * mCompatScaling ) ; float res = native_getTextRunAdvances ( mNativePaint , chars , index , count , contextIndex , contextCount , flags , advances , advancesIndex ) ; setTextSize ( oldSize ) ; if ( advances != null ) { for ( int i = advancesIndex , e = i + count ; i < e ; i ++ ) { advances [ i ] *= mInvCompatScaling ; } } return res * mInvCompatScaling ; } 
public List < Float > getFloat1X2 ( ) { if ( float1X2 == null ) { float1X2 = new ArrayList < Float > ( ) ; } return this . float1X2 ; } 
@ Override public String toString ( ) { return this . getClass ( ) . getName ( ) + '(' + getName ( ) + ':' + getTypeInternal ( ) + ')' ; } 
public String [ ] getLastAndNextPaymentsMonthYear ( ) { try { if ( seMonthlyDao == null ) seMonthlyDao = new SeMonthlyDao ( ) ; Object [ ] monthYear = seMonthlyDao . findLatestPaymentMonth ( ) ; int monthNo = ( ( Integer ) monthYear [ 0 ] ) . intValue ( ) ; String [ ] monthNameYear = new String [ 2 ] ; monthNameYear [ 0 ] = DateUtil . getMonthName ( ( String ) monthYear [ 0 ] . toString ( ) ) ; if ( monthNo < 7 ) monthNameYear [ 0 ] = monthNameYear [ 0 ] + ",-" + ( ( String ) monthYear [ 1 ] ) . substring ( 4 ) ; else monthNameYear [ 0 ] = monthNameYear [ 0 ] + ",-" + ( ( String ) monthYear [ 1 ] ) . substring ( 0 , 4 ) ; int nextMonthNo = monthNo + 1 ; if ( monthNo > 12 ) nextMonthNo = 1 ; monthNameYear [ 1 ] = DateUtil . getMonthName ( String . valueOf ( nextMonthNo ) ) ; if ( nextMonthNo < 7 ) monthNameYear [ 1 ] = monthNameYear [ 1 ] + ",-" + ( ( String ) monthYear [ 1 ] ) . substring ( 4 ) ; else monthNameYear [ 1 ] = monthNameYear [ 1 ] + ",-" + ( ( String ) monthYear [ 1 ] ) . substring ( 0 , 4 ) ; return monthNameYear ; } catch ( Exception e ) { logger . debug ( "-Could-not-get-getLastAndNextPaymentsMonthYear" + e ) ; } return null ; } 
private void go ( ) { frame = new JFrame ( ) ; frame . setLayout ( new GridLayout ( 2 , 0 ) ) ; frame . setSize ( 300 , 300 ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; buildMenu ( ) ; buildButton ( ) ; frame . setVisible ( true ) ; } 
protected Rectangle2D getLabelEnclosure ( Graphics2D g2 , RectangleEdge edge ) { Rectangle2D result = new Rectangle2D . Double ( ) ; Rectangle2D bounds = null ; if ( this . attributedLabel != null ) { TextLayout layout = new TextLayout ( this . attributedLabel . getIterator ( ) , g2 . getFontRenderContext ( ) ) ; bounds = layout . getBounds ( ) ; } else { String axisLabel = getLabel ( ) ; if ( axisLabel != null && ! axisLabel . equals ( "" ) ) { FontMetrics fm = g2 . getFontMetrics ( getLabelFont ( ) ) ; bounds = TextUtilities . getTextBounds ( axisLabel , g2 , fm ) ; } } if ( bounds != null ) { RectangleInsets insets = getLabelInsets ( ) ; bounds = insets . createOutsetRectangle ( bounds ) ; double angle = getLabelAngle ( ) ; if ( edge == RectangleEdge . LEFT || edge == RectangleEdge . RIGHT ) { angle = angle - Math . PI / 2.0 ; } double x = bounds . getCenterX ( ) ; double y = bounds . getCenterY ( ) ; AffineTransform transformer = AffineTransform . getRotateInstance ( angle , x , y ) ; Shape labelBounds = transformer . createTransformedShape ( bounds ) ; result = labelBounds . getBounds2D ( ) ; } return result ; } 
public String [ ] getHeader ( String name ) { Vector values = new Vector ( ) ; for ( int i = 0 ; i < headers . size ( ) ; i ++ ) { MimeHeader hdr = ( MimeHeader ) headers . elementAt ( i ) ; if ( hdr . getName ( ) . equalsIgnoreCase ( name ) && hdr . getValue ( ) != null ) values . addElement ( hdr . getValue ( ) ) ; } if ( values . size ( ) == 0 ) return null ; String r [ ] = new String [ values . size ( ) ] ; values . copyInto ( r ) ; return r ; } 
private void serviceInfoFromProperties ( Provider . Service s ) { super . remove ( s . type + "." + s . algorithm ) ; if ( s . aliases != null ) { for ( Iterator < String > i = s . aliases . iterator ( ) ; i . hasNext ( ) ; ) { super . remove ( "Alg.Alias." + s . type + "." + i . next ( ) ) ; } } if ( s . attributes != null ) { for ( Map . Entry < String , String > entry : s . attributes . entrySet ( ) ) { super . remove ( s . type + "." + s . algorithm + "-" + entry . getKey ( ) ) ; } } if ( providerNumber != - 1 ) { Services . setNeedRefresh ( ) ; } } 
public void removeExceptStartingWith ( Set < E > keys ) { if ( keys == null ) throw new IllegalArgumentException ( "The-key-cannot-be-(null)!" ) ; TreeSet < E > dead = new TreeSet < E > ( ) ; for ( E key : pPaths . keySet ( ) ) { if ( ! keys . contains ( key ) ) dead . add ( key ) ; } for ( E key : dead ) pPaths . remove ( key ) ; } 
public void setDateFormat ( int style , Locale locale ) { setText ( DateFormat . getDateInstance ( style , locale ) . format ( new Date ( ) ) ) ; } 
public String removeNTString ( ) { StringBuffer s = new StringBuffer ( ) ; char b = removeChar ( ) ; while ( b != ( char ) 0x00 ) { s . append ( b ) ; b = removeChar ( ) ; } return s . toString ( ) ; } 
void set ( final int type , final String strVal1 , final String strVal2 , final String strVal3 ) { this . type = type ; this . strVal1 = strVal1 ; this . strVal2 = strVal2 ; this . strVal3 = strVal3 ; switch ( type ) { case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : case ClassWriter . MTYPE : case ClassWriter . TYPE_NORMAL : hashCode = 0x7FFFFFFF & ( type + strVal1 . hashCode ( ) ) ; return ; case ClassWriter . NAME_TYPE : { hashCode = 0x7FFFFFFF & ( type + strVal1 . hashCode ( ) * strVal2 . hashCode ( ) ) ; return ; } default : hashCode = 0x7FFFFFFF & ( type + strVal1 . hashCode ( ) * strVal2 . hashCode ( ) * strVal3 . hashCode ( ) ) ; } } 
public static boolean booleanF ( Object obj ) { if ( obj instanceof Double ) { final double temp = ( ( Double ) obj ) . doubleValue ( ) ; return temp != 0.0 && ! Double . isNaN ( temp ) ; } else if ( obj instanceof Integer ) { return ( ( Integer ) obj ) . doubleValue ( ) != 0 ; } else if ( obj instanceof Boolean ) { return ( ( Boolean ) obj ) . booleanValue ( ) ; } else if ( obj instanceof String ) { return ! ( ( String ) obj ) . equals ( EMPTYSTRING ) ; } else if ( obj instanceof DTMAxisIterator ) { DTMAxisIterator iter = ( DTMAxisIterator ) obj ; return iter . reset ( ) . next ( ) != DTMAxisIterator . END ; } else if ( obj instanceof Node ) { return true ; } else if ( obj instanceof DOM ) { String temp = ( ( DOM ) obj ) . getStringValue ( ) ; return ! temp . equals ( EMPTYSTRING ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( INVALID_ARGUMENT_ERR , className , "boolean()" ) ; } return false ; } 
@ Deprecated public void clearPluginObjects ( ) { pluginMap . clear ( ) ; } 
public Matcher useAnchoringBounds ( boolean value ) { anchoringBounds = value ; useAnchoringBoundsImpl ( address , value ) ; return this ; } 
public void setActions ( List < Action > actions ) { if ( actions == null ) { return ; } this . actions = new ArrayList < Action > ( actions . size ( ) ) ; for ( Action action : actions ) { if ( action . isValid ( ) ) { this . actions . add ( action ) ; } } } 
public static int [ ] extend ( int [ ] a , int additional ) { int [ ] ret = new int [ a . length + additional ] ; System . arraycopy ( a , 0 , ret , 0 , a . length ) ; return ret ; } 
public void writeText ( String text ) { int index = 0 , textLen = text . length ( ) ; if ( GoLconst . OUTPUT_DESTINATION . equals ( "SCREEN" ) ) { textArea . append ( text ) ; } else { if ( ! GoLconst . flagOutFileCreated ) { try { bos = new BufferedOutputStream ( new FileOutputStream ( "AI_exec.txt" ) ) ; } catch ( Exception e ) { System . err . println ( "Error-creating-output-file:-" + e ) ; } GoLconst . flagOutFileCreated = true ; } try { do { bos . write ( text . charAt ( index ) ) ; } while ( index ++ > textLen ) ; } catch ( Exception e ) { System . err . println ( "Error-writing-output-file:-" + e ) ; bos = null ; } } } 
public void testPosPosSameLength ( ) { byte aBytes [ ] = { - 128 , 56 , 100 , - 2 , - 76 , 89 , 45 , 91 , 3 , - 15 , 35 , 26 , - 117 } ; byte bBytes [ ] = { - 2 , - 3 , - 4 , - 4 , 5 , 14 , 23 , 39 , 48 , 57 , 66 , 5 , 14 , 23 } ; int aSign = 1 ; int bSign = 1 ; byte rBytes [ ] = { 0 , - 128 , 56 , 100 , 4 , 4 , 17 , 37 , 16 , 1 , 64 , 1 , 10 , 3 } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . and ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = 0 ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( "incorrect-sign" , 1 , result . signum ( ) ) ; } 
private static int setColorAlpha ( int color , byte alpha ) { return Color . argb ( alpha , Color . red ( color ) , Color . green ( color ) , Color . blue ( color ) ) ; } 
public static boolean isOs ( String identifier ) { return ( OS . indexOf ( identifier ) >= 0 ) ; } 
public static void writeFile ( InputStream inStream , OutputStream out ) throws IOException { try { byte [ ] buf = new byte [ BUFF_SIZE ] ; int len = inStream . read ( buf ) ; while ( len > 0 ) { out . write ( buf , 0 , len ) ; len = inStream . read ( buf ) ; } } finally { if ( inStream != null ) { inStream . close ( ) ; } if ( out != null ) { out . close ( ) ; } } } 
DirectoryTypeCache ( File directory , FileStoreFactory factory ) throws IOException { if ( directory == null ) throw new NullPointerException ( "Directory-parameter-should-be-not-null" ) ; if ( ! directory . exists ( ) ) { throw new IllegalArgumentException ( "Specified-directory-does-not-exists:-" + directory . getAbsolutePath ( ) ) ; } if ( ! directory . isDirectory ( ) ) { throw new IllegalArgumentException ( "Specified-path-is-not-a-directory,-it'a-s-file-instead:-" + directory . getAbsolutePath ( ) ) ; } this . directory = directory ; this . factory = factory ; this . watcher = new ImmediateDirectoryWatcher ( directory ) ; } 
public void setName ( String policyName ) throws InvalidNameException { validateName ( policyName ) ; if ( this . policyName . equals ( policyName ) ) { return ; } if ( origPolicyName == null ) { origPolicyName = this . policyName ; } this . policyName = policyName ; } 
@ XmlElementDecl ( namespace = "http://www.serviceobjects.com" , name = "FragmentPMBPrefix" , scope = SuiteLinkAddress . class ) public JAXBElement < String > createSuiteLinkAddressFragmentPMBPrefix ( String value ) { return new JAXBElement < String > ( _AddressCandidateFragmentPMBPrefix_QNAME , String . class , SuiteLinkAddress . class , value ) ; } 
public final String format ( long value ) { return format ( value , new StringBuffer ( ) , new FieldPosition ( 0 ) ) . toString ( ) ; } 
protected void fill ( ) throws IOException { pos = 0 ; count = 0 ; int nRead = is . read ( buf , 0 , buf . length ) ; if ( nRead > 0 ) { count = nRead ; } } 
public static boolean isDeprecated ( String key ) { return deprecatedKeyMap . containsKey ( key ) ; } 
protected double getStandardDev ( int attIndex ) throws Exception { if ( ! m_clusterInstances . attribute ( attIndex ) . isNumeric ( ) ) { throw new Exception ( "getStandardDev:-attribute-is-not-numeric" ) ; } m_attStats [ attIndex ] . numericStats . calculateDerived ( ) ; double stdDev = m_attStats [ attIndex ] . numericStats . stdDev ; if ( Double . isNaN ( stdDev ) || Double . isInfinite ( stdDev ) ) { return m_acuity ; } return Math . max ( m_acuity , stdDev ) ; } 
public void setSpeedLimit ( String limit ) { myPreferences . put ( "DownloadSettingsMaxConnectionSpeed" , limit ) ; prefMap . put ( "DownloadSettingsMaxConnectionSpeed" , limit ) ; } 
public float getHeading ( ) { this . lastAccessTime = System . currentTimeMillis ( ) ; return this . heading ; } 
private boolean checkValidity ( ) { if ( mLastModified != mFile . lastModified ( ) ) { mLength = mFile . length ( ) ; mSha1 = null ; return true ; } return false ; } 
public String getClob ( String champ ) throws Exception { try { if ( m_Rset . getClob ( champ ) != null ) return m_Rset . getClob ( champ ) . getSubString ( 1 , new Integer ( "" + m_Rset . getClob ( champ ) . length ( ) ) . intValue ( ) ) ; else return "" ; } catch ( Exception e ) { throw new Exception ( "Error.JDBCWrapper.LectureChamp-" + champ + "-" + e . toString ( ) ) ; } } 
private void updateViewPort ( ) { if ( ! updateViewPort ) return ; if ( ( posInViewPort & PLAYER_TOP + PLAYER_VCENTER + PLAYER_BOTTOM ) != 0 ) { viewPortY = Math . max ( Math . min ( viewPortY , player . getY ( ) + topLimit ) , player . getY ( ) + bottomLimit ) ; } if ( ( posInViewPort & PLAYER_LEFT + PLAYER_HCENTER + PLAYER_RIGHT ) != 0 ) { viewPortX = Math . max ( Math . min ( viewPortX , player . getX ( ) + leftLimit ) , player . getX ( ) + rightLimit ) ; } viewPortX = Math . max ( minX , Math . min ( viewPortX , maxX - screenWidth ) ) ; viewPortY = Math . max ( minY , Math . min ( viewPortY , maxY - screenHeight ) ) ; updateViewPort = false ; } 
synchronized public void setSeed ( int [ ] array ) { if ( array . length == 0 ) { throw new IllegalArgumentException ( "Array-length-must-be-greater-than-zero" ) ; } int i , j , k ; setSeed ( 19650218 ) ; i = 1 ; j = 0 ; k = ( N > array . length ? N : array . length ) ; for ( ; k != 0 ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( ( mt [ i - 1 ] ^ ( mt [ i - 1 ] >>> 30 ) ) * 1664525 ) ) + array [ j ] + j ; i ++ ; j ++ ; if ( i >= N ) { mt [ 0 ] = mt [ N - 1 ] ; i = 1 ; } if ( j >= array . length ) { j = 0 ; } } for ( k = N - 1 ; k != 0 ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( ( mt [ i - 1 ] ^ ( mt [ i - 1 ] >>> 30 ) ) * 1566083941 ) ) - i ; i ++ ; if ( i >= N ) { mt [ 0 ] = mt [ N - 1 ] ; i = 1 ; } } mt [ 0 ] = 0x80000000 ; } 
public void update ( byte [ ] buf ) { update ( buf , 0 , buf . length ) ; } 
@ XmlElementDecl ( namespace = "http://www.opengis.net/gml/3.2" , name = "derivedCRSRef" ) public JAXBElement < DerivedCRSPropertyType > createDerivedCRSRef ( DerivedCRSPropertyType value ) { return new JAXBElement < DerivedCRSPropertyType > ( _DerivedCRSRef_QNAME , DerivedCRSPropertyType . class , null , value ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public Builder with ( Animator anim ) { Node node = mNodeMap . get ( anim ) ; if ( node == null ) { node = new Node ( anim ) ; mNodeMap . put ( anim , node ) ; mNodes . add ( node ) ; } Dependency dependency = new Dependency ( mCurrentNode , Dependency . WITH ) ; node . addDependency ( dependency ) ; return this ; } 
private ApnSetting getNextApn ( ) { ArrayList < ApnSetting > list = waitingApns ; ApnSetting apn = null ; if ( list != null ) { if ( ! list . isEmpty ( ) ) { apn = list . get ( 0 ) ; } } return apn ; } 
protected void processFocusEvent ( FocusEvent e ) { super . processFocusEvent ( e ) ; if ( e . isTemporary ( ) ) { return ; } if ( isEdited ( ) && e . getID ( ) == FocusEvent . FOCUS_LOST ) { InputContext ic = getInputContext ( ) ; if ( focusLostHandler == null ) { focusLostHandler = new FocusLostHandler ( ) ; } if ( ( ic != null ) && composedTextExists ) { ic . endComposition ( ) ; EventQueue . invokeLater ( focusLostHandler ) ; } else { focusLostHandler . run ( ) ; } } else if ( ! isEdited ( ) ) { setValue ( getValue ( ) , true , true ) ; } } 
public void setAttributeIndices ( String rangeList ) throws Exception { m_DeltaCols . setRanges ( rangeList ) ; } 
public int getComponentIndex ( Component c ) { int ncomponents = this . getComponentCount ( ) ; Component [ ] component = this . getComponents ( ) ; for ( int i = 0 ; i < ncomponents ; i ++ ) { Component comp = component [ i ] ; if ( comp == c ) return i ; } return - 1 ; } 
private int getRandom ( ) { Random random = new Random ( ) ; int intReturn = random . nextInt ( ) ; while ( intReturn <= 0 ) intReturn = random . nextInt ( ) ; return intReturn ; } 
public Enumeration < Object > getLoadedPropertyIndexes ( ) { return propBase_ . keys ( ) ; } 
public void setWriter ( OutputStream os ) { this . canonicalizerSpi . setWriter ( os ) ; } 
long getUTFlength ( String value , int start , long sum ) { int len = value . length ( ) ; for ( int i = start ; i < len ; ++ i ) { char c = value . charAt ( i ) ; if ( c >= '' && c <= '' ) sum += 1 ; else if ( c == ' ' || ( c >= '?' && c <= '?' ) ) sum += 2 ; else sum += 3 ; } return sum ; } 
protected void resetState ( ) { foundURIs = new ArrayList < String > ( ) ; encounteredReferences = new ArrayList < ArrayList < Integer >> ( ) ; documentReader = null ; document = null ; catalog = null ; for ( int i = 0 ; i < encounteredReferences . size ( ) ; i ++ ) { encounteredReferences . add ( new ArrayList < Integer > ( ) ) ; } } 
public final StringBuffer format ( Object [ ] objects , StringBuffer buffer , FieldPosition field ) { return formatImpl ( objects , buffer , field , null ) ; } 
public static String format ( String format , Object ... args ) { return format ( Locale . getDefault ( ) , format , args ) ; } 
public float bearingTo ( Location dest ) { synchronized ( mResults ) { if ( mLatitude != mLat1 || mLongitude != mLon1 || dest . mLatitude != mLat2 || dest . mLongitude != mLon2 ) { computeDistanceAndBearing ( mLatitude , mLongitude , dest . mLatitude , dest . mLongitude , mResults ) ; mLat1 = mLatitude ; mLon1 = mLongitude ; mLat2 = dest . mLatitude ; mLon2 = dest . mLongitude ; mDistance = mResults [ 0 ] ; mInitialBearing = mResults [ 1 ] ; } return mInitialBearing ; } } 
public static double tanh ( double d ) { double ePowX = Math . pow ( Math . E , d ) ; double ePowNegX = Math . pow ( Math . E , - d ) ; return ( ePowX - ePowNegX ) / ( ePowX + ePowNegX ) ; } 
static ObjectName createObjectName ( String domain , Role role ) throws MalformedObjectNameException { ObjectName name = null ; name = new ObjectName ( domain + ":type=Role,rolename=" + role . getRolename ( ) + ",database=" + role . getUserDatabase ( ) . getId ( ) ) ; return ( name ) ; } 
public PageFormat validatePage ( PageFormat page ) { PageFormat newPage = ( PageFormat ) page . clone ( ) ; Paper newPaper = new Paper ( ) ; validatePaper ( newPage . getPaper ( ) , newPaper ) ; newPage . setPaper ( newPaper ) ; return newPage ; } 
public void fatalError ( String domain , String key , XMLParseException exception ) throws XNIException { fDOMError . fSeverity = DOMError . SEVERITY_FATAL_ERROR ; fDOMError . fException = exception ; fErrorCode . setValues ( domain , key ) ; String domErrorType = DOMErrorTypeMap . getDOMErrorType ( fErrorCode ) ; fDOMError . fType = ( domErrorType != null ) ? domErrorType : key ; fDOMError . fRelatedData = fDOMError . fMessage = exception . getMessage ( ) ; DOMLocatorImpl locator = fDOMError . fLocator ; if ( locator != null ) { locator . fColumnNumber = exception . getColumnNumber ( ) ; locator . fLineNumber = exception . getLineNumber ( ) ; locator . fUtf16Offset = exception . getCharacterOffset ( ) ; locator . fUri = exception . getExpandedSystemId ( ) ; locator . fRelatedNode = fCurrentNode ; } if ( fDomErrorHandler != null ) { fDomErrorHandler . handleError ( fDOMError ) ; } } 
@ Override public void close ( ) throws IOException { super . close ( ) ; __socket . close ( ) ; } 
public String getPrefix ( String uri ) { return ( String ) prefixTable . get ( uri ) ; } 
public float getBaseline ( int labelID ) { return mLabels . get ( labelID ) . baseline ; } 
protected void getHostName ( ) { if ( System . getProperty ( "os.name" ) . startsWith ( "Windows" ) ) { hostName = System . getenv ( "COMPUTERNAME" ) ; } else { hostName = System . getenv ( "HOSTNAME" ) ; } String allowRedeployStr = System . getenv ( "allowRedeploy" ) ; if ( allowRedeployStr != null ) { allowRedeploy = allowRedeployStr . equals ( "true" ) ? true : false ; } else { getLog ( ) . info ( "###-Es-gibt-keine-Umgebungsvar-'allowRedeploy'-->-Redeployment-ist-somit-generell-verboten!-" ) ; getLog ( ) . info ( "###-Tip:-Erzeuge-die-Umgebungsvar-'allowRedeploy'-und-setze-sie-auf-true,-um-das-Redeployment-zeitweilig-zu-erlauben!-" ) ; } } 
@ SuppressWarnings ( "unused" ) public static void scrubClass ( @ NonNull final TestCase testCase ) throws IllegalAccessException { final Field [ ] fields = testCase . getClass ( ) . getDeclaredFields ( ) ; for ( final Field field : fields ) { if ( ! field . getType ( ) . isPrimitive ( ) && ! Modifier . isStatic ( field . getModifiers ( ) ) ) { try { field . setAccessible ( true ) ; field . set ( testCase , null ) ; } catch ( final Exception e ) { LogManager . d ( "Could-not-nullify-field!" ) ; } if ( null != field . get ( testCase ) ) { LogManager . d ( "Could-not-nullify-field!" ) ; } } } } 
private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; if ( jdate == null ) { jdate = jcal . newCalendarDate ( getZone ( ) ) ; cachedFixedDate = Long . MIN_VALUE ; } } 
public static Object addListener ( Object bag , Object listener ) { if ( listener == null ) throw new IllegalArgumentException ( ) ; if ( listener instanceof Object [ ] ) throw new IllegalArgumentException ( ) ; if ( bag == null ) { bag = listener ; } else if ( ! ( bag instanceof Object [ ] ) ) { bag = new Object [ ] { bag , listener } ; } else { Object [ ] array = ( Object [ ] ) bag ; int L = array . length ; if ( L < 2 ) throw new IllegalArgumentException ( ) ; Object [ ] tmp = new Object [ L + 1 ] ; System . arraycopy ( array , 0 , tmp , 0 , L ) ; tmp [ L ] = listener ; bag = tmp ; } return bag ; } 
public void focusNextComponent ( Component aComponent ) { if ( aComponent != null ) { aComponent . transferFocus ( ) ; } } 
public static String getTempDirectoryPath ( Context ctx ) { File cache = null ; if ( Environment . getExternalStorageState ( ) . equals ( Environment . MEDIA_MOUNTED ) ) { cache = new File ( Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) + "/Android/data/" + ctx . getPackageName ( ) + "/cache/" ) ; } else { cache = ctx . getCacheDir ( ) ; } if ( ! cache . exists ( ) ) { cache . mkdirs ( ) ; } return cache . getAbsolutePath ( ) ; } 
private void importPublicDependencies ( final FileDescriptor file ) { for ( FileDescriptor dependency : file . getPublicDependencies ( ) ) { if ( dependencies . add ( dependency ) ) { importPublicDependencies ( dependency ) ; } } } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; javax . xml . namespace . NamespaceContext nsContext = xmlWriter . getNamespaceContext ( ) ; while ( true ) { java . lang . String uri = nsContext . getNamespaceURI ( prefix ) ; if ( uri == null || uri . length ( ) == 0 ) { break ; } prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public int pop ( ) { if ( isEmpty ( ) ) throw new RuntimeException ( "Stack-is-empty" ) ; return items [ top -- ] ; } 
public void setLocationP ( Point2D . Double loc ) { if ( porigin_ == null || ! porigin_ . equals ( loc ) ) { Point2D . Double temp = porigin_ ; porigin_ = loc ; changes_ . firePropertyChange ( "location" , temp , porigin_ ) ; modified ( "Logo:-setLocationP()" ) ; } } 
public void addFooterView ( View view ) { mFooterViews . add ( view ) ; } 
public void erasePurchase ( String sku ) { if ( mPurchaseMap . containsKey ( sku ) ) mPurchaseMap . remove ( sku ) ; } 
public String toString ( ) { return "ImgReaderPGM:-WxH-=-" + w + "x" + h + ",-Component-=-0" + "-Underlying-RandomAccessIO:-" + in . toString ( ) ; } 
public void joinQueue ( Map metadata , String userID ) throws XMPPException { if ( inQueue ) { throw new IllegalStateException ( "Already-in-queue-" + workgroupJID ) ; } Form form = new Form ( Form . TYPE_SUBMIT ) ; Iterator iter = metadata . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String name = ( String ) iter . next ( ) ; String value = ( String ) metadata . get ( name ) . toString ( ) ; String escapedName = StringUtils . escapeForXML ( name ) ; String escapedValue = StringUtils . escapeForXML ( value ) ; FormField field = new FormField ( escapedName ) ; field . setType ( FormField . TYPE_TEXT_SINGLE ) ; form . addField ( field ) ; form . setAnswer ( escapedName , escapedValue ) ; } joinQueue ( form , userID ) ; } 
protected final JTextComponent getTextComponent ( ActionEvent e ) { if ( e != null ) { Object o = e . getSource ( ) ; if ( o instanceof JTextComponent ) { return ( JTextComponent ) o ; } } return getFocusedComponent ( ) ; } 
private Map < String , List < Object >> convertPrincipalAttributesToPersonAttributes ( final Principal p ) { final Map < String , List < Object >> convertedAttributes = new HashMap < > ( p . getAttributes ( ) . size ( ) ) ; final Map < String , Object > principalAttributes = p . getAttributes ( ) ; for ( final Map . Entry < String , Object > entry : principalAttributes . entrySet ( ) ) { final Object values = entry . getValue ( ) ; final String key = entry . getKey ( ) ; if ( values instanceof List ) { convertedAttributes . put ( key , ( List ) values ) ; } else { convertedAttributes . put ( key , Collections . singletonList ( values ) ) ; } } return convertedAttributes ; } 
public static void main ( final String [ ] args ) { boolean decode = false ; if ( args . length == 0 ) { System . out . println ( "usage:-java-Base64-[-d[ecode]]-filename" ) ; System . exit ( 0 ) ; } for ( int i = 0 ; i < args . length ; i ++ ) { if ( "-decode" . equalsIgnoreCase ( args [ i ] ) ) { decode = true ; } else if ( "-d" . equalsIgnoreCase ( args [ i ] ) ) { decode = true ; } } final String filename = args [ args . length - 1 ] ; final File file = new File ( filename ) ; if ( ! file . exists ( ) ) { System . out . println ( "Error:-file-'" + filename + "'-doesn't-exist!" ) ; System . exit ( 0 ) ; } if ( decode ) { final char [ ] encoded = readChars ( file ) ; final byte [ ] decoded = decode ( encoded ) ; writeBytes ( file , decoded ) ; } else { final byte [ ] decoded = readBytes ( file ) ; final char [ ] encoded = encode ( decoded ) ; writeChars ( file , encoded ) ; } } 
int validate ( String hostname , String port ) { Matcher match = HOSTNAME_PATTERN . matcher ( hostname ) ; if ( ! match . matches ( ) ) return R . string . proxy_error_invalid_host ; if ( hostname . length ( ) > 0 && port . length ( ) == 0 ) { return R . string . proxy_error_empty_port ; } if ( port . length ( ) > 0 ) { if ( hostname . length ( ) == 0 ) { return R . string . proxy_error_empty_host_set_port ; } int portVal = - 1 ; try { portVal = Integer . parseInt ( port ) ; } catch ( NumberFormatException ex ) { return R . string . proxy_error_invalid_port ; } if ( portVal <= 0 || portVal > 0xFFFF ) { return R . string . proxy_error_invalid_port ; } } return 0 ; } 
private static StringBuilder createEntityTableBuilder ( Entity entity ) throws IllegalArgumentException { StringBuilder tableBuilder = new StringBuilder ( String . format ( CREATE_TABLE_FORMAT , entity . getName ( ) . toLowerCase ( ) ) ) ; for ( Attribute attr : entity . getAttributes ( ) ) { if ( attr . getType ( ) == AttributeType . UNDEFINED ) { throw new IllegalArgumentException ( attr . getName ( ) + "-does-not-have-a-valid-type" ) ; } if ( attr . isPrimaryKey ( ) ) { tableBuilder . append ( String . format ( ATTR_COLUMN_DEFN_FORMAT , attr . getName ( ) , PRIMARY_KEY_DEFN ) ) . append ( ",-" ) ; } else { tableBuilder . append ( String . format ( ATTR_COLUMN_DEFN_FORMAT , attr . getName ( ) , attr . getType ( ) . toSQLiteString ( ) ) ) . append ( ",-" ) ; } } tableBuilder . delete ( tableBuilder . length ( ) - 2 , tableBuilder . length ( ) - 1 ) . append ( ");" ) ; return tableBuilder ; } 
private void initTable ( ) throws RemoteException , NotBoundException , FileNotFoundException { table . setAutoResizeMode ( JTable . AUTO_RESIZE_SUBSEQUENT_COLUMNS ) ; table . setRowSelectionAllowed ( true ) ; table . setSelectionMode ( ListSelectionModel . SINGLE_SELECTION ) ; table . getSelectionModel ( ) . addListSelectionListener ( new ListSelectionListener ( ) { public void valueChanged ( ListSelectionEvent e ) { row = table . getSelectedRow ( ) ; if ( row == - 1 ) { tableForm . clearFields ( ) ; tableForm . getDeleteButton ( ) . setEnabled ( false ) ; tableForm . getInsertButton ( ) . setText ( "VloÅ¾it-zÃ¡znam" ) ; tableForm . getInsertButton ( ) . setToolTipText ( "VloÅ¾it-novÃ½-zÃ¡znam-Menu" ) ; } else { tableForm . getTableNumberTextField ( ) . setText ( String . valueOf ( table . getModel ( ) . getValueAt ( row , 1 ) ) ) ; tableForm . getPlacesTextField ( ) . setText ( String . valueOf ( table . getModel ( ) . getValueAt ( row , 2 ) ) ) ; tableForm . getDeleteButton ( ) . setEnabled ( true ) ; tableForm . getInsertButton ( ) . setText ( "Aktualizovat-zÃ¡znam" ) ; tableForm . getInsertButton ( ) . setToolTipText ( "Smazat-vybranÃ½-zÃ¡znam-Menu" ) ; } } } ) ; refresh ( ) ; } 
private static int calculateStringDistance ( String s1 , String s2 ) { if ( s1 . length ( ) == 0 ) { return s2 . length ( ) ; } if ( s2 . length ( ) == 0 ) { return s1 . length ( ) ; } int d [ ] [ ] = new int [ s1 . length ( ) + 1 ] [ s2 . length ( ) + 1 ] ; for ( int i = 0 ; i <= s1 . length ( ) ; i ++ ) { d [ i ] [ 0 ] = i ; } for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { d [ 0 ] [ j ] = j ; } for ( int i = 1 ; i <= s1 . length ( ) ; i ++ ) { char s_i = s1 . charAt ( i - 1 ) ; for ( int j = 1 ; j <= s2 . length ( ) ; j ++ ) { int cost ; char t_j = s2 . charAt ( j - 1 ) ; if ( s_i == t_j ) { cost = 0 ; } else { cost = 1 ; } d [ i ] [ j ] = Math . min ( Math . min ( d [ i - 1 ] [ j ] + 1 , d [ i ] [ j - 1 ] + 1 ) , d [ i - 1 ] [ j - 1 ] + cost ) ; } } return d [ s1 . length ( ) ] [ s2 . length ( ) ] ; } 
private static String parsePiece ( String whole , int [ ] idx ) throws IllegalArgumentException { int start = idx [ 0 ] ; while ( idx [ 0 ] < whole . length ( ) && isDigitOrPeriod ( whole . charAt ( idx [ 0 ] ) ) ) { idx [ 0 ] ++ ; } if ( idx [ 0 ] == whole . length ( ) ) { throw new IllegalArgumentException ( whole ) ; } idx [ 0 ] ++ ; return whole . substring ( start , idx [ 0 ] ) ; } 
public Location getLocation ( ) { return new Location ( ) { String _systemId = fEntityScanner . getExpandedSystemId ( ) ; String _publicId = fEntityScanner . getPublicId ( ) ; int _offset = fEntityScanner . getCharacterOffset ( ) ; int _columnNumber = fEntityScanner . getColumnNumber ( ) ; int _lineNumber = fEntityScanner . getLineNumber ( ) ; public String getLocationURI ( ) { return _systemId ; } public int getCharacterOffset ( ) { return _offset ; } public int getColumnNumber ( ) { return _columnNumber ; } public int getLineNumber ( ) { return _lineNumber ; } public String getPublicId ( ) { return _publicId ; } public String getSystemId ( ) { return _systemId ; } public String toString ( ) { StringBuffer sbuffer = new StringBuffer ( ) ; sbuffer . append ( "Line-number-=-" + getLineNumber ( ) ) ; sbuffer . append ( "-" ) ; sbuffer . append ( "Column-number-=-" + getColumnNumber ( ) ) ; sbuffer . append ( "-" ) ; sbuffer . append ( "System-Id-=-" + getSystemId ( ) ) ; sbuffer . append ( "-" ) ; sbuffer . append ( "Public-Id-=-" + getPublicId ( ) ) ; sbuffer . append ( "-" ) ; sbuffer . append ( "Location-Uri=-" + getLocationURI ( ) ) ; sbuffer . append ( "-" ) ; sbuffer . append ( "CharacterOffset-=-" + getCharacterOffset ( ) ) ; sbuffer . append ( "-" ) ; return sbuffer . toString ( ) ; } } ; } 
public void makeVisible ( ) { TreeStateNode parent = ( TreeStateNode ) getParent ( ) ; if ( parent != null ) parent . expandParentAndReceiver ( ) ; } 
public void setOtherConfig ( Connection c , Map < String , String > otherConfig ) throws BadServerResponse , XenAPIException , XmlRpcException { String method_call = "SM.set_other_config" ; String session = c . getSessionReference ( ) ; Object [ ] method_params = { Marshalling . toXMLRPC ( session ) , Marshalling . toXMLRPC ( this . ref ) , Marshalling . toXMLRPC ( otherConfig ) } ; Map response = c . dispatch ( method_call , method_params ) ; return ; } 
public final AccessControl getControlAt ( int idx ) { if ( idx < 0 || idx >= m_list . size ( ) ) return null ; return m_list . get ( idx ) ; } 
private void schedWait ( ) { schedulerIsAwake = false ; assert Thread . currentThread ( ) == scheduler ; while ( ! schedulerIsAwake ) { try { scheduler . wait ( 1 ) ; } catch ( InterruptedException e ) { } } } 
protected String getCurrentText ( ) { return this . currentText . toString ( ) ; } 
public Certificate createCertificate ( ) { return new Certificate ( ) ; } 
public static long copy ( Readable from , Appendable to ) throws IOException { CharBuffer buf = CharBuffer . allocate ( BUF_SIZE ) ; long total = 0 ; while ( true ) { int r = from . read ( buf ) ; if ( r == - 1 ) { break ; } buf . flip ( ) ; to . append ( buf , 0 , r ) ; total += r ; } return total ; } 
private ToolManager ( ) { tools = new TreeSet ( ) ; support = new PropertyChangeSupport ( this ) ; } 
public URI apply ( URI uri , Separator separator ) { StringBuilder builder = new StringBuilder ( ) ; if ( uri . getScheme ( ) != null ) { builder . append ( uri . getScheme ( ) ) ; builder . append ( ':' ) ; } if ( uri . getHost ( ) != null ) { builder . append ( "//" ) ; if ( uri . getUserInfo ( ) != null ) { builder . append ( uri . getUserInfo ( ) ) ; builder . append ( '@' ) ; } builder . append ( uri . getHost ( ) ) ; if ( uri . getPort ( ) != - 1 ) { builder . append ( ':' ) ; builder . append ( uri . getPort ( ) ) ; } } else if ( uri . getAuthority ( ) != null ) { builder . append ( "//" ) ; builder . append ( uri . getAuthority ( ) ) ; } if ( uri . getPath ( ) != null ) { builder . append ( uri . getPath ( ) ) ; } String query = toString ( separator ) ; if ( query . length ( ) != 0 ) { builder . append ( '?' ) ; builder . append ( query ) ; } if ( uri . getFragment ( ) != null ) { builder . append ( '#' ) ; builder . append ( uri . getFragment ( ) ) ; } try { return new URI ( builder . toString ( ) ) ; } catch ( URISyntaxException e ) { throw new RuntimeException ( e ) ; } } 
private void adjustForTableSelection ( ) { assert ( SwingUtilities . isEventDispatchThread ( ) ) : "not-in-UI-thread" ; String selfactory = getSelectedFactory ( false ) ; String seluri = getSelectedURI ( null ) ; if ( selfactory != null ) { if ( mFactories != null && ! mFactories . containsKey ( selfactory ) ) { Factory factory = new Factory ( selfactory ) ; mFactories . put ( selfactory , factory ) ; new DiscoBackground ( mConnection , new DiscoBackground . Callback ( ) { public void run ( IQ result , XMPPException err , Object rock ) { acceptFactoryBotList ( result , err , ( String ) rock ) ; } } , DiscoBackground . QUERY_ITEMS , selfactory , "bots" , selfactory ) ; } } if ( selfactory == null ) { if ( mFactoryOfBotTable != null ) { mFactoryOfBotTable = null ; adjustFactoryContents ( ) ; } mURIButton . setEnabled ( false ) ; mSelectButton . setEnabled ( false ) ; } else { if ( mFactoryOfBotTable == null || ! mFactoryOfBotTable . equals ( selfactory ) ) { mFactoryOfBotTable = selfactory ; adjustFactoryContents ( ) ; } mURIButton . setEnabled ( true ) ; mSelectButton . setEnabled ( seluri != null ) ; } } 
private void insert ( Object obj , int handle ) { int index = hash ( obj ) % spine . length ; objs [ handle ] = obj ; next [ handle ] = spine [ index ] ; spine [ index ] = handle ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
String getLanguageAttributeTag ( ) { if ( ( lang_ != null ) && ( lang_ . length ( ) > 0 ) ) return "-lang="" + lang_ + """ ; else return "" ; } 
public static void setPattern ( Configuration conf , String regex ) throws PatternSyntaxException { try { Pattern . compile ( regex ) ; } catch ( PatternSyntaxException e ) { throw new IllegalArgumentException ( "Invalid-pattern:-" + regex ) ; } conf . set ( FILTER_REGEX , regex ) ; } 
protected final long getNowNanos ( ) { return absoluteNanosOffset + System . nanoTime ( ) ; } 
public void setRequestMethod ( String method ) throws ProtocolException { if ( connected ) { throw new ProtocolException ( "Connection-already-established" ) ; } for ( String permittedUserMethod : PERMITTED_USER_METHODS ) { if ( permittedUserMethod . equals ( method ) ) { this . method = permittedUserMethod ; return ; } } throw new ProtocolException ( "Unknown-method-'" + method + "';-must-be-one-of-" + Arrays . toString ( PERMITTED_USER_METHODS ) ) ; } 
public static boolean isToolBarButton ( JComponent component ) { if ( component instanceof SubstanceDropDownButton ) return false ; if ( component instanceof SubstanceSpinnerButton ) return false ; Container parent = component . getParent ( ) ; return ( parent != null ) && ( ( parent instanceof JToolBar ) || ( parent . getParent ( ) instanceof JToolBar ) ) ; } 
private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; } 
private TableViewerColumn createColumn ( Column column , int colNumber ) { TableViewerColumn viewerColumn = new TableViewerColumn ( this , SWT . NONE ) ; TableColumn tableColumn = viewerColumn . getColumn ( ) ; tableColumn . setText ( column . toString ( ) ) ; tableColumn . setWidth ( columnBounds [ colNumber ] ) ; tableColumn . setResizable ( true ) ; tableColumn . setMoveable ( true ) ; tableColumn . addSelectionListener ( new ViewController ( this ) ) ; tableColumn . setData ( column ) ; return viewerColumn ; } 
private static String pad ( char c , int len ) { char [ ] buf = new char [ len ] ; Arrays . fill ( buf , c ) ; return new String ( buf ) ; } 
public static void readFileChannelFully ( FileChannel fileChannel , byte buf [ ] , int off , int len ) throws IOException { int toRead = len ; ByteBuffer byteBuffer = ByteBuffer . wrap ( buf , off , len ) ; while ( toRead > 0 ) { int ret = fileChannel . read ( byteBuffer ) ; if ( ret < 0 ) { throw new IOException ( "Premeture-EOF-from-inputStream" ) ; } toRead -= ret ; off += ret ; } } 
int adjustTextWidth ( int width ) { maxTextWidth = Math . max ( maxTextWidth , width ) ; return maxTextWidth ; } 
public void clearRegexRoutings ( ) { regexRoutings . clear ( ) ; } 
public Notification buildNotification ( Builder builder ) { return builder . build ( ) ; } 
public List < AccessibilityNodeInfoCompat > findAccessibilityNodeInfosByText ( String text ) { List < AccessibilityNodeInfoCompat > result = new ArrayList < AccessibilityNodeInfoCompat > ( ) ; List < Object > infos = IMPL . findAccessibilityNodeInfosByText ( mInfo , text ) ; final int infoCount = infos . size ( ) ; for ( int i = 0 ; i < infoCount ; i ++ ) { Object info = infos . get ( i ) ; result . add ( new AccessibilityNodeInfoCompat ( info ) ) ; } return result ; } 
public static void d ( String tag , String s , Object ... args ) { if ( LOG . DEBUG >= LOGLEVEL ) Log . d ( tag , String . format ( s , args ) ) ; } 
public boolean saveImage ( BufferedImage img , String path , String type ) { boolean result = false ; if ( img != null && path != null && type != null ) { File file = new File ( path ) ; try { result = ImageIO . write ( img , type , file ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return result ; } 
static int hash ( String key ) { int hash = key . hashCode ( ) ; hash += ~ ( hash << 9 ) ; hash ^= ( hash >>> 14 ) ; hash += ( hash << 4 ) ; hash ^= ( hash >>> 10 ) ; return hash ; } 
public void cancel ( ) { if ( mAnimatorMap . size ( ) > 0 ) { HashMap < Animator , PropertyBundle > mAnimatorMapCopy = ( HashMap < Animator , PropertyBundle > ) mAnimatorMap . clone ( ) ; Set < Animator > animatorSet = mAnimatorMapCopy . keySet ( ) ; for ( Animator runningAnim : animatorSet ) { runningAnim . cancel ( ) ; } } mPendingAnimations . clear ( ) ; mView . removeCallbacks ( mAnimationStarter ) ; } 
public static CompilationUnit parse ( File file ) throws ParseException , IOException { return parse ( file , null ) ; } 
private static File constructFilePaths ( String file1 , String file2 ) { File newPath ; if ( file2 . startsWith ( file1 ) ) { newPath = new File ( file2 ) ; } else { newPath = new File ( file1 + "/" + file2 ) ; } return newPath ; } 
public String [ ] getValues ( ) { return this . attributeManager . getValues ( ) ; } 
public static boolean mkdirsWithExistsAndPermissionCheck ( LocalFileSystem localFS , Path dir , FsPermission expected ) throws IOException { File directory = new File ( dir . makeQualified ( localFS ) . toUri ( ) . getPath ( ) ) ; if ( ! directory . exists ( ) ) { boolean created = mkdirsWithExistsCheck ( directory ) ; if ( created ) { localFS . setPermission ( dir , expected ) ; return true ; } else { return false ; } } checkPermission ( dir , expected , localFS . getFileStatus ( dir ) . getPermission ( ) ) ; return true ; } 
protected void fireModelChangedEvent ( ) { ArrayList objects = new ArrayList ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "TRACE(DefaultGraphModel)-firing-child-removed-event-" + objects ) ; } GraphModelEvent evt = new GraphModelEvent ( this , objects ) ; for ( int i = 0 ; i < listeners . size ( ) ; i ++ ) { listeners . get ( i ) . modelChanged ( evt ) ; } } 
public static byte [ ] encode ( byte [ ] input , int flags ) { return encode ( input , 0 , input . length , flags ) ; } 
public List getSubplots ( ) { if ( this . subplots != null ) { return Collections . unmodifiableList ( this . subplots ) ; } else { return Collections . EMPTY_LIST ; } } 
protected String add_escapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '|b' : retval . append ( "|b" ) ; continue ; case '|t' : retval . append ( "|t" ) ; continue ; case '|n' : retval . append ( "|n" ) ; continue ; case '|f' : retval . append ( "|f" ) ; continue ; case '|r' : retval . append ( "|r" ) ; continue ; case '|"' : retval . append ( "|"" ) ; continue ; case '|'' : retval . append ( "|'" ) ; continue ; case '|' : retval . append ( "||" ) ; continue ; default : if ( ( ( ch = str . charAt ( i ) ) < 0x20 ) || ( ch > 0x7e ) ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "|u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } 
protected final void synchronizeChildren ( AttrImpl a , int nodeIndex ) { boolean orig = getMutationEvents ( ) ; setMutationEvents ( false ) ; a . needsSyncChildren ( false ) ; int last = getLastChild ( nodeIndex ) ; int prev = getPrevSibling ( last ) ; if ( prev == - 1 ) { a . value = getNodeValueString ( nodeIndex ) ; a . hasStringValue ( true ) ; } else { ChildNode firstNode = null ; ChildNode lastNode = null ; for ( int index = last ; index != - 1 ; index = getPrevSibling ( index ) ) { ChildNode node = ( ChildNode ) getNodeObject ( index ) ; if ( lastNode == null ) { lastNode = node ; } else { firstNode . previousSibling = node ; } node . ownerNode = a ; node . isOwned ( true ) ; node . nextSibling = firstNode ; firstNode = node ; } if ( lastNode != null ) { a . value = firstNode ; firstNode . isFirstChild ( true ) ; a . lastChild ( lastNode ) ; } a . hasStringValue ( false ) ; } setMutationEvents ( orig ) ; } 
private static MessageDigest getDigest ( String algorithm ) { try { return MessageDigest . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException ex ) { throw new IllegalStateException ( "Could-not-find-MessageDigest-with-algorithm-"" + algorithm + """ , ex ) ; } } 
public boolean isNull ( int fieldNum ) throws ExecException { return ( mFields . get ( fieldNum ) == null ) ; } 
@ POST @ Produces ( { "application/x-javascript" , MediaType . APPLICATION_JSON } ) @ JSONP ( queryParam = "cb" , callback = "callback" ) @ Consumes ( MediaType . APPLICATION_FORM_URLENCODED ) public Object grantAccessToClient ( @ BeanParam AuthorizeClientAuthenticationForm form ) { LOG . info ( "[ENTRY]--Received-request-for-granting-access-to-the-client,-so-that-it-can-use-the-user-data-on-behalf" ) ; Object response = authorizationClientProcessor . invoke ( form ) ; LOG . info ( "[EXIT]--Received-request-for-granting-access-to-the-client,-so-that-it-can-use-the-user-data-on-behalf" ) ; return response ; } 
private void decodeHeader ( BufferedReader in , Properties pre , Properties parms , Properties header ) throws InterruptedException { try { String inLine = in . readLine ( ) ; if ( inLine == null ) return ; StringTokenizer st = new StringTokenizer ( inLine ) ; if ( ! st . hasMoreTokens ( ) ) sendError ( HTTP_BADREQUEST , "BAD-REQUEST:-Syntax-error.-Usage:-GET-/example/file.html" ) ; String method = st . nextToken ( ) ; pre . put ( "method" , method ) ; if ( ! st . hasMoreTokens ( ) ) sendError ( HTTP_BADREQUEST , "BAD-REQUEST:-Missing-URI.-Usage:-GET-/example/file.html" ) ; String uri = st . nextToken ( ) ; int qmi = uri . indexOf ( '?' ) ; if ( qmi >= 0 ) { decodeParms ( uri . substring ( qmi + 1 ) , parms ) ; uri = decodePercent ( uri . substring ( 0 , qmi ) ) ; } else uri = decodePercent ( uri ) ; if ( st . hasMoreTokens ( ) ) { String line = in . readLine ( ) ; while ( line != null && line . trim ( ) . length ( ) > 0 ) { int p = line . indexOf ( ':' ) ; if ( p >= 0 ) header . put ( line . substring ( 0 , p ) . trim ( ) . toLowerCase ( ) , line . substring ( p + 1 ) . trim ( ) ) ; line = in . readLine ( ) ; } } pre . put ( "uri" , uri ) ; } catch ( IOException ioe ) { sendError ( HTTP_INTERNALERROR , "SERVER-INTERNAL-ERROR:-IOException:-" + ioe . getMessage ( ) ) ; } } 
public StructDeclaration lookupStruct ( String name ) { return fStructs . get ( name ) ; } 
@ Override public Instant minus ( TemporalAmount amountToSubtract ) { return ( Instant ) amountToSubtract . subtractFrom ( this ) ; } 
public void connect ( SocketAddress remoteAddr , int timeout ) throws IOException { checkOpenAndCreate ( true ) ; if ( timeout < 0 ) { throw new IllegalArgumentException ( "timeout-<-0" ) ; } if ( isConnected ( ) ) { throw new SocketException ( "Already-connected" ) ; } if ( remoteAddr == null ) { throw new IllegalArgumentException ( "remoteAddr-==-null" ) ; } if ( ! ( remoteAddr instanceof InetSocketAddress ) ) { throw new IllegalArgumentException ( "Remote-address-not-an-InetSocketAddress:-" + remoteAddr . getClass ( ) ) ; } InetSocketAddress inetAddr = ( InetSocketAddress ) remoteAddr ; InetAddress addr ; if ( ( addr = inetAddr . getAddress ( ) ) == null ) { throw new UnknownHostException ( "Host-is-unresolved:-" + inetAddr . getHostName ( ) ) ; } int port = inetAddr . getPort ( ) ; checkDestination ( addr , port ) ; synchronized ( connectLock ) { try { if ( ! isBound ( ) ) { if ( ! usingSocks ( ) ) { impl . bind ( Inet6Address . ANY , 0 ) ; } isBound = true ; } impl . connect ( remoteAddr , timeout ) ; isConnected = true ; cacheLocalAddress ( ) ; } catch ( IOException e ) { impl . close ( ) ; throw e ; } } } 
public MapEnvironment setValue ( String paramName , Object value ) { paramMap_ . put ( paramName , value ) ; return this ; } 
public DealerSalesReportCalculator withPrevious ( final Option < ReportDealerSalesDataList > previousDetail ) { if ( previousDetail . isNone ( ) ) { return this ; } final Map < Integer , ReportDataDealerSalesDetail > dealerPreviousDetails = Maps . uniqueIndex ( previousDetail . some ( ) . getDetail ( ) , GetDealerIDFromReportDetailFunction . INSTANCE ) ; dealerPreviousDetailOption = Option . < Map < Integer , ReportDataDealerSalesDetail >> some ( dealerPreviousDetails ) ; return this ; } 
public void printStackTrace ( PrintWriter anOutput ) { super . printStackTrace ( anOutput ) ; if ( _theSourceError != null ) { anOutput . print ( "---->-NESTED-EXCEPTION-IS:-" ) ; _theSourceError . printStackTrace ( anOutput ) ; } } 
public long approximateDataSize ( ) { long result = 0 ; for ( Map . Entry < String , DataNode > entry : nodes . entrySet ( ) ) { DataNode value = entry . getValue ( ) ; synchronized ( value ) { result += entry . getKey ( ) . length ( ) ; result += ( value . data == null ? 0 : value . data . length ) ; } } return result ; } 
public static Method findMethod ( String methodName_ , int argCount_ , Class < ? > target_ ) { if ( ( methodName_ == null ) || ( target_ == null ) ) return null ; try { Method [ ] declaredMethods = target_ . getDeclaredMethods ( ) ; if ( ( declaredMethods == null ) || ( declaredMethods . length == 0 ) ) return null ; for ( Method method : declaredMethods ) { int modifiers = method . getModifiers ( ) ; if ( Modifier . isAbstract ( modifiers ) ) continue ; if ( ! methodName_ . equals ( method . getName ( ) ) ) continue ; if ( ! ( getParameterCount ( method ) == argCount_ ) ) continue ; return method ; } } catch ( Exception e_ ) { LOG . error ( null , e_ ) ; return null ; } return findMethod ( methodName_ , argCount_ , target_ . getSuperclass ( ) ) ; } 
protected void createPoints ( ) { ArrayList tempPoints = new ArrayList ( ) ; maxX = - Float . MIN_VALUE ; maxY = - Float . MIN_VALUE ; minX = Float . MAX_VALUE ; minY = Float . MAX_VALUE ; float start = 0 ; float end = 359 ; float cx = x + radius1 ; float cy = y + radius2 ; int step = 360 / segmentCount ; for ( float a = start ; a <= end + step ; a += step ) { float ang = a ; if ( ang > end ) { ang = end ; } float newX = ( float ) ( cx + ( FastTrig . cos ( Math . toRadians ( ang ) ) * radius1 ) ) ; float newY = ( float ) ( cy + ( FastTrig . sin ( Math . toRadians ( ang ) ) * radius2 ) ) ; if ( newX > maxX ) { maxX = newX ; } if ( newY > maxY ) { maxY = newY ; } if ( newX < minX ) { minX = newX ; } if ( newY < minY ) { minY = newY ; } tempPoints . add ( new Float ( newX ) ) ; tempPoints . add ( new Float ( newY ) ) ; } points = new float [ tempPoints . size ( ) ] ; for ( int i = 0 ; i < points . length ; i ++ ) { points [ i ] = ( ( Float ) tempPoints . get ( i ) ) . floatValue ( ) ; } } 
public boolean areSet ( int [ ] indices ) { boolean set = true ; for ( int i = 0 ; i < indices . length && set ; i ++ ) { set &= bits . get ( i ) ; } return set ; } 
public synchronized List < RMContainer > getReservedContainers ( ) { List < RMContainer > reservedContainers = new ArrayList < RMContainer > ( ) ; for ( Map . Entry < Priority , Map < NodeId , RMContainer >> e : this . reservedContainers . entrySet ( ) ) { reservedContainers . addAll ( e . getValue ( ) . values ( ) ) ; } return reservedContainers ; } 
public void removeRounds ( int limit ) { roundsLock . lock ( ) ; for ( Integer key : ( Integer [ ] ) rounds . keySet ( ) . toArray ( new Integer [ 0 ] ) ) { if ( key > limit ) { Round round = rounds . remove ( key ) ; round . setRemoved ( ) ; } } roundsLock . unlock ( ) ; } 
RosterGroup ( String name , XMPPConnection connection ) { super ( connection ) ; this . name = name ; entries = new LinkedHashSet < RosterEntry > ( ) ; } 
public Method get ( final String name , final Object [ ] params ) throws MethodMap . AmbiguousException { String methodKey = makeMethodKey ( name , params ) ; Object cacheEntry = cache . get ( methodKey ) ; if ( cacheEntry == CACHE_MISS ) { return null ; } if ( cacheEntry == null ) { try { cacheEntry = methodMap . find ( name , params ) ; } catch ( MethodMap . AmbiguousException ae ) { cache . put ( methodKey , CACHE_MISS ) ; throw ae ; } cache . put ( methodKey , ( cacheEntry != null ) ? cacheEntry : CACHE_MISS ) ; } return ( Method ) cacheEntry ; } 
public void drawLegendShape ( Canvas canvas , SimpleSeriesRenderer renderer , float x , float y , int seriesIndex , Paint paint ) { canvas . drawRect ( x , y - SHAPE_WIDTH / 2 , x + SHAPE_WIDTH , y + SHAPE_WIDTH / 2 , paint ) ; } 
@ VisibleForTesting static String getImapId ( Context context , String userName , String host , String capabilities ) { synchronized ( ImapStore . class ) { if ( sImapId == null ) { TelephonyManager tm = ( TelephonyManager ) context . getSystemService ( Context . TELEPHONY_SERVICE ) ; String networkOperator = tm . getNetworkOperatorName ( ) ; if ( networkOperator == null ) networkOperator = "" ; sImapId = makeCommonImapId ( context . getPackageName ( ) , Build . VERSION . RELEASE , Build . VERSION . CODENAME , Build . MODEL , Build . ID , Build . MANUFACTURER , networkOperator ) ; } } StringBuilder id = new StringBuilder ( sImapId ) ; String vendorId = VendorPolicyLoader . getInstance ( context ) . getImapIdValues ( userName , host , capabilities ) ; if ( vendorId != null ) { id . append ( '-' ) ; id . append ( vendorId ) ; } try { String devUID = Preferences . getPreferences ( context ) . getDeviceUID ( ) ; MessageDigest messageDigest ; messageDigest = MessageDigest . getInstance ( "SHA-1" ) ; messageDigest . update ( userName . getBytes ( ) ) ; messageDigest . update ( devUID . getBytes ( ) ) ; byte [ ] uid = messageDigest . digest ( ) ; String hexUid = Base64 . encodeToString ( uid , Base64 . NO_WRAP ) ; id . append ( "-"AGUID"-"" ) ; id . append ( hexUid ) ; id . append ( '|"' ) ; } catch ( NoSuchAlgorithmException e ) { Log . d ( Logging . LOG_TAG , "couldn't-obtain-SHA-1-hash-for-device-UID" ) ; } return id . toString ( ) ; } 
public void setArc ( Arc2D a ) { setArc ( a . getX ( ) , a . getY ( ) , a . getWidth ( ) , a . getHeight ( ) , a . getAngleStart ( ) , a . getAngleExtent ( ) , a . type ) ; } 
public void setLeftTopRightBottom ( int left , int top , int right , int bottom ) { setFrame ( left , top , right , bottom ) ; } 
public static void executeAgent ( String param1 , String param2 ) { String toolName = "TARGET" ; String toolVersion = "RSCH-TARGT_N_01.00.01I" ; String command = folder + "TUClientAgent.exe" ; command += "--u-" ; Process p = null ; try { p = Runtime . getRuntime ( ) . exec ( command ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } try { p . waitFor ( ) ; int exitValue = p . exitValue ( ) ; if ( exitValue != 0 ) { System . out . println ( "exitValue-!=-0" ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } 
public Map < String , Object > toMap ( ) { return new LinkedHashMap < String , Object > ( this ) ; } 
public short getFilStBlk ( ) { return Util . readShortBE ( filStBlk ) ; } 
public void print ( long lnum ) { print ( String . valueOf ( lnum ) ) ; } 
public void roll ( int field , int amount ) { switch ( field ) { case DAY_OF_WEEK : add ( field , amount ) ; return ; case ZONE_OFFSET : case DST_OFFSET : throw new IllegalArgumentException ( "Can't-roll-time-zone" ) ; } complete ( ) ; int min = getActualMinimum ( field ) ; int range = getActualMaximum ( field ) - min + 1 ; int oldval = fields [ field ] ; int newval = ( oldval - min + range + amount ) % range + min ; if ( newval < min ) newval += range ; fields [ field ] = newval ; cleanUpAfterRoll ( field , newval - oldval ) ; } 
public static String _ ( String key ) { if ( bundle != null ) { try { return bundle . getString ( key ) ; } catch ( MissingResourceException e ) { log . log ( Level . WARNING , "Failed-to-find-message" , e ) ; } } return "${" + key + "}" ; } 
void add ( EmitterDescriptor ed ) { emitters . add ( ed ) ; } 
private static boolean isRGBProfile ( ProfileHeader header , Hashtable tags ) { if ( header . getColorSpace ( ) != ColorSpace . TYPE_RGB ) return false ; if ( tags . get ( TagEntry . tagHashKey ( icSigRedColorantTag ) ) == null ) return false ; if ( tags . get ( TagEntry . tagHashKey ( icSigGreenColorantTag ) ) == null ) return false ; if ( tags . get ( TagEntry . tagHashKey ( icSigBlueColorantTag ) ) == null ) return false ; if ( tags . get ( TagEntry . tagHashKey ( icSigRedTRCTag ) ) == null ) return false ; if ( tags . get ( TagEntry . tagHashKey ( icSigGreenTRCTag ) ) == null ) return false ; if ( tags . get ( TagEntry . tagHashKey ( icSigBlueTRCTag ) ) == null ) return false ; return ( tags . get ( TagEntry . tagHashKey ( icSigMediaWhitePointTag ) ) != null ) ; } 
public List < Filter > getFilters ( ) { return new ArrayList < Filter > ( filters ) ; } 
public static Message obtain ( Handler h , int what , int arg1 , int arg2 , Object obj ) { Message m = obtain ( ) ; m . target = h ; m . what = what ; m . arg1 = arg1 ; m . arg2 = arg2 ; m . obj = obj ; return m ; } 
public boolean includes ( float x , float y ) { if ( points . length == 0 ) { return false ; } checkPoints ( ) ; Line testLine = new Line ( 0 , 0 , 0 , 0 ) ; Vector2 pt = new Vector2 ( x , y ) ; for ( int i = 0 ; i < points . length ; i += 2 ) { int n = i + 2 ; if ( n >= points . length ) { n = 0 ; } testLine . set ( points [ i ] , points [ i + 1 ] , points [ n ] , points [ n + 1 ] ) ; if ( testLine . on ( pt ) ) { return true ; } } return false ; } 
public void changeToParentDirectory ( ) { selectedFile = null ; File oldValue = getCurrentDirectory ( ) ; setCurrentDirectory ( getFileSystemView ( ) . getParentDirectory ( oldValue ) ) ; } 
protected Counter findCounter ( String counterName , String displayName ) { Counter result = counters . get ( counterName ) ; if ( result == null ) { result = new Counter ( counterName , displayName ) ; counters . put ( counterName , result ) ; } return result ; } 
TestSuiteReference ( String className ) { mClassName = className ; mTests = new ArrayList < AndroidTestReference > ( ) ; } 
public void drawImage ( Image image , float x , float y ) { drawImage ( image , x , y , Color . white ) ; } 
public long parseDateTime ( String s ) { Calendar local_calendar ; if ( s . length ( ) > 15 && s . charAt ( 15 ) == 'Z' ) { local_calendar = Calendar . getInstance ( TimeZone . getTimeZone ( "GMT" ) ) ; } else { local_calendar = Calendar . getInstance ( ) ; } int year , month , day , hour , min , sec ; year = Integer . parseInt ( s . substring ( 0 , 4 ) ) ; month = Integer . parseInt ( s . substring ( 4 , 6 ) ) ; day = Integer . parseInt ( s . substring ( 6 , 8 ) ) ; hour = Integer . parseInt ( s . substring ( 9 , 11 ) ) ; min = Integer . parseInt ( s . substring ( 11 , 13 ) ) ; sec = Integer . parseInt ( s . substring ( 13 , 15 ) ) ; local_calendar . set ( Calendar . YEAR , year ) ; local_calendar . set ( Calendar . MONTH , month - 1 ) ; local_calendar . set ( Calendar . DAY_OF_MONTH , day ) ; local_calendar . set ( Calendar . HOUR_OF_DAY , hour ) ; local_calendar . set ( Calendar . MINUTE , min ) ; local_calendar . set ( Calendar . SECOND , sec ) ; local_calendar . set ( Calendar . MILLISECOND , 0 ) ; return ( local_calendar . getTime ( ) ) . getTime ( ) ; } 
public static FSAuthnResponseEnvelope parseBASE64EncodedString ( String encodedReq ) throws FSMsgException { if ( encodedReq != null ) { String decodedAuthnReq = new String ( Base64 . decode ( encodedReq ) ) ; if ( FSUtils . debug . messageEnabled ( ) ) { FSUtils . debug . message ( "FSAuthnResponseEnvelope." + "parseBASE64EncodedString:-decoded-input-string:-" + decodedAuthnReq ) ; } return parseXML ( decodedAuthnReq ) ; } else { if ( FSUtils . debug . messageEnabled ( ) ) { FSUtils . debug . message ( "FSAuthnResponseEnvelope." + "parseBASE64EncodedString:-null-String-passed" + "in-as-argument." ) ; } throw new FSMsgException ( "nullInput" , null ) ; } } 
@ XmlElementDecl ( namespace = "http://www.opengis.net/gml" , name = "_GeneralOperationParameter" , substitutionHeadNamespace = "http://www.opengis.net/gml" , substitutionHeadName = "Definition" ) public JAXBElement < AbstractGeneralOperationParameterType > create_GeneralOperationParameter ( AbstractGeneralOperationParameterType value ) { return new JAXBElement < AbstractGeneralOperationParameterType > ( __GeneralOperationParameter_QNAME , AbstractGeneralOperationParameterType . class , null , value ) ; } 
protected void setLocalSubcontract ( ) { if ( ! effectiveTargetIOR . getProfile ( ) . isLocal ( ) ) { LocalClientRequestDispatcher = new NotLocalLocalCRDImpl ( ) ; return ; } int scid = effectiveTargetIOR . getProfile ( ) . getObjectKeyTemplate ( ) . getSubcontractId ( ) ; LocalClientRequestDispatcherFactory lcsf = orb . getRequestDispatcherRegistry ( ) . getLocalClientRequestDispatcherFactory ( scid ) ; LocalClientRequestDispatcher = lcsf . create ( scid , effectiveTargetIOR ) ; } 
public void removeChangeListener ( AxisChangeListener listener ) { this . listenerList . remove ( AxisChangeListener . class , listener ) ; } 
public void closeEntry ( ) throws IOException { ensureOpen ( ) ; while ( read ( tmpbuf , 0 , tmpbuf . length ) != - 1 ) ; entryEOF = true ; } 
private synchronized void release ( SelectorInfo info ) { long now = System . currentTimeMillis ( ) ; trimIdleSelectors ( now ) ; info . lastActivityTime = now ; info . queue . addLast ( info ) ; } 
public void setProperty ( String key , String value ) { if ( key . equals ( OutputKeys . METHOD ) ) { setMethodDefaults ( value ) ; } if ( key . startsWith ( OutputPropertiesFactory . S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL ) ) key = OutputPropertiesFactory . S_BUILTIN_EXTENSIONS_UNIVERSAL + key . substring ( OutputPropertiesFactory . S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL_LEN ) ; m_properties . put ( key , value ) ; } 
private void setUser ( Long user_id , String session_key , Long expires ) { if ( ! inFbCanvas ( ) ) { Map < String , String > cookiesInfo = _getCookiesParams ( ) ; String cookieUser = cookiesInfo . get ( this . apiKey + "_user" ) ; if ( cookieUser == null || ! cookieUser . equals ( user_id + "" ) ) { Map < String , String > cookies = new TreeMap < String , String > ( ) ; cookies . put ( "user" , user_id + "" ) ; cookies . put ( "session_key" , session_key ) ; String sig = generateSig ( cookies , this . secret ) ; int age = 0 ; if ( expires != null ) { age = ( int ) ( expires . longValue ( ) - ( System . currentTimeMillis ( ) / 1000 ) ) ; } for ( Map . Entry < String , String > entry : cookies . entrySet ( ) ) { addCookie ( this . apiKey + "_" + entry . getKey ( ) , entry . getValue ( ) , age ) ; } addCookie ( this . apiKey , sig , age ) ; } } this . user = user_id ; } 
public void prepareConnection ( HttpURLConnection con ) { try { con . setRequestMethod ( "GET" ) ; } catch ( ProtocolException e ) { e . printStackTrace ( ) ; } con . setDoInput ( true ) ; con . setUseCaches ( false ) ; con . setRequestProperty ( "Connection" , "close" ) ; } 
public List < T > restore ( List < T > target ) { List < T > result = new LinkedList < T > ( target ) ; ListIterator < Delta < T >> it = getDeltas ( ) . listIterator ( deltas . size ( ) ) ; while ( it . hasPrevious ( ) ) { Delta < T > delta = ( Delta < T > ) it . previous ( ) ; delta . restore ( result ) ; } return result ; } 
public double getMappedInputDistance ( int index ) { return inputDistances . get ( index ) ; } 
private int getCountDetectedTG ( String tg , String subkey ) { Map < String , Counter > ct = TGCount . get ( tg ) ; if ( ct != null ) { if ( subkey . endsWith ( "CP" ) ) { subkey = subkey . substring ( 0 , subkey . length ( ) - 2 ) + "NP" ; } Counter c = ct . get ( subkey ) ; return c != null ? c . count : 0 ; } return 0 ; } 
public boolean connect ( Edge e , Point2D p1 , Point2D p2 ) { Node n1 = findNode ( p1 ) ; Node n2 = findNode ( p2 ) ; if ( n1 != null ) { e . connect ( n1 , n2 ) ; if ( n1 . addEdge ( e , p1 , p2 ) ) { edges . add ( e ) ; if ( ! nodes . contains ( e . getEnd ( ) ) ) nodes . add ( e . getEnd ( ) ) ; needsLayout = true ; return true ; } } return false ; } 
public static int binarySearch ( int [ ] a , int fromIndex , int toIndex , int key ) { rangeCheck ( a . length , fromIndex , toIndex ) ; return binarySearch0 ( a , fromIndex , toIndex , key ) ; } 
public boolean isWhitespace ( int nodeHandle ) { int type = getNodeType ( nodeHandle ) ; Node node = getNode ( nodeHandle ) ; if ( TEXT_NODE == type || CDATA_SECTION_NODE == type ) { FastStringBuffer buf = StringBufferPool . get ( ) ; while ( node != null ) { buf . append ( node . getNodeValue ( ) ) ; node = logicalNextDOMTextNode ( node ) ; } boolean b = buf . isWhitespace ( 0 , buf . length ( ) ) ; StringBufferPool . free ( buf ) ; return b ; } return false ; } 
public static Object getSavedCollection ( Object uri , Environment env ) { if ( uri == null ) uri = "#default" ; Symbol sym = Symbol . make ( collectionNamespace , uri . toString ( ) ) ; Object coll = env . get ( sym , null , null ) ; if ( coll == null ) throw new RuntimeException ( "collection-'" + uri + "'-not-found" ) ; return coll ; } 
public static boolean inPointArray ( Point [ ] haystack , Point needle ) { for ( Point option : haystack ) { if ( needle . getX ( ) == option . getX ( ) && needle . getY ( ) == option . getY ( ) ) { return true ; } } return false ; } 
public void setDescription ( String description ) { _description = new ArrayList ( ) ; _description . add ( description ) ; } 
public static Comparator reversedComparator ( Comparator comparator ) { if ( comparator == null ) { comparator = NATURAL_COMPARATOR ; } return new ReverseComparator ( comparator ) ; } 
public int getLength ( ) { int length = 0 ; for ( Segment segment : segmentSet ) { length += segment . getLength ( ) ; } return length ; } 
public void delete ( int id ) { PreparedStatement ps ; try { ps = con . prepareStatement ( "DELETE-FROM-Booking-WHERE-id-=-?" ) ; ps . setInt ( 1 , id ) ; int rowCount = ps . executeUpdate ( ) ; if ( rowCount == 0 ) { System . out . println ( "ooking-" + id + "-does-not-exist!" ) ; } con . commit ( ) ; ps . close ( ) ; } catch ( SQLException ex ) { System . out . println ( "Message:-" + ex . getMessage ( ) ) ; try { con . rollback ( ) ; } catch ( SQLException ex2 ) { System . out . println ( "Message:-" + ex2 . getMessage ( ) ) ; System . exit ( - 1 ) ; } } } 
public static String getStaticResolution ( String host ) { synchronized ( hostToResolved ) { return hostToResolved . get ( host ) ; } } 
private static String formatObject ( Comparable c ) { if ( c == null ) { return "null" ; } else if ( c instanceof Double ) { return Float . toString ( ( ( Number ) c ) . floatValue ( ) ) ; } else { return c . toString ( ) ; } } 
public Access getTypeAccess ( ) { return ( Access ) getChild ( 0 ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public synchronized void abortGrabbing ( ) { imageComplete ( IMAGEABORTED ) ; } 
public PostgresExplainResult ( PreparedStatement stmt ) throws SQLException { if ( stmt == null ) { throw ( new NullPointerException ( "PreparedStatement-argument-cannot-be-null" ) ) ; } Connection database = stmt . getConnection ( ) ; if ( database == null ) { throw ( new NullPointerException ( "Failed-to-retrieve-Connection" + "-from-PreparedStatement" ) ) ; } stmt . execute ( ) ; retrieveExplainString ( stmt ) ; stmt . close ( ) ; } 
public static CodeSetServiceContext find ( ServiceContext [ ] contexts ) { if ( contexts != null ) for ( int i = 0 ; i < contexts . length ; i ++ ) { if ( contexts [ i ] instanceof CodeSetServiceContext ) return ( CodeSetServiceContext ) contexts [ i ] ; } return STANDARD ; } 
private void compress ( SsaBasicBlock in ) { DFSInfo bbInfo = info [ in . getIndex ( ) ] ; DFSInfo ancestorbbInfo = info [ bbInfo . ancestor . getIndex ( ) ] ; if ( ancestorbbInfo . ancestor != null ) { ArrayList < SsaBasicBlock > worklist = new ArrayList < SsaBasicBlock > ( ) ; HashSet < SsaBasicBlock > visited = new HashSet < SsaBasicBlock > ( ) ; worklist . add ( in ) ; while ( ! worklist . isEmpty ( ) ) { int wsize = worklist . size ( ) ; SsaBasicBlock v = worklist . get ( wsize - 1 ) ; DFSInfo vbbInfo = info [ v . getIndex ( ) ] ; SsaBasicBlock vAncestor = vbbInfo . ancestor ; DFSInfo vabbInfo = info [ vAncestor . getIndex ( ) ] ; if ( visited . add ( vAncestor ) && vabbInfo . ancestor != null ) { worklist . add ( vAncestor ) ; continue ; } worklist . remove ( wsize - 1 ) ; if ( vabbInfo . ancestor == null ) { continue ; } SsaBasicBlock vAncestorRep = vabbInfo . rep ; SsaBasicBlock vRep = vbbInfo . rep ; if ( info [ vAncestorRep . getIndex ( ) ] . semidom < info [ vRep . getIndex ( ) ] . semidom ) { vbbInfo . rep = vAncestorRep ; } vbbInfo . ancestor = vabbInfo . ancestor ; } } } 
public int size ( ) { return a . size ( ) ; } 
public static String stripSeparators ( String phoneNumber ) { if ( phoneNumber == null ) { return null ; } int len = phoneNumber . length ( ) ; StringBuilder ret = new StringBuilder ( len ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = phoneNumber . charAt ( i ) ; int digit = Character . digit ( c , 10 ) ; if ( digit != - 1 ) { ret . append ( digit ) ; } else if ( isNonSeparator ( c ) ) { ret . append ( c ) ; } } return ret . toString ( ) ; } 
@ Override protected void restoreState ( Hashtable < String , Object > state ) { if ( state . containsKey ( BACKUP_PROCESS ) ) { m_Process = ( Process ) state . get ( BACKUP_PROCESS ) ; state . remove ( BACKUP_PROCESS ) ; } if ( state . containsKey ( BACKUP_WRITER ) ) { m_Writer = ( BufferedWriter ) state . get ( BACKUP_WRITER ) ; state . remove ( BACKUP_WRITER ) ; } if ( state . containsKey ( BACKUP_OUTPUTPROCESSOR_STDOUT ) ) { m_Stdout = ( OutputProcessStream ) state . get ( BACKUP_OUTPUTPROCESSOR_STDOUT ) ; state . remove ( BACKUP_OUTPUTPROCESSOR_STDOUT ) ; } if ( state . containsKey ( BACKUP_OUTPUTPROCESSOR_STDERR ) ) { m_Stderr = ( OutputProcessStream ) state . get ( BACKUP_OUTPUTPROCESSOR_STDERR ) ; state . remove ( BACKUP_OUTPUTPROCESSOR_STDERR ) ; } super . restoreState ( state ) ; } 
protected short unwrapKey ( Short key ) { return key . shortValue ( ) ; } 
public int getNextNode ( ) { if ( null != m_exprObj ) { int next = m_exprObj . nextNode ( ) ; return next ; } else return DTM . NULL ; } 
public void setPixels ( int x , int y , int w , int h , ColorModel model , byte pixels [ ] , int off , int scansize ) { consumer . setPixels ( x , y , w , h , model , pixels , off , scansize ) ; } 
static void putString ( ByteBuffer buf , String str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) buf . putChar ( str . charAt ( i ) ) ; } 
public int getComponentIndex ( Component c ) { int ncomponents = this . getComponentCount ( ) ; Component [ ] component = this . getComponents ( ) ; for ( int i = 0 ; i < ncomponents ; i ++ ) { Component comp = component [ i ] ; if ( comp == c ) return i ; } return - 1 ; } 
private boolean addLinkToStructure ( Map < NodePortTuple , Set < Link >> s , Link l ) { boolean result1 = false , result2 = false ; NodePortTuple n1 = new NodePortTuple ( l . getSrc ( ) , l . getSrcPort ( ) ) ; NodePortTuple n2 = new NodePortTuple ( l . getDst ( ) , l . getDstPort ( ) ) ; if ( s . get ( n1 ) == null ) { s . put ( n1 , new HashSet < Link > ( ) ) ; } if ( s . get ( n2 ) == null ) { s . put ( n2 , new HashSet < Link > ( ) ) ; } result1 = s . get ( n1 ) . add ( l ) ; result2 = s . get ( n2 ) . add ( l ) ; return ( result1 || result2 ) ; } 
public void installUI ( JComponent a ) { for ( int i = 0 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . installUI ( a ) ; } } 
public static APIVersion apiParseVersion ( String version , String prefix ) { String pattern = "([0-9]+)[.]([0-9]+)([.]|S+)?|s*(.+)?" ; if ( prefix != null ) pattern = prefix + "|s+" + pattern ; Matcher matcher = Pattern . compile ( pattern ) . matcher ( version ) ; if ( ! matcher . matches ( ) ) throw new IllegalArgumentException ( String . format ( "Malformed-API-version-string-[%s]" , version ) ) ; return new APIVersion ( Integer . parseInt ( matcher . group ( 1 ) ) , Integer . parseInt ( matcher . group ( 2 ) ) , matcher . group ( 3 ) , matcher . group ( 4 ) ) ; } 
public static < Key , Value > Value remove ( Map < Key , Value > map , Key key ) { return map . remove ( key ) ; } 
public int neighbor ( int v , int k ) { return successor ( v , k ) ; } 
public static JTextArea textAreaAsLabel ( JTextArea textArea ) { textArea . setLineWrap ( true ) ; textArea . setWrapStyleWord ( true ) ; textComponentAsLabel ( textArea ) ; return textArea ; } 
public void removeCallback ( Callback callback ) { callbacks . remove ( callback ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public Iterator getAnalysedMethods ( ) { return data . keySet ( ) . iterator ( ) ; } 
public int indexOf ( AbsContentElement element ) { return elements . indexOf ( element ) ; } 
public String getMethodName ( ) { if ( action != null ) return action . getMethodName ( ) ; return method . getName ( ) ; } 
static public int count ( Context context , Uri uri , String selection , String [ ] selectionArgs ) { Cursor cursor = context . getContentResolver ( ) . query ( uri , COUNT_COLUMNS , selection , selectionArgs , null ) ; try { if ( ! cursor . moveToFirst ( ) ) { return 0 ; } return cursor . getInt ( 0 ) ; } finally { cursor . close ( ) ; } } 
public static void registerTarget ( javax . rmi . CORBA . Tie tie , java . rmi . Remote target ) { if ( utilDelegate != null ) { utilDelegate . registerTarget ( tie , target ) ; } } 
private String downloadUrl ( String strUrl ) throws IOException { String data = "" ; InputStream iStream = null ; HttpURLConnection urlConnection = null ; try { URL url = new URL ( strUrl ) ; urlConnection = ( HttpURLConnection ) url . openConnection ( ) ; urlConnection . connect ( ) ; iStream = urlConnection . getInputStream ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( iStream ) ) ; StringBuffer sb = new StringBuffer ( ) ; String line = "" ; while ( ( line = br . readLine ( ) ) != null ) { sb . append ( line ) ; } data = sb . toString ( ) ; br . close ( ) ; } catch ( Exception e ) { Log . d ( "Exception-while-downloading-url" , e . toString ( ) ) ; } finally { iStream . close ( ) ; urlConnection . disconnect ( ) ; } return data ; } 
public static String format ( String format , Object ... args ) { return format ( Locale . getDefault ( ) , format , args ) ; } 
public void actionPerformed ( ActionEvent e ) { optionPane . setValue ( btnString1 ) ; } 
protected int defaultMaximumAllowedCharacter ( ) { String encoding = format . getEncoding ( ) ; if ( encoding != null ) { if ( encoding . equals ( "US-ASCII" ) ) { return 127 ; } } return - 1 ; } 
private boolean isTypeParameterIntroducer ( String identifier ) { return identifier . length ( ) > 0 && ( Character . isUpperCase ( identifier . charAt ( 0 ) ) || identifier . startsWith ( "final" ) || identifier . startsWith ( "public" ) || identifier . startsWith ( "public" ) || identifier . startsWith ( "protected" ) || identifier . startsWith ( "private" ) ) ; } 
public Services authenticate ( String login , String password ) { User user = request ( ) . to ( "user_session" ) . post ( ) . send ( "login" , login , "password" , password ) . as ( User . class ) ; return new Services ( this , user ) ; } 
protected boolean isOldMaintainableInDocument ( Document xmlDocument ) { boolean isOldMaintainableInExistence = false ; if ( xmlDocument . getElementsByTagName ( OLD_MAINTAINABLE_TAG_NAME ) . getLength ( ) > 0 ) { isOldMaintainableInExistence = true ; } return isOldMaintainableInExistence ; } 
public boolean dialogItemChanged ( GenericDialog gd , AWTEvent e ) { if ( previewCheckbox == null || imp == null ) return true ; previewCheckboxOn = previewCheckbox . getState ( ) ; if ( previewCheckboxOn && previewThread == null ) { bgPreviewOn = true ; previewThread = new Thread ( this , command + "-Preview" ) ; int priority = Thread . currentThread ( ) . getPriority ( ) - 2 ; if ( priority < Thread . MIN_PRIORITY ) priority = Thread . MIN_PRIORITY ; previewThread . setPriority ( priority ) ; previewThread . start ( ) ; if ( IJ . debugMode ) IJ . log ( command + "-Preview-thread-was-started" ) ; return true ; } if ( previewThread != null ) { if ( ! previewCheckboxOn ) { killPreview ( ) ; return true ; } else previewThread . interrupt ( ) ; } return true ; } 
public void setTickLabelInsets ( RectangleInsets insets ) { if ( insets == null ) { throw new IllegalArgumentException ( "Null-'insets'-argument." ) ; } if ( ! this . tickLabelInsets . equals ( insets ) ) { this . tickLabelInsets = insets ; fireChangeEvent ( ) ; } } 
protected void CDATA ( boolean clearBuffer ) throws ParseException { Token start = hTag = getTokenAhead ( ) ; if ( clearBuffer ) buffer . setLength ( 0 ) ; if ( start . kind == EOF ) return ; read : while ( true ) { t = getTokenAhead ( ) ; if ( t . kind == EOF ) { error ( "unexpected-eof" , t ) ; break read ; } else if ( t . kind == BEGIN ) break read ; else if ( t . kind == Constants . ENTITY ) { resolveAndAppendEntity ( t ) ; getNextToken ( ) ; } else { append ( t ) ; getNextToken ( ) ; } } hTag = new Token ( start , getTokenAhead ( 0 ) ) ; if ( buffer . length ( ) != 0 ) _handleText ( ) ; } 
public static int readSingleByte ( InputStream in ) throws IOException { byte [ ] buffer = new byte [ 1 ] ; int result = in . read ( buffer , 0 , 1 ) ; return ( result != - 1 ) ? buffer [ 0 ] & 0xff : - 1 ; } 
public HologramFactory withText ( String ... text ) { Collections . addAll ( this . tags , text ) ; return this ; } 
public String get ( Keys k ) { String s = values . get ( k ) ; return s == null ? "" : s ; } 
public static int binarySearch ( double [ ] a , double key ) { return binarySearch0 ( a , 0 , a . length , key ) ; } 
private Leaf parseQuotedLabel ( ) throws ParseException { StringBuffer leafname = new StringBuffer ( ) ; while ( newick [ ++ position ] != '|'' ) { leafname . append ( newick [ position ] ) ; if ( newick [ position + 1 ] == '|'' && newick [ position + 2 ] == '|'' ) { leafname . append ( "''" ) ; position += 2 ; } } return new Leaf ( leafname . toString ( ) ) ; } 
public void setRecord_guid ( String record_guid ) { this . record_guid = record_guid == null ? null : record_guid . trim ( ) ; } 
private int getCharClass ( int index ) { if ( ( index < 0 ) || ( text . length ( ) <= index ) ) { return 0 ; } char ch = text . charAt ( index ) ; if ( Character . isWhitespace ( ch ) ) { return 1 ; } else if ( Character . isLetter ( ch ) ) { return 2 ; } else if ( Character . isDigit ( ch ) ) { return 3 ; } else if ( isPunctuation ( ch ) ) { return ++ nextClass ; } else { return 4 ; } } 
@ Override public Path makeQualified ( Path path ) { Path fqPath = fs . makeQualified ( path ) ; if ( swapScheme != null ) { try { fqPath = new Path ( new URI ( swapScheme , fqPath . toUri ( ) . getSchemeSpecificPart ( ) , null ) ) ; } catch ( URISyntaxException e ) { throw new IllegalArgumentException ( e ) ; } } return fqPath ; } 
public String getDuplicateId ( WaContext context , RequestParser parser ) { String returnCode = "N" ; String account = ( String ) parser . getParameter ( "account" ) ; Connection conn = null ; PreparedStatement pstmt = null ; ResultSet rs = null ; String sql = null ; try { sql = "SELECT-to_char(count(*))-as-cnt-FROM-BCDBA.TBLTAXUNIFMGRINFO-WHERE-MGR_ID-=-?-" ; conn = context . getDbConnection ( "default" , null ) ; pstmt = conn . prepareStatement ( sql ) ; pstmt . setString ( 1 , account ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { returnCode = rs . getString ( "cnt" ) ; } if ( "0" . equals ( returnCode ) ) { returnCode = "N" ; } else { returnCode = "Y" ; } } catch ( Throwable t ) { error ( t . getMessage ( ) ) ; returnCode = "Err" ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( Throwable e ) { } } if ( pstmt != null ) { try { pstmt . close ( ) ; } catch ( Throwable e ) { } } if ( conn != null ) { try { conn . close ( ) ; } catch ( Throwable ex1 ) { } } } return returnCode ; } 
protected void addKeyValueTag ( final String key , final String value ) { keyValueTags . put ( key , value ) ; } 
@ SuppressWarnings ( "unchecked" ) public static < T > T [ ] reverse ( T [ ] self , boolean mutate ) { if ( ! mutate ) { return ( T [ ] ) toList ( new ReverseListIterator < T > ( Arrays . asList ( self ) ) ) . toArray ( ) ; } List < T > items = Arrays . asList ( self ) ; Collections . reverse ( items ) ; System . arraycopy ( ( T [ ] ) items . toArray ( ) , 0 , self , 0 , items . size ( ) ) ; return self ; } 
public HashCodeBuilder append ( short [ ] array ) { if ( array == null ) { iTotal = iTotal * iConstant ; } else { for ( short element : array ) { append ( element ) ; } } return this ; } 
public static byte [ ] charToByteArray ( char [ ] buffer , int offset , int length , String enc ) throws UnsupportedEncodingException { if ( isISO8859_1 ( enc ) ) { char c ; byte [ ] value = new byte [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { value [ i ] = ( byte ) buffer [ i + offset ] ; } return value ; } else if ( ISO8859_1_ONLY_SUPPORTED ) { throw new UnsupportedEncodingException ( enc ) ; } else { return charToByteArray0 ( buffer , offset , length , enc ) ; } } 
@ SuppressWarnings ( "fallthrough" ) private String nextLiteral ( ) throws IOException { StringBuilder builder = null ; do { int start = pos ; while ( pos < limit ) { int c = buffer [ pos ++ ] ; switch ( c ) { case '/' : case '|' : case ';' : case '#' : case '=' : checkLenient ( ) ; case '{' : case '}' : case '[' : case ']' : case ':' : case ',' : case '-' : case '|t' : case '|f' : case '|r' : case '|n' : pos -- ; if ( skipping ) { return "skipped!" ; } else if ( builder == null ) { return stringPool . get ( buffer , start , pos - start ) ; } else { builder . append ( buffer , start , pos - start ) ; return builder . toString ( ) ; } } } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , start , pos - start ) ; } while ( fillBuffer ( 1 ) ) ; return builder . toString ( ) ; } 
public static int skipUntil ( String input , int pos , String characters ) { for ( ; pos < input . length ( ) ; pos ++ ) { if ( characters . indexOf ( input . charAt ( pos ) ) != - 1 ) { break ; } } return pos ; } 
public void setKeyStoreResource ( Resource resource ) { checkNotStarted ( ) ; try { _keyStoreInputStream = resource . getInputStream ( ) ; } catch ( IOException e ) { throw new InvalidParameterException ( "Unable-to-get-resource-" + "input-stream-for-resource-" + resource . toString ( ) ) ; } } 
public static boolean isSOAP12 ( SOAPMessage soapMessage ) throws SOAPException { SOAPPart soapPart = soapMessage . getSOAPPart ( ) ; SOAPEnvelope soapEnvelope = soapPart . getEnvelope ( ) ; if ( SOAPConstants . URI_NS_SOAP_1_2_ENVELOPE . equals ( soapEnvelope . getNamespaceURI ( ) ) ) return true ; return false ; } 
public double toXYZ ( double v ) { double a = 0.055 ; if ( v < 0.04045 ) return v / 12.92 ; else return Math . pow ( ( v + a ) / a , 2.4 ) ; } 
public void addPoint ( float x , float y ) { if ( hasVertex ( x , y ) && ( ! allowDups ) ) { return ; } ArrayList tempPoints = new ArrayList ( ) ; for ( int i = 0 ; i < points . length ; i ++ ) { tempPoints . add ( new Float ( points [ i ] ) ) ; } tempPoints . add ( new Float ( x ) ) ; tempPoints . add ( new Float ( y ) ) ; int length = tempPoints . size ( ) ; points = new float [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { points [ i ] = ( ( Float ) tempPoints . get ( i ) ) . floatValue ( ) ; } if ( x > maxX ) { maxX = x ; } if ( y > maxY ) { maxY = y ; } if ( x < minX ) { minX = x ; } if ( y < minY ) { minY = y ; } findCenter ( ) ; calculateRadius ( ) ; pointsDirty = true ; } 
private HttpURLConnection openConnection ( URL url , Request < ? > request ) throws IOException { HttpURLConnection connection = createConnection ( url ) ; int timeoutMs = request . getTimeoutMs ( ) ; connection . setConnectTimeout ( timeoutMs ) ; connection . setReadTimeout ( timeoutMs ) ; connection . setUseCaches ( false ) ; connection . setDoInput ( true ) ; if ( "https" . equals ( url . getProtocol ( ) ) && mSslSocketFactory != null ) { ( ( HttpsURLConnection ) connection ) . setSSLSocketFactory ( mSslSocketFactory ) ; } return connection ; } 
public static void removeListener ( PropertyEventListener listener ) { listeners . remove ( listener ) ; } 
void unregisterOnActivityStopListener ( OnActivityStopListener listener ) { synchronized ( this ) { if ( mActivityStopListeners != null ) { mActivityStopListeners . remove ( listener ) ; } } } 
@ Override public int read ( ) throws IOException { synchronized ( lock ) { checkNotClosed ( ) ; if ( pos < end || fillBuf ( ) != - 1 ) { return buf [ pos ++ ] ; } return - 1 ; } } 
public byte [ ] getData ( ) { if ( ! mHasValidTlvObject ) return null ; byte [ ] ret = new byte [ mCurDataLength ] ; System . arraycopy ( mRecord , mCurDataOffset , ret , 0 , mCurDataLength ) ; return ret ; } 
static boolean isElement ( Element element ) { return element . getName ( ) . equals ( "mixin" ) ; } 
public String toString ( ) { return ( digits ( mostSigBits >> 32 , 8 ) + "-" + digits ( mostSigBits >> 16 , 4 ) + "-" + digits ( mostSigBits , 4 ) + "-" + digits ( leastSigBits >> 48 , 4 ) + "-" + digits ( leastSigBits , 12 ) ) ; } 
public Number getMaximumAccessibleValue ( ) { return new Integer ( model . getMaximum ( ) - model . getExtent ( ) ) ; } 
private static String timeToDaysMinutesSeconds ( Context context , long time ) { long days = time / MS_PER_DAY ; long hours = ( time / MS_PER_HOUR ) % 24 ; long minutes = ( time / MS_PER_MINUTE ) % 60 ; return context . getString ( R . string . status_days_hours_minutes , days , hours , minutes ) ; } 
public Collection < List < ? >> getPairsList ( ) { Collection < List < ? >> result = new ArrayList < List < ? >> ( ) ; if ( generalNames == null ) { return result ; } for ( GeneralName generalName : generalNames ) { final List < Object > genNameList ; try { genNameList = generalName . getAsList ( ) ; } catch ( IllegalArgumentException ignored ) { continue ; } result . add ( genNameList ) ; } return result ; } 
public void addModifyListener ( ModifyListener listener ) { checkWidget ( ) ; if ( listener == null ) error ( SWT . ERROR_NULL_ARGUMENT ) ; TypedListener typedListener = new TypedListener ( listener ) ; addListener ( SWT . Modify , typedListener ) ; } 
@ Override public void close ( ) throws IOException { Path outDir = new Path ( TMP_DIR , "out" ) ; Path outFile = new Path ( outDir , "reduce-out" ) ; FileSystem fileSys = FileSystem . get ( conf ) ; SequenceFile . Writer writer = SequenceFile . createWriter ( fileSys , conf , outFile , LongWritable . class , LongWritable . class , CompressionType . NONE ) ; writer . append ( new LongWritable ( numInside ) , new LongWritable ( numOutside ) ) ; writer . close ( ) ; } 
public void readAttributes ( ObjectInputStream in , MutableAttributeSet a ) throws ClassNotFoundException , IOException { readAttributeSet ( in , a ) ; } 
private byte [ ] getPhotoBytes ( String filename ) { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; try { int bytesRead = 0 ; long totalBytesRead = 0 ; byte [ ] data = new byte [ 8192 ] ; InputStream in = getPathFromUri ( filename ) ; while ( ( bytesRead = in . read ( data , 0 , data . length ) ) != - 1 && totalBytesRead <= MAX_PHOTO_SIZE ) { buffer . write ( data , 0 , bytesRead ) ; totalBytesRead += bytesRead ; } in . close ( ) ; buffer . flush ( ) ; } catch ( FileNotFoundException e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } catch ( IOException e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return buffer . toByteArray ( ) ; } 
private void upgradeLegacyBackgroundData ( ) { mRestrictBackground = Settings . Secure . getInt ( mContext . getContentResolver ( ) , Settings . Secure . BACKGROUND_DATA , 1 ) != 1 ; if ( mRestrictBackground ) { final Intent broadcast = new Intent ( ConnectivityManager . ACTION_BACKGROUND_DATA_SETTING_CHANGED ) ; mContext . sendBroadcastAsUser ( broadcast , UserHandle . ALL ) ; } } 
public void setFeature ( String featureId , boolean state ) throws XMLConfigurationException { if ( featureId . equals ( ALLOW_UE_AND_NOTATION_EVENTS ) ) { fSendUEAndNotationEvents = state ; } if ( fSettings != null ) { fNeedCopyFeatures = true ; fSettings . setFeature ( featureId , state ) ; } } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
@ XmlElementDecl ( namespace = "http://www.sdltridion.com/ContentManager/R6" , name = "ArrayOfClassificationDetailData" ) public JAXBElement < ArrayOfClassificationDetailData > createArrayOfClassificationDetailData ( ArrayOfClassificationDetailData value ) { return new JAXBElement < ArrayOfClassificationDetailData > ( _ArrayOfClassificationDetailData_QNAME , ArrayOfClassificationDetailData . class , null , value ) ; } 
private void updateImportListWith ( SchemaGrammar newGrammar ) { SchemaGrammar [ ] schemaGrammars = fGrammarBucket . getGrammars ( ) ; for ( int i = 0 ; i < schemaGrammars . length ; ++ i ) { SchemaGrammar sg = schemaGrammars [ i ] ; if ( sg != newGrammar ) { Vector importedGrammars = sg . getImportedGrammars ( ) ; if ( importedGrammars != null ) { for ( int j = 0 ; j < importedGrammars . size ( ) ; j ++ ) { SchemaGrammar isg = ( SchemaGrammar ) importedGrammars . elementAt ( j ) ; if ( null2EmptyString ( isg . getTargetNamespace ( ) ) . equals ( null2EmptyString ( newGrammar . getTargetNamespace ( ) ) ) ) { if ( isg != newGrammar ) { importedGrammars . set ( j , newGrammar ) ; } break ; } } } } } } 
public static MethodType fromMethodDescriptorString ( String descriptor , ClassLoader loader ) throws IllegalArgumentException , TypeNotPresentException { if ( ! descriptor . startsWith ( "(" ) || descriptor . indexOf ( ')' ) < 0 || descriptor . indexOf ( '.' ) >= 0 ) throw newIllegalArgumentException ( "not-a-method-descriptor:-" + descriptor ) ; List < Class < ? >> types = BytecodeDescriptor . parseMethod ( descriptor , loader ) ; Class < ? > rtype = types . remove ( types . size ( ) - 1 ) ; checkSlotCount ( types . size ( ) ) ; Class < ? > [ ] ptypes = listToArray ( types ) ; return makeImpl ( rtype , ptypes , true ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public static String toStringLiteral ( String strValue ) { if ( strValue == null ) return "null" ; int len = strValue . length ( ) ; StringBuffer result = new StringBuffer ( len + 16 ) ; result . append ( '|"' ) ; for ( int i = 0 ; i < len ; i ++ ) { result . append ( escapeChar ( strValue . charAt ( i ) ) ) ; } result . append ( '|"' ) ; return result . toString ( ) ; } 
protected void resetActionsCache ( ) { actionsCache . clear ( ) ; } 
@ Override public boolean addPackets ( Queue < Packet > packets ) { boolean result = true ; Packet p = packets . peek ( ) ; while ( p != null ) { result = addPacket ( p ) ; if ( result ) { packets . poll ( ) ; } else { break ; } p = packets . peek ( ) ; } return result ; } 
public void playTogether ( Collection < Animator > items ) { if ( items != null && items . size ( ) > 0 ) { mNeedsSort = true ; Builder builder = null ; for ( Animator anim : items ) { if ( builder == null ) { builder = play ( anim ) ; } else { builder . with ( anim ) ; } } } } 
@ XmlElementDecl ( namespace = "http://www.devspringsoftware.com" , name = "WidthBucketFunction" ) public JAXBElement < WidthBucketFunctionType > createWidthBucketFunction ( WidthBucketFunctionType value ) { return new JAXBElement < WidthBucketFunctionType > ( _WidthBucketFunction_QNAME , WidthBucketFunctionType . class , null , value ) ; } 
public List < T > toList ( ) { final List < T > list = new ArrayList < T > ( ) ; final Iterator < T > iterator = iterator ( ) ; while ( iterator . hasNext ( ) ) { list . add ( iterator . next ( ) ) ; } return list ; } 
private String readLineFromResource ( String resourceName ) { InputStream in = VersionService . class . getResourceAsStream ( resourceName ) ; if ( in == null ) { return null ; } BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( in ) ) ; return reader . readLine ( ) ; } catch ( IOException x ) { return null ; } finally { IOUtils . closeQuietly ( reader ) ; IOUtils . closeQuietly ( in ) ; } } 
@ XmlElementDecl ( namespace = "http://www.w3.org/2000/09/xmldsig#" , name = "X509Data" ) public JAXBElement < X509DataType > createX509Data ( X509DataType value ) { return new JAXBElement < X509DataType > ( _X509Data_QNAME , X509DataType . class , null , value ) ; } 
public String getClassName ( ) { String cname = super . getClassName ( ) ; if ( cname != null ) { return cname ; } if ( boundObj != null ) return boundObj . getClass ( ) . getName ( ) ; else return null ; } 
void deviceDisconnected ( IDevice device ) { IDeviceChangeListener [ ] listenersCopy = null ; synchronized ( sLock ) { listenersCopy = sDeviceListeners . toArray ( new IDeviceChangeListener [ sDeviceListeners . size ( ) ] ) ; } for ( IDeviceChangeListener listener : listenersCopy ) { try { listener . deviceDisconnected ( device ) ; } catch ( Exception e ) { Log . e ( DDMS , e ) ; } } } 
public static void w ( String tag , String s , Object ... args ) { if ( LOG . WARN >= LOGLEVEL ) Log . w ( tag , String . format ( s , args ) ) ; } 
public static boolean isNativeZlibLoaded ( Configuration conf ) { return nativeZlibLoaded && conf . getBoolean ( "hadoop.native.lib" , true ) ; } 
public String getFetchtimeout ( ) { return getAttribute ( ATTRIBUTE_FETCHTIMEOUT ) ; } 
private boolean checkDataBase ( ) { try { String myPath = myContext . getString ( R . string . DB_PATH ) + myContext . getString ( R . string . DB_NAME ) ; File f = new File ( myPath ) ; if ( f . exists ( ) ) return true ; else return false ; } catch ( SQLiteException e ) { e . printStackTrace ( ) ; return false ; } } 
public boolean isSubtype ( YetiType yt ) { if ( directSuperTypes . containsValue ( yt ) ) return true ; for ( YetiType t : directSuperTypes . values ( ) ) if ( t . isSubtype ( yt ) ) return true ; return false ; } 
public double getPPG ( ) { return Math . round ( points * 10.0 / games ) / 10.0 ; } 
public final PrefixResolver getNamespaceContext ( ) { return ( PrefixResolver ) m_prefixResolvers . peek ( ) ; } 
public void setNaN ( String v ) { m_dfs . setNaN ( v ) ; } 
public int size ( ) { return set . size ( ) ; } 
public String getStringV ( ) { int i = 0 ; int currentOffset = dataBuffer . position ( ) ; for ( ; dataBuffer . hasRemaining ( ) ; i ++ ) { if ( dataBuffer . get ( currentOffset + i ) == 0 ) break ; } return makeString ( dataBuffer , i ) ; } 
public JPanel left_panel ( ) { JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . Y_AXIS ) ) ; JButton create = new JButton ( "Create-Album" ) ; create . addActionListener ( new create_listener ( ) ) ; create . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; JButton delete = new JButton ( "Delete-Album" ) ; delete . addActionListener ( new delete_listener ( ) ) ; delete . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; JButton rename = new JButton ( "Rename-Album" ) ; rename . addActionListener ( new rename_listener ( ) ) ; rename . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; panel . add ( Box . createRigidArea ( new Dimension ( 0 , 25 ) ) ) ; panel . add ( create ) ; panel . add ( Box . createRigidArea ( new Dimension ( 0 , 50 ) ) ) ; panel . add ( delete ) ; panel . add ( Box . createRigidArea ( new Dimension ( 0 , 50 ) ) ) ; panel . add ( rename ) ; panel . setBorder ( BorderFactory . createTitledBorder ( "Album" ) ) ; panel . setBackground ( Color . white ) ; return panel ; } 
protected Logger getLogger ( final Member member ) { if ( logger != null ) { return logger ; } return LoggerFactory . getLogger ( member . getDeclaringClass ( ) ) ; } 
public void setLabel ( String pLabel ) { mLabel . setText ( pLabel ) ; } 
public Collection values ( ) { Collection vs = values ; return ( vs != null ? vs : ( values = new Values ( ) ) ) ; } 
private EriInfo getEriInfo ( int roamingIndicator ) { if ( mEriFile . mRoamIndTable . containsKey ( roamingIndicator ) ) { return mEriFile . mRoamIndTable . get ( roamingIndicator ) ; } else { return null ; } } 
public List expn ( String address ) throws IOException { String command = EXPN + '-' + address ; send ( command ) ; List list = new ArrayList ( ) ; do { switch ( getResponse ( ) ) { case OK : response = response . trim ( ) ; list . add ( response ) ; break ; default : return null ; } } while ( continuation ) ; return Collections . unmodifiableList ( list ) ; } 
public Extension get ( String alias ) { X509AttributeName attr = new X509AttributeName ( alias ) ; String name ; String id = attr . getPrefix ( ) ; if ( id . equalsIgnoreCase ( X509CertImpl . NAME ) ) { int index = alias . lastIndexOf ( "." ) ; name = alias . substring ( index + 1 ) ; } else name = alias ; return map . get ( name ) ; } 
public int getRowForPoint ( Point point ) { return getRowForPoint ( point , true ) ; } 
public static int getLeftSideBearing ( JComponent c , FontMetrics fm , String string ) { if ( ( string == null ) || ( string . length ( ) == 0 ) ) { return 0 ; } return getLeftSideBearing ( c , fm , string . charAt ( 0 ) ) ; } 
public Property minuteOfDay ( ) { return new Property ( this , getChronology ( ) . minuteOfDay ( ) ) ; } 
public String getLocalName ( ) { InetAddress ia = socket . getLocalAddress ( ) ; return ia == null ? null : ia . getCanonicalHostName ( ) ; } 
@ Override public List getValues ( Comparable rowKey , Comparable columnKey ) { return Collections . unmodifiableList ( ( List ) this . data . getObject ( rowKey , columnKey ) ) ; } 
public final Object getProperty ( Object key ) { return getDocumentProperties ( ) . get ( key ) ; } 
public Graphics2D createGraphics ( ) { return bufferedImage . createGraphics ( ) ; } 
public static void zip ( String dataDirectoryPath , File outputArchive ) throws IOException { File dataDirectory = new File ( dataDirectoryPath ) ; LOG . debug ( "Bundling:-" + dataDirectory . getPath ( ) ) ; LOG . debug ( "-to:-" + outputArchive . getPath ( ) ) ; ZipOutputStream out = new ZipOutputStream ( new BufferedOutputStream ( new FileOutputStream ( outputArchive ) ) ) ; if ( ! dataDirectory . exists ( ) || ! dataDirectory . isDirectory ( ) ) throw new IllegalArgumentException ( "Not-a-directory:-" + dataDirectory . getPath ( ) ) ; byte [ ] buffer = new byte [ ResourceUtils . BUFFER_SIZE ] ; addDirectoryToZip ( out , dataDirectory , dataDirectoryPath , buffer ) ; out . close ( ) ; } 
public String toString ( ) { String result = "Discrete-Estimator.-Counts-=-" ; if ( m_SumOfCounts > 1 ) { for ( int i = 0 ; i < m_Counts . length ; i ++ ) { result += "-" + Utils . doubleToString ( m_Counts [ i ] , 2 ) ; } result += "-(Total-=-" + Utils . doubleToString ( m_SumOfCounts , 2 ) + ")-" ; } else { for ( int i = 0 ; i < m_Counts . length ; i ++ ) { result += "-" + m_Counts [ i ] ; } result += "-(Total-=-" + m_SumOfCounts + ")-" ; } return result ; } 
public synchronized void forgetByteCode ( ) { this . _methodByteCodeOffsets = new HashMap < MethodBinding , Integer > ( ) ; this . _classFile = null ; this . _classByteCode = null ; this . _constantPoolOffsets = null ; } 
public void unsnooze ( ) { snoozeUntil = new Date ( 0 ) ; } 
private void directWrite ( final char chars [ ] , final int start , final int length ) throws java . io . IOException { if ( length >= BYTES_MAX - count ) { flushBuffer ( ) ; if ( length >= BYTES_MAX ) { int chunks = 1 + length / CHARS_MAX ; for ( int chunk = 0 ; chunk < chunks ; chunk ++ ) { int start_chunk = start + ( ( length * chunk ) / chunks ) ; int end_chunk = start + ( ( length * ( chunk + 1 ) ) / chunks ) ; int len_chunk = ( end_chunk - start_chunk ) ; this . directWrite ( chars , start_chunk , len_chunk ) ; } return ; } } final int n = length + start ; final byte [ ] buf_loc = m_outputBytes ; int count_loc = count ; for ( int i = start ; i < n ; i ++ ) buf_loc [ count_loc ++ ] = ( byte ) buf_loc [ i ] ; count = count_loc ; } 
public void showWaitDialog ( String message ) { if ( isFinishing ( ) ) { return ; } if ( waitDialog != null && waitDialog . isShowing ( ) ) { waitDialog . dismiss ( ) ; waitDialog = null ; } waitDialog = new Dialog ( this , R . style . dialog ) ; waitDialog . setContentView ( R . layout . dialog_progress ) ; ( ( TextView ) waitDialog . findViewById ( R . id . message ) ) . setText ( message ) ; waitDialog . setCancelable ( false ) ; waitDialog . show ( ) ; } 
public final void addChangeListener ( ChangeListener listener ) { changeListeners . add ( listener ) ; } 
public List < String > toNameValueBlock ( ) { Set < String > names = new HashSet < String > ( ) ; List < String > result = new ArrayList < String > ( ) ; for ( int i = 0 ; i < namesAndValues . size ( ) ; i += 2 ) { String name = namesAndValues . get ( i ) . toLowerCase ( Locale . US ) ; String value = namesAndValues . get ( i + 1 ) ; if ( name . equals ( "connection" ) || name . equals ( "host" ) || name . equals ( "keep-alive" ) || name . equals ( "proxy-connection" ) || name . equals ( "transfer-encoding" ) ) { continue ; } if ( names . add ( name ) ) { result . add ( name ) ; result . add ( value ) ; continue ; } for ( int j = 0 ; j < result . size ( ) ; j += 2 ) { if ( name . equals ( result . get ( j ) ) ) { result . set ( j + 1 , result . get ( j + 1 ) + " " + value ) ; break ; } } } return result ; } 
public EventHeader createEventHeader ( String eventType ) throws ParseException { if ( eventType == null ) throw new NullPointerException ( "null-eventType" ) ; Event event = new Event ( ) ; event . setEventType ( eventType ) ; return event ; } 
public double getRangeLowerBound ( boolean includeInterval ) { if ( includeInterval && ! Double . isNaN ( this . minimumRangeValueIncStdDev ) ) { return this . minimumRangeValueIncStdDev ; } else { return this . minimumRangeValue ; } } 
public void addOption ( String name , String textValue ) { _options . add ( new ProjectInput . Option ( name , toObjectValue ( textValue ) ) ) ; } 
public String replace ( char oldChar , char newChar ) { char [ ] buffer = value ; int _offset = offset ; int _count = count ; int idx = _offset ; int last = _offset + _count ; boolean copied = false ; while ( idx < last ) { if ( buffer [ idx ] == oldChar ) { if ( ! copied ) { char [ ] newBuffer = new char [ _count ] ; System . arraycopy ( buffer , _offset , newBuffer , 0 , _count ) ; buffer = newBuffer ; idx -= _offset ; last -= _offset ; copied = true ; } buffer [ idx ] = newChar ; } idx ++ ; } return copied ? new String ( 0 , count , buffer ) : this ; } 
public static String toString ( InputStream input ) throws IOException { StringWriter sw = new StringWriter ( ) ; copy ( input , sw ) ; return sw . toString ( ) ; } 
public void resetFields ( ) { jComboReference . removeAllItems ( ) ; jComboReference . setEnabled ( false ) ; jComboName . removeAllItems ( ) ; jComboName . setEnabled ( false ) ; jComboBarcode . removeAllItems ( ) ; jComboBarcode . setEnabled ( false ) ; jComboBuy . removeAllItems ( ) ; jComboBuy . setEnabled ( false ) ; jComboSell . removeAllItems ( ) ; jComboSell . setEnabled ( false ) ; jComboCategory . removeAllItems ( ) ; jComboCategory . setEnabled ( false ) ; jComboDefaultCategory . setEnabled ( false ) ; jComboTax . setEnabled ( false ) ; jImport . setEnabled ( false ) ; jHeaderRead . setEnabled ( false ) ; jCheckInCatalogue . setSelected ( false ) ; jCheckInCatalogue . setEnabled ( false ) ; jCheckSellIncTax . setSelected ( false ) ; jCheckSellIncTax . setEnabled ( false ) ; jFileName . setText ( null ) ; csvFileName = "" ; jTextNew . setText ( "" ) ; jTextUpdate . setText ( "" ) ; jTextInvalid . setText ( "" ) ; jTextMissing . setText ( "" ) ; jTextNoChange . setText ( "" ) ; jTextRecords . setText ( "" ) ; jTextBadPrice . setText ( "" ) ; Headers . clear ( ) ; } 
public static byte [ ] decode ( byte [ ] source , int off , int len , int options ) { byte [ ] DECODABET = getDecodabet ( options ) ; int len34 = len * 3 / 4 ; byte [ ] outBuff = new byte [ len34 ] ; int outBuffPosn = 0 ; byte [ ] b4 = new byte [ 4 ] ; int b4Posn = 0 ; int i = 0 ; byte sbiCrop = 0 ; byte sbiDecode = 0 ; for ( i = off ; i < off + len ; i ++ ) { sbiCrop = ( byte ) ( source [ i ] & 0x7f ) ; sbiDecode = DECODABET [ sbiCrop ] ; if ( sbiDecode >= WHITE_SPACE_ENC ) { if ( sbiDecode >= EQUALS_SIGN_ENC ) { b4 [ b4Posn ++ ] = sbiCrop ; if ( b4Posn > 3 ) { outBuffPosn += decode4to3 ( b4 , 0 , outBuff , outBuffPosn , options ) ; b4Posn = 0 ; if ( sbiCrop == EQUALS_SIGN ) break ; } } } else { System . err . println ( "Bad-Base64-input-character-at-" + i + ":-" + source [ i ] + "(decimal)" ) ; return null ; } } byte [ ] out = new byte [ outBuffPosn ] ; System . arraycopy ( outBuff , 0 , out , 0 , outBuffPosn ) ; return out ; } 
public void delete ( int startIndex , int endIndex ) { AccessibleEditableText at = getEditorAccessibleEditableText ( ) ; if ( at != null ) { at . delete ( startIndex , endIndex ) ; } } 
public Object getBean ( String name ) { Bean bean = beans . get ( name ) ; if ( null == bean ) { return null ; } return bean . object ; } 
public static Method findReadMethod ( Object o , String name ) { Class [ ] params ; Method result ; result = null ; params = new Class [ 1 ] ; params [ 0 ] = Element . class ; try { result = o . getClass ( ) . getMethod ( name , params ) ; } catch ( Exception e ) { result = null ; } return result ; } 
public Body addBody ( String language , String body ) { language = determineLanguage ( language ) ; Body messageBody = new Body ( language , body ) ; bodies . add ( messageBody ) ; return messageBody ; } 
public static Object invokeViewMethod ( final View view , final Method method , final Object [ ] args ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final AtomicReference < Object > result = new AtomicReference < Object > ( ) ; final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; view . post ( new Runnable ( ) { @ Override public void run ( ) { try { result . set ( method . invoke ( view , args ) ) ; } catch ( InvocationTargetException e ) { exception . set ( e . getCause ( ) ) ; } catch ( Exception e ) { exception . set ( e ) ; } latch . countDown ( ) ; } } ) ; try { latch . await ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } if ( exception . get ( ) != null ) { throw new RuntimeException ( exception . get ( ) ) ; } return result . get ( ) ; } 
public static AssignPrivateIpAddresses parse ( javax . xml . stream . XMLStreamReader reader ) throws java . lang . Exception { AssignPrivateIpAddresses object = new AssignPrivateIpAddresses ( ) ; int event ; java . lang . String nillableValue = null ; java . lang . String prefix = "" ; java . lang . String namespaceuri = "" ; try { while ( ! reader . isStartElement ( ) && ! reader . isEndElement ( ) ) reader . next ( ) ; java . util . Vector handledAttributes = new java . util . Vector ( ) ; while ( ! reader . isEndElement ( ) ) { if ( reader . isStartElement ( ) ) { if ( reader . isStartElement ( ) && new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2012-08-15/" , "AssignPrivateIpAddresses" ) . equals ( reader . getName ( ) ) ) { object . setAssignPrivateIpAddresses ( com . amazon . ec2 . AssignPrivateIpAddressesType . Factory . parse ( reader ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "Unexpected-subelement-" + reader . getLocalName ( ) ) ; } } else { reader . next ( ) ; } } } catch ( javax . xml . stream . XMLStreamException e ) { throw new java . lang . Exception ( e ) ; } return object ; } 
public static Object decodeToObject ( String encodedObject ) throws java . io . IOException , java . lang . ClassNotFoundException { return decodeToObject ( encodedObject , NO_OPTIONS , null ) ; } 
public void jsxSet_MozUserModify ( final String mozUserModify ) { setStyleAttribute ( "MozUserModify" , mozUserModify ) ; } 
public final boolean push ( boolean val ) { if ( m_index == m_allocatedSize - 1 ) grow ( ) ; return ( m_values [ ++ m_index ] = val ) ; } 
public void markDirty ( Instruction s , Register symb ) { HashSet < Register > set = dirtyMap . get ( s ) ; if ( set == null ) { set = new HashSet < Register > ( 3 ) ; dirtyMap . put ( s , set ) ; } set . add ( symb ) ; } 
public String nextCDATA ( ) throws JSONException { char c ; int i ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( end ( ) ) { throw syntaxError ( "Unclosed-CDATA" ) ; } sb . append ( c ) ; i = sb . length ( ) - 3 ; if ( i >= 0 && sb . charAt ( i ) == ']' && sb . charAt ( i + 1 ) == ']' && sb . charAt ( i + 2 ) == '>' ) { sb . setLength ( i ) ; return sb . toString ( ) ; } } } 
void parseInvalidTag ( ) throws IOException { while ( true ) { skipSpace ( ) ; switch ( ch ) { case '>' : case - 1 : ch = readCh ( ) ; return ; case '<' : return ; default : ch = readCh ( ) ; } } } 
public static String getTempDirectoryPath ( Context ctx ) { File cache = null ; if ( Environment . getExternalStorageState ( ) . equals ( Environment . MEDIA_MOUNTED ) ) { cache = new File ( Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) + "/Android/data/" + ctx . getPackageName ( ) + "/cache/" ) ; } else { cache = ctx . getCacheDir ( ) ; } if ( ! cache . exists ( ) ) { cache . mkdirs ( ) ; } return cache . getAbsolutePath ( ) ; } 
public String [ ] getOptions ( ) { Vector result ; String [ ] options ; int i ; result = new Vector ( ) ; options = super . getOptions ( ) ; for ( i = 0 ; i < options . length ; i ++ ) result . add ( options [ i ] ) ; result . add ( "-C" ) ; result . add ( getClassIndex ( ) ) ; return ( String [ ] ) result . toArray ( new String [ result . size ( ) ] ) ; } 
protected RealDistribution getKernel ( SummaryStatistics bStats ) { return new NormalDistribution ( randomData . getRandomGenerator ( ) , bStats . getMean ( ) , bStats . getStandardDeviation ( ) , NormalDistribution . DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; } 
public static void setLogStream ( java . io . PrintStream out ) { SecurityManager sec = System . getSecurityManager ( ) ; if ( sec != null ) { sec . checkPermission ( SET_LOG_PERMISSION ) ; } logStream = out ; if ( out != null ) logWriter = new java . io . PrintWriter ( out ) ; else logWriter = null ; } 
public void onSyncCanceled ( Thread thread ) { thread . interrupt ( ) ; } 
public void compileStmnt ( String src ) throws CompileError { Parser p = new Parser ( new Lex ( src ) ) ; SymbolTable stb = new SymbolTable ( stable ) ; while ( p . hasMore ( ) ) { Stmnt s = p . parseStatement ( stb ) ; if ( s != null ) s . accept ( gen ) ; } } 
private boolean isSipServletDirectory ( File dir ) { if ( dir . isDirectory ( ) ) { File sipXmlFile = new File ( dir . getAbsoluteFile ( ) , SipContext . APPLICATION_SIP_XML ) ; if ( sipXmlFile . exists ( ) ) { return true ; } if ( SipApplicationAnnotationUtils . findPackageInfoinDirectory ( dir ) ) return true ; } return false ; } 
public List < String > getXPath ( ) { if ( xPath == null ) { xPath = new ArrayList < String > ( ) ; } return this . xPath ; } 
private int getDefaultWidth ( ) { String extras = PrefUtil . getAPIPreferenceStore ( ) . getString ( IWorkbenchPreferenceConstants . PERSPECTIVE_BAR_EXTRAS ) ; StringTokenizer tok = new StringTokenizer ( extras , ",-" ) ; int numExtras = tok . countTokens ( ) ; int numPersps = Math . max ( numExtras , 1 ) ; return Math . max ( MIN_DEFAULT_WIDTH , MIN_WIDTH + ( numPersps * ITEM_WIDTH ) ) ; } 
public Iterator getVersions ( ) { return versionList . iterator ( ) ; } 
public void setDecimalSeparatorAlwaysShown ( boolean value ) { ndf . setDecimalSeparatorAlwaysShown ( value ) ; } 
public String nextCDATA ( ) throws JSONException { char c ; int i ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( c == 0 ) { throw syntaxError ( "Unclosed-CDATA." ) ; } sb . append ( c ) ; i = sb . length ( ) - 3 ; if ( i >= 0 && sb . charAt ( i ) == ']' && sb . charAt ( i + 1 ) == ']' && sb . charAt ( i + 2 ) == '>' ) { sb . setLength ( i ) ; return sb . toString ( ) ; } } } 
public void setTextLimit ( int limit ) { checkWidget ( ) ; if ( limit == 0 ) error ( SWT . ERROR_CANNOT_BE_ZERO ) ; if ( limit < 0 ) limit = LIMIT ; limit = Math . min ( limit , LIMIT ) ; if ( ( style & SWT . PASSWORD ) != 0 ) { OS . PasswordBox_MaxLength ( handle , limit ) ; } else { OS . TextBox_MaxLength ( handle , limit ) ; } } 
public ShareDialogBuilder setFriends ( List < String > friends ) { this . friends = new ArrayList < String > ( friends ) ; return this ; } 
public static < K , V > ImmutableListMultimap < K , V > of ( K k1 , V v1 ) { ImmutableListMultimap . Builder < K , V > builder = ImmutableListMultimap . builder ( ) ; builder . put ( k1 , v1 ) ; return builder . build ( ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public boolean tryLock ( long timeout , TimeUnit unit ) throws InterruptedException { return sync . tryAcquireNanos ( 1 , unit . toNanos ( timeout ) ) ; } 
protected void registerHandlers ( Map < String , Object > urlMap ) throws BeansException { if ( urlMap . isEmpty ( ) ) { logger . warn ( "Neither-'urlMap'-nor-'mappings'-set-on-SimpleUrlHandlerMapping" ) ; } else { for ( Map . Entry < String , Object > entry : urlMap . entrySet ( ) ) { String url = entry . getKey ( ) ; Object handler = entry . getValue ( ) ; if ( ! url . startsWith ( "/" ) ) { url = "/" + url ; } if ( handler instanceof String ) { handler = ( ( String ) handler ) . trim ( ) ; } registerHandler ( url , handler ) ; } } } 
private float getUnigramSmear ( Node node ) { float prob ; if ( wantUnigramSmear ) { prob = node . getUnigramProbability ( ) * unigramSmearWeight ; } else { prob = logOne ; } return prob ; } 
public double getPercentage ( ) { DecimalFormat decimalFormat = new DecimalFormat ( "###.##" ) ; double percentage = getScore ( ) ; percentage /= getMaxScore ( ) ; percentage *= 100 ; return Double . parseDouble ( decimalFormat . format ( percentage ) ) ; } 
public boolean verify ( String message , String signedMessage , PublicKey key ) throws InvalidKeyException { try { Signature signature = Signature . getInstance ( "SHA1withRSA" ) ; signature . initVerify ( key ) ; signature . update ( message . getBytes ( ) ) ; return signature . verify ( base64Decode ( signedMessage ) ) ; } catch ( NoSuchAlgorithmException e ) { return false ; } catch ( SignatureException e ) { return false ; } } 
public void setARGB ( int a , int r , int g , int b ) { setColor ( ( a << 24 ) | ( r << 16 ) | ( g << 8 ) | b ) ; } 
public static Mapping identity ( ) { return new Identity ( ) ; } 
public VolatileImage createCompatibleVolatileImage ( int width , int height ) { VolatileImage vi = null ; try { vi = createCompatibleVolatileImage ( width , height , null , Transparency . OPAQUE ) ; } catch ( AWTException e ) { assert false ; } return vi ; } 
public List < PromotionOrderEntryConsumedDTO > getPromotionOrderEntryConsumed ( ) { if ( promotionOrderEntryConsumed == null ) { promotionOrderEntryConsumed = new ArrayList < PromotionOrderEntryConsumedDTO > ( ) ; } return this . promotionOrderEntryConsumed ; } 
public long getTimeInMillis ( final Date startInstant ) { Calendar cal = new GregorianCalendar ( ) ; cal . setTime ( startInstant ) ; this . addTo ( cal ) ; return getCalendarTimeInMillis ( cal ) - startInstant . getTime ( ) ; } 
public String encode ( ) { StringBuilder builder = new StringBuilder ( ) ; encode ( builder ) ; return builder . toString ( ) ; } 
public static void main ( String [ ] args ) { Tool t = new TestTool ( ) ; int result = t . run ( args ) ; if ( result != 0 ) System . exit ( result ) ; } 
public XMLString toLowerCase ( Locale locale ) { return new XString ( str ( ) . toLowerCase ( locale ) ) ; } 
@ Override public boolean equals ( Object o ) { return ( o instanceof Integer ) && ( ( ( Integer ) o ) . value == value ) ; } 
public String getLinkName ( ) { return linkName . toString ( ) ; } 
private static ErrorPage findErrorPage ( Context context , Throwable exception ) { if ( exception == null ) return ( null ) ; Class < ? > clazz = exception . getClass ( ) ; String name = clazz . getName ( ) ; while ( ! Object . class . equals ( clazz ) ) { ErrorPage errorPage = context . findErrorPage ( name ) ; if ( errorPage != null ) return ( errorPage ) ; clazz = clazz . getSuperclass ( ) ; if ( clazz == null ) break ; name = clazz . getName ( ) ; } return ( null ) ; } 
public String getUndoPresentationName ( ) { return UIManager . getString ( "AbstractDocument.undoText" ) + "-" + getPresentationName ( ) ; } 
public static char readChar ( ) { scanner . useDelimiter ( EMPTY_PATTERN ) ; String ch = scanner . next ( ) ; assert ( ch . length ( ) == 1 ) : "Internal-(Std)In.readChar()-error!" + "-Please-contact-the-authors." ; scanner . useDelimiter ( WHITESPACE_PATTERN ) ; return ch . charAt ( 0 ) ; } 
public String asString ( ) throws WeiboException { if ( null == responseAsString ) { BufferedReader br ; try { InputStream stream = asStream ( ) ; if ( null == stream ) { return null ; } br = new BufferedReader ( new InputStreamReader ( stream , "UTF-8" ) ) ; StringBuffer buf = new StringBuffer ( ) ; String line ; while ( null != ( line = br . readLine ( ) ) ) { buf . append ( line ) . append ( "-" ) ; } this . responseAsString = buf . toString ( ) ; if ( Configuration . isDalvik ( ) ) { this . responseAsString = unescape ( responseAsString ) ; } log ( responseAsString ) ; stream . close ( ) ; con . disconnect ( ) ; streamConsumed = true ; } catch ( NullPointerException npe ) { throw new WeiboException ( npe . getMessage ( ) , npe ) ; } catch ( IOException ioe ) { throw new WeiboException ( ioe . getMessage ( ) , ioe ) ; } } return responseAsString ; } 
public static Object wrap ( Object object ) { try { if ( object == null ) { return NULL ; } if ( object instanceof JSONObject || object instanceof JSONArray || NULL . equals ( object ) || object instanceof JSONString || object instanceof Byte || object instanceof Character || object instanceof Short || object instanceof Integer || object instanceof Long || object instanceof Boolean || object instanceof Float || object instanceof Double || object instanceof String ) { return object ; } if ( object instanceof Collection ) { return new JSONArray ( ( Collection < Object > ) object ) ; } if ( object . getClass ( ) . isArray ( ) ) { return new JSONArray ( object ) ; } if ( object instanceof Map ) { return new JSONObject ( ( Map < String , Object > ) object ) ; } Package objectPackage = object . getClass ( ) . getPackage ( ) ; String objectPackageName = objectPackage != null ? objectPackage . getName ( ) : "" ; if ( objectPackageName . startsWith ( "java." ) || objectPackageName . startsWith ( "javax." ) || object . getClass ( ) . getClassLoader ( ) == null ) { return object . toString ( ) ; } return new JSONObject ( object ) ; } catch ( Exception exception ) { return null ; } } 
public static String [ ] split ( String str , char escapeChar , char separator ) { if ( str == null ) { return null ; } ArrayList < String > strList = new ArrayList < String > ( ) ; StringBuilder split = new StringBuilder ( ) ; int index = 0 ; while ( ( index = findNext ( str , separator , escapeChar , index , split ) ) >= 0 ) { ++ index ; strList . add ( split . toString ( ) ) ; split . setLength ( 0 ) ; } strList . add ( split . toString ( ) ) ; int last = strList . size ( ) ; while ( -- last >= 0 && "" . equals ( strList . get ( last ) ) ) { strList . remove ( last ) ; } return strList . toArray ( new String [ strList . size ( ) ] ) ; } 
public synchronized void abortRemove ( ) { removeEnabled = false ; if ( remover != null ) { remover . interrupt ( ) ; } } 
public String getBaseTypeName ( ) throws SQLException { return elementType . getNameString ( ) ; } 
public Function getFunc ( String key ) { return funcs . get ( key ) ; } 
public Object createObject ( ) { final float width = getFloatParameter ( "value" ) ; if ( width > 0 ) { return new BasicStroke ( width ) ; } Float realWidth = ( Float ) getParameter ( "width" ) ; Float [ ] dashes = ( Float [ ] ) getParameter ( "dashes" ) ; if ( realWidth == null || dashes == null ) { return null ; } float [ ] dashesPrimitive = new float [ dashes . length ] ; for ( int i = 0 ; i < dashes . length ; i ++ ) { Float dash = dashes [ i ] ; dashesPrimitive [ i ] = dash . floatValue ( ) ; } return new BasicStroke ( realWidth . floatValue ( ) , BasicStroke . CAP_SQUARE , BasicStroke . JOIN_MITER , 10.0f , dashesPrimitive , 0.0f ) ; } 
public static String wildcardAsRegex ( String wildcard ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < wildcard . length ( ) ; i ++ ) { final char c = wildcard . charAt ( i ) ; switch ( c ) { case '*' : sb . append ( ".*?" ) ; break ; case '?' : sb . append ( "." ) ; break ; case '$' : case '(' : case ')' : case '+' : case '-' : case '.' : case '[' : case '|' : case ']' : case '^' : case '{' : case '|' : case '}' : sb . append ( '|' ) ; sb . append ( c ) ; break ; default : sb . append ( c ) ; break ; } } return sb . toString ( ) ; } 
public boolean isViewUnder ( View view , int x , int y ) { if ( view == null ) { return false ; } return x >= view . getLeft ( ) && x < view . getRight ( ) && y >= view . getTop ( ) && y < view . getBottom ( ) ; } 
private void scanDirectory ( File directory , String pathPrefix ) throws DPUException { final Path directoryPath = directory . toPath ( ) ; final Iterator < File > iter = FileUtils . iterateFiles ( directory , null , true ) ; while ( iter . hasNext ( ) ) { final File newFile = iter . next ( ) ; final String relativePath = directoryPath . relativize ( newFile . toPath ( ) ) . toString ( ) ; final String newFileRelativePath ; if ( config . isNotPrefixed ( ) ) { newFileRelativePath = relativePath ; } else { newFileRelativePath = pathPrefix + "/" + relativePath ; } faultTolerance . execute ( new FaultTolerance . Action ( ) { @ Override public void action ( ) throws Exception { FilesDataUnitUtils . addFile ( outFilesData , newFile , newFileRelativePath ) ; } } , "unzipper7zip.error.file.add" ) ; } } 
public static String encodeFromFile ( String filename ) { String encodedData = null ; Base64 . InputStream bis = null ; try { java . io . File file = new java . io . File ( filename ) ; byte [ ] buffer = new byte [ ( int ) ( file . length ( ) * 1.4 ) ] ; int length = 0 ; int numBytes = 0 ; bis = new Base64 . InputStream ( new java . io . BufferedInputStream ( new java . io . FileInputStream ( file ) ) , Base64 . ENCODE ) ; while ( ( numBytes = bis . read ( buffer , length , 4096 ) ) >= 0 ) length += numBytes ; encodedData = new String ( buffer , 0 , length , Base64 . PREFERRED_ENCODING ) ; } catch ( java . io . IOException e ) { System . err . println ( "Error-encoding-from-file-" + filename ) ; } finally { try { bis . close ( ) ; } catch ( Exception e ) { } } return encodedData ; } 
@ Override @ ViewDebug . ExportedProperty ( category = "layout" ) public int getBaseline ( ) { if ( mBaselineAlignBottom ) { return getMeasuredHeight ( ) ; } else { return mBaseline ; } } 
private final void updateHead ( ) { Node < E > h , p , q ; restartFromHead : while ( ( h = head ) . item == null && ( p = h . prev ) != null ) { for ( ; ; ) { if ( ( q = p . prev ) == null || ( q = ( p = q ) . prev ) == null ) { if ( casHead ( h , p ) ) return ; else continue restartFromHead ; } else if ( h != head ) continue restartFromHead ; else p = q ; } } } 
public static JavaCompiler getSystemJavaCompiler ( ) { return instance ( ) . getSystemTool ( JavaCompiler . class , defaultJavaCompilerName ) ; } 
public static void usage ( String progName ) { System . err . println ( progName + ":-<implementation>-[fileName-to-output-search-results-to]" ) ; System . err . println ( "<implementation>-=-<linkedlist-|-sortedlinkedlist-|-bst|-hash-|-baltree>" ) ; System . exit ( 1 ) ; } 
public static String getDoubleQuotedValue ( final String value ) { return MessageFormat . format ( DOUBLE_QUOTED_STRING_FORMAT , value ) ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; javax . xml . namespace . NamespaceContext nsContext = xmlWriter . getNamespaceContext ( ) ; while ( true ) { java . lang . String uri = nsContext . getNamespaceURI ( prefix ) ; if ( uri == null || uri . length ( ) == 0 ) { break ; } prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; } 
protected Class < ? > resolveProxyClass ( String [ ] interfaceNames ) throws IOException , ClassNotFoundException { ClassLoader loader = ClassLoader . getSystemClassLoader ( ) ; Class < ? > [ ] interfaces = new Class < ? > [ interfaceNames . length ] ; for ( int i = 0 ; i < interfaceNames . length ; i ++ ) { interfaces [ i ] = Class . forName ( interfaceNames [ i ] , false , loader ) ; } try { return Proxy . getProxyClass ( loader , interfaces ) ; } catch ( IllegalArgumentException e ) { throw new ClassNotFoundException ( e . toString ( ) , e ) ; } } 
private void discardData ( ) throws ClassNotFoundException , IOException { primitiveData = emptyStream ; boolean resolve = mustResolve ; mustResolve = false ; do { byte tc = nextTC ( ) ; if ( tc == TC_ENDBLOCKDATA ) { mustResolve = resolve ; return ; } readContent ( tc ) ; } while ( true ) ; } 
public boolean isAlive ( ) { return getState ( ) . isAlive ( ) ; } 
public DragSourceContext getDragSourceContext ( ) { return ( DragSourceContext ) getSource ( ) ; } 
public List getExceptionSegments ( ) { return Collections . unmodifiableList ( this . exceptionSegments ) ; } 
private synchronized void compile ( Token tok ) { if ( this . operations != null ) return ; this . numberOfClosures = 0 ; this . operations = this . compile ( tok , null , false ) ; } 
public int getTextWidths ( String text , int start , int end , float [ ] widths ) { if ( text == null ) { throw new IllegalArgumentException ( "text-cannot-be-null" ) ; } if ( ( start | end | ( end - start ) | ( text . length ( ) - end ) ) < 0 ) { throw new IndexOutOfBoundsException ( ) ; } if ( end - start > widths . length ) { throw new ArrayIndexOutOfBoundsException ( ) ; } if ( text . length ( ) == 0 || start == end ) { return 0 ; } if ( ! mHasCompatScaling ) { return native_getTextWidths ( mNativePaint , text , start , end , mBidiFlags , widths ) ; } final float oldSize = getTextSize ( ) ; setTextSize ( oldSize * mCompatScaling ) ; int res = native_getTextWidths ( mNativePaint , text , start , end , mBidiFlags , widths ) ; setTextSize ( oldSize ) ; for ( int i = 0 ; i < res ; i ++ ) { widths [ i ] *= mInvCompatScaling ; } return res ; } 
@ Override public Map < Edge , Set < Property >> getEdges ( ) { if ( this . edgesDB == null ) { return null ; } Map < Edge , Set < Property >> edgeMap = new HashMap < Edge , Set < Property >> ( ) ; Set < Property > props ; for ( Map . Entry < Edge , Set < Property >> edgeEntry : edgesDB . entrySet ( ) ) { props = new HashSet < Property > ( edgeEntry . getValue ( ) ) ; edgeMap . put ( edgeEntry . getKey ( ) , props ) ; } return edgeMap ; } 
public static SecretKey generateKey ( ) { return defaultExecutor . generateKey ( ) ; } 
public final void addElement ( int value ) { if ( ( m_firstFree + 1 ) >= m_mapSize ) { m_mapSize += m_blocksize ; int newMap [ ] = new int [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } m_map [ m_firstFree ] = value ; m_firstFree ++ ; } 
public Builder setTitle ( int title ) { this . title = ( String ) context . getText ( title ) ; return this ; } 
@ Deprecated public double getCumPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; } 
public static Object stringToValue ( String string ) { if ( string . equals ( "" ) ) { return string ; } if ( string . equalsIgnoreCase ( "true" ) ) { return Boolean . TRUE ; } if ( string . equalsIgnoreCase ( "false" ) ) { return Boolean . FALSE ; } if ( string . equalsIgnoreCase ( "null" ) ) { return JSONObject . NULL ; } if ( string . equals ( "0" ) ) { return new Integer ( 0 ) ; } try { char initial = string . charAt ( 0 ) ; boolean negative = false ; if ( initial == '-' ) { initial = string . charAt ( 1 ) ; negative = true ; } if ( initial == '0' && string . charAt ( negative ? 2 : 1 ) == '0' ) { return string ; } if ( ( initial >= '0' && initial <= '9' ) ) { if ( string . indexOf ( '.' ) >= 0 ) { return Double . valueOf ( string ) ; } else if ( string . indexOf ( 'e' ) < 0 && string . indexOf ( 'E' ) < 0 ) { Long myLong = new Long ( string ) ; if ( myLong . longValue ( ) == myLong . intValue ( ) ) { return new Integer ( myLong . intValue ( ) ) ; } else { return myLong ; } } } } catch ( Exception ignore ) { } return string ; } 
private boolean isCopyOnItself ( String src , String dest ) { return dest . equals ( src ) || dest . startsWith ( src + File . separator ) ; } 
public Messages ( String id ) throws IOException { super ( id ) ; defaultMessages = load ( "messages.properties" ) ; setLocale ( Locale . getDefault ( ) ) ; } 
public int getAttributeCount ( ) { return attributes . getAttributeCount ( ) ; } 
private String getPacketHeader ( final long timeStamp ) { if ( header ) { StringBuffer buf = new StringBuffer ( dateFormat . format ( new Date ( timeStamp ) ) ) ; if ( buf . charAt ( 4 ) == '0' ) { buf . setCharAt ( 4 , '-' ) ; } buf . append ( getLocalHostname ( ) ) ; buf . append ( '-' ) ; return buf . toString ( ) ; } return "" ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public float getWidth ( int labelID ) { return mLabels . get ( labelID ) . width ; } 
public String getAccessibleName ( ) { if ( accessibleName != null ) { return accessibleName ; } else { if ( getTitle ( ) == null ) { return super . getAccessibleName ( ) ; } else { return getTitle ( ) ; } } } 
public void setTagInternal ( int key , Object tag ) { if ( ( key >>> 24 ) != 0x1 ) { throw new IllegalArgumentException ( "The-key-must-be-a-framework-specific-" + "resource-id." ) ; } setKeyedTag ( key , tag ) ; } 
public final void addCategory ( String category ) { if ( mCategories == null ) mCategories = new ArrayList < String > ( ) ; if ( ! mCategories . contains ( category ) ) { mCategories . add ( category . intern ( ) ) ; } } 
public List < Object > getAny ( ) { if ( any == null ) { any = new ArrayList < Object > ( ) ; } return this . any ; } 
public com . google . protobuf . ByteString getNameBytes ( ) { java . lang . Object ref = name_ ; if ( ref instanceof java . lang . String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; name_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public static String getToYear ( ) { return PROPERTIES . getProperty ( "ToYear" , "" + Calendar . getInstance ( ) . get ( Calendar . YEAR ) ) ; } 
public SocketHandler ( String host , int port ) throws IOException { super ( DEFAULT_LEVEL , null , DEFAULT_FORMATTER , null ) ; initSocket ( host , String . valueOf ( port ) ) ; } 
public final void addToZipArchiveAndKeepLast ( File f , File fNew ) throws IOException { int count ; byte data [ ] = new byte [ BUFFER ] ; BufferedInputStream origin = new BufferedInputStream ( new FileInputStream ( f ) , BUFFER ) ; out . putNextEntry ( new ZipEntry ( f . getName ( ) ) ) ; while ( ( count = origin . read ( data , 0 , BUFFER ) ) != - 1 ) { out . write ( data , 0 , count ) ; } origin . close ( ) ; f . renameTo ( fNew ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
private static String guessMimeTypeFromUri ( final String uri ) { final int questionmark = uri . indexOf ( '?' , 1 ) ; final int end = ( questionmark > 0 ? questionmark : uri . length ( ) ) - 1 ; if ( end < 5 ) { return null ; } final char a = uri . charAt ( end - 3 ) ; final char b = uri . charAt ( end - 2 ) ; final char c = uri . charAt ( end - 1 ) ; switch ( uri . charAt ( end ) ) { case 'g' : return a == '.' && b == 'p' && c == 'n' ? "image/png" : null ; case 'l' : return a == 'h' && b == 't' && c == 'm' ? HTML_CONTENT_TYPE : null ; case 's' : if ( a == '.' && b == 'c' && c == 's' ) { return "text/css" ; } else if ( b == '.' && c == 'j' ) { return "text/javascript" ; } else { break ; } case 'f' : return a == '.' && b == 'g' && c == 'i' ? "image/gif" : null ; case 'o' : return a == '.' && b == 'i' && c == 'c' ? "image/x-icon" : null ; } return null ; } 
private boolean isExhausted ( ) { return runnableTasks . isEmpty ( ) && runnableActions . isEmpty ( ) && runningTasks == 0 ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
protected int getNumberOfNodes ( ) { return m_nodes . size ( ) ; } 
public int getResult ( ) { checkDone ( ) ; return result ; } 
public void reset ( long now , int numBalls ) { mRegions . clear ( ) ; ArrayList < Ball > balls = new ArrayList < Ball > ( numBalls ) ; for ( int i = 0 ; i < numBalls ; i ++ ) { Ball ball = new Ball . Builder ( ) . setNow ( now ) . setPixelsPerSecond ( mBallSpeed ) . setAngle ( Math . random ( ) * 2 * Math . PI ) . setX ( ( float ) Math . random ( ) * ( mMaxX - mMinX ) + mMinX ) . setY ( ( float ) Math . random ( ) * ( mMaxY - mMinY ) + mMinY ) . setRadiusPixels ( mBallRadius ) . create ( ) ; balls . add ( ball ) ; } BallRegion region = new BallRegion ( now , mMinX , mMaxX , mMinY , mMaxY , balls ) ; region . setCallBack ( mCallBack ) ; mRegions . add ( region ) ; } 
public static Controller getController ( int index ) { return controllers . get ( index ) ; } 
public void loadLibrary ( String libname ) { loadLibrary0 ( System . getCallerClass ( ) , libname ) ; } 
public static String printBytes ( byte [ ] bytes ) { if ( bytes == null ) { return "" ; } BigInteger bi = new BigInteger ( 1 , bytes ) ; return bi . toString ( SystemConfiguration . DEBUG_RADIX ) ; } 
public static final boolean isOrphanTag ( String tagname ) { return _orphans . contains ( tagname . toLowerCase ( java . util . Locale . ENGLISH ) ) ; } 
public boolean canReplaceStreamMetadata ( ) throws IOException { return checkOutputReturnFalse ( ) ; } 
private List < String > callRadiusSearch ( final List < Double > location , final double radius ) { final List < String > output = new ArrayList < String > ( ) ; if ( radius < 0 ) { output . add ( "Please-input-a-non-negative-number-for-the-search-radius." ) ; } else { output . addAll ( idsOfNodes ( tree . neighborsInRange ( location , radius ) ) ) ; } return output ; } 
public int getAccessibleActionCount ( ) { Action [ ] actions = JTextComponent . this . getActions ( ) ; return actions . length ; } 
private int calculateTop ( View child , boolean duringLayout ) { int myHeight = duringLayout ? mMeasuredHeight : getHeight ( ) ; int childHeight = duringLayout ? child . getMeasuredHeight ( ) : child . getHeight ( ) ; int childTop = 0 ; switch ( mGravity ) { case Gravity . TOP : childTop = mSpinnerPadding . top ; break ; case Gravity . CENTER_VERTICAL : int availableSpace = myHeight - mSpinnerPadding . bottom - mSpinnerPadding . top - childHeight ; childTop = mSpinnerPadding . top + ( availableSpace / 2 ) ; break ; case Gravity . BOTTOM : childTop = myHeight - mSpinnerPadding . bottom - childHeight ; break ; } return childTop ; } 
private int nextToken ( char idChar ) throws IOException { readWS = false ; int nextChar = readWS ( ) ; switch ( nextChar ) { case '|'' : readTill ( '|'' ) ; if ( tokenBufferLength > 0 ) { tokenBufferLength -- ; } return IDENTIFIER ; case '"' : readTill ( '"' ) ; if ( tokenBufferLength > 0 ) { tokenBufferLength -- ; } return IDENTIFIER ; case '[' : return BRACKET_OPEN ; case ']' : return BRACKET_CLOSE ; case '{' : return BRACE_OPEN ; case '}' : return BRACE_CLOSE ; case '(' : return PAREN_OPEN ; case ')' : return PAREN_CLOSE ; case - 1 : return END ; default : pushChar ( nextChar ) ; getIdentifier ( idChar ) ; return IDENTIFIER ; } } 
public int getBComponent ( int x , int y ) { return ( getColorArray ( ) [ ( ( y * width + x ) ) ] & 0x000000FF ) ; } 
public Reader getReaderForText ( ) throws IOException { if ( printData instanceof Reader ) { return ( Reader ) printData ; } synchronized ( this ) { if ( reader != null ) { return reader ; } if ( printData instanceof char [ ] ) { reader = new CharArrayReader ( ( char [ ] ) printData ) ; } else if ( printData instanceof String ) { reader = new StringReader ( ( String ) printData ) ; } } return reader ; } 
protected void resetValues ( ) { synchronized ( values ) { values . removeAll ( new ArrayList < String > ( values ) ) ; } } 
public final void update ( ByteBuffer input ) { engineUpdate ( input ) ; } 
public void sort ( ) { sorted = true ; int [ ] lastViewToModel = getViewToModelAsInts ( viewToModel ) ; updateUseToString ( ) ; if ( isUnsorted ( ) ) { cachedSortKeys = new SortKey [ 0 ] ; if ( getRowFilter ( ) == null ) { if ( viewToModel != null ) { viewToModel = null ; modelToView = null ; } else { return ; } } else { initializeFilteredMapping ( ) ; } } else { cacheSortKeys ( getSortKeys ( ) ) ; if ( getRowFilter ( ) != null ) { initializeFilteredMapping ( ) ; } else { createModelToView ( getModelWrapper ( ) . getRowCount ( ) ) ; createViewToModel ( getModelWrapper ( ) . getRowCount ( ) ) ; } Arrays . sort ( viewToModel ) ; setModelToViewFromViewToModel ( false ) ; } fireRowSorterChanged ( lastViewToModel ) ; } 
public static void sort ( int [ ] a ) { qsort ( a , 0 , a . length ) ; } 
public static String processDiff ( diff_match_patch . Diff diff , LinkedList < Integer > lineNums , LinkedList < String > lines , String line , int i , String begSpan , boolean forceOutputLine ) { String endSpan = "</span>" ; String br = "&nbsp;" ; if ( diff . text . endsWith ( "-" ) || forceOutputLine ) { lineNums . add ( i ) ; line += begSpan + diff . text . replace ( "-" , "&nbsp;&nbsp;" ) + endSpan + br ; lines . add ( line ) ; line = "" ; } else { line += begSpan + diff . text . replace ( "-" , "&nbsp;&nbsp;" ) + endSpan ; } return line ; } 
public static String commify ( int integer ) { return String . valueOf ( integer ) . replaceAll ( "(|d)(?=(|d{3})+$)" , "$1," ) ; } 
public synchronized boolean remove ( String key ) throws IOException { checkNotClosed ( ) ; validateKey ( key ) ; Entry entry = lruEntries . get ( key ) ; if ( entry == null || entry . currentEditor != null ) { return false ; } for ( int i = 0 ; i < valueCount ; i ++ ) { File file = entry . getCleanFile ( i ) ; if ( ! file . delete ( ) ) { throw new IOException ( "failed-to-delete-" + file ) ; } size -= entry . lengths [ i ] ; entry . lengths [ i ] = 0 ; } redundantOpCount ++ ; journalWriter . append ( REMOVE + '-' + key + '|n' ) ; lruEntries . remove ( key ) ; if ( journalRebuildRequired ( ) ) { executorService . submit ( cleanupCallable ) ; } return true ; } 
public void printStackTrace ( ) { super . printStackTrace ( ) ; if ( cause != null ) { System . err . println ( "BaseException-Caused-by-:" ) ; cause . printStackTrace ( ) ; if ( log . isErrorEnabled ( ) ) { log . error ( "BaseException-Caused-by-:" + cause . getMessage ( ) ) ; } } } 
protected AbstractHashedMap ( Map < ? extends K , ? extends V > map ) { this ( Math . max ( 2 * map . size ( ) , DEFAULT_CAPACITY ) , DEFAULT_LOAD_FACTOR ) ; putAll ( map ) ; } 
static String add_escapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '|b' : retval . append ( "|b" ) ; continue ; case '|t' : retval . append ( "|t" ) ; continue ; case '|n' : retval . append ( "|n" ) ; continue ; case '|f' : retval . append ( "|f" ) ; continue ; case '|r' : retval . append ( "|r" ) ; continue ; case '|"' : retval . append ( "|"" ) ; continue ; case '|'' : retval . append ( "|'" ) ; continue ; case '|' : retval . append ( "||" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 || ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "|u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } 
public int getTransparency ( ) { return ( bufImg . getColorModel ( ) ) . getTransparency ( ) ; } 
public String getEncoding ( ) { return m_handler . getEncoding ( ) ; } 
public int getRowCount ( ) { return node . getAttributes ( ) . getLength ( ) ; } 
public static ASN1ObjectIdentifier getOID ( String name ) { return ( ASN1ObjectIdentifier ) objIds . get ( Strings . toLowerCase ( name ) ) ; } 
public static boolean propertyFileIsWritable ( ) { if ( manager == null ) { synchronized ( managerLock ) { if ( manager == null ) { manager = new PropertyManager ( propsName ) ; } } } return manager . propFileIsWritable ( ) ; } 
private void loadSelectData ( AttributeSet attr , StringBuilder buffer ) { String name = ( String ) attr . getAttribute ( HTML . Attribute . NAME ) ; if ( name == null ) { return ; } Object m = attr . getAttribute ( StyleConstants . ModelAttribute ) ; if ( m instanceof OptionListModel ) { OptionListModel < Option > model = ( OptionListModel < Option > ) m ; for ( int i = 0 ; i < model . getSize ( ) ; i ++ ) { if ( model . isSelectedIndex ( i ) ) { Option option = model . getElementAt ( i ) ; appendBuffer ( buffer , name , option . getValue ( ) ) ; } } } else if ( m instanceof ComboBoxModel ) { ComboBoxModel model = ( ComboBoxModel ) m ; Option option = ( Option ) model . getSelectedItem ( ) ; if ( option != null ) { appendBuffer ( buffer , name , option . getValue ( ) ) ; } } } 
public int getStolenCount ( ) { return stolen_ . size ( ) ; } 
public String eatId ( ) { if ( ! matchId ( ) ) throw new BadSyntaxException ( ) ; String s = tok . sval ; nextToken ( ) ; return s ; } 
@ Override public int executeUpdate ( String sql , int autoGeneratedKeys ) throws SQLException { return statement . executeUpdate ( sql , autoGeneratedKeys ) ; } 
private void resetNextInetSocketAddress ( Proxy proxy ) throws UnknownHostException { socketAddresses = null ; String socketHost ; if ( proxy . type ( ) == Proxy . Type . DIRECT ) { socketHost = uri . getHost ( ) ; socketPort = getEffectivePort ( uri ) ; } else { SocketAddress proxyAddress = proxy . address ( ) ; if ( ! ( proxyAddress instanceof InetSocketAddress ) ) { throw new IllegalArgumentException ( "Proxy.address()-is-not-an-" + "InetSocketAddress:-" + proxyAddress . getClass ( ) ) ; } InetSocketAddress proxySocketAddress = ( InetSocketAddress ) proxyAddress ; socketHost = proxySocketAddress . getHostName ( ) ; socketPort = proxySocketAddress . getPort ( ) ; } socketAddresses = dns . getAllByName ( socketHost ) ; nextSocketAddressIndex = 0 ; } 
public void setOtherConfig ( Connection c , Map < String , String > otherConfig ) throws BadServerResponse , XenAPIException , XmlRpcException { String method_call = "host_crashdump.set_other_config" ; String session = c . getSessionReference ( ) ; Object [ ] method_params = { Marshalling . toXMLRPC ( session ) , Marshalling . toXMLRPC ( this . ref ) , Marshalling . toXMLRPC ( otherConfig ) } ; Map response = c . dispatch ( method_call , method_params ) ; return ; } 
public void messageLogged ( BuildEvent event ) { int priority = event . getPriority ( ) ; if ( priority <= msgOutputLevel ) { StringBuffer message = new StringBuffer ( ) ; if ( event . getTask ( ) != null && ! emacsMode ) { String name = event . getTask ( ) . getTaskName ( ) ; String label = "[" + name + "]-" ; int size = LEFT_COLUMN_SIZE - label . length ( ) ; StringBuffer tmp = new StringBuffer ( ) ; for ( int i = 0 ; i < size ; i ++ ) { tmp . append ( "-" ) ; } tmp . append ( label ) ; label = tmp . toString ( ) ; try { BufferedReader r = new BufferedReader ( new StringReader ( event . getMessage ( ) ) ) ; String line = r . readLine ( ) ; boolean first = true ; while ( line != null ) { if ( ! first ) { message . append ( StringUtils . LINE_SEP ) ; } first = false ; message . append ( label ) . append ( line ) ; line = r . readLine ( ) ; } } catch ( IOException e ) { message . append ( label ) . append ( event . getMessage ( ) ) ; } } else { message . append ( event . getMessage ( ) ) ; } String msg = message . toString ( ) ; if ( priority != Project . MSG_ERR ) { printMessage ( msg , out , priority ) ; } else { printMessage ( msg , err , priority ) ; } log ( msg ) ; } } 
public static void write ( StringBuffer data , OutputStream output , String encoding ) throws IOException { if ( data != null ) { if ( encoding == null ) { write ( data , output ) ; } else { output . write ( data . toString ( ) . getBytes ( encoding ) ) ; } } } 
public static void print ( short x ) { out . print ( x ) ; out . flush ( ) ; } 
public static Notification [ ] getNoticesForService ( int serviceId , boolean includeAcknowledged , ServletContext servletContext ) throws SQLException { Notification [ ] notices = null ; Connection conn = Vault . getDbConnection ( ) ; try { StringBuffer select = new StringBuffer ( "SELECT-*-FROM-NOTIFICATION-WHERE-SERVICEID=?" ) ; if ( ! includeAcknowledged ) { select . append ( "-AND-RESPONDTIME-IS-NULL" ) ; } select . append ( "-ORDER-BY-NOTIFIYID-DESC" ) ; PreparedStatement stmt = conn . prepareStatement ( select . toString ( ) ) ; stmt . setInt ( 1 , serviceId ) ; ResultSet rs = stmt . executeQuery ( ) ; notices = rs2Notices ( rs , servletContext ) ; rs . close ( ) ; stmt . close ( ) ; } finally { Vault . releaseDbConnection ( conn ) ; } return notices ; } 
void showPopupMenu ( JComponent source , int x , int y , Class < ? > clazz , boolean expandEnabled ) { log . trace ( "Go-ahead-and-show-popup!-as-x=" + x + ",-y=" + y + ",-class=" + clazz + ",-expandEnabled=" + expandEnabled ) ; JPopupMenu popupMenu = initPopupMenu ( expandEnabled , clazz ) ; log . trace ( "Popup-menu-=-" + popupMenu . toString ( ) ) ; popupMenu . show ( source , x , y ) ; } 
public static String [ ] getSelectedLines ( JTextComponent target ) { String [ ] lines = null ; try { PlainDocument document = ( PlainDocument ) target . getDocument ( ) ; int start = document . getParagraphElement ( target . getSelectionStart ( ) ) . getStartOffset ( ) ; int end ; if ( target . getSelectionStart ( ) == target . getSelectionEnd ( ) ) { end = document . getParagraphElement ( target . getSelectionEnd ( ) ) . getEndOffset ( ) ; } else { end = document . getParagraphElement ( target . getSelectionEnd ( ) - 1 ) . getEndOffset ( ) ; } target . select ( start , end ) ; lines = document . getText ( start , end - start ) . split ( "-" ) ; target . select ( start , end ) ; } catch ( BadLocationException e ) { LOG . error ( e . getMessage ( ) , e ) ; lines = EMPTY_STRING_ARRAY ; } return lines ; } 
public void addListener ( AccuAdapterListener aListener ) { mListListener . add ( aListener ) ; } 
public List < WSMenuEntry > getMenuEntries ( ) { if ( menuEntries == null ) { menuEntries = new ArrayList < WSMenuEntry > ( ) ; } return this . menuEntries ; } 
public static void print ( int x ) { out . print ( x ) ; out . flush ( ) ; } 
public List < DocumentType > getDocument ( ) { if ( document == null ) { document = new ArrayList < DocumentType > ( ) ; } return this . document ; } 
public String getKey ( ) { return new Integer ( getMessageId ( ) ) . toString ( ) ; } 
public Cursor getSuggestions ( SearchableInfo searchable , String query , int limit ) { if ( searchable == null ) { return null ; } String authority = searchable . getSuggestAuthority ( ) ; if ( authority == null ) { return null ; } Uri . Builder uriBuilder = new Uri . Builder ( ) . scheme ( ContentResolver . SCHEME_CONTENT ) . authority ( authority ) . query ( "" ) . fragment ( "" ) ; final String contentPath = searchable . getSuggestPath ( ) ; if ( contentPath != null ) { uriBuilder . appendEncodedPath ( contentPath ) ; } uriBuilder . appendPath ( SearchManager . SUGGEST_URI_PATH_QUERY ) ; String selection = searchable . getSuggestSelection ( ) ; String [ ] selArgs = null ; if ( selection != null ) { selArgs = new String [ ] { query } ; } else { uriBuilder . appendPath ( query ) ; } if ( limit > 0 ) { uriBuilder . appendQueryParameter ( SUGGEST_PARAMETER_LIMIT , String . valueOf ( limit ) ) ; } Uri uri = uriBuilder . build ( ) ; return mContext . getContentResolver ( ) . query ( uri , null , selection , selArgs , null ) ; } 
private int appendAffix ( StringBuffer buf , boolean isNegative , boolean isPrefix , boolean parseAttr ) { if ( currencyChoice != null ) { String affixPat = null ; if ( isPrefix ) { affixPat = isNegative ? negPrefixPattern : posPrefixPattern ; } else { affixPat = isNegative ? negSuffixPattern : posSuffixPattern ; } StringBuffer affixBuf = new StringBuffer ( ) ; expandAffix ( affixPat , null , affixBuf , true ) ; buf . append ( affixBuf ) ; return affixBuf . length ( ) ; } String affix = null ; if ( isPrefix ) { affix = isNegative ? negativePrefix : positivePrefix ; } else { affix = isNegative ? negativeSuffix : positiveSuffix ; } if ( parseAttr ) { int offset = affix . indexOf ( symbols . getCurrencySymbol ( ) ) ; if ( - 1 == offset ) { offset = affix . indexOf ( symbols . getPercent ( ) ) ; if ( - 1 == offset ) { offset = 0 ; } } formatAffix2Attribute ( affix , buf . length ( ) + offset , buf . length ( ) + affix . length ( ) ) ; } buf . append ( affix ) ; return affix . length ( ) ; } 
public void addCustomData ( final Plotter plotter ) { if ( plotter == null ) { throw new IllegalArgumentException ( "Plotter-cannot-be-null" ) ; } defaultGraph . addPlotter ( plotter ) ; graphs . add ( defaultGraph ) ; } 
String getLiteral ( ) { StringBuffer sb = new StringBuffer ( ) ; int i = 0 ; while ( i < fmt . length ( ) ) { if ( fmt . charAt ( i ) == '|' ) { i ++ ; if ( i < fmt . length ( ) ) { char c = fmt . charAt ( i ) ; switch ( c ) { case 'a' : sb . append ( ( char ) 0x07 ) ; break ; case 'b' : sb . append ( '|b' ) ; break ; case 'f' : sb . append ( '|f' ) ; break ; case 'n' : sb . append ( System . getProperty ( "line.separator" ) ) ; break ; case 'r' : sb . append ( '|r' ) ; break ; case 't' : sb . append ( '|t' ) ; break ; case 'v' : sb . append ( ( char ) 0x0b ) ; break ; case '|' : sb . append ( '|' ) ; break ; } i ++ ; } else sb . append ( '|' ) ; } else i ++ ; } return fmt ; } 
public byte [ ] getSalt ( ) { return Arrays . clone ( salt ) ; } 
public static void d ( String tag , String s , Object ... args ) { if ( LOG . DEBUG >= LOGLEVEL ) Log . d ( tag , String . format ( s , args ) ) ; } 
public static BufferedReader StringToBufferedReader ( String string ) { InputStream Fichier = new ByteArrayInputStream ( string . getBytes ( ) ) ; BufferedReader lecteur = new BufferedReader ( new InputStreamReader ( Fichier ) ) ; return lecteur ; } 
private void showSearchProgress ( boolean show ) { if ( mSearchProgress != null ) { mSearchProgress . setVisibility ( show ? View . VISIBLE : View . GONE ) ; } } 
public abstract_activity get_user_recent_social_activity ( ) throws SQLException { List < abstract_activity > act_list = get_user_recent_social_activities ( current_user_id , 1 ) ; if ( act_list . size ( ) > 0 ) return ( act_list . get ( 0 ) ) ; else return ( null ) ; } 
protected void synchronizeChildren ( ) { needsSyncChildren ( false ) ; } 
RequestStream getRequestStream ( int bufferSize , int maxPrecision ) { synchronized ( socketTable ) { int id ; for ( id = 0 ; id < socketTable . size ( ) ; id ++ ) { if ( socketTable . get ( id ) == null ) { break ; } } VirtualSocket vsock = new VirtualSocket ( id ) ; if ( id >= socketTable . size ( ) ) { socketTable . add ( vsock ) ; } else { socketTable . set ( id , vsock ) ; } return new RequestStream ( this , vsock , bufferSize , maxPrecision ) ; } } 
public void insert_longlong ( long l ) { typeCode = orb . get_primitive_tc ( TCKind . _tk_longlong ) ; value = l ; isInitialized = true ; } 
@ Override public void send ( DatagramPacket p ) throws IOException { if ( delegate == null ) { try { super . send ( p ) ; } catch ( Exception ex ) { InetAddress tmpAddr = p . getAddress ( ) ; if ( ( ( ex instanceof NoRouteToHostException ) || ( ex . getMessage ( ) != null && ex . getMessage ( ) . equals ( "No-route-to-host" ) ) ) && ( tmpAddr instanceof Inet6Address ) && ( tmpAddr . isLinkLocalAddress ( ) ) ) { Inet6Address newAddr = Inet6Address . getByAddress ( "" , tmpAddr . getAddress ( ) , ( ( Inet6Address ) super . getLocalAddress ( ) ) . getScopeId ( ) ) ; p . setAddress ( newAddr ) ; super . send ( p ) ; } } ++ nbSentRtpPackets ; logPacketToPcap ( p , this . nbSentRtpPackets , true , super . getLocalAddress ( ) , super . getLocalPort ( ) ) ; } else { delegate . send ( p ) ; } } 
public KeyValue createFirstOnRowColTS ( long ts ) { return new KeyValue ( bytes , getRowOffset ( ) , getRowLength ( ) , bytes , getFamilyOffset ( ) , getFamilyLength ( ) , bytes , getQualifierOffset ( ) , getQualifierLength ( ) , ts , Type . Maximum , bytes , getValueOffset ( ) , getValueLength ( ) ) ; } 
public static NumberFormat getDefaultNumberFormat ( final Locale locale ) { final NumberFormat nf = NumberFormat . getInstance ( locale ) ; nf . setMaximumFractionDigits ( 10 ) ; return nf ; } 
public JSONObject increment ( String key ) throws org . cjson . JSONException { Object value = this . opt ( key ) ; if ( value == null ) { this . put ( key , 1 ) ; } else if ( value instanceof Integer ) { this . put ( key , ( ( Integer ) value ) . intValue ( ) + 1 ) ; } else if ( value instanceof Long ) { this . put ( key , ( ( Long ) value ) . longValue ( ) + 1 ) ; } else if ( value instanceof Double ) { this . put ( key , ( ( Double ) value ) . doubleValue ( ) + 1 ) ; } else if ( value instanceof Float ) { this . put ( key , ( ( Float ) value ) . floatValue ( ) + 1 ) ; } else { throw new org . cjson . JSONException ( "Unable-to-increment-[" + quote ( key ) + "]." ) ; } return this ; } 
public String getTabTitleToolTip ( ) { return Messages . getInstance ( ) . getString ( "PreprocessPanel_GetTabTitleToolTip_Text" ) ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
@ SuppressWarnings ( "unused" ) public Object profileExit ( final Object result ) { depth -- ; if ( depth == 0 ) { totalTime += System . nanoTime ( ) - startTime ; } return result ; } 
public boolean equals ( Object obj ) { if ( obj instanceof Point2D ) { Point2D p2d = ( Point2D ) obj ; return ( getX ( ) == p2d . getX ( ) ) && ( getY ( ) == p2d . getY ( ) ) ; } return super . equals ( obj ) ; } 
public List < String > getNilReason ( ) { if ( nilReason == null ) { nilReason = new ArrayList < String > ( ) ; } return this . nilReason ; } 
public int hashCode ( ) { int result = 0 ; int increment = Math . min ( 3 , values . length / 16 ) ; for ( int i = 0 ; i < values . length ; i += increment ) { result = result * 37 + values [ i ] ; } return result ; } 
public static String getBaseUrl ( Context context ) { String url = URL_MAP . get ( context ) ; if ( url == null ) { url = getDebugUrl ( context ) ; if ( url == null ) { url = Setup . PROD_URL ; } URL_MAP . put ( context , url ) ; } return url ; } 
public CharSequence getTitle ( Resources res ) { if ( titleRes != 0 ) { return res . getText ( titleRes ) ; } return title ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public List < Error > getError ( ) { if ( error == null ) { error = new ArrayList < Error > ( ) ; } return this . error ; } 
public Builder setMultiChoiceItems ( int itemsId , boolean [ ] checkedItems , final OnMultiChoiceClickListener listener ) { P . mItems = P . mContext . getResources ( ) . getTextArray ( itemsId ) ; P . mOnCheckboxClickListener = listener ; P . mCheckedItems = checkedItems ; P . mIsMultiChoice = true ; return this ; } 
public final String [ ] getChannels ( ) { String [ ] channels = new String [ 0 ] ; synchronized ( _channels ) { channels = new String [ _channels . size ( ) ] ; Enumeration enumeration = _channels . keys ( ) ; for ( int i = 0 ; i < channels . length ; i ++ ) { channels [ i ] = ( String ) enumeration . nextElement ( ) ; } } return channels ; } 
public String registerExtendedProperties ( String identifier , IExtendedEntityProperties properties ) { if ( identifier == null ) { FMLLog . warning ( "Someone-is-attempting-to-register-extended-properties-using-a-null-identifier.-This-is-not-allowed.-Aborting.-This-may-have-caused-instability." ) ; return "" ; } if ( properties == null ) { FMLLog . warning ( "Someone-is-attempting-to-register-null-extended-properties.-This-is-not-allowed.-Aborting.-This-may-have-caused-instability." ) ; return "" ; } String baseIdentifier = identifier ; int identifierModCount = 1 ; while ( this . extendedProperties . containsKey ( identifier ) ) { identifier = String . format ( "%s%d" , baseIdentifier , identifierModCount ++ ) ; } if ( baseIdentifier != identifier ) { FMLLog . info ( "An-attempt-was-made-to-register-exended-properties-using-an-existing-key.-The-duplicate-identifier-(%s)-has-been-remapped-to-%s." , baseIdentifier , identifier ) ; } this . extendedProperties . put ( identifier , properties ) ; return identifier ; } 
public Object visit ( ASTExplicitConstructorInvocation node , Object data ) { if ( super . visit ( node , data ) . equals ( Boolean . TRUE ) ) { if ( node . getName ( ) . equals ( ( ( ASTExplicitConstructorInvocation ) data ) . getName ( ) ) ) { return Boolean . TRUE ; } } return Boolean . FALSE ; } 
@ Override public boolean e_prefers ( String instructor , String ta , String c ) { Instructor prof = cons . getInstructor ( instructor ) ; TA obj = cons . getTA ( ta ) ; Course course = cons . getCourse ( c ) ; if ( ( prof == null ) || ( obj == null ) || ( course == null ) ) { predicateError ( "TA/course/instructor-doesn't-exist" ) ; return false ; } return prof . hasPrefers ( obj , course ) ; } 
public int getEndOffset ( ) { if ( view != null ) { return view . getEndOffset ( ) ; } return getElement ( ) . getEndOffset ( ) ; } 
public static int codePointCount ( CharSequence seq , int beginIndex , int endIndex ) { if ( seq == null ) { throw new NullPointerException ( ) ; } int len = seq . length ( ) ; if ( beginIndex < 0 || endIndex > len || beginIndex > endIndex ) { throw new IndexOutOfBoundsException ( ) ; } int result = 0 ; for ( int i = beginIndex ; i < endIndex ; i ++ ) { char c = seq . charAt ( i ) ; if ( isHighSurrogate ( c ) ) { if ( ++ i < endIndex ) { c = seq . charAt ( i ) ; if ( ! isLowSurrogate ( c ) ) { result ++ ; } } } result ++ ; } return result ; } 
private long getVerificationTimeout ( ) { return android . provider . Settings . Secure . getLong ( mContext . getContentResolver ( ) , android . provider . Settings . Secure . PACKAGE_VERIFIER_TIMEOUT , DEFAULT_VERIFICATION_TIMEOUT ) ; } 
public void elementAttributesProcessed ( String name , Properties extraAttributes , String systemId , int lineNr ) { Properties props = ( Properties ) this . currentElements . pop ( ) ; Enumeration enume = props . keys ( ) ; while ( enume . hasMoreElements ( ) ) { String key = ( String ) enume . nextElement ( ) ; extraAttributes . put ( key , props . get ( key ) ) ; } } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public void setLoopback ( boolean theFlag ) { try { _myMulticastSocket . setLoopbackMode ( theFlag ) ; } catch ( SocketException se ) { Logger . printError ( "Multicast.setLoopback()" , "" + se ) ; } } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
private void addSnippetFile ( File file ) { if ( fSnippetFiles == null ) { fSnippetFiles = new ArrayList < File > ( ) ; } fSnippetFiles . add ( file ) ; } 
public static String substringBetween ( String str , String open , String close ) { if ( str == null || open == null || close == null ) { return null ; } int start = str . indexOf ( open ) ; if ( start != - 1 ) { int end = str . indexOf ( close , start + open . length ( ) ) ; if ( end != - 1 ) { return str . substring ( start + open . length ( ) , end ) ; } } return null ; } 
protected void tearDown ( ) throws Exception { super . tearDown ( ) ; Locale . setDefault ( this . savedLocale ) ; } 
public static void runJavadoc ( String [ ] javadocArgs ) { if ( com . sun . tools . javadoc . Main . execute ( javadocArgs ) != 0 ) { throw new Error ( "Javadoc-failed-to-execute" ) ; } } 
public com . google . protobuf . ByteString getLogoBytes ( ) { java . lang . Object ref = logo_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; logo_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public Set < Plotter > getPlotters ( ) { return Collections . unmodifiableSet ( plotters ) ; } 
@ Override @ SuppressWarnings ( "unchecked" ) public synchronized Object clone ( ) { try { Vector < E > vector = ( Vector < E > ) super . clone ( ) ; vector . elementData = elementData . clone ( ) ; return vector ; } catch ( CloneNotSupportedException e ) { throw new AssertionError ( e ) ; } } 
private List calculateSuffixes ( Locale locale ) { List suffixes = new ArrayList ( 3 ) ; String language = locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; String variant = locale . getVariant ( ) ; StringBuffer suffix = new StringBuffer ( ) ; suffix . append ( '_' ) ; suffix . append ( language ) ; if ( language . length ( ) > 0 ) { suffixes . add ( suffix . toString ( ) ) ; } suffix . append ( '_' ) ; suffix . append ( country ) ; if ( country . length ( ) > 0 ) { suffixes . add ( suffix . toString ( ) ) ; } suffix . append ( '_' ) ; suffix . append ( variant ) ; if ( variant . length ( ) > 0 ) { suffixes . add ( suffix . toString ( ) ) ; } return suffixes ; } 
public int prepareAddWindowLw ( WindowState win , WindowManager . LayoutParams attrs ) { switch ( attrs . type ) { case TYPE_STATUS_BAR : mContext . enforceCallingOrSelfPermission ( android . Manifest . permission . STATUS_BAR_SERVICE , "PhoneWindowManager" ) ; if ( mStatusBar != null ) { return WindowManagerImpl . ADD_MULTIPLE_SINGLETON ; } mStatusBar = win ; break ; case TYPE_STATUS_BAR_PANEL : mContext . enforceCallingOrSelfPermission ( android . Manifest . permission . STATUS_BAR_SERVICE , "PhoneWindowManager" ) ; mStatusBarPanels . add ( win ) ; break ; case TYPE_KEYGUARD : if ( mKeyguard != null ) { return WindowManagerImpl . ADD_MULTIPLE_SINGLETON ; } mKeyguard = win ; break ; } return WindowManagerImpl . ADD_OKAY ; } 
public static void setCheckpoint ( EvolutionState state ) { try { File file = new File ( "" + state . checkpointPrefix + "." + state . generation + ".gz" ) ; if ( state . checkpointDirectory != null ) { file = new File ( state . checkpointDirectory , "" + state . checkpointPrefix + "." + state . generation + ".gz" ) ; } ObjectOutputStream s = new ObjectOutputStream ( new GZIPOutputStream ( new BufferedOutputStream ( new FileOutputStream ( file ) ) ) ) ; s . writeObject ( state ) ; s . close ( ) ; state . output . message ( "Wrote-out-checkpoint-file-" + state . checkpointPrefix + "." + state . generation + ".gz" ) ; } catch ( IOException e ) { state . output . warning ( "Unable-to-create-the-checkpoint-file-" + state . checkpointPrefix + "." + state . generation + ".gz" + "because-of-an-IOException:---EXCEPTION---" + e + "---EXCEPTION-END---" ) ; } } 
protected String generateHash ( User . State state , Map < String , String > props ) { String ha1 = String . format ( "%s:%s:%s" , props . get ( "username" ) , props . get ( "realm" ) , state . password ) ; String ha2 = String . format ( "%s:%s" , "REGISTER" , props . get ( "uri" ) ) ; return encoder . encodePassword ( String . format ( "%s:%s:%s" , encoder . encodePassword ( ha1 , null ) , props . get ( "nonce" ) , encoder . encodePassword ( ha2 , null ) ) , null ) ; } 
public Rectangle createIntersection ( Rectangle r ) { Rectangle dest = new Rectangle ( ) ; Rectangle . intersect ( this , r , dest ) ; return dest ; } 
public void setCommentAnonymityFlag ( String commentAnonymityFlag ) { this . commentAnonymityFlag = commentAnonymityFlag == null ? null : commentAnonymityFlag . trim ( ) ; } 
public XMLString concat ( String str ) { return new XString ( str ( ) . concat ( str ) ) ; } 
public void logCall ( Connection c , int callLogType ) { final String number = c . getAddress ( ) ; final long date = c . getCreateTime ( ) ; final long duration = c . getDurationMillis ( ) ; final Phone phone = c . getCall ( ) . getPhone ( ) ; final CallerInfo ci = getCallerInfoFromConnection ( c ) ; final String logNumber = getLogNumber ( c , ci ) ; if ( DBG ) { log ( "--onDisconnect():-logNumber-set-to:" + PhoneUtils . toLogSafePhoneNumber ( logNumber ) + ",-number-set-to:-" + PhoneUtils . toLogSafePhoneNumber ( number ) ) ; } final int presentation = getPresentation ( c , ci ) ; final boolean isOtaspNumber = TelephonyCapabilities . supportsOtasp ( phone ) && phone . isOtaSpNumber ( number ) ; if ( ! isOtaspNumber ) { logCall ( ci , logNumber , presentation , callLogType , date , duration ) ; } } 
@ Override public final String toString ( ) { String result = cachedToStringResult ; return ( result == null ) ? ( cachedToStringResult = toNewString ( ) ) : result ; } 
public String createMD5 ( ) { try { MessageDigest m = MessageDigest . getInstance ( "MD5" ) ; String s = this . id + "" + this . name + this . title + this . email + this . phoneNumber + this . photoUrl ; m . update ( s . getBytes ( ) , 0 , s . length ( ) ) ; BigInteger i = new BigInteger ( 1 , m . digest ( ) ) ; String md5str = String . format ( "%1$032x" , i ) ; return md5str ; } catch ( NoSuchAlgorithmException e ) { System . out . println ( "Error-from-getMd5-method" ) ; e . printStackTrace ( ) ; } return null ; } 
private String trim ( String value ) { if ( value != null ) return value . trim ( ) ; else return value ; } 
public static int calcColumnWidth ( JTable table , int col ) { int width = calcHeaderWidth ( table , col ) ; if ( width == - 1 ) return width ; TableColumnModel columns = table . getColumnModel ( ) ; TableModel data = table . getModel ( ) ; int rowCount = data . getRowCount ( ) ; TableColumn column = columns . getColumn ( col ) ; try { for ( int row = rowCount - 1 ; row >= 0 ; -- row ) { Component c = table . prepareRenderer ( table . getCellRenderer ( row , col ) , row , col ) ; width = Math . max ( width , c . getPreferredSize ( ) . width + 10 ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return width ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public String getInputEncoding ( ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; return null ; } 
private void whoCommand ( String key ) { NetworkInterface ni = niHashMap . get ( key ) ; for ( Entry < String , NetworkInterface > entry : niHashMap . entrySet ( ) ) { ni . sendMessage ( "--->-" + entry . getKey ( ) ) ; } } 
public static String valueOf ( char [ ] data ) { return new String ( data , 0 , data . length ) ; } 
public long getHeartbeatFrequency ( final TimeUnit timeUnit ) { return timeUnit . convert ( heartbeatFrequencyMS , TimeUnit . MILLISECONDS ) ; } 
public Map < String , Map < String , Double >> classifyWithPretrainedClassifier ( Instances testSet , ArrayList < String > unknownDocTitles , Set < String > trainSetAuthors ) { this . testSet = testSet ; Iterator < String > authIter = trainSetAuthors . iterator ( ) ; List < String > authors = new ArrayList < String > ( trainSetAuthors . size ( ) ) ; while ( authIter . hasNext ( ) ) authors . add ( authIter . next ( ) ) ; this . authors = authors ; int numOfInstances = testSet . numInstances ( ) ; int numOfAuthors = authors . size ( ) ; Map < String , Map < String , Double >> res = new HashMap < String , Map < String , Double >> ( numOfInstances ) ; for ( int i = 0 ; i < numOfInstances ; i ++ ) res . put ( unknownDocTitles . get ( i ) , new HashMap < String , Double > ( numOfAuthors ) ) ; Map < String , Double > map ; double [ ] currRes ; for ( int i = 0 ; i < testSet . numInstances ( ) ; i ++ ) { Instance test = testSet . instance ( i ) ; map = res . get ( unknownDocTitles . get ( i ) ) ; try { currRes = classifier . distributionForInstance ( test ) ; for ( int j = 0 ; j < numOfAuthors ; j ++ ) { map . put ( authors . get ( j ) , currRes [ j ] ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } results = res ; return res ; } 
public void selectInitialValue ( ) { OptionPaneUI ui = getUI ( ) ; if ( ui != null ) { ui . selectInitialValue ( this ) ; } } 
private Map getPathMapForEvent ( String event ) { if ( event == null || "*" . equals ( event ) ) { event = "on*" ; } if ( ! event . startsWith ( "on" ) ) { throw new IllegalArgumentException ( "Unrecognised-event:-'" + event + "'" ) ; } Map pathmap = ( Map ) _eventMap . get ( event ) ; if ( pathmap == null ) { pathmap = new LinkedHashMap ( ) ; _eventMap . put ( event , pathmap ) ; } return pathmap ; } 
private CharSequence insertGrouping ( CharSequence s ) { StringBuilder result = new StringBuilder ( s . length ( ) + s . length ( ) / 3 ) ; int digitsLength = s . length ( ) ; int i = 0 ; if ( s . charAt ( 0 ) == '-' ) { -- digitsLength ; ++ i ; result . append ( '-' ) ; } int headLength = digitsLength % 3 ; if ( headLength == 0 ) { headLength = 3 ; } result . append ( s , i , i + headLength ) ; i += headLength ; for ( ; i < s . length ( ) ; i += 3 ) { result . append ( localeData . groupingSeparator ) ; result . append ( s , i , i + 3 ) ; } return result ; } 
public int getSkeletonType ( ) { return this . dataWatcher . getWatchableObjectByte ( 13 ) ; } 
public void addExclusiveArgumentSet ( final Collection < Argument > exclusiveArguments ) { ensureNotNull ( exclusiveArguments ) ; final LinkedHashSet < Argument > argSet = new LinkedHashSet < Argument > ( exclusiveArguments ) ; exclusiveArgumentSets . add ( Collections . unmodifiableSet ( argSet ) ) ; } 
public Enumeration listOptions ( ) { Vector result ; result = new Vector ( ) ; result . addElement ( new Option ( "-Prints-this-help." , "h" , 1 , "-h" ) ) ; result . addElement ( new Option ( "-The-name-of-the-output-file,-otherwise-the-generated-data-is-" + "-printed-to-stdout." , "o" , 1 , "-o-<file>" ) ) ; result . addElement ( new Option ( "-The-name-of-the-relation." , "r" , 1 , "-r-<name>" ) ) ; result . addElement ( new Option ( "-Whether-to-print-debug-informations." , "d" , 0 , "-d" ) ) ; result . addElement ( new Option ( "-The-seed-for-random-function-(default-" + defaultSeed ( ) + ")" , "S" , 1 , "-S" ) ) ; return result . elements ( ) ; } 
public String toString ( ) { return Channels . isTopic ( name ) ? ( "[Topic-'" + name + "']" ) : ( "[Queue-'" + name + "']" ) ; } 
public void setParentStyleSheet ( StyleSheet parentStyleSheet ) { this . parentStyleSheet = parentStyleSheet ; if ( ! parentStyleSheet . containsSelector ( this ) ) parentStyleSheet . addSelector ( this ) ; } 
protected Skin MinimalBirdFactory ( Skin s ) { s . getG ( ) . setColor ( corps ) ; s . getG ( ) . fillOval ( x , y , widht , hight ) ; s . getG ( ) . setColor ( Color . black ) ; s . getG ( ) . drawOval ( x , y , widht , hight ) ; return s ; } 
public static boolean isEmptyTag ( String tagName ) { return isElement ( tagName , EMPTY ) ; } 
public void execute ( boolean verbose ) { List < Item > keySetList = new ArrayList < Item > ( mapSequenceID . keySet ( ) ) ; Collections . sort ( keySetList ) ; if ( verbose ) { System . out . println ( keySetList . size ( ) + "-frequent-items" ) ; } int numberOfFrequentItems = keySetList . size ( ) ; int cont = 0 ; for ( Item item : keySetList ) { cont ++ ; if ( verbose ) { System . out . println ( "Projecting-item-=-" + item + "-(" + cont + "/" + numberOfFrequentItems + ")" ) ; } PseudoSequenceDatabase projectedContext = makePseudoProjections ( item , pseudoDatabase , abstractionCreator . CreateDefaultAbstraction ( ) , true ) ; ItemAbstractionPair pair = new ItemAbstractionPair ( item , abstractionCreator . CreateDefaultAbstraction ( ) ) ; Pattern prefix = new Pattern ( pair ) ; prefix . setAppearingIn ( mapSequenceID . get ( item ) ) ; Trie newTrie = new Trie ( ) ; newTrie . setAppearingIn ( prefix . getAppearingIn ( ) ) ; TrieNode prefixNode = new TrieNode ( pair , newTrie ) ; generalTrie . addNode ( prefixNode ) ; if ( projectedContext != null ) { cloSpanLoop ( prefix , prefixNode , 2 , projectedContext , verbose ) ; } } } 
public boolean contains ( int x , int y ) { return inside ( x , y ) ; } 
public final void join ( long millis ) throws InterruptedException { join ( millis , 0 ) ; } 
public static Tree buildTree ( TreebankNode node , Pair < String , MultiDimensionalMap < Integer , Integer , String >> labels , List < String > possibleLabels ) throws Exception { if ( node . getLeaf ( ) ) return toTree ( node ) ; else { List < TreebankNode > preChildren = children ( node ) ; List < Tree > children = new ArrayList < > ( ) ; Tree t = toTree ( node ) ; for ( Pair < Integer , Integer > interval : labels . getSecond ( ) . keySet ( ) ) { if ( inRange ( interval . getFirst ( ) , interval . getSecond ( ) , t ) ) { t . setGoldLabel ( possibleLabels . indexOf ( labels . getSecond ( ) . get ( interval . getFirst ( ) , interval . getSecond ( ) ) ) ) ; break ; } } for ( int i = 0 ; i < preChildren . size ( ) ; i ++ ) { children . add ( buildTree ( preChildren . get ( i ) ) ) ; } t . connect ( children ) ; return t ; } } 
public static SOCPickResources parseDataStr ( String s ) { final String ga ; final int cl , or , sh , wh , wo , uk ; StringTokenizer st = new StringTokenizer ( s , sep2 ) ; try { ga = st . nextToken ( ) ; cl = Integer . parseInt ( st . nextToken ( ) ) ; or = Integer . parseInt ( st . nextToken ( ) ) ; sh = Integer . parseInt ( st . nextToken ( ) ) ; wh = Integer . parseInt ( st . nextToken ( ) ) ; wo = Integer . parseInt ( st . nextToken ( ) ) ; uk = Integer . parseInt ( st . nextToken ( ) ) ; } catch ( Exception e ) { return null ; } return new SOCPickResources ( ga , cl , or , sh , wh , wo , uk ) ; } 
public static QueuePlacementPolicy fromXml ( Element el , Map < FSQueueType , Set < String >> configuredQueues , Configuration conf ) throws AllocationConfigurationException { List < QueuePlacementRule > rules = new ArrayList < QueuePlacementRule > ( ) ; NodeList elements = el . getChildNodes ( ) ; for ( int i = 0 ; i < elements . getLength ( ) ; i ++ ) { Node node = elements . item ( i ) ; if ( node instanceof Element ) { QueuePlacementRule rule = createAndInitializeRule ( node ) ; rules . add ( rule ) ; } } return new QueuePlacementPolicy ( rules , configuredQueues , conf ) ; } 
protected static boolean same ( String s1 , String s2 ) { return s1 . equalsIgnoreCase ( s2 ) ; } 
public static String authoritySafePath ( String authority , String path ) { if ( authority != null && ! authority . isEmpty ( ) && ! path . isEmpty ( ) && ! path . startsWith ( "/" ) ) { return "/" + path ; } return path ; } 
@ Override public boolean equals ( final Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof Type ) ) { return false ; } final Type t = ( Type ) o ; if ( sort != t . sort ) { return false ; } if ( sort == OBJECT || sort == ARRAY ) { if ( len != t . len ) { return false ; } for ( int i = off , j = t . off , end = i + len ; i < end ; i ++ , j ++ ) { if ( buf [ i ] != t . buf [ j ] ) { return false ; } } } return true ; } 
public AutoAnnouncementInstance getAutoAnnouncementInstance ( int id ) { return _registeredAnnouncements . get ( id ) ; } 
static String getCharsetFromContentType ( String contentType ) { if ( contentType == null ) return null ; Matcher m = charsetPattern . matcher ( contentType ) ; if ( m . find ( ) ) { String charset = m . group ( 1 ) . trim ( ) ; charset = charset . replace ( "charset=" , "" ) ; if ( charset . length ( ) == 0 ) return null ; try { if ( Charset . isSupported ( charset ) ) return charset ; charset = charset . toUpperCase ( Locale . ENGLISH ) ; if ( Charset . isSupported ( charset ) ) return charset ; } catch ( IllegalCharsetNameException e ) { return null ; } } return null ; } 
private static long getCalendarTimeInMillis ( Calendar cal ) { return cal . getTime ( ) . getTime ( ) ; } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } else if ( obj instanceof ActivationGroupID ) { ActivationGroupID id = ( ActivationGroupID ) obj ; return ( uid . equals ( id . uid ) && system . equals ( id . system ) ) ; } else { return false ; } } 
public static void copyDirectoryToDirectory ( File srcDir , File destDir ) throws IOException { if ( srcDir == null ) { throw new NullPointerException ( "Source-must-not-be-null" ) ; } if ( srcDir . exists ( ) && srcDir . isDirectory ( ) == false ) { throw new IllegalArgumentException ( "Source-'" + destDir + "'-is-not-a-directory" ) ; } if ( destDir == null ) { throw new NullPointerException ( "Destination-must-not-be-null" ) ; } if ( destDir . exists ( ) && destDir . isDirectory ( ) == false ) { throw new IllegalArgumentException ( "Destination-'" + destDir + "'-is-not-a-directory" ) ; } copyDirectory ( srcDir , new File ( destDir , srcDir . getName ( ) ) , true ) ; } 
public void fixWhiteSpace ( ) { int index = mOutputBuilder . length ( ) - 1 ; if ( index >= 0 ) { char lastCharacter = mOutputBuilder . charAt ( index ) ; if ( ! Character . isWhitespace ( lastCharacter ) ) { mOutputBuilder . append ( "-" ) ; } } } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public void cleanup ( ) throws IOException , JMException { try { ( ( NotificationEmitter ) proxy ) . removeNotificationListener ( listener , null , null ) ; } finally { ManagementFactory . getPlatformMBeanServer ( ) . unregisterMBean ( ScanManager . SCAN_MANAGER_NAME ) ; } } 
public CodeSigner [ ] getCodeSigners ( ) { if ( null == signers ) { signers = getCodeSigners ( getCertificates ( ) ) ; } if ( null == signers ) { return null ; } CodeSigner [ ] tmp = new CodeSigner [ signers . length ] ; System . arraycopy ( signers , 0 , tmp , 0 , tmp . length ) ; return tmp ; } 
public int hashCode ( ) { if ( hash != 0 ) return hash ; int h = hashIgnoringCase ( 0 , scheme ) ; h = hash ( h , fragment ) ; if ( isOpaque ( ) ) { h = hash ( h , schemeSpecificPart ) ; } else { h = hash ( h , path ) ; h = hash ( h , query ) ; if ( host != null ) { h = hash ( h , userInfo ) ; h = hashIgnoringCase ( h , host ) ; h += 1949 * port ; } else { h = hash ( h , authority ) ; } } hash = h ; return h ; } 
public void printAclEntry ( AclEntry entry ) { out . println ( "----" + entry . getScope ( ) . getValue ( ) + ":-" + entry . getRole ( ) . getValue ( ) ) ; } 
public static char [ ] toCharArray ( InputStream is , String encoding ) throws IOException { CharArrayWriter output = new CharArrayWriter ( ) ; copy ( is , output , encoding ) ; return output . toCharArray ( ) ; } 
public static CoordinatorInitiatorProtocol_AtomicBinding getAtomicStub ( final CoordinationContext ctx , final EndpointReference initiatorServiceEPR ) throws AxisFault , MalformedURLException { if ( BACoordinator . COORDINATION_TYPE__ATOMIC . equals ( ctx . getCoordinationType ( ) ) ) { throw new IllegalArgumentException ( "Sorry,-getAtomicStub-is-only-valid-with-an-atomic-outcome!" ) ; } final CoordinatorInitiatorProtocol_AtomicBinding r = new CoordinatorInitiatorProtocol_AtomicBinding ( new URL ( initiatorServiceEPR . getAddress ( ) . toString ( ) ) , initiatorServiceEPR ) ; return r ; } 
public void revertVertical ( ) { dy = - dy ; updatePolar ( ) ; } 
public boolean canTraverseOutsideSubtree ( ) { int n = getPredicateCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( getPredicate ( i ) . canTraverseOutsideSubtree ( ) ) return true ; } return false ; } 
public static int frequency ( Collection < ? > c , Object o ) { int result = 0 ; if ( o == null ) { for ( Object e : c ) if ( e == null ) result ++ ; } else { for ( Object e : c ) if ( o . equals ( e ) ) result ++ ; } return result ; } 
private void interruptWorkers ( ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { for ( Worker w : workers ) { try { w . thread . interrupt ( ) ; } catch ( SecurityException ignore ) { } } } finally { mainLock . unlock ( ) ; } } 
public SAXParserFactory getFactory ( ) throws SAXNotRecognizedException , SAXNotSupportedException , ParserConfigurationException { if ( factory == null ) { factory = SAXParserFactory . newInstance ( ) ; factory . setNamespaceAware ( namespaceAware ) ; if ( namespaceAware ) { factory . setFeature ( "http://xml.org/sax/features/namespace-prefixes" , true ) ; } factory . setValidating ( validating ) ; if ( validating ) { factory . setFeature ( "http://xml.org/sax/features/validation" , true ) ; factory . setFeature ( "http://apache.org/xml/features/validation/schema" , true ) ; } } return ( factory ) ; } 
public void valueChanged ( int value ) { mHandler . sendMessage ( mHandler . obtainMessage ( BUMP_MSG , value , 0 ) ) ; } 
public void setUnitIncrement ( int unitIncrement ) { unitIncrementSet = true ; this . putClientProperty ( "JScrollBar.fastWheelScrolling" , null ) ; super . setUnitIncrement ( unitIncrement ) ; } 
public void put ( Object key , Object value ) { int bucket = ( key . hashCode ( ) & 0x7FFFFFFF ) % fTableSize ; Entry entry = search ( key , bucket ) ; if ( entry != null ) { entry . value = value ; } else { entry = new Entry ( key , value , fBuckets [ bucket ] ) ; fBuckets [ bucket ] = entry ; fNum ++ ; } } 
public boolean contains ( final MRData x ) { if ( materialized ( ) ) return content . contains ( x ) ; if ( streamed ( ) && consumed ) throw new Error ( "***-The-collection-stream-has-already-been-consumed" ) ; for ( MRData e : this ) if ( x . equals ( e ) ) return true ; if ( streamed ( ) ) consumed = true ; return false ; } 
public Point getLocationOnScreen ( ) { synchronized ( getTreeLock ( ) ) { return getLocationOnScreen_NoTreeLock ( ) ; } } 
public synchronized long nextId ( ) { if ( fileChannel == null ) { throw new IllegalStateException ( "Closed-id-generator-" + fileName ) ; } if ( defragedIdList . size ( ) > 0 ) { long id = defragedIdList . removeFirst ( ) ; if ( haveMore && defragedIdList . size ( ) == 0 ) { readIdBatch ( ) ; } defraggedIdCount -- ; return id ; } if ( nextFreeId >= OVERFLOW_ID || nextFreeId < 0 ) { throw new UnderlyingStorageException ( "Id-capacity-exceeded" ) ; } return nextFreeId ++ ; } 
public synchronized void setEscapeProcessing ( boolean enable ) throws java . sql . SQLException { if ( Driver . TRACE ) { Object [ ] args = { new Boolean ( enable ) } ; Debug . methodCall ( this , "setEscapeProcessing" , args ) ; } doEscapeProcessing = enable ; } 
@ Override public int lastIndexOf ( final Object o ) { if ( o == null ) { for ( int i = this . size - 1 ; i >= 0 ; i -- ) if ( this . elementData [ i ] == null ) return i ; } else { for ( int i = this . size - 1 ; i >= 0 ; i -- ) if ( o . equals ( this . elementData [ i ] ) ) return i ; } return - 1 ; } 
public void set ( String name , Object obj ) throws IOException { if ( ! ( obj instanceof Integer ) ) { throw new IOException ( "Attribute-must-be-of-type-Integer." ) ; } if ( name . equalsIgnoreCase ( REASON ) ) { reasonCode = ( ( Integer ) obj ) . intValue ( ) ; } else { throw new IOException ( "Name-not-supported-by-CRLReasonCodeExtension" ) ; } encodeThis ( ) ; } 
protected List getTransportListeners ( ) { return Collections . unmodifiableList ( listeners ) ; } 
public String attributesToString ( ) { StringBuffer text = new StringBuffer ( ) ; int j = 0 ; for ( int i = 0 ; i < m_attributes . length ; i ++ ) { if ( m_attributes [ i ] ) { if ( isGaussian ( ) ) { text . append ( "-Attribute:-" + i ) ; text . append ( "-Mean:-" + m_meanValue [ j ] ) ; text . append ( "-StdDev:-" + m_stddevValue [ j ] + "-%" ) ; } else { text . append ( "-Attribute:-" + i ) ; text . append ( "-Range:-" + m_minValue [ j ] ) ; text . append ( "---" + m_maxValue [ j ] + "-%" ) ; } j ++ ; } } return text . toString ( ) ; } 
public static Object doPrivileged ( PrivilegedExceptionAction action ) throws PrivilegedActionException { try { return doPrivileged0 ( action , getContext ( ) ) ; } catch ( Exception e ) { throw new PrivilegedActionException ( e ) ; } } 
public boolean getBoolean ( int index ) throws JSONException { Object o = get ( index ) ; if ( o . equals ( Boolean . FALSE ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( o . equals ( Boolean . TRUE ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONArray[" + index + "]-is-not-a-Boolean." ) ; } 
private static int indexOfMatchingClosingQuote ( String expressionString , int indexOfOpeningQuote ) { char quote = expressionString . charAt ( indexOfOpeningQuote ) ; for ( int i = expressionString . indexOf ( quote , indexOfOpeningQuote + 1 ) ; i >= 0 ; i = expressionString . indexOf ( quote , i + 1 ) ) { if ( ! isEscaped ( expressionString , i ) ) { return i ; } } return - 1 ; } 
@ Override void write ( final DataOutputStream out ) throws IOException { out . writeByte ( CONSTANT_DOUBLE ) ; out . writeDouble ( this . value . doubleValue ( ) ) ; } 
public int getColumnIndex ( Object identifier ) { if ( identifier == null ) { throw new IllegalArgumentException ( "Identifier-is-null" ) ; } Enumeration enumeration = getColumns ( ) ; TableColumn aColumn ; int index = 0 ; while ( enumeration . hasMoreElements ( ) ) { aColumn = ( TableColumn ) enumeration . nextElement ( ) ; if ( identifier . equals ( aColumn . getIdentifier ( ) ) ) return index ; index ++ ; } throw new IllegalArgumentException ( "Identifier-not-found" ) ; } 
void reset ( ) { if ( version != - 1 ) { throw new RuntimeException ( "reset()-can-be-only-be-called-before-protocolDetermined" ) ; } data . reset ( ) ; } 
@ Deprecated public static IOFileFilter andFileFilter ( IOFileFilter filter1 , IOFileFilter filter2 ) { return new AndFileFilter ( filter1 , filter2 ) ; } 
public void setExtraFields ( Collection < String > fields ) { extraFields = new HashSet < String > ( ) ; if ( fields != null ) { extraFields . addAll ( fields ) ; } } 
private void moveComponents ( Container target , int x , int y , int width , int height , int colStart , int colEnd ) { switch ( vAlign ) { case TOP : break ; case CENTER : y += height / 2 ; break ; case BOTTOM : y += height ; } for ( int i = colStart ; i < colEnd ; i ++ ) { Component c = target . getComponent ( i ) ; Dimension cDim = c . size ( ) ; if ( c . isVisible ( ) ) { c . move ( x + ( width - cDim . width ) / 2 , y ) ; y += vVGap + cDim . height ; } } } 
public static int strcmp ( String str , char [ ] a , int start ) { int i , d , len = str . length ( ) ; for ( i = 0 ; i < len ; i ++ ) { d = str . charAt ( i ) - a [ start + i ] ; if ( d != 0 ) { return d ; } if ( a [ start + i ] == 0 ) { return d ; } } if ( a [ start + i ] != 0 ) { return - a [ start + i ] ; } return 0 ; } 
public void flush ( ) throws IOException { OutputStream output = getStream ( ) ; if ( null != output ) { output . flush ( ) ; } } 
public void setOffset ( int offset ) { checkThread ( ) ; if ( offsetPosition == - 1 ) { throw new IllegalStateException ( "Offset-must-be-set-with-QueryBuilder-before-it-can-be-used-here" ) ; } parameters [ offsetPosition ] = Integer . toString ( offset ) ; } 
public int getAccessibleChildrenCount ( JComponent a ) { int returnValue = ( ( ComponentUI ) ( uis . elementAt ( 0 ) ) ) . getAccessibleChildrenCount ( a ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . getAccessibleChildrenCount ( a ) ; } return returnValue ; } 
@ XmlElementDecl ( namespace = "http://www.example.org/subtract" , name = "subtract" ) public JAXBElement < Subtract > createSubtract ( Subtract value ) { return new JAXBElement < Subtract > ( _Subtract_QNAME , Subtract . class , null , value ) ; } 
SourceFile ( ClassDoc cdoc ) { if ( cdoc . containingClass ( ) != null ) { throw new BuildException ( "cannot-request-source-file-for-nested-class-" + cdoc . qualifiedName ( ) ) ; } this . cdoc = cdoc ; buffer = new CharArrayWriter ( 2000 ) ; out = new PrintWriter ( buffer ) ; } 
public void setCurrentPanel ( String name ) { if ( PANELS . containsKey ( name ) ) { LOG . log ( "Setting-current-panel-to-"" + name + ""." ) ; CURRENT_PANEL = PANELS . get ( name ) ; CURRENT_PANEL_NAME = name ; } else { LOG . setSubSection ( "Error" ) ; LOG . log ( "Attempted-current-panel-does-not-exist-in-the-HashMap." ) ; LOG . useSubSection ( false ) ; } } 
protected void autoScaleFrame ( float [ ] fr ) { if ( ! autoscaleEnabled ) { return ; } float max = Float . NEGATIVE_INFINITY , min = Float . POSITIVE_INFINITY ; for ( int i = 0 ; i < fr . length ; i ++ ) { float f = fr [ i ] - grayValue ; if ( f > max ) { max = f ; } else if ( f < min ) { min = f ; } } float m , b = grayValue ; if ( max == min ) { return ; } if ( max > - min ) { m = ( 1 - grayValue ) / ( max ) ; b = grayValue - grayValue * m ; } else { m = grayValue / ( - min ) ; b = grayValue - grayValue * m ; } if ( colorMode != ColorMode . Contrast ) { autoScaleValue = ( int ) Math . round ( Math . max ( max , - min ) / step ) ; } else { if ( max > - min ) { autoScaleValue = 1 ; } else { autoScaleValue = - 1 ; } } for ( int i = 0 ; i < fr . length ; i ++ ) { fr [ i ] = m * fr [ i ] + b ; } } 
public Future < GetIdentityMailFromDomainAttributesResult > getIdentityMailFromDomainAttributesAsync ( final GetIdentityMailFromDomainAttributesRequest getIdentityMailFromDomainAttributesRequest , final AsyncHandler < GetIdentityMailFromDomainAttributesRequest , GetIdentityMailFromDomainAttributesResult > asyncHandler ) throws AmazonServiceException , AmazonClientException { return executorService . submit ( new Callable < GetIdentityMailFromDomainAttributesResult > ( ) { public GetIdentityMailFromDomainAttributesResult call ( ) throws Exception { GetIdentityMailFromDomainAttributesResult result ; try { result = getIdentityMailFromDomainAttributes ( getIdentityMailFromDomainAttributesRequest ) ; } catch ( Exception ex ) { asyncHandler . onError ( ex ) ; throw ex ; } asyncHandler . onSuccess ( getIdentityMailFromDomainAttributesRequest , result ) ; return result ; } } ) ; } 
private static final < T > boolean removeMap ( MapElement < T > [ ] oldMap , MapElement < T > [ ] newMap , String name ) { int pos = find ( oldMap , name ) ; if ( ( pos != - 1 ) && ( name . equals ( oldMap [ pos ] . name ) ) ) { System . arraycopy ( oldMap , 0 , newMap , 0 , pos ) ; System . arraycopy ( oldMap , pos + 1 , newMap , pos , oldMap . length - pos - 1 ) ; return true ; } return false ; } 
public Rectangle getUntiledImageBounds ( ) { return ( untiledBounds != null ) ? ( Rectangle ) untiledBounds . clone ( ) : null ; } 
public int run ( Object ... parameters ) { Object obj = super . findObject ( parameters ) ; if ( ! ( obj instanceof Number ) ) { throw new TypeMismatchDataAccessException ( "Couldn't-convert-result-object-[" + obj + "]-to-int" ) ; } return ( ( Number ) obj ) . intValue ( ) ; } 
Resources resources ( ) { final Thread currentThread = Thread . currentThread ( ) ; int local = 0 , total = 0 ; for ( final Account account : accounts . values ( ) ) { if ( account . getAccountant ( ) == this ) { if ( account . owner == currentThread ) local ++ ; total ++ ; } } return new Resources ( local , total ) ; } 
public static ArrayList < ContactAddress > getPostalAddresses ( Context ctx , ArrayList < Long > ids ) { ArrayList < ContactAddress > res = new ArrayList < ContactAddress > ( ) ; if ( ids . size ( ) > 0 ) { String where = ContactsContract . Data . CONTACT_ID + "-IN-(" + TextUtils . join ( ",-" , ids ) + ")-AND-" + ContactsContract . Data . MIMETYPE + "-=-?" ; String [ ] whereParams = new String [ ] { ContactsContract . CommonDataKinds . StructuredPostal . CONTENT_ITEM_TYPE } ; Cursor c = ctx . getContentResolver ( ) . query ( ContactsContract . Data . CONTENT_URI , null , where , whereParams , null ) ; if ( c != null ) { while ( c . moveToNext ( ) ) { int type = Tools . getLong ( c , ContactsContract . CommonDataKinds . StructuredPostal . TYPE ) . intValue ( ) ; String label = Tools . getString ( c , ContactsContract . CommonDataKinds . StructuredPostal . LABEL ) ; if ( type != 0 && ( label == null || label . compareTo ( "" ) != 0 ) ) { label = ContactsContract . CommonDataKinds . StructuredPostal . getTypeLabel ( ctx . getResources ( ) , type , "" ) . toString ( ) ; } ContactAddress a = new ContactAddress ( ) ; a . address = Tools . getString ( c , ContactsContract . CommonDataKinds . StructuredPostal . DATA ) ; a . label = label ; res . add ( a ) ; } c . close ( ) ; } } return res ; } 
public List < List < Integer >> generate ( int numRows ) { List < List < Integer >> result = new ArrayList < List < Integer >> ( ) ; if ( numRows <= 0 ) return result ; ArrayList < Integer > line = new ArrayList < Integer > ( ) ; line . add ( 1 ) ; result . add ( line ) ; for ( int i = 1 ; i < numRows ; i ++ ) { line = new ArrayList < Integer > ( ) ; for ( int j = 1 ; j < i ; j ++ ) { List < Integer > preline = result . get ( i - 1 ) ; line . add ( preline . get ( j - 1 ) + preline . get ( j ) ) ; } line . add ( 0 , 1 ) ; line . add ( 1 ) ; result . add ( line ) ; } return result ; } 
protected byte [ ] readFileAsBytes ( File file ) throws IOException { final byte [ ] contents ; FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; FileChannel fc = fis . getChannel ( ) ; int sz = ( int ) fc . size ( ) ; MappedByteBuffer bb = fc . map ( FileChannel . MapMode . READ_ONLY , 0 , sz ) ; if ( bb . hasArray ( ) ) { contents = bb . array ( ) ; } else { contents = new byte [ sz ] ; bb . get ( contents ) ; } } catch ( IOException e ) { throw new RuntimeException ( "Error-while-trying-to-read-file:-" + file . getCanonicalPath ( ) , e ) ; } finally { if ( fis != null ) fis . close ( ) ; } return contents ; } 
private void paintCheckIconEnabledAndSelected ( Graphics2D g , int width , int height ) { Shape s = shapeGenerator . createCheckMark ( 0 , 0 , width , height ) ; g . setPaint ( iconEnabledSelected ) ; g . fill ( s ) ; } 
static public void releaseBuffer ( ByteBuffer niobuffer ) { if ( niobuffer != null && niobuffer . isDirect ( ) ) { Object cleaner = ( ( DirectBuffer ) niobuffer ) . cleaner ( ) ; if ( cleaner != null ) ( ( Cleaner ) cleaner ) . clean ( ) ; niobuffer = null ; } } 
public static void setGuard ( Instruction i , Operand Guard ) { if ( Configuration . ExtremeAssertions && ! conforms ( i ) ) fail ( i , "PutField" ) ; i . putOperand ( 4 , Guard ) ; } 
public static Type < UsersDeletedEvent . Handler > getType ( ) { if ( TYPE == null ) { TYPE = new Type < UsersDeletedEvent . Handler > ( ) ; } return TYPE ; } 
public static int binarySearch ( short [ ] a , short key ) { return binarySearch0 ( a , 0 , a . length , key ) ; } 
public void setName ( String name ) { if ( name != null && ! name . equals ( "" ) ) { name = name . replaceAll ( "&" , "and" ) ; this . name = name ; } else { name = "UNKNOWN" ; } } 
public static Request newRestRequest ( Session session , String restMethod , Bundle parameters , HttpMethod httpMethod ) { Request request = new Request ( session , null , parameters , httpMethod ) ; request . setRestMethod ( restMethod ) ; return request ; } 
public void insert ( Object obj ) { int count = 0 ; Iterator elements = _set . iterator ( ) ; while ( elements . hasNext ( ) ) { Object next = elements . next ( ) ; int comparisonResult = _comparator . compare ( obj , next ) ; if ( comparisonResult == 0 ) { return ; } else if ( comparisonResult < 0 ) { _set . add ( count , obj ) ; return ; } count ++ ; } _set . addLast ( obj ) ; } 
private void writeObject ( java . io . ObjectOutputStream s ) throws java . io . IOException { s . defaultWriteObject ( ) ; s . writeInt ( size ( ) ) ; int mask = elements . length - 1 ; for ( int i = head ; i != tail ; i = ( i + 1 ) & mask ) s . writeObject ( elements [ i ] ) ; } 
public static void appendColumns ( StringBuilder s , String [ ] columns ) { int n = columns . length ; for ( int i = 0 ; i < n ; i ++ ) { String column = columns [ i ] ; if ( column != null ) { if ( i > 0 ) { s . append ( ",-" ) ; } s . append ( column ) ; } } s . append ( '-' ) ; } 
public void consumeAndStoreMessageAttributesFor ( XMLElement elem ) throws UnableToCompleteException { Collection < AttributeMessage > attributeMessages = consumeAttributeMessages ( elem ) ; if ( ! attributeMessages . isEmpty ( ) ) { elemToAttributeMessages . put ( elem , attributeMessages ) ; } } 
public boolean shouldAcquire ( String name ) { int lastDot = name . lastIndexOf ( '.' ) ; String pkgName = name . substring ( 0 , lastDot == - 1 ? 0 : lastDot ) ; if ( pkgName . equals ( "org.robolectric.res" ) || ( pkgName . equals ( "org.robolectric.manifest" ) ) ) { return name . contains ( "Test" ) ; } if ( name . matches ( "com|.android|.internal|.R(|$.*)?" ) ) return true ; if ( name . equals ( "android.R$styleable" ) ) return true ; for ( String packageName : packagesToNotAquire ) { if ( name . startsWith ( packageName ) ) return false ; } return ! ( name . matches ( ".*|.R(||$[a-z]+)$" ) || classesToNotAquire . contains ( name ) ) ; } 
CharToByteConverter setConverter ( Object key , CharToByteConverter converter ) { Map ctbMap = ( ( Map [ ] ) converterCaches . get ( ) ) [ CTB_CACHE_MAP ] ; ctbMap . put ( key , converter ) ; return converter ; } 
public boolean hasUniformLineMetrics ( ) { return font . hasUniformLineMetrics ( ) ; } 
@ Override public boolean isOwner ( String id ) { return ( ( owner == null ) ? false : owner . equals ( id ) ) ; } 
public static double sqrt ( double x ) { return Math . sqrt ( x ) ; } 
public String nextTo ( char delimiter ) throws JSONException { StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c == '|n' || c == '|r' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } } 
public StrBuilder append ( StringBuffer str , int startIndex , int length ) { if ( str == null ) { return appendNull ( ) ; } if ( startIndex < 0 || startIndex > str . length ( ) ) { throw new StringIndexOutOfBoundsException ( "startIndex-must-be-valid" ) ; } if ( length < 0 || ( startIndex + length ) > str . length ( ) ) { throw new StringIndexOutOfBoundsException ( "length-must-be-valid" ) ; } if ( length > 0 ) { int len = length ( ) ; ensureCapacity ( len + length ) ; str . getChars ( startIndex , startIndex + length , buffer , len ) ; size += length ; } return this ; } 
public void xmlDump ( PrintStream out ) throws IOException { super . xmlDump ( out ) ; out . print ( "<qmax>" + Double . toString ( qMax ) + "</qmax>" ) ; out . print ( "</event>" ) ; return ; } 
public boolean containsAll ( Collection < ? > coll ) { for ( Object e : coll ) { if ( ! contains ( e ) ) return false ; } return true ; } 
private static Codec getFICodec ( ) { try { Class c = Class . forName ( "com.sun.xml.internal.ws.encoding.fastinfoset.FastInfosetCodec" ) ; Method m = c . getMethod ( "create" ) ; return ( Codec ) m . invoke ( null ) ; } catch ( Exception e ) { return null ; } } 
public void processTransactionFromFile ( String input ) throws FileNotFoundException , IOException { BufferedReader reader = new BufferedReader ( new FileReader ( input ) ) ; String line ; while ( ( ( line = reader . readLine ( ) ) != null ) ) { String [ ] lineSplited = line . split ( "-" ) ; int [ ] transaction = getVector ( lineSplited ) ; processTransaction ( transaction ) ; } reader . close ( ) ; } 
protected String removeQuotes ( final String source ) { final String quote = "'" ; if ( ! ( source . startsWith ( quote ) && source . endsWith ( quote ) ) ) { return source ; } int length = source . length ( ) ; String result = source . substring ( 1 , length - 1 ) ; result = result . replaceAll ( "''" , "'" ) ; return result ; } 
public void close ( ) throws IOException { synchronized ( in ) { if ( buf != null ) { buf = null ; in . close ( ) ; } } } 
@ GET @ Path ( "/{colourpalette_id}" ) @ Produces ( MediaType . APPLICATION_XML ) public Response getColourPalette ( @ PathParam ( "colourpalette_id" ) String colourpalette_id ) { String colourpalette_str = dh . getColourPalette ( colourpalette_id ) ; if ( colourpalette_str != null ) return Response . ok ( ) . entity ( colourpalette_str ) . build ( ) ; else { return Response . status ( 404 ) . build ( ) ; } } 
public List < FxSurfaceInitFromCommon > getInitFroms ( ) { if ( initFroms == null ) { initFroms = new ArrayList < FxSurfaceInitFromCommon > ( ) ; } return this . initFroms ; } 
final void addValue ( String value ) { m_Values = Utils . cast ( m_Values . clone ( ) ) ; m_Hashtable = Utils . cast ( m_Hashtable . clone ( ) ) ; forceAddValue ( value ) ; } 
public List < PolicyTreeElement > getChildren ( ) { return Collections . emptyList ( ) ; } 
public List < FareRestrictPref > getFareRestrictPref ( ) { if ( fareRestrictPref == null ) { fareRestrictPref = new ArrayList < FareRestrictPref > ( ) ; } return this . fareRestrictPref ; } 
protected void handleTitle ( char text [ ] ) { handleText ( text ) ; } 
@ XmlElementDecl ( namespace = "http://schemas.ipcommerce.com/CWS/v2.0/Transactions/Bankcard" , name = "PartialApprovalSupportType" ) public JAXBElement < PartialApprovalSupportType > createPartialApprovalSupportType ( PartialApprovalSupportType value ) { return new JAXBElement < PartialApprovalSupportType > ( _PartialApprovalSupportType_QNAME , PartialApprovalSupportType . class , null , value ) ; } 
@ Override public void draw ( Graphics2D g2 , DialPlot plot , Rectangle2D frame , Rectangle2D view ) { Shape window = getWindow ( frame ) ; Shape outerWindow = getOuterWindow ( frame ) ; Area area1 = new Area ( outerWindow ) ; Area area2 = new Area ( window ) ; area1 . subtract ( area2 ) ; g2 . setPaint ( Color . lightGray ) ; g2 . fill ( area1 ) ; g2 . setStroke ( this . stroke ) ; g2 . setPaint ( this . foregroundPaint ) ; g2 . draw ( window ) ; g2 . draw ( outerWindow ) ; } 
public void renderFrame ( ) { double offY = 0 ; if ( cell . isMultiPage ( ) ) { offY = pageNo * MULTIPAGESEPARATION ; } for ( int i = 0 ; i < lineFromEnd . size ( ) ; i ++ ) { Point2D from = lineFromEnd . get ( i ) ; Point2D to = lineToEnd . get ( i ) ; if ( offY != 0 ) { from = new Point2D . Double ( from . getX ( ) , from . getY ( ) + offY ) ; to = new Point2D . Double ( to . getX ( ) , to . getY ( ) + offY ) ; } showFrameLine ( from , to ) ; } for ( int i = 0 ; i < textPoint . size ( ) ; i ++ ) { Point2D at = textPoint . get ( i ) ; if ( offY != 0 ) { at = new Point2D . Double ( at . getX ( ) , at . getY ( ) + offY ) ; } double size = textSize . get ( i ) . doubleValue ( ) ; Point2D box = textBox . get ( i ) ; double width = box . getX ( ) ; double height = box . getY ( ) ; String msg = textMessage . get ( i ) ; showFrameText ( at , size , width , height , msg ) ; } } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public int size ( ) { return expressionParts . size ( ) ; } 
public static synchronized void removeProvider ( int providerNumber ) { Provider p = providers . remove ( providerNumber - 1 ) ; providersNames . remove ( p . getName ( ) ) ; setNeedRefresh ( ) ; } 
public static non_terminal find ( int indx ) { Integer the_indx = new Integer ( indx ) ; return ( non_terminal ) _all_by_index . get ( the_indx ) ; } 
public Collection < ResourceType > getResourceTypes ( ) { ArrayList < ResourceType > list = new ArrayList < ResourceType > ( ) ; if ( mFiles != null ) { for ( ResourceFile file : mFiles ) { Collection < ResourceType > types = file . getResourceTypes ( ) ; for ( ResourceType resType : types ) { if ( list . indexOf ( resType ) == - 1 ) { list . add ( resType ) ; } } } } return list ; } 
private static ProcessStartResult zygoteSendArgsAndGetResult ( ZygoteState zygoteState , ArrayList < String > args ) throws ZygoteStartFailedEx { try { final BufferedWriter writer = zygoteState . writer ; final DataInputStream inputStream = zygoteState . inputStream ; writer . write ( Integer . toString ( args . size ( ) ) ) ; writer . newLine ( ) ; int sz = args . size ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { String arg = args . get ( i ) ; if ( arg . indexOf ( '|n' ) >= 0 ) { throw new ZygoteStartFailedEx ( "embedded-newlines-not-allowed" ) ; } writer . write ( arg ) ; writer . newLine ( ) ; } writer . flush ( ) ; ProcessStartResult result = new ProcessStartResult ( ) ; result . pid = inputStream . readInt ( ) ; if ( result . pid < 0 ) { throw new ZygoteStartFailedEx ( "fork()-failed" ) ; } result . usingWrapper = inputStream . readBoolean ( ) ; return result ; } catch ( IOException ex ) { zygoteState . close ( ) ; throw new ZygoteStartFailedEx ( ex ) ; } } 
private byte nextTC ( ) throws IOException { if ( hasPushbackTC ) { hasPushbackTC = false ; } else { pushbackTC = input . readByte ( ) ; } return pushbackTC ; } 
private void resetPurgeTimer ( ) { purgeHandler . removeCallbacks ( purger ) ; purgeHandler . postDelayed ( purger , DELAY_BEFORE_PURGE ) ; } 
public void setLineDash ( float phase ) { content . append ( "[]-" ) . append ( phase ) . append ( "-d" ) . append_i ( separator ) ; } 
public int getGroupCount ( ) { return groups . size ( ) ; } 
public Event getNextEvent ( ) { try { Event e = this . first ( ) ; this . remove ( e ) ; eventNumber ++ ; notifyListeners ( ) ; return e ; } catch ( NoSuchElementException nSEE ) { notifyListeners ( ) ; return null ; } } 
public short [ ] getValues ( ) { return Arrays . copyOf ( values , values . length ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '|b' : retval . append ( "|b" ) ; continue ; case '|t' : retval . append ( "|t" ) ; continue ; case '|n' : retval . append ( "|n" ) ; continue ; case '|f' : retval . append ( "|f" ) ; continue ; case '|r' : retval . append ( "|r" ) ; continue ; case '|"' : retval . append ( "|"" ) ; continue ; case '|'' : retval . append ( "|'" ) ; continue ; case '|' : retval . append ( "||" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 || ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "|u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } 
void readBytes ( byte [ ] buffer ) throws IOException { mDexFile . readFully ( buffer ) ; } 
@ PortedFrom ( file = "tRole.h" , name = "setTransitive" ) public void setTransitive ( boolean value ) { transitivity . setValue ( value ) ; inverse ( ) . transitivity . setValue ( value ) ; } 
protected void notifyEdgeDeleted ( Edge e ) { assert ( e != null ) && e . isValid ( ) && containsEdge ( e ) ; if ( graphStructureChangedListenersWithAutoRemoval != null ) { Iterator < WeakReference < GraphStructureChangedListener >> iterator = getListenerListIteratorForAutoRemove ( ) ; while ( iterator . hasNext ( ) ) { GraphStructureChangedListener currentListener = iterator . next ( ) . get ( ) ; if ( currentListener == null ) { iterator . remove ( ) ; } else { currentListener . edgeDeleted ( e ) ; } } setAutoListenerListToNullIfEmpty ( ) ; } int n = graphStructureChangedListeners . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { graphStructureChangedListeners . get ( i ) . edgeDeleted ( e ) ; } } 
static byte [ ] toIntegerBytes ( BigInteger bigInt ) { int bitlen = bigInt . bitLength ( ) ; bitlen = ( ( bitlen + 7 ) >> 3 ) << 3 ; byte [ ] bigBytes = bigInt . toByteArray ( ) ; if ( ( ( bigInt . bitLength ( ) % 8 ) != 0 ) && ( ( ( bigInt . bitLength ( ) / 8 ) + 1 ) == ( bitlen / 8 ) ) ) { return bigBytes ; } int startSrc = 0 ; int len = bigBytes . length ; if ( ( bigInt . bitLength ( ) % 8 ) == 0 ) { startSrc = 1 ; len -- ; } int startDst = bitlen / 8 - len ; byte [ ] resizedBytes = new byte [ bitlen / 8 ] ; System . arraycopy ( bigBytes , startSrc , resizedBytes , startDst , len ) ; return resizedBytes ; } 
public static final DataSource mkDataSource ( final @ Nullable String name , final @ Nullable MimeType contentMimeType , final byte [ ] data ) { class ByteArrayDataSource implements DataSource , Serializable { @ Override public @ Nullable String getName ( ) { return name ; } @ Override public @ Nullable String getContentType ( ) { return ( contentMimeType != null ) ? contentMimeType . toString ( ) : null ; } @ Override public OutputStream getOutputStream ( ) throws IOException { throw new IOException ( ) ; } @ Override public InputStream getInputStream ( ) throws IOException { return new ByteArrayInputStream ( data ) ; } } ; return new ByteArrayDataSource ( ) ; } 
public void start ( ) { thread = new Thread ( this ) ; paused = false ; thread . start ( ) ; } 
public void maybeShare ( Connection connection ) { executorService . submit ( connectionsCleanupCallable ) ; if ( ! connection . isSpdy ( ) ) { return ; } if ( connection . isAlive ( ) ) { synchronized ( this ) { connections . addFirst ( connection ) ; } } } 
public double getDouble ( int parameterIndex ) throws SQLException { return dbCstm . getDouble ( parameterIndex ) ; } 
public void add ( PublicKey pk ) { this . add ( new KeyValue ( this . _doc , pk ) ) ; } 
public final < R > Observable < R > flatMap ( Func1 < ? super T , ? extends Observable < ? extends R >> onNext , Func1 < ? super Throwable , ? extends Observable < ? extends R >> onError , Func0 < ? extends Observable < ? extends R >> onCompleted ) { return merge ( mapNotification ( onNext , onError , onCompleted ) ) ; } 
public final void setMaxVersion ( String tmp ) { maxVersion = Double . parseDouble ( tmp ) ; } 
@ TargetApi ( Build . VERSION_CODES . JELLY_BEAN ) public void setNavigationBarTintDrawable ( Drawable drawable ) { if ( mNavBarAvailable ) { mNavBarTintView . setBackground ( drawable ) ; } } 
public void forceCleanup ( ) { if ( name . equals ( SYSTEM_TABLE ) ) throw new RuntimeException ( "Cleanup-of-the-system-table-is-neither-necessary-nor-wise" ) ; for ( ColumnFamilyStore cfStore : columnFamilyStores . values ( ) ) cfStore . forceCleanup ( ) ; } 
public DiffBuilder append ( final String fieldName , final int lhs , final int rhs ) { if ( fieldName == null ) { throw new IllegalArgumentException ( "Field-name-cannot-be-null" ) ; } if ( objectsTriviallyEqual ) { return this ; } if ( lhs != rhs ) { diffs . add ( new Diff < Integer > ( fieldName ) { private static final long serialVersionUID = 1L ; @ Override public Integer getLeft ( ) { return Integer . valueOf ( lhs ) ; } @ Override public Integer getRight ( ) { return Integer . valueOf ( rhs ) ; } } ) ; } return this ; } 
@ SuppressWarnings ( "unchecked" ) public static ArrayList < Restaurant > Load_RestoData ( ) { ArrayList < Restaurant > all_Resto = new ArrayList < Restaurant > ( ) ; try { all_Resto = ( ArrayList < Restaurant > ) Serializer . deserialize ( filePath + "Restaurant_database.txt" ) ; System . out . println ( "succed-in-loading-the-new-All_resto-database" ) ; System . out . println ( all_Resto ) ; } catch ( IOException | ClassNotFoundException e ) { e . printStackTrace ( ) ; System . out . println ( "error:-fail-to-load-the-All_resto-data" ) ; } return all_Resto ; } 
public static Set < GaiaUser > entitySetToResourceSet ( Set < GaiaUserEntity > entities ) { if ( entities == null ) { return null ; } Set < GaiaUser > resources = new HashSet < GaiaUser > ( entities . size ( ) ) ; for ( GaiaUserEntity entity : entities ) { resources . add ( entityToResource ( entity ) ) ; } return resources ; } 
@ Override @ SuppressWarnings ( "unchecked" ) public boolean remove ( Object o ) { if ( o == null ) { return false ; } for ( int targetIndex = 0 ; targetIndex < size ; targetIndex ++ ) { if ( o . equals ( elements [ targetIndex ] ) ) { removeAt ( targetIndex ) ; return true ; } } return false ; } 
@ Override public boolean isEmpty ( ) { return map . isEmpty ( ) ; } 
public boolean isEmpty ( ) { return len == 1 && strings . size ( ) == 0 ; } 
int get ( ) throws IOException { int c = in . read ( ) ; if ( c >= '-' || c == '|n' || c == EOF ) { return c ; } if ( c == '|r' ) { return '|n' ; } return '-' ; } 
public short getAndAdd ( int i , short value ) { for ( ; ; ) { short oldvalue = ( short ) myArray . get ( i ) ; short newvalue = ( short ) ( oldvalue + value ) ; if ( myArray . compareAndSet ( i , oldvalue , newvalue ) ) return oldvalue ; } } 
void write ( final String data ) throws IOException { this . checkWrite ( ) ; this . m_document . write ( data ) ; } 
public void removeConnectionProperty ( String name ) { connectionProperties . remove ( name ) ; } 
public static void sortOutButton ( AbstractButton button , Image nornal , Image hover , Image pressed ) { button . setIcon ( new ImageIcon ( nornal ) ) ; button . setRolloverIcon ( new ImageIcon ( hover ) ) ; Icon down = new ImageIcon ( pressed ) ; button . setRolloverSelectedIcon ( down ) ; button . setSelectedIcon ( down ) ; button . setPressedIcon ( down ) ; button . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; button . setBorderPainted ( false ) ; button . setFocusPainted ( false ) ; button . setContentAreaFilled ( false ) ; button . setHorizontalTextPosition ( javax . swing . SwingConstants . CENTER ) ; button . addFocusListener ( new ImageButtonFocusListener ( button ) ) ; } 
public static void disableConnectionReuseIfNecessary ( ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . FROYO ) { System . setProperty ( "http.keepAlive" , "false" ) ; } } 
public Response delete ( String bucket , String key , Map headers ) throws MalformedURLException , IOException { return new Response ( makeRequest ( "DELETE" , bucket , Utils . urlencode ( key ) , null , headers ) ) ; } 
public boolean is ( String word ) { return m_Words . contains ( word . toLowerCase ( ) ) ; } 
public static String toString ( boolean [ ] a ) { if ( a == null ) return "null" ; int iMax = a . length - 1 ; if ( iMax == - 1 ) return "[]" ; StringBuilder b = new StringBuilder ( ) ; b . append ( '[' ) ; for ( int i = 0 ; ; i ++ ) { b . append ( a [ i ] ) ; if ( i == iMax ) return b . append ( ']' ) . toString ( ) ; b . append ( ",-" ) ; } } 
public String toXML ( int indent ) { StringBuffer xmlBuf = new StringBuffer ( ) ; synchronized ( xmlBuf ) { for ( int i = 0 ; i < indent ; i ++ ) { xmlBuf . append ( "-" ) ; } xmlBuf . append ( "<SignLanguage-translation="" ) ; xmlBuf . append ( translation ) ; xmlBuf . append ( ""-primary="" ) ; xmlBuf . append ( primary ) ; xmlBuf . append ( """ ) ; if ( type != null ) { xmlBuf . append ( "-type="" ) ; xmlBuf . append ( type ) ; xmlBuf . append ( """ ) ; } xmlBuf . append ( ">" ) ; xmlBuf . append ( lang ) ; xmlBuf . append ( "</SignLanguage>" ) ; return xmlBuf . toString ( ) ; } } 
public String toString ( boolean freq ) { String result = m_attribute . name ( ) + "=" + m_attribute . value ( m_valueIndex ) ; if ( freq ) { result += ":" + m_frequency ; } return result ; } 
public static boolean isExternalStorageEnable ( ) { String state = Environment . getExternalStorageState ( ) ; if ( Environment . MEDIA_MOUNTED . equals ( state ) ) { return true ; } return false ; } 
public FreeText find ( int formId , int sectionId , int id ) { Connection connection = null ; Statement stmt = null ; try { try { connection = dataSource . getConnection ( ) ; try { stmt = connection . createStatement ( ) ; ResultSet result = stmt . executeQuery ( "SELECT-*-FROM-FreeText-where-formID-=-" + formId + "-AND-sectionID-=-" + sectionId + "-AND-id-=-" + id ) ; if ( result . next ( ) ) { return new FreeText ( result . getInt ( "formID" ) , result . getInt ( "sectionID" ) , result . getInt ( "id" ) , result . getString ( "answer" ) ) ; } else { return null ; } } finally { if ( stmt != null ) { stmt . close ( ) ; } } } finally { if ( connection != null ) { connection . close ( ) ; } } } catch ( SQLException ex ) { System . out . println ( "Error-in-find-" + formId ) ; ex . printStackTrace ( ) ; return null ; } } 
public static String dateToMillis ( Date date ) { return zeroPadString ( Long . toString ( date . getTime ( ) ) , 15 ) ; } 
public java . sql . ResultSet getTableTypes ( ) throws SQLException { ArrayList < ResultSetRow > tuples = new ArrayList < ResultSetRow > ( ) ; Field [ ] fields = new Field [ 1 ] ; fields [ 0 ] = new Field ( "" , "TABLE_TYPE" , Types . VARCHAR , 5 ) ; byte [ ] [ ] tableTypeRow = new byte [ 1 ] [ ] ; tableTypeRow [ 0 ] = TABLE_AS_BYTES ; tuples . add ( new ByteArrayRow ( tableTypeRow , getExceptionInterceptor ( ) ) ) ; if ( this . conn . versionMeetsMinimum ( 5 , 0 , 1 ) ) { byte [ ] [ ] viewTypeRow = new byte [ 1 ] [ ] ; viewTypeRow [ 0 ] = VIEW_AS_BYTES ; tuples . add ( new ByteArrayRow ( viewTypeRow , getExceptionInterceptor ( ) ) ) ; } byte [ ] [ ] tempTypeRow = new byte [ 1 ] [ ] ; tempTypeRow [ 0 ] = s2b ( "LOCAL-TEMPORARY" ) ; tuples . add ( new ByteArrayRow ( tempTypeRow , getExceptionInterceptor ( ) ) ) ; return buildResultSet ( fields , tuples ) ; } 
@ Deprecated public static RequestAsyncTask executeMeRequestAsync ( Session session , GraphUserCallback callback ) { return newMeRequest ( session , callback ) . executeAsync ( ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public EclipseClasspath ( Reporter reporter , File workspace , File project , @ SuppressWarnings ( "unused" ) int options ) throws Exception { this . project = project . getCanonicalFile ( ) ; this . workspace = workspace . getCanonicalFile ( ) ; this . reporter = reporter ; db = documentBuilderFactory . newDocumentBuilder ( ) ; parse ( this . project , true ) ; db = null ; } 
public static ArrayList < QuadPixcell > refineSamples ( double ox , double oy , double scale , int smallbit ) { ArrayList < QuadPixcell > results = new ArrayList < > ( 13 ) ; QuadPixcell ori = sampleRefineOri ( ox , oy , scale ) ; results . add ( ori ) ; int checkBit = 0x0001 ; for ( int dir = 0 ; dir < 4 ; dir ++ ) { boolean small = ( checkBit & smallbit ) != 0 ; checkBit <<= 1 ; QuadPixcell [ ] pxes = sampleRefineOriNeibour ( ori , scale , dir , small ) ; results . addAll ( Arrays . asList ( pxes ) ) ; } return results ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public static void noteDifferences ( Comments oldComments , Comments newComments ) { if ( oldComments == null ) { System . out . println ( "Note:-all-the-comments-have-been-newly-generated" ) ; return ; } Iterator iter = oldComments . commentsList_ . iterator ( ) ; while ( iter . hasNext ( ) ) { SingleComment oldComment = ( SingleComment ) ( iter . next ( ) ) ; int idx = Collections . binarySearch ( newComments . commentsList_ , oldComment ) ; if ( idx < 0 ) { System . out . println ( "Warning:-comment-"" + oldComment . id_ + ""-is-no-longer-used." ) ; oldComment . isUsed_ = false ; newComments . commentsList_ . add ( oldComment ) ; } } } 
protected File configFile ( ) { File file = new File ( configFile ) ; if ( ! file . isAbsolute ( ) ) { file = new File ( Bootstrap . getCatalinaBase ( ) , configFile ) ; } return ( file ) ; } 
public ArrayList < PerfTask > extractTasks ( ) { ArrayList < PerfTask > res = new ArrayList < PerfTask > ( ) ; extractTasks ( res , sequence ) ; return res ; } 
@ XmlElementDecl ( namespace = "http://www.nltaxonomie.nl/9.0/basis/bd/items/bd-burgers" , name = "TaxationElsewhereBox3ImmovablePropertyDeductionDescripton" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < Anstring35VItemType > createTaxationElsewhereBox3ImmovablePropertyDeductionDescripton ( Anstring35VItemType value ) { return new JAXBElement < Anstring35VItemType > ( _TaxationElsewhereBox3ImmovablePropertyDeductionDescripton_QNAME , Anstring35VItemType . class , null , value ) ; } 
public void testSerialization ( ) { CategoryStepRenderer r1 = new CategoryStepRenderer ( ) ; CategoryStepRenderer r2 = null ; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; ObjectOutput out = new ObjectOutputStream ( buffer ) ; out . writeObject ( r1 ) ; out . close ( ) ; ObjectInput in = new ObjectInputStream ( new ByteArrayInputStream ( buffer . toByteArray ( ) ) ) ; r2 = ( CategoryStepRenderer ) in . readObject ( ) ; in . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } assertEquals ( r1 , r2 ) ; } 
private void findClassesInApk ( String apkPath , String packageName , Set < String > classNames , Set < String > subpackageNames ) throws IOException { DexFile dexFile = null ; try { dexFile = new DexFile ( apkPath ) ; Enumeration < String > apkClassNames = dexFile . entries ( ) ; while ( apkClassNames . hasMoreElements ( ) ) { String className = apkClassNames . nextElement ( ) ; if ( className . startsWith ( packageName ) ) { String subPackageName = packageName ; int lastPackageSeparator = className . lastIndexOf ( '.' ) ; if ( lastPackageSeparator > 0 ) { subPackageName = className . substring ( 0 , lastPackageSeparator ) ; } if ( subPackageName . length ( ) > packageName . length ( ) ) { subpackageNames . add ( subPackageName ) ; } else if ( isToplevelClass ( className ) ) { classNames . add ( className ) ; } } } } catch ( IOException e ) { if ( false ) { Log . w ( "ClassPathPackageInfoSource" , "Error-finding-classes-at-apk-path:-" + apkPath , e ) ; } } finally { if ( dexFile != null ) { } } } 
public long length ( ) { try { checkClosed ( ) ; return raf . length ( ) ; } catch ( IOException e ) { return - 1L ; } } 
private String [ ] getRequiredSchemes ( final Element providerDef ) { final ArrayList < String > schemes = new ArrayList < String > ( ) ; final NodeList deps = providerDef . getElementsByTagName ( "if-available" ) ; final int count = deps . getLength ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final Element dep = ( Element ) deps . item ( i ) ; String scheme = dep . getAttribute ( "scheme" ) ; if ( scheme != null && scheme . length ( ) > 0 ) { schemes . add ( scheme ) ; } } return schemes . toArray ( new String [ schemes . size ( ) ] ) ; } 
protected boolean teleportRandomly ( ) { double d0 = this . posX + ( this . rand . nextDouble ( ) - 0.5D ) * 64.0D ; double d1 = this . posY + ( double ) ( this . rand . nextInt ( 64 ) - 32 ) ; double d2 = this . posZ + ( this . rand . nextDouble ( ) - 0.5D ) * 64.0D ; return this . teleportTo ( d0 , d1 , d2 ) ; } 
public static Request authenticationRequest ( boolean withAuthenticate ) { Request request = new Request ( REQUEST_TYPE_AUTHENTICATION ) ; request . put ( AuthenticationOperation . PARAM_WITH_AUTHENTICATE , withAuthenticate ) ; request . setMemoryCacheEnabled ( true ) ; return request ; } 
public static Properties getServerProperties ( ) { String fileName = basedir + File . separator + DIR_UPGRADE + File . separator + DIR_CONFIG + File . separator + BACKUP_AMCONFIG ; Properties properties = ( Properties ) propertyFileMap . get ( fileName ) ; if ( properties == null ) { properties = getProperties ( fileName ) ; } return properties ; } 
public boolean isUndef ( Symbol property ) { return ! isDefined ( property ) ; } 
@ XmlElementDecl ( namespace = "http://www.maquina.core.br/domain" , name = "historicoEnvio" ) public JAXBElement < HistoricoEnvio > createHistoricoEnvio ( HistoricoEnvio value ) { return new JAXBElement < HistoricoEnvio > ( _HistoricoEnvio_QNAME , HistoricoEnvio . class , null , value ) ; } 
public static void saveChartAsJPEG ( File file , float quality , JFreeChart chart , int width , int height , ChartRenderingInfo info ) throws IOException { if ( file == null ) { throw new IllegalArgumentException ( "Null-'file'-argument." ) ; } if ( chart == null ) { throw new IllegalArgumentException ( "Null-'chart'-argument." ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; try { writeChartAsJPEG ( out , quality , chart , width , height , info ) ; } finally { out . close ( ) ; } } 
private void linkLast ( E e ) { checkNotNull ( e ) ; final Node < E > newNode = new Node < E > ( e ) ; restartFromTail : for ( ; ; ) for ( Node < E > t = tail , p = t , q ; ; ) { if ( ( q = p . next ) != null && ( q = ( p = q ) . next ) != null ) p = ( t != ( t = tail ) ) ? t : q ; else if ( p . prev == p ) continue restartFromTail ; else { newNode . lazySetPrev ( p ) ; if ( p . casNext ( null , newNode ) ) { if ( p != t ) casTail ( t , newNode ) ; return ; } } } } 
public static String readFully ( Reader reader ) throws IOException { try { StringWriter writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , count ) ; } return writer . toString ( ) ; } finally { reader . close ( ) ; } } 
public void destroy ( ) { URLConnection conn = _conn ; _conn = null ; if ( conn instanceof HttpURLConnection ) ( ( HttpURLConnection ) conn ) . disconnect ( ) ; } 
public FloatPolygon getInterpolatedPolygon ( double interval , boolean smooth ) { FloatPolygon p = ( this instanceof Line ) ? ( ( Line ) this ) . getFloatPoints ( ) : getFloatPolygon ( ) ; return getInterpolatedPolygon ( p , interval , smooth ) ; } 
private static String newString ( final byte [ ] bytes , final Charset charset ) { return bytes == null ? null : new String ( bytes , charset ) ; } 
public boolean isStarted ( ) { return isRunning ( ) ; } 
public ItemStack decrStackSize ( int par1 ) { if ( this . getHasStack ( ) ) { this . amountCrafted += Math . min ( par1 , this . getStack ( ) . stackSize ) ; } return super . decrStackSize ( par1 ) ; } 
private boolean hasPixels ( Image image ) { return image != null && ( image . getHeight ( imageObserver ) > 0 ) && ( image . getWidth ( imageObserver ) > 0 ) ; } 
public DateTime withChronology ( Chronology newChronology ) { newChronology = DateTimeUtils . getChronology ( newChronology ) ; return ( newChronology == getChronology ( ) ? this : new DateTime ( getMillis ( ) , newChronology ) ) ; } 
@ Override public String toString ( ) { return new StringBuilder ( ) . append ( "PersistenceContext[entityKeys=" ) . append ( entitiesByKey . keySet ( ) ) . append ( ",collectionKeys=" ) . append ( collectionsByKey . keySet ( ) ) . append ( "]" ) . toString ( ) ; } 
private static IndexableField getTimestampField ( VTITemplate . ColumnDescriptor keyDescriptor , ResultSet rs , int columnIdx ) throws SQLException { Timestamp value = rs . getTimestamp ( columnIdx ) ; if ( rs . wasNull ( ) ) { return null ; } else { return new StoredField ( keyDescriptor . columnName , value . getTime ( ) ) ; } } 
public void clearParameters ( ) throws SQLException { params . clear ( ) ; } 
public static int clamp ( int value , int min , int max ) { return Math . max ( min , Math . min ( max , value ) ) ; } 
@ SuppressWarnings ( "unchecked" ) protected < T extends ResCloudlet > List < T > getCloudletExecList ( ) { return ( List < T > ) cloudletExecList ; } 
public boolean isValid ( int timeout ) throws SQLException { if ( timeout < 0 ) { throw Util . outOfRangeArgument ( "timeout:-" + timeout ) ; } if ( this . isInternal ) { return true ; } else if ( ! this . isNetConn ) { return ! this . isClosed ( ) ; } else if ( this . isClosed ( ) ) { return false ; } final boolean [ ] flag = new boolean [ ] { true } ; Thread t = new Thread ( ) { public void run ( ) { try { getMetaData ( ) . getDatabaseMajorVersion ( ) ; } catch ( Throwable e ) { flag [ 0 ] = false ; } } } ; if ( timeout > 60 ) { timeout = 60 ; } timeout *= 1000 ; try { t . start ( ) ; final long start = System . currentTimeMillis ( ) ; t . join ( timeout ) ; try { t . setContextClassLoader ( null ) ; } catch ( Throwable th ) { } if ( timeout == 0 ) { return flag [ 0 ] ; } return flag [ 0 ] && ( System . currentTimeMillis ( ) - start ) < timeout ; } catch ( Throwable e ) { return false ; } } 
public static boolean isConformantSchemeName ( String p_scheme ) { if ( p_scheme == null || p_scheme . trim ( ) . length ( ) == 0 ) { return false ; } if ( ! isAlpha ( p_scheme . charAt ( 0 ) ) ) { return false ; } char testChar ; for ( int i = 1 ; i < p_scheme . length ( ) ; i ++ ) { testChar = p_scheme . charAt ( i ) ; if ( ! isAlphanum ( testChar ) && SCHEME_CHARACTERS . indexOf ( testChar ) == - 1 ) { return false ; } } return true ; } 
public List < OT2AGREEMENT > getAGREEMENT ( ) { if ( agreement == null ) { agreement = new ArrayList < OT2AGREEMENT > ( ) ; } return this . agreement ; } 
@ Override protected synchronized void startInternal ( ) throws LifecycleException { String format = getFileDateFormat ( ) ; fileDateFormatter = new SimpleDateFormat ( format , Locale . US ) ; fileDateFormatter . setTimeZone ( TimeZone . getDefault ( ) ) ; dateStamp = fileDateFormatter . format ( new Date ( System . currentTimeMillis ( ) ) ) ; if ( rotatable && renameOnRotate ) { restore ( ) ; } open ( ) ; super . startInternal ( ) ; } 
public static com . appspot . cpd200_extras . conference . Conference buildServiceHandler ( Context context , String email ) { GoogleAccountCredential credential = GoogleAccountCredential . usingAudience ( context , AppConstants . AUDIENCE ) ; credential . setSelectedAccountName ( email ) ; com . appspot . cpd200_extras . conference . Conference . Builder builder = new com . appspot . cpd200_extras . conference . Conference . Builder ( AppConstants . HTTP_TRANSPORT , AppConstants . JSON_FACTORY , credential ) ; builder . setApplicationName ( "conference-central-server" ) ; return builder . build ( ) ; } 
public void notifyObservers ( ) { notifyObservers ( null ) ; } 
public static Graph binaryTree ( int V ) { Graph G = new Graph ( V ) ; int [ ] vertices = new int [ V ] ; for ( int i = 0 ; i < V ; i ++ ) vertices [ i ] = i ; StdRandom . shuffle ( vertices ) ; for ( int i = 1 ; i < V ; i ++ ) { G . addEdge ( vertices [ i ] , vertices [ ( i - 1 ) / 2 ] ) ; } return G ; } 
public String [ ] getOptions ( ) { Vector result ; result = new Vector ( ) ; result . add ( "-S" ) ; result . add ( "" + getSeed ( ) ) ; return ( String [ ] ) result . toArray ( new String [ result . size ( ) ] ) ; } 
public BasicBlock nextItem ( ) { return workList . removeFirst ( ) ; } 
public String getResolverProperty ( String key ) { return ( String ) this . _resolverProperties . get ( key ) ; } 
public AnyType element ( ) { if ( isEmpty ( ) ) throw new NoSuchElementException ( ) ; return array [ 1 ] ; } 
public void setHasParams ( ) { if ( _paramTypes == null ) _paramTypes = new ArrayList < String > ( ) ; } 
private void doParse ( ) { output . setText ( "" ) ; String data = input . getText ( ) ; if ( data . trim ( ) . length ( ) == 0 ) { output . setText ( "ERROR:-There-is-no-text-in-the-input-box!-" ) ; return ; } Document xmldoc ; try { DocumentBuilder docReader = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; xmldoc = docReader . parse ( new InputSource ( new StringReader ( data ) ) ) ; } catch ( Exception e ) { output . setText ( "ERROR:-The-input-is-not-well-formed-XML.-" + e ) ; return ; } output . append ( "Input-has-been-parsed-successfully.-" ) ; output . append ( "Nodes-in-the-DOM-representation:-" ) ; Element root = xmldoc . getDocumentElement ( ) ; listNodes ( root , "" , 1 ) ; } 
private short computeChecksum ( byte [ ] hdrBytes , int endByteOffset ) { int startByteOffset = endByteOffset - getHeaderLen ( ) ; short checkSum = ( short ) 0 ; int sum = 0 , carry = 0 , finalSum = 0 ; int parsedHex = 0 ; int checksumStartByte = startByteOffset + getfieldOffset ( CHECKSUM ) / NetUtils . NumBitsInAByte ; for ( int i = startByteOffset ; i <= ( endByteOffset - 1 ) ; i = i + 2 ) { if ( i == checksumStartByte ) continue ; StringBuffer sbuffer = new StringBuffer ( ) ; sbuffer . append ( String . format ( "%02X" , hdrBytes [ i ] ) ) ; if ( i < ( hdrBytes . length - 1 ) ) sbuffer . append ( String . format ( "%02X" , hdrBytes [ i + 1 ] ) ) ; parsedHex = Integer . valueOf ( sbuffer . toString ( ) , 16 ) ; sum += parsedHex ; } carry = ( sum >> 16 ) & 0xFF ; finalSum = ( sum & 0xFFFF ) + carry ; checkSum = ( short ) ~ ( ( short ) finalSum & 0xFFFF ) ; return checkSum ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
private void ensureCapacity ( int size ) { if ( size > data . length ) { Object [ ] oldData = this . data ; int newSize = data . length * 2 ; if ( newSize < size ) { newSize = size ; } this . data = new Object [ newSize ] ; System . arraycopy ( oldData , 0 , this . data , 0 , oldData . length ) ; } } 
public String getParam ( String name ) { if ( params == null ) { return null ; } return params . getProperty ( name ) ; } 
public void setEmail ( String email ) { this . email = email == null ? null : email . trim ( ) ; } 
public void writeDouble ( double val ) throws IOException { bout . writeDouble ( val ) ; } 
String renameType ( Type type ) { if ( type == null ) { return null ; } if ( type . getSort ( ) == Type . OBJECT ) { String in = type . getInternalName ( ) ; return "L" + renameInternalType ( in ) + ";" ; } else if ( type . getSort ( ) == Type . ARRAY ) { StringBuilder sb = new StringBuilder ( ) ; for ( int n = type . getDimensions ( ) ; n > 0 ; n -- ) { sb . append ( '[' ) ; } sb . append ( renameType ( type . getElementType ( ) ) ) ; return sb . toString ( ) ; } return type . getDescriptor ( ) ; } 
private void handleLocation ( LocationPoint locationNode , Attributes attributes ) { try { double longitude = Double . parseDouble ( attributes . getValue ( ATTR_LONGITUDE ) ) ; double latitude = Double . parseDouble ( attributes . getValue ( ATTR_LATITUDE ) ) ; locationNode . setLocation ( longitude , latitude ) ; } catch ( NumberFormatException e ) { } } 
public List getAvailablePairsAfter ( Unit u ) { return unitToPairsAfter . get ( u ) ; } 
public static boolean isZoomTrigger ( MouseEvent ev ) { return Platform . isMac ? ( ( ev . getButton ( ) == MouseEvent . BUTTON1 && ev . isMetaDown ( ) ) || ( ev . getButton ( ) == MouseEvent . BUTTON2 ) ) : ( ev . getButton ( ) == MouseEvent . BUTTON2 || ev . isMetaDown ( ) ) ; } 
public com . google . protobuf . ByteString getIdBytes ( ) { java . lang . Object ref = id_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; id_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public Date getDate ( Integer id ) { Object [ ] obj = timerTable . get ( id ) ; if ( obj != null ) { Date date = ( Date ) obj [ TIMER_DATE_INDEX ] ; return ( new Date ( date . getTime ( ) ) ) ; } return null ; } 
public void save ( String outputPath ) { System . out . print ( "Saving-network:-" + outputPath ) ; BufferedWriter bufWriter = null ; try { bufWriter = new BufferedWriter ( new FileWriter ( outputPath ) ) ; String line = "ARCID;HEAD;TAIL;WEIGHT" ; bufWriter . write ( line ) ; bufWriter . newLine ( ) ; } catch ( NumberFormatException ex ) { ex . printStackTrace ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } finally { try { bufWriter . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } System . out . print ( "-..Saved" ) ; } 
public static double parseDouble ( String s ) throws NumberFormatException { return FloatingDecimal . readJavaFormatString ( s ) . doubleValue ( ) ; } 
private static double shiftWithNoZeroCrossing ( double value , double delta ) { if ( value > 0.0 ) { return Math . max ( value + delta , 0.0 ) ; } else if ( value < 0.0 ) { return Math . min ( value + delta , 0.0 ) ; } else { return value + delta ; } } 
public static String listToEnglishCompound ( Collection < ? > list , String prefix , String suffix ) { StringBuilder builder = new StringBuilder ( ) ; int i = 0 ; for ( Object str : list ) { if ( i != 0 ) { if ( i == list . size ( ) - 1 ) { builder . append ( "-and-" ) ; } else { builder . append ( ",-" ) ; } } builder . append ( prefix ) . append ( str ) . append ( suffix ) ; i ++ ; } return builder . toString ( ) ; } 
public synchronized void setMaxSize ( long maxSize ) { this . maxSize = maxSize ; executorService . submit ( cleanupCallable ) ; } 
protected void postFocusEvent ( int id , boolean temporary ) { q ( ) . postEvent ( new FocusEvent ( awtComponent , id , temporary ) ) ; } 
public void addCallback ( Callback callback ) { if ( ! callbacks . contains ( callback ) ) { callbacks . add ( callback ) ; } } 
public boolean sendString ( String string ) { return sendByteArray ( string . getBytes ( ) ) ; } 
public boolean isUseCaseSelected ( String feat , String uc ) { Object [ ] featureUseCase = getUseCase ( feat , uc ) ; if ( featureUseCase [ 1 ] != null ) { List < UseCase > usecases = selectedUseCases . get ( featureUseCase [ 0 ] ) ; return ( usecases != null && usecases . contains ( featureUseCase [ 1 ] ) ) ; } return false ; } 
public void invalidate ( Rect dirty ) { final int scrollX = mScrollX ; final int scrollY = mScrollY ; invalidateInternal ( dirty . left - scrollX , dirty . top - scrollY , dirty . right - scrollX , dirty . bottom - scrollY , true , false ) ; } 
public static < T > Enumeration < T > asEnumeration ( final Iterator < T > iterator ) { checkNotNull ( iterator ) ; return new Enumeration < T > ( ) { @ Override public boolean hasMoreElements ( ) { return iterator . hasNext ( ) ; } @ Override public T nextElement ( ) { return iterator . next ( ) ; } } ; } 
protected static ForkJoinTask < ? > peekNextLocalTask ( ) { return ( ( ForkJoinWorkerThread ) Thread . currentThread ( ) ) . peekTask ( ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
protected AttrImpl ( CoreDocumentImpl ownerDocument , String name ) { super ( ownerDocument ) ; this . name = name ; isSpecified ( true ) ; hasStringValue ( true ) ; } 
protected String getTimestamp ( ) { Date now = Calendar . getInstance ( ) . getTime ( ) ; SimpleDateFormat formatter = new SimpleDateFormat ( "yyyyMMdd'T'HH:mm:ss" ) ; try { return formatter . format ( now ) ; } catch ( Exception e ) { throw new RpcError ( e ) ; } } 
public Charset charset ( Charset defaultValue ) { return charset != null ? Charset . forName ( charset ) : defaultValue ; } 
public synchronized void setMaxSize ( long maxSize ) { this . maxSize = maxSize ; executorService . submit ( cleanupCallable ) ; } 
public synchronized void print ( String s , int _verbosity , int log ) throws OutputException { if ( log == NO_LOGS ) return ; if ( log == ALL_MESSAGE_LOGS ) for ( int x = 0 ; x < logs . size ( ) ; x ++ ) { Log l = ( Log ) logs . elementAt ( x ) ; if ( l == null ) throw new OutputException ( "Unknown-log-number" + l ) ; print ( s , V_VERBOSE , l ) ; } else { Log l = ( Log ) logs . elementAt ( log ) ; if ( l == null ) throw new OutputException ( "Unknown-log-number" + log ) ; print ( s , V_VERBOSE , l ) ; } } 
@ SuppressWarnings ( "unchecked" ) public boolean containsKey ( Object key ) { Segment < K , V > s ; HashEntry < K , V > [ ] tab ; int h = hash ( key . hashCode ( ) ) ; long u = ( ( ( h >>> segmentShift ) & segmentMask ) << SSHIFT ) + SBASE ; if ( ( s = ( Segment < K , V > ) UNSAFE . getObjectVolatile ( segments , u ) ) != null && ( tab = s . table ) != null ) { for ( HashEntry < K , V > e = ( HashEntry < K , V > ) UNSAFE . getObjectVolatile ( tab , ( ( long ) ( ( ( tab . length - 1 ) & h ) ) << TSHIFT ) + TBASE ) ; e != null ; e = e . next ) { K k ; if ( ( k = e . key ) == key || ( e . hash == h && key . equals ( k ) ) ) return true ; } } return false ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; javax . xml . namespace . NamespaceContext nsContext = xmlWriter . getNamespaceContext ( ) ; while ( true ) { java . lang . String uri = nsContext . getNamespaceURI ( prefix ) ; if ( uri == null || uri . length ( ) == 0 ) { break ; } prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public boolean readBool ( ) throws IOException { return in . readBoolean ( ) ; } 
public ArrayList < Entity > intersectOnRender ( Shape shape ) { Area a1 = new Area ( shape ) ; ArrayList < Entity > retEnts = new ArrayList < Entity > ( ) ; for ( Entity ent : entityMap . values ( ) ) { Point p = Utils . convCartToIso ( new Point ( ent . xCoord , ent . yCoord ) ) ; Area a2 = new Area ( new Rectangle ( p . x , p . y , ent . getWidth ( ) , ent . getHeight ( ) ) ) ; a2 . intersect ( a1 ) ; if ( ! a2 . isEmpty ( ) ) { retEnts . add ( ent ) ; } } return retEnts ; } 
public static String toString ( double [ ] [ ] m ) { if ( m == null ) return "(double[][])null" ; StringBuffer sb = new StringBuffer ( ) ; sb . append ( "new-double[][]{" ) ; for ( int i = 0 ; i < m . length ; i ++ ) { if ( i > 0 ) sb . append ( ",-" ) ; if ( m [ i ] == null ) sb . append ( "null" ) ; else { sb . append ( "{" ) ; for ( int j = 0 ; j < m [ i ] . length ; j ++ ) { if ( j > 0 ) sb . append ( ",-" ) ; sb . append ( String . valueOf ( m [ i ] [ j ] ) ) ; } sb . append ( "}" ) ; } } sb . append ( "}" ) ; return sb . toString ( ) ; } 
public void removePCMProcessor ( PCMProcessor processor ) { synchronized ( pcmProcessors ) { pcmProcessors . remove ( processor ) ; } } 
public Rectangle2D getBounds2D ( ParameterBlock paramBlock ) { RenderableImage source = paramBlock . getRenderableSource ( 0 ) ; double scaleX = paramBlock . getDoubleParameter ( 0 ) ; double scaleY = paramBlock . getDoubleParameter ( 1 ) ; float x0 = ( float ) source . getMinX ( ) ; float y0 = ( float ) source . getMinY ( ) ; float w = ( float ) source . getWidth ( ) ; float h = ( float ) source . getHeight ( ) ; float d_x0 = ( float ) ( x0 * scaleX ) ; float d_y0 = ( float ) ( y0 * scaleY ) ; float d_w = ( float ) ( w * scaleX ) ; float d_h = ( float ) ( h * scaleY ) ; return new Rectangle2D . Float ( d_x0 , d_y0 , d_w , d_h ) ; } 
public void setDefaultCloseOperation ( int operation ) { if ( operation != DO_NOTHING_ON_CLOSE && operation != HIDE_ON_CLOSE && operation != DISPOSE_ON_CLOSE && operation != EXIT_ON_CLOSE ) { throw new IllegalArgumentException ( "defaultCloseOperation-must-be-one-of:-DO_NOTHING_ON_CLOSE,-HIDE_ON_CLOSE,-DISPOSE_ON_CLOSE,-or-EXIT_ON_CLOSE" ) ; } if ( operation == EXIT_ON_CLOSE ) { SecurityManager security = System . getSecurityManager ( ) ; if ( security != null ) { security . checkExit ( 0 ) ; } } if ( this . defaultCloseOperation != operation ) { int oldValue = this . defaultCloseOperation ; this . defaultCloseOperation = operation ; firePropertyChange ( "defaultCloseOperation" , oldValue , operation ) ; } } 
public static String normalizeMimeType ( String type ) { if ( type == null ) { return null ; } type = type . trim ( ) . toLowerCase ( Locale . US ) ; final int semicolonIndex = type . indexOf ( ';' ) ; if ( semicolonIndex != - 1 ) { type = type . substring ( 0 , semicolonIndex ) ; } return type ; } 
public String toJson ( Object src , Type typeOfSrc ) { StringWriter writer = new StringWriter ( ) ; toJson ( src , typeOfSrc , writer ) ; return writer . toString ( ) ; } 
public OutputStream newDeflaterOutputStream ( OutputStream out , Deflater deflater , boolean syncFlush ) { try { Constructor < DeflaterOutputStream > constructor = deflaterConstructor ; if ( constructor == null ) { constructor = deflaterConstructor = DeflaterOutputStream . class . getConstructor ( OutputStream . class , Deflater . class , boolean . class ) ; } return constructor . newInstance ( out , deflater , syncFlush ) ; } catch ( NoSuchMethodException e ) { throw new UnsupportedOperationException ( "Cannot-SPDY;-no-SYNC_FLUSH-available" ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) instanceof RuntimeException ? ( RuntimeException ) e . getCause ( ) : new RuntimeException ( e . getCause ( ) ) ; } catch ( InstantiationException e ) { throw new RuntimeException ( e ) ; } catch ( IllegalAccessException e ) { throw new AssertionError ( ) ; } } 
public void updateWeatherData ( ) { Cursor c = null ; final WeatherData weatherData = WeatherData . getInstance ( ) ; try { c = mContext . getContentResolver ( ) . query ( WeatherData . CONTENT_URI , null , null , null , null ) ; if ( c != null && c . getCount ( ) > 0 ) { final String relcity = WeatherData . KEY_RELCITY ; final String description = WeatherData . KEY_DESCRIPTION ; final String temperature = WeatherData . KEY_TEMPERATURE ; final String temperature_now = WeatherData . KEY_TEMPERATURE_NOW ; c . moveToFirst ( ) ; if ( c . getString ( c . getColumnIndex ( relcity ) ) == null || c . getString ( c . getColumnIndex ( description ) ) == null || c . getString ( c . getColumnIndex ( temperature ) ) == null || c . getString ( c . getColumnIndex ( temperature_now ) ) == null ) { c . close ( ) ; return ; } weatherData . setCity ( c . getString ( c . getColumnIndex ( relcity ) ) ) ; parseAndSetTemperatrue ( c . getString ( c . getColumnIndex ( temperature ) ) , c . getString ( c . getColumnIndex ( temperature_now ) ) ) ; try { String description1 = c . getString ( c . getColumnIndex ( description ) ) ; weatherData . setWeather ( parseWeatherType ( description1 ) , description1 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } weatherData . dataChanged ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { if ( c != null ) c . close ( ) ; } } 
public void addPart ( String key , Object value ) { jsonParams . put ( key , value ) ; } 
public final void init ( AlgorithmParameterSpec genParamSpec , SecureRandom random ) throws InvalidAlgorithmParameterException { spiImpl . engineInit ( genParamSpec , random ) ; } 
protected void paints ( Painter painter ) { painter . drawRect ( _x , _y , _width , _height ) ; painter . drawImage ( _images . get ( _state ) . getImage ( ) , _x , _y , _width , _height , null ) ; } 
public synchronized Vector < Integer > getNotificationIDs ( String type ) { String s ; Vector < Integer > v = new Vector < Integer > ( ) ; for ( Map . Entry < Integer , Object [ ] > entry : timerTable . entrySet ( ) ) { Object [ ] obj = entry . getValue ( ) ; s = ( ( TimerNotification ) obj [ TIMER_NOTIF_INDEX ] ) . getType ( ) ; if ( ( type == null ) ? s == null : type . equals ( s ) ) v . addElement ( entry . getKey ( ) ) ; } return v ; } 
@ Override protected void initFromFile ( ByteSequence bytes , boolean wide ) throws IOException { length = 3 ; index = bytes . readShort ( ) ; } 
public String getAnnotationValue ( String field ) { return fields . get ( field ) ; } 
public BiomeGenBase [ ] loadBlockGeneratorData ( BiomeGenBase [ ] par1ArrayOfBiomeGenBase , int par2 , int par3 , int par4 , int par5 ) { if ( par1ArrayOfBiomeGenBase == null || par1ArrayOfBiomeGenBase . length < par4 * par5 ) { par1ArrayOfBiomeGenBase = new BiomeGenBase [ par4 * par5 ] ; } Arrays . fill ( par1ArrayOfBiomeGenBase , 0 , par4 * par5 , this . biomeGenerator ) ; return par1ArrayOfBiomeGenBase ; } 
void checkAllDefined ( DiagnosticPosition pos , ClassSymbol c ) { try { MethodSymbol undef = firstUndef ( c , c ) ; if ( undef != null ) { if ( ( c . flags ( ) & ENUM ) != 0 && types . supertype ( c . type ) . tsym == syms . enumSym && ( c . flags ( ) & FINAL ) == 0 ) { c . flags_field |= ABSTRACT ; } else { MethodSymbol undef1 = new MethodSymbol ( undef . flags ( ) , undef . name , types . memberType ( c . type , undef ) , undef . owner ) ; log . error ( pos , "does.not.override.abstract" , c , undef1 , undef1 . location ( ) ) ; } } } catch ( CompletionFailure ex ) { completionError ( pos , ex ) ; } } 
public boolean hasVertex ( String s ) { return vertexLabels . containsValue ( s ) ; } 
public Request addRequestHeader ( String header , String value ) { if ( header == null ) { throw new NullPointerException ( "header-cannot-be-null" ) ; } if ( header . contains ( ":" ) ) { throw new IllegalArgumentException ( "header-may-not-contain-':'" ) ; } if ( value == null ) { value = "" ; } mRequestHeaders . add ( Pair . create ( header , value ) ) ; return this ; } 
public static JPanel createTablePanel ( final TableModel model ) { final JPanel panel = new JPanel ( new BorderLayout ( ) ) ; final JTable table = new JTable ( model ) ; for ( int columnIndex = 0 ; columnIndex < model . getColumnCount ( ) ; columnIndex ++ ) { final TableColumn column = table . getColumnModel ( ) . getColumn ( columnIndex ) ; final Class c = model . getColumnClass ( columnIndex ) ; if ( c . equals ( Number . class ) ) { column . setCellRenderer ( new NumberCellRenderer ( ) ) ; } } panel . add ( new JScrollPane ( table ) ) ; return panel ; } 
public void interpretLine ( String line ) { String answerString = interpreter . executeExpression ( line ) ; answer . displayText ( answerString ) ; answer . displayPrompt ( ) ; } 
private static synchronized byte [ ] getUnixDeviceRandom ( int numBytes ) { byte [ ] bytes = new byte [ numBytes ] ; int total = 0 ; int bytesRead ; int offset = 0 ; try { for ( ; ; ) { bytesRead = fis . read ( bytes , offset , numBytes - total ) ; if ( bytesRead == - 1 ) { throw new ProviderException ( "bytesRead-==--1" ) ; } total += bytesRead ; offset += bytesRead ; if ( total >= numBytes ) { break ; } } } catch ( IOException e ) { throw new ProviderException ( "ATTENTION:-IOException-in-RandomBitsSupplier.getLinuxRandomBits():-" + e ) ; } return bytes ; } 
private void setThumbPos ( float position ) { final Rect container = mContainerRect ; final int top = container . top ; final int bottom = container . bottom ; final View trackImage = mTrackImage ; final View thumbImage = mThumbImage ; final float min = trackImage . getTop ( ) ; final float max = trackImage . getBottom ( ) ; final float offset = min ; final float range = max - min ; final float thumbMiddle = position * range + offset ; thumbImage . setTranslationY ( thumbMiddle - thumbImage . getHeight ( ) / 2 ) ; final View previewImage = mPreviewImage ; final float previewHalfHeight = previewImage . getHeight ( ) / 2f ; final float previewPos ; switch ( mOverlayPosition ) { case OVERLAY_AT_THUMB : previewPos = thumbMiddle ; break ; case OVERLAY_ABOVE_THUMB : previewPos = thumbMiddle - previewHalfHeight ; break ; case OVERLAY_FLOATING : default : previewPos = 0 ; break ; } final float minP = top + previewHalfHeight ; final float maxP = bottom - previewHalfHeight ; final float previewMiddle = MathUtils . constrain ( previewPos , minP , maxP ) ; final float previewTop = previewMiddle - previewHalfHeight ; previewImage . setTranslationY ( previewTop ) ; mPrimaryText . setTranslationY ( previewTop ) ; mSecondaryText . setTranslationY ( previewTop ) ; } 
public void addLoanItem ( LoanedItem item ) { if ( ! loanedItems . contains ( item ) ) { loanedItems . add ( item ) ; } } 
String formatDate ( LocalDateTime date ) { if ( date == null ) { return "<no-date>" ; } else { return date . format ( dateOutputFormat ) ; } } 
public final int sign ( byte [ ] outbuf , int offset , int len ) throws SignatureException { if ( outbuf == null || offset < 0 || len < 0 || offset + len > outbuf . length ) { throw new IllegalArgumentException ( Messages . getString ( "security.05" ) ) ; } if ( state != SIGN ) { throw new SignatureException ( Messages . getString ( "security.27" ) ) ; } return engineSign ( outbuf , offset , len ) ; } 
@ Override public final void event ( Request request , Response response , CometEvent event ) throws IOException , ServletException { request . getHost ( ) . getPipeline ( ) . getFirst ( ) . event ( request , response , event ) ; } 
@ Override protected Class < ? > resolveProxyClass ( String [ ] interfaces ) throws IOException , ClassNotFoundException { ClassLoader latestLoader ; if ( classLoaders != null && classLoaders . length > 0 ) { latestLoader = classLoaders [ 0 ] ; } else { latestLoader = null ; } ClassLoader nonPublicLoader = null ; boolean hasNonPublicInterface = false ; Class < ? > [ ] classObjs = new Class [ interfaces . length ] ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { Class < ? > cl = this . resolveClass ( interfaces [ i ] ) ; if ( latestLoader == null ) latestLoader = cl . getClassLoader ( ) ; if ( ( cl . getModifiers ( ) & Modifier . PUBLIC ) == 0 ) { if ( hasNonPublicInterface ) { if ( nonPublicLoader != cl . getClassLoader ( ) ) { throw new IllegalAccessError ( "conflicting-non-public-interface-class-loaders" ) ; } } else { nonPublicLoader = cl . getClassLoader ( ) ; hasNonPublicInterface = true ; } } classObjs [ i ] = cl ; } try { return Proxy . getProxyClass ( hasNonPublicInterface ? nonPublicLoader : latestLoader , classObjs ) ; } catch ( IllegalArgumentException e ) { throw new ClassNotFoundException ( null , e ) ; } } 
public T get ( ) { NamedProvider < T > item = ref . get ( ) ; return item != null ? item . impl . get ( ) : null ; } 
public String getQName ( int i ) { return ( ( Attr ) m_attrs . item ( i ) ) . getName ( ) ; } 
public void _write ( OutputStream output ) { output . write_TypeCode ( value ) ; } 
public void addParameter ( ParameterInfo parameter ) { synchronized ( parameters ) { ParameterInfo results [ ] = new ParameterInfo [ parameters . length + 1 ] ; System . arraycopy ( parameters , 0 , results , 0 , parameters . length ) ; results [ parameters . length ] = parameter ; parameters = results ; this . info = null ; } } 
public lalr_item ( production prod , int pos , terminal_set look ) throws internal_error { super ( prod , pos ) ; _lookahead = look ; _propagate_items = new Stack ( ) ; needs_propagation = true ; } 
public int getRulesCount ( ) { return rules . size ( ) ; } 
@ XmlElementDecl ( namespace = "urn:schemas-microsoft-com:office:excel" , name = "ScriptText" , scope = CTClientData . class ) public JAXBElement < String > createCTClientDataScriptText ( String value ) { return new JAXBElement < String > ( _CTClientDataScriptText_QNAME , String . class , CTClientData . class , value ) ; } 
private boolean containsPairSum11 ( List < Integer > selectedCards ) { for ( int sk1 = 0 ; sk1 < selectedCards . size ( ) ; sk1 ++ ) { int k1 = selectedCards . get ( sk1 ) . intValue ( ) ; for ( int sk2 = sk1 + 1 ; sk2 < selectedCards . size ( ) ; sk2 ++ ) { int k2 = selectedCards . get ( sk2 ) . intValue ( ) ; if ( cardAt ( k1 ) . pointValue ( ) + cardAt ( k2 ) . pointValue ( ) == 11 ) { return true ; } } } return false ; } 
private void add ( final String currName , ConfigProperty a_cp ) { List props = ( List ) m_metaMap . get ( currName ) ; if ( null == props ) { props = Collections . synchronizedList ( new ArrayList ( ) ) ; m_metaMap . put ( currName , props ) ; } props . add ( a_cp ) ; } 
public static String createValidECMAIdentifier ( String origIdentifier ) { return origIdentifier . replace ( "-" , "$_" ) ; } 
public void curveTo ( Function xf , Function yf , double t0 , double t1 ) { flush ( ) ; double dt = ( t1 - t0 ) ; double dx0 = xf . getDerivative ( t0 ) * dt ; double dx1 = xf . getDerivative ( t1 ) * dt ; double dy0 = yf . getDerivative ( t0 ) * dt ; double dy1 = yf . getDerivative ( t1 ) * dt ; double x0 = xf . evaluate ( t0 ) ; double x1 = xf . evaluate ( t1 ) ; double y0 = yf . evaluate ( t0 ) ; double y1 = yf . evaluate ( t1 ) ; g . curveTo ( ( float ) ( x0 + dx0 / 3 ) , ( float ) ( y0 + dy0 / 3 ) , ( float ) ( x1 - dx1 / 3 ) , ( float ) ( y1 - dy1 / 3 ) , ( float ) ( x1 ) , ( float ) ( y1 ) ) ; } 
public void calculateDependents ( ) { dependents = new HashMap < String , Set < String >> ( ) ; for ( String s : packages . keySet ( ) ) { Package p = packages . get ( s ) ; for ( String d : p . dependencies ( ) ) { Set < String > ss = dependents . get ( d ) ; if ( ss == null ) { ss = new HashSet < String > ( ) ; dependents . put ( d , ss ) ; } ss . add ( s ) ; Package dp = packages . get ( d ) ; if ( dp != null ) { dp . addDependent ( p . name ( ) ) ; } } } } 
public void grabFocus ( ) { m_TextSearch . grabFocus ( ) ; } 
protected int makePressColor ( ) { int r = ( this . backgroundColor >> 16 ) & 0xFF ; int g = ( this . backgroundColor >> 8 ) & 0xFF ; int b = ( this . backgroundColor >> 0 ) & 0xFF ; return Color . argb ( 128 , r , g , b ) ; } 
public ByteBuffer getBuffer ( int size ) { Queue < WeakReference < ByteBuffer >> list = buffersBySize . get ( size ) ; if ( list == null ) { return ByteBuffer . allocateDirect ( size ) ; } WeakReference < ByteBuffer > ref ; while ( ( ref = list . poll ( ) ) != null ) { ByteBuffer b = ref . get ( ) ; if ( b != null ) { return b ; } } return ByteBuffer . allocateDirect ( size ) ; } 
public void run ( ) { inList = new ArrayList < Integer > ( ) ; while ( sc . hasNextInt ( ) ) { inList . add ( sc . nextInt ( ) ) ; } insertionSort ( inList , inList . size ( ) ) ; for ( int i = 0 ; i < inList . size ( ) ; i ++ ) { System . out . println ( inList . get ( i ) ) ; } } 
private void updateRGBfromHSV ( ) { int color = Color . HSVToColor ( mHSV ) ; mRGB [ 0 ] = Color . red ( color ) ; mRGB [ 1 ] = Color . green ( color ) ; mRGB [ 2 ] = Color . blue ( color ) ; } 
public String getDatabaseProductVersion ( ) throws SQLException { return this . conn . getServerVersion ( ) ; } 
public synchronized String toString ( String charsetName ) throws UnsupportedEncodingException { return new String ( buf , 0 , count , charsetName ) ; } 
public String getValue ( int index ) { int valueIndex = index * 2 + 1 ; if ( valueIndex < 0 || valueIndex >= namesAndValues . size ( ) ) { return null ; } return namesAndValues . get ( valueIndex ) ; } 
public F getInstance ( final String pattern , TimeZone timeZone , Locale locale ) { if ( pattern == null ) { throw new NullPointerException ( "pattern-must-not-be-null" ) ; } if ( timeZone == null ) { timeZone = TimeZone . getDefault ( ) ; } if ( locale == null ) { locale = Locale . getDefault ( ) ; } final MultiKey key = new MultiKey ( pattern , timeZone , locale ) ; F format = cInstanceCache . get ( key ) ; if ( format == null ) { format = createInstance ( pattern , timeZone , locale ) ; final F previousValue = cInstanceCache . putIfAbsent ( key , format ) ; if ( previousValue != null ) { format = previousValue ; } } return format ; } 
public void translate ( int x , int y ) { mGraphics . translate ( x , y ) ; } 
public Locale getLocale ( ) { String language = properties . getProperty ( KEY_LOCALE_LANGUAGE , DEFAULT_LOCALE_LANGUAGE ) ; String country = properties . getProperty ( KEY_LOCALE_COUNTRY , DEFAULT_LOCALE_COUNTRY ) ; String variant = properties . getProperty ( KEY_LOCALE_VARIANT , DEFAULT_LOCALE_VARIANT ) ; return new Locale ( language , country , variant ) ; } 
@ Override public void setTarget ( Object target ) { if ( mTarget != target ) { final Object oldTarget = mTarget ; mTarget = target ; if ( oldTarget != null && target != null && oldTarget . getClass ( ) == target . getClass ( ) ) { return ; } mInitialized = false ; } } 
public boolean before ( Time that ) { return Time . compare ( this , that ) < 0 ; } 
public final int getAndDecrement ( ) { for ( ; ; ) { int current = get ( ) ; int next = current - 1 ; if ( compareAndSet ( current , next ) ) return current ; } } 
public byte readByte ( ) { if ( position == slice . length ( ) ) { throw new IndexOutOfBoundsException ( ) ; } return slice . getByte ( position ++ ) ; } 
private void compilePredicates ( int opPos , Expression [ ] predicates ) throws TransformerException { for ( int i = 0 ; OpCodes . OP_PREDICATE == getOp ( opPos ) ; i ++ ) { predicates [ i ] = predicate ( opPos ) ; opPos = getNextOpPos ( opPos ) ; } } 
public static String toString ( InputStream input , String encoding ) throws IOException { StringBuilderWriter sw = new StringBuilderWriter ( ) ; copy ( input , sw , encoding ) ; return sw . toString ( ) ; } 
public boolean hasEvent ( ) { return fieldSetFlags ( ) [ 1 ] ; } 
public static String getGlassfishVersion ( ) { final String version = System . getProperty ( "glassfish.version" ) ; return version ; } 
public boolean isOutDated ( ) { return isOutDated ( true ) ; } 
public final Observable < T > throttleLast ( long intervalDuration , TimeUnit unit , Scheduler scheduler ) { return sample ( intervalDuration , unit , scheduler ) ; } 
public ResourceBundle [ ] getResourceSet ( String name ) { return _sets . get ( name ) ; } 
public char charValue ( ) { return ( ( Character ) value ) . charValue ( ) ; } 
public Number getField ( DatatypeConstants . Field field ) { if ( field == null ) { String methodName = "javax.xml.datatype.Duration" + "#isSet(DatatypeConstants.Field-field)-" ; throw new NullPointerException ( DatatypeMessageFormatter . formatMessage ( null , "FieldCannotBeNull" , new Object [ ] { methodName } ) ) ; } if ( field == DatatypeConstants . YEARS ) { return years ; } if ( field == DatatypeConstants . MONTHS ) { return months ; } if ( field == DatatypeConstants . DAYS ) { return days ; } if ( field == DatatypeConstants . HOURS ) { return hours ; } if ( field == DatatypeConstants . MINUTES ) { return minutes ; } if ( field == DatatypeConstants . SECONDS ) { return seconds ; } String methodName = "javax.xml.datatype.Duration" + "#(getSet(DatatypeConstants.Field-field)" ; throw new IllegalArgumentException ( DatatypeMessageFormatter . formatMessage ( null , "UnknownField" , new Object [ ] { methodName , field . toString ( ) } ) ) ; } 
public InanimateObject dropItem ( String anItem ) { InanimateObject toDrop = carryBag . get ( anItem ) ; this . weightOfItems -= toDrop . getWeight ( ) ; carryBag . remove ( anItem ) ; return toDrop ; } 
public static final char [ ] concat ( char prefix , char [ ] array , char suffix ) { if ( array == null ) return new char [ ] { prefix , suffix } ; int length = array . length ; char [ ] result = new char [ length + 2 ] ; result [ 0 ] = prefix ; System . arraycopy ( array , 0 , result , 1 , length ) ; result [ length + 1 ] = suffix ; return result ; } 
protected JDialog createDialog ( Component owner ) { Window window = SwingUtilities . getWindowAncestor ( owner ) ; if ( window instanceof Frame ) return new JDialog ( ( Frame ) window ) ; if ( window instanceof Dialog ) return new JDialog ( ( Dialog ) window ) ; return new JDialog ( ) ; } 
public void setNull ( int parameterIndex , int sqlType ) throws SQLException { Object nullVal [ ] ; checkParamIndex ( parameterIndex ) ; nullVal = new Object [ 2 ] ; nullVal [ 0 ] = null ; nullVal [ 1 ] = new Integer ( sqlType ) ; if ( params == null ) { throw new SQLException ( "Set-initParams()-before-setNull" ) ; } params . put ( new Integer ( parameterIndex - 1 ) , nullVal ) ; } 
private AuthorityInfo getAuthorityLocked ( Account accountName , int userId , String authorityName , String tag ) { AccountAndUser au = new AccountAndUser ( accountName , userId ) ; AccountInfo accountInfo = mAccounts . get ( au ) ; if ( accountInfo == null ) { if ( tag != null ) { if ( DEBUG ) { Log . v ( TAG , tag + ":-unknown-account-" + au ) ; } } return null ; } AuthorityInfo authority = accountInfo . authorities . get ( authorityName ) ; if ( authority == null ) { if ( tag != null ) { if ( DEBUG ) { Log . v ( TAG , tag + ":-unknown-authority-" + authorityName ) ; } } return null ; } return authority ; } 
public Enumeration getClientPropertyKeysEnumeration ( ) { if ( clientProperties == null ) { return PUtil . NULL_ENUMERATION ; } else { return clientProperties . getAttributeNames ( ) ; } } 
public void fixupVariables ( java . util . Vector vars , int globalsSize ) { ( ( Expression ) m_obj ) . fixupVariables ( vars , globalsSize ) ; } 
private static StatsFile makeStatsFile ( File thisFile , Pattern thisPattern , SimpleDateFormat sdf ) { Matcher matcher = thisPattern . matcher ( thisFile . getName ( ) ) ; if ( matcher . matches ( ) ) { StatsFile sf = new StatsFile ( ) ; sf . file = thisFile ; sf . path = thisFile . getPath ( ) ; sf . dateStr = matcher . group ( 1 ) . trim ( ) ; try { sf . date = sdf . parse ( sf . dateStr ) ; } catch ( ParseException e ) { } return sf ; } return null ; } 
private Object readResolve ( ) { return iChronology . year ( ) ; } 
protected Level ( String name , int level , String resourceBundleName ) { if ( name == null ) { throw new NullPointerException ( "name-==-null" ) ; } this . name = name ; this . value = level ; this . resourceBundleName = resourceBundleName ; if ( resourceBundleName != null ) { try { rb = ResourceBundle . getBundle ( resourceBundleName , Locale . getDefault ( ) , VMStack . getCallingClassLoader ( ) ) ; } catch ( MissingResourceException e ) { rb = null ; } } synchronized ( levels ) { levels . add ( this ) ; } } 
protected void performFiltering ( CharSequence text , int start , int end , int keyCode ) { getFilter ( ) . filter ( text . subSequence ( start , end ) , this ) ; } 
public Element setAttribute ( final String name , final String value , final Namespace ns ) { final Attribute attribute = getAttribute ( name , ns ) ; if ( attribute == null ) { final Attribute newAttribute = new Attribute ( name , value , ns ) ; setAttribute ( newAttribute ) ; } else { attribute . setValue ( value ) ; } return this ; } 
private void validateChecksum ( DataInputStream in , Checksum checksum , long txid ) throws IOException { if ( checksum != null ) { int calculatedChecksum = ( int ) checksum . getValue ( ) ; int readChecksum = in . readInt ( ) ; if ( readChecksum != calculatedChecksum ) { throw new ChecksumException ( "Transaction-is-corrupt.-Calculated-checksum-is-" + calculatedChecksum + "-but-read-checksum-" + readChecksum , txid ) ; } } } 
public List < Integer > getInt2 ( ) { if ( int2 == null ) { int2 = new ArrayList < Integer > ( ) ; } return this . int2 ; } 
public com . google . protobuf . ByteString getTypeBytes ( ) { java . lang . Object ref = type_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; type_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
protected short getNativeShort ( int columnIndex ) throws SQLException { return getNativeShort ( columnIndex , true ) ; } 
public AccessibleStateSet getAccessibleStateSet ( ) { AccessibleStateSet states = super . getAccessibleStateSet ( ) ; if ( isResizable ( ) ) { states . add ( AccessibleState . RESIZABLE ) ; } if ( getFocusOwner ( ) != null ) { states . add ( AccessibleState . ACTIVE ) ; } return states ; } 
public Schema newSchema ( URL schema ) throws SAXException { return newSchema ( new StreamSource ( schema . toExternalForm ( ) ) ) ; } 
public void init ( RenderContext r ) { renderContext = r ; renderContext . setSceneManager ( sceneManager ) ; Timer timer = new Timer ( ) ; angle = 0.01f ; timer . scheduleAtFixedRate ( new AnimationTask ( ) , 0 , 10 ) ; } 
public void setMessage ( String message ) { if ( _messageArea != null ) { _messageArea . setText ( message ) ; } } 
private BufferedImage loadImage ( final String fnm ) { try { final BufferedImage im = ImageIO . read ( new File ( fnm ) ) ; final BufferedImage copy = gc . createCompatibleImage ( im . getWidth ( ) , im . getHeight ( ) , im . getTransparency ( ) ) ; final Graphics2D g2d = copy . createGraphics ( ) ; g2d . drawImage ( im , 0 , 0 , null ) ; g2d . dispose ( ) ; return copy ; } catch ( final IOException e ) { e . printStackTrace ( ) ; System . out . println ( "Load-Image-error-for-" + fnm + "-" + e ) ; return null ; } catch ( final IllegalArgumentException e ) { e . printStackTrace ( ) ; System . out . println ( "Load-Image-Illegal-argument-for-" + fnm + "-" + e ) ; return null ; } catch ( final Exception e ) { System . out . println ( "Load-Image-error-" + fnm + "-" + e ) ; e . printStackTrace ( ) ; return null ; } } 
public double getImageableY ( ) { return mImageableArea . getY ( ) ; } 
public Object [ ] toArray ( Object [ ] a ) { if ( a . length >= elementCount ) { copyInto ( a ) ; if ( a . length > elementCount ) { a [ elementCount ] = null ; } return a ; } else { Object [ ] newArray = ( Object [ ] ) java . lang . reflect . Array . newInstance ( a [ 0 ] . getClass ( ) , elementCount ) ; copyInto ( newArray ) ; return newArray ; } } 
protected void updateLCB ( final int rowIndex , final Dimension d0 , final Dimension d1 , final Dimension d2 ) { this . rowHeights [ rowIndex ] = Math . max ( d0 . height , Math . max ( d1 . height , d2 . height ) ) ; this . totalHeight = this . totalHeight + this . rowHeights [ rowIndex ] ; this . columnWidths [ 0 ] = Math . max ( this . columnWidths [ 0 ] , d0 . width ) ; this . columns1to4Width = Math . max ( this . columns1to4Width , d1 . width ) ; this . columnWidths [ 5 ] = Math . max ( this . columnWidths [ 5 ] , d2 . width ) ; } 
public void destroyJoint ( Joint joint ) { joints . remove ( joint . addr ) ; joint . jointEdgeA . other . joints . remove ( joint . jointEdgeB ) ; joint . jointEdgeB . other . joints . remove ( joint . jointEdgeA ) ; jniDestroyJoint ( addr , joint . addr ) ; } 
public static < E extends Enum < E >> EnumSet < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 ) { EnumSet < E > set = of ( e1 , e2 , e3 , e4 ) ; set . add ( e5 ) ; return set ; } 
public static List < Field > getAllFieldsList ( final Class < ? > cls ) { Validate . isTrue ( cls != null , "The-class-must-not-be-null" ) ; final List < Field > allFields = new ArrayList < Field > ( ) ; Class < ? > currentClass = cls ; while ( currentClass != null ) { final Field [ ] declaredFields = currentClass . getDeclaredFields ( ) ; for ( final Field field : declaredFields ) { allFields . add ( field ) ; } currentClass = currentClass . getSuperclass ( ) ; } return allFields ; } 
protected static boolean startsWith ( String target_string , String key_string ) { if ( target_string . length ( ) < key_string . length ( ) ) return false ; if ( target_string . substring ( 0 , key_string . length ( ) ) . equals ( key_string ) ) return true ; return false ; } 
public Enumeration engineAliases ( ) { return entries . keys ( ) ; } 
public void insertAfter ( InstructionHandle ih , InstructionList x ) { InstructionHandle nextih = ih . getNext ( ) ; if ( nextih != null ) { il . insert ( nextih , x ) ; } else { il . append ( x ) ; } } 
public int numberOfLayers ( ) { return sessionTemplates . size ( ) ; } 
Operation updateSampleRate ( int rate ) { return new Operation ( native_pa_stream_update_sample_rate ( rate ) ) ; } 
public synchronized void addTransportListener ( TransportListener l ) { if ( transportListeners == null ) transportListeners = new Vector ( ) ; transportListeners . addElement ( l ) ; } 
public void setIssuers ( Collection < X500Principal > issuers ) { if ( ( issuers == null ) || issuers . isEmpty ( ) ) { issuerNames = null ; issuerX500Principals = null ; } else { issuerX500Principals = new HashSet < X500Principal > ( issuers ) ; issuerNames = new HashSet < Object > ( ) ; for ( X500Principal p : issuerX500Principals ) { issuerNames . add ( p . getEncoded ( ) ) ; } } } 
public void setENM110EntityRelationshipCode ( JAXBElement < ENM110EntityRelationshipCode > value ) { this . enm110EntityRelationshipCode = ( ( JAXBElement < ENM110EntityRelationshipCode > ) value ) ; } 
public int getSize ( ) { return contributions . size ( ) ; } 
public static boolean isMatch ( Pattern pattern , String subject ) { if ( subject != null && ! "" . equals ( subject ) ) { Matcher matcher = pattern . matcher ( subject ) ; if ( matcher . find ( ) ) { return true ; } } return false ; } 
public static < E > AtomicReferenceArray < E > newReferenceArray ( int length ) { return new AtomicReferenceArray < E > ( length ) ; } 
public String getNamespaceURI ( String qname , boolean isElement ) { String uri = EMPTYSTRING ; int col = qname . lastIndexOf ( ':' ) ; final String prefix = ( col > 0 ) ? qname . substring ( 0 , col ) : EMPTYSTRING ; if ( ! EMPTYSTRING . equals ( prefix ) || isElement ) { if ( m_prefixMap != null ) { uri = m_prefixMap . lookupNamespace ( prefix ) ; if ( uri == null && ! prefix . equals ( XMLNS_PREFIX ) ) { throw new RuntimeException ( Utils . messages . createMessage ( MsgKey . ER_NAMESPACE_PREFIX , new Object [ ] { qname . substring ( 0 , col ) } ) ) ; } } } return uri ; } 
public synchronized void connect ( org . omg . CORBA . Object servant ) { checkShutdownState ( ) ; if ( getTOAFactory ( ) == null ) throw wrapper . noToa ( ) ; try { String codebase = javax . rmi . CORBA . Util . getCodebase ( servant . getClass ( ) ) ; getTOAFactory ( ) . getTOA ( codebase ) . connect ( servant ) ; } catch ( Exception ex ) { throw wrapper . orbConnectError ( ex ) ; } } 
private static StringBuilder getBuffer ( ) { StringBuilder b = BUFFERS . get ( ) ; if ( b == null ) { b = new StringBuilder ( ) ; BUFFERS . set ( b ) ; } else { b . setLength ( 0 ) ; } return b ; } 
public void loadDescriptors ( String packageName , ClassLoader classLoader ) { String res = packageName . replace ( '.' , '/' ) ; if ( log . isTraceEnabled ( ) ) { log . trace ( "Finding-descriptor-" + res ) ; } if ( searchedPaths . get ( packageName ) != null ) { return ; } String descriptors = res + "/mbeans-descriptors.ser" ; URL dURL = classLoader . getResource ( descriptors ) ; if ( dURL == null ) { descriptors = res + "/mbeans-descriptors.xml" ; dURL = classLoader . getResource ( descriptors ) ; } if ( dURL == null ) { return ; } log . debug ( "Found-" + dURL ) ; searchedPaths . put ( packageName , dURL ) ; try { if ( descriptors . endsWith ( ".xml" ) ) loadDescriptors ( "MbeansDescriptorsDigesterSource" , dURL , null ) ; else loadDescriptors ( "MbeansDescriptorsSerSource" , dURL , null ) ; return ; } catch ( Exception ex ) { log . error ( "Error-loading-" + dURL ) ; } return ; } 
public void fireParameterChangedEvent ( ) { fireParameterChangedEvent ( - 1 , Parameter . ChangeType . VALUE_CHANGED ) ; } 
private void focusSpinnerIfNecessary ( ) { Component fo = KeyboardFocusManager . getCurrentKeyboardFocusManager ( ) . getFocusOwner ( ) ; if ( spinner . isRequestFocusEnabled ( ) && ( fo == null || ! SwingUtilities . isDescendingFrom ( fo , spinner ) ) ) { Container root = spinner ; if ( ! root . isFocusCycleRoot ( ) ) { root = root . getFocusCycleRootAncestor ( ) ; } if ( root != null ) { FocusTraversalPolicy ftp = root . getFocusTraversalPolicy ( ) ; Component child = ftp . getComponentAfter ( root , spinner ) ; if ( child != null && SwingUtilities . isDescendingFrom ( child , spinner ) ) { child . requestFocus ( ) ; } } } } 
public static org . apache . http . NameValuePair [ ] toHttpClient ( final NameValuePair [ ] pairs ) { final org . apache . http . NameValuePair [ ] pairs2 = new org . apache . http . NameValuePair [ pairs . length ] ; for ( int i = 0 ; i < pairs . length ; i ++ ) { final NameValuePair pair = pairs [ i ] ; pairs2 [ i ] = new BasicNameValuePair ( pair . getName ( ) , pair . getValue ( ) ) ; } return pairs2 ; } 
protected void writeMetadata ( ObjectOutput out ) throws IOException { super . writeMetadata ( out ) ; out . writeBoolean ( overwrite ) ; } 
public void insertionSort ( ArrayList < T > list ) { int index ; for ( int i = 1 ; i < list . size ( ) ; i ++ ) { index = i ; while ( list . get ( index ) . compareTo ( list . get ( index - 1 ) ) < 0 ) { exchange ( list , index , index - 1 ) ; index = index - 1 ; if ( index == 0 ) { break ; } } } } 
@ XmlElementDecl ( namespace = "http://www.collada.org/2005/11/COLLADASchema" , name = "half2x2" , scope = CgSetarrayType . class ) public JAXBElement < List < java . lang . Float >> createCgSetarrayTypeHalf2X2 ( List < java . lang . Float > value ) { return new JAXBElement < List < java . lang . Float >> ( _CgNewarrayTypeHalf2X2_QNAME , ( ( Class ) List . class ) , CgSetarrayType . class , ( ( List < java . lang . Float > ) value ) ) ; } 
public Instant withMillis ( long newMillis ) { return ( newMillis == iMillis ? this : new Instant ( newMillis ) ) ; } 
public Object get ( String key ) { return state . get ( key ) ; } 
@ XmlElementDecl ( namespace = "http://www.cisco.com/AXL/API/10.5" , name = "removeBillingServerResponse" ) public JAXBElement < StandardResponse > createRemoveBillingServerResponse ( StandardResponse value ) { return new JAXBElement < StandardResponse > ( new QName ( "http://www.cisco.com/AXL/API/10.5" , "removeBillingServerResponse" ) , StandardResponse . class , null , value ) ; } 
public String getElement ( int i ) throws ArrayIndexOutOfBoundsException { if ( null == m_elements ) throw new ArrayIndexOutOfBoundsException ( ) ; return ( String ) m_elements . elementAt ( i ) ; } 
public void difference ( Vector other ) { Vector v = new Vector ( other ) ; v . negate ( ) ; sum ( v ) ; } 
private static byte [ ] getKeyBytes ( String string ) { try { int utfCount = ( int ) ModifiedUtf8 . countBytes ( string , false ) ; byte [ ] result = new byte [ utfCount ] ; ModifiedUtf8 . encode ( result , 0 , string ) ; return result ; } catch ( UTFDataFormatException e ) { throw new RuntimeException ( e ) ; } } 
public boolean voteRegister ( int ansID ) { int register = 0 ; boolean wasRegistered = false ; try { Statement stmt = con . createStatement ( ) ; ResultSet result = stmt . executeQuery ( "select-registerAns-from-topicAnswers-" + "where-idNum-=-" + ansID ) ; while ( result . next ( ) ) { register = result . getInt ( "registerAns" ) ; } register ++ ; stmt . executeUpdate ( "UPDATE-topicAnswers-SET-registerAns-=-" + register + "-where-idNum-=-" + ansID ) ; wasRegistered = true ; } catch ( SQLException e ) { System . out . println ( "Problem-with-connection:-" + e . getMessage ( ) ) ; } return wasRegistered ; } 
public String addNumber ( String s1 , String s2 ) { if ( s1 == null || s1 . length ( ) == 0 ) return s2 ; if ( s2 == null || s2 . length ( ) == 0 ) return s1 ; char [ ] chs1 = s1 . toCharArray ( ) ; char [ ] chs2 = s2 . toCharArray ( ) ; char [ ] res = new char [ Math . max ( chs1 . length , chs2 . length ) + 1 ] ; int i = chs1 . length - 1 ; int j = chs2 . length - 1 ; int carry = 0 ; int index = res . length - 1 ; while ( i >= 0 || j >= 0 ) { int v1 = i < 0 ? 0 : chs1 [ i -- ] - '0' ; int v2 = j < 0 ? 0 : chs2 [ j -- ] - '0' ; int v = v1 + v2 + carry ; res [ index -- ] = ( char ) ( v % 10 + '0' ) ; carry = v / 10 ; } res [ 0 ] = ( char ) ( carry + '0' ) ; int start = res [ 0 ] == '0' ? 1 : 0 ; return new String ( res , start , res . length - start ) ; } 
public void addElseNode ( Node node ) { elseNodes . add ( node ) ; } 
public boolean contains ( NodeType nodeType ) { for ( int i = 0 , n = path . size ( ) ; i < n ; i ++ ) { if ( path . get ( i ) . getNodeType ( ) == nodeType ) { return true ; } } return false ; } 
public void writeToSD ( boolean alarm ) { Log . v ( TAG , "writeToSD(" + alarm + ")" ) ; Time tnow = new Time ( Time . getCurrentTimezone ( ) ) ; tnow . setToNow ( ) ; String dateStr = tnow . format ( "%Y-%m-%d" ) ; String fname ; if ( alarm ) fname = "AlarmLog" ; else fname = "DataLog" ; fname = fname + "_" + dateStr + ".txt" ; if ( isExternalStorageWritable ( ) ) { try { FileWriter of = new FileWriter ( getDataStorageDir ( ) . toString ( ) + "/" + fname , true ) ; if ( mSdData != null ) { Log . v ( TAG , "writing-mSdData.toString()" ) ; of . append ( mSdData . toString ( ) + "-" ) ; } of . close ( ) ; } catch ( Exception ex ) { Log . e ( TAG , "writeAlarmToSD---error-" + ex . toString ( ) ) ; } } else { Log . e ( TAG , "ERROR---Can-not-Write-to-External-Folder" ) ; } } 
private int randomNum ( ) { int rand = 0 ; boolean found = false ; while ( ! found ) { Random r = new Random ( ) ; rand = r . nextInt ( entries ) ; if ( ! tries . contains ( rand ) ) { tries . add ( rand ) ; found = true ; } } return rand ; } 
void removeCursor ( IndexCursor cursor ) { cursors . remove ( cursor ) ; } 
public void print ( double dnum ) { print ( String . valueOf ( dnum ) ) ; } 
public boolean isReady ( ) { Thread . currentThread ( ) . yield ( ) ; return _isReady ; } 
private int sortedLastIndexOf ( final int [ ] a , final int e ) { int i = Arrays . binarySearch ( a , 0 , rows , e ) ; if ( i >= 0 ) { while ( ++ i < rows && a [ i ] == e ) ; return i - 1 ; } return i ; } 
protected int getDate ( String buffer , int start , int end , DateTimeData date ) throws RuntimeException { start = getYearMonth ( buffer , start , end , date ) ; if ( buffer . charAt ( start ++ ) != '-' ) { throw new RuntimeException ( "CCYY-MM-must-be-followed-by-'-'-sign" ) ; } int stop = start + 2 ; date . day = parseInt ( buffer , start , stop ) ; return stop ; } 
public synchronized IndexCommit getIndexCommit ( long gen ) { return indexCommits . get ( gen ) ; } 
public void addLineNumber ( char startPc , char lineNumber ) { if ( lineDebugInfo ) { if ( lineInfo . nonEmpty ( ) && lineInfo . head [ 0 ] == startPc ) lineInfo = lineInfo . tail ; if ( lineInfo . isEmpty ( ) || lineInfo . head [ 1 ] != lineNumber ) lineInfo = lineInfo . prepend ( new char [ ] { startPc , lineNumber } ) ; } } 
public Color [ ] getColors ( ) { return ( colors != null ) ? colors . clone ( ) : null ; } 
public Signature getSignature ( String predName ) { return signatures . get ( predName ) ; } 
public void close ( ) throws IOException { s . close ( ) ; } 
long getCurrentTime ( ) { return System . currentTimeMillis ( ) ; } 
@ Override public void changeCursor ( Cursor c ) { if ( DBG ) Log . d ( LOG_TAG , "changeCursor(" + c + ")" ) ; if ( mClosed ) { Log . w ( LOG_TAG , "Tried-to-change-cursor-after-adapter-was-closed." ) ; if ( c != null ) c . close ( ) ; return ; } try { super . changeCursor ( c ) ; if ( c != null ) { mText1Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_TEXT_1 ) ; mText2Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_TEXT_2 ) ; mText2UrlCol = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_TEXT_2_URL ) ; mIconName1Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_ICON_1 ) ; mIconName2Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_ICON_2 ) ; mFlagsCol = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_FLAGS ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , "error-changing-cursor-and-caching-columns" , e ) ; } } 
public static IntegerVariable makeBinTreeIntVar ( String name , int [ ] values ) { int [ ] values2 = new int [ values . length ] ; System . arraycopy ( values , 0 , values2 , 0 , values . length ) ; Arrays . sort ( values2 ) ; IntegerVariable v = makeIntVar ( name , values2 , "cp:enum" ) ; return v ; } 
protected void fillPathSegments ( ArrayList < String > list ) { if ( isRoot ) { return ; } if ( parent != null ) { parent . fillPathSegments ( list ) ; } list . add ( name ) ; } 
private void copyWhiteSpace ( ) { while ( s < in . length && Character . isWhitespace ( in [ s ] ) ) { out [ d ++ ] = in [ s ++ ] ; } } 
public Element bgColor ( String color ) { return attribute ( BGCOLOR , color ) ; } 
public static boolean getDefaultLightWeightPopupEnabled ( ) { Boolean b = ( Boolean ) SwingUtilities . appContextGet ( defaultLWPopupEnabledKey ) ; if ( b == null ) { SwingUtilities . appContextPut ( defaultLWPopupEnabledKey , Boolean . TRUE ) ; return true ; } return b . booleanValue ( ) ; } 
public InetSocketAddress getInetSocketAddress ( ) { return new InetSocketAddress ( hostname , port ) ; } 
protected void addDebugArguments ( ArrayList argsList , Debugger debugger ) { ArrayList debugArguments = new ArrayList ( ) ; super . addDebugArguments ( debugArguments , debugger ) ; int index = 1 ; for ( Iterator iter = debugArguments . iterator ( ) ; iter . hasNext ( ) ; ) { String arg = ( String ) iter . next ( ) ; argsList . add ( index , arg ) ; index ++ ; } } 
public void setAsText ( String text ) throws java . lang . IllegalArgumentException { if ( value instanceof String ) { setValue ( text ) ; return ; } throw new java . lang . IllegalArgumentException ( text ) ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof Constructor ) ) return false ; Constructor that = ( Constructor ) o ; if ( clazz != that . getDeclaringClass ( ) ) return false ; if ( ! Arrays . equals ( getParameterTypes ( ) , that . getParameterTypes ( ) ) ) return false ; return true ; } 
public static void i ( String tag , String s , Object ... args ) { if ( LOG . INFO >= LOGLEVEL ) Log . i ( tag , String . format ( s , args ) ) ; } 
public void setOutputProperty ( String name , String val ) { setProp ( name , val , false ) ; } 
public void remove ( ) { map . remove ( Thread . currentThread ( ) . getId ( ) ) ; } 
public int getYears ( ) { return getInt ( DatatypeConstants . YEARS ) ; } 
@ ViewDebug . ExportedProperty ( category = "layout" , mapping = { @ ViewDebug . IntToString ( from = LAYOUT_DIRECTION_LTR , to = "RESOLVED_DIRECTION_LTR" ) , @ ViewDebug . IntToString ( from = LAYOUT_DIRECTION_RTL , to = "RESOLVED_DIRECTION_RTL" ) } ) @ ResolvedLayoutDir public int getLayoutDirection ( ) { final int targetSdkVersion = getContext ( ) . getApplicationInfo ( ) . targetSdkVersion ; if ( targetSdkVersion < JELLY_BEAN_MR1 ) { mPrivateFlags2 |= PFLAG2_LAYOUT_DIRECTION_RESOLVED ; return LAYOUT_DIRECTION_RESOLVED_DEFAULT ; } return ( ( mPrivateFlags2 & PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL ) == PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL ) ? LAYOUT_DIRECTION_RTL : LAYOUT_DIRECTION_LTR ; } 
private Class ConvertWrapper ( Class cls ) { Class ret = ( Class ) TYPES . get ( cls ) ; if ( ret != null ) { return ret ; } return cls ; } 
private Method setupSetterOrGetter ( Class targetClass , HashMap < Class , HashMap < String , Method >> propertyMapMap , String prefix , Class valueType ) { Method setterOrGetter = null ; try { mPropertyMapLock . writeLock ( ) . lock ( ) ; HashMap < String , Method > propertyMap = propertyMapMap . get ( targetClass ) ; if ( propertyMap != null ) { setterOrGetter = propertyMap . get ( mPropertyName ) ; } if ( setterOrGetter == null ) { setterOrGetter = getPropertyFunction ( targetClass , prefix , valueType ) ; if ( propertyMap == null ) { propertyMap = new HashMap < String , Method > ( ) ; propertyMapMap . put ( targetClass , propertyMap ) ; } propertyMap . put ( mPropertyName , setterOrGetter ) ; } } finally { mPropertyMapLock . writeLock ( ) . unlock ( ) ; } return setterOrGetter ; } 
public boolean canMerge ( Space other ) { if ( ! hasJoinedEdge ( other ) ) { return false ; } if ( ( x == other . x ) && ( width == other . width ) ) { return true ; } if ( ( y == other . y ) && ( height == other . height ) ) { return true ; } return false ; } 
private static double [ ] computeLabels ( final double start , final double end , final int approxNumLabels ) { if ( Math . abs ( start - end ) < 0.0000001f ) { return new double [ ] { start , start , 0 } ; } double s = start ; double e = end ; boolean switched = false ; if ( s > e ) { switched = true ; double tmp = s ; s = e ; e = tmp ; } double xStep = roundUp ( Math . abs ( s - e ) / approxNumLabels ) ; double xStart = xStep * Math . ceil ( s / xStep ) ; double xEnd = xStep * Math . floor ( e / xStep ) ; if ( switched ) { return new double [ ] { xEnd , xStart , - 1.0 * xStep } ; } return new double [ ] { xStart , xEnd , xStep } ; } 
public static Body create ( final MediaType contentType , final File file ) { if ( contentType == null ) throw new NullPointerException ( "contentType-==-null" ) ; if ( file == null ) throw new NullPointerException ( "content-==-null" ) ; return new Body ( ) { @ Override public MediaType contentType ( ) { return contentType ; } @ Override public long contentLength ( ) { return file . length ( ) ; } @ Override public void writeTo ( OutputStream out ) throws IOException { long length = contentLength ( ) ; if ( length == 0 ) return ; InputStream in = null ; try { in = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ ( int ) Math . min ( 8192 , length ) ] ; for ( int c ; ( c = in . read ( buffer ) ) != - 1 ; ) { out . write ( buffer , 0 , c ) ; } } finally { Util . closeQuietly ( in ) ; } } } ; } 
private static int arg ( String [ ] args , int i , int def ) { try { return Integer . parseInt ( args [ i ] ) ; } catch ( Throwable t ) { return def ; } } 
public void setAttribute ( final int index ) { setHeader ( index ) ; if ( m_AttributeStats [ index ] == null ) { Thread t = new Thread ( ) { public void run ( ) { m_AttributeStats [ index ] = m_Instances . attributeStats ( index ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { setDerived ( index ) ; m_StatsTable . sizeColumnsToFit ( - 1 ) ; m_StatsTable . revalidate ( ) ; m_StatsTable . repaint ( ) ; } } ) ; } } ; t . setPriority ( Thread . MIN_PRIORITY ) ; t . start ( ) ; } else { setDerived ( index ) ; } } 
public void clear ( ) { bet = 0 ; contributors . clear ( ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public void connectVertex ( Vertex v ) { v . adjVerticesList . add ( this ) ; this . adjVerticesList . add ( v ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
protected DefaultLogger ( ConfigElement config , String tag ) throws IOException { System . out . print ( "Initialing-default-logger-...-" ) ; this . tag = tag ; loadConfigurations ( config ) ; synchronized ( outputMap ) { out = outputMap . get ( logFile ) ; if ( out == null ) { out = new PrintWriter ( new FileWriter ( new File ( logFile ) , true ) , true ) ; outputMap . put ( logFile , out ) ; } } try { hostName = InetAddress . getLocalHost ( ) . getHostName ( ) ; } catch ( UnknownHostException e ) { hostName = "**Unknown-Host**" ; } try { LogFactory . registerCleanupMethod ( getClass ( ) . getMethod ( "cleanup" , new Class [ 0 ] ) ) ; } catch ( Exception e ) { System . out . println ( "Could-not-register-the-cleanup-method-to-LogFactory,-will-skip-the-cleanup." ) ; e . printStackTrace ( System . out ) ; } System . out . println ( "done." ) ; } 
public final boolean isKeyEntry ( String alias ) throws KeyStoreException { if ( ! initialized ) { throw new KeyStoreException ( "Uninitialized-keystore" ) ; } return keyStoreSpi . engineIsKeyEntry ( alias ) ; } 
public static RemoteException toRemoteException ( final Map < ? , ? > json ) { final Map < ? , ? > m = ( Map < ? , ? > ) json . get ( RemoteException . class . getSimpleName ( ) ) ; final String message = ( String ) m . get ( "message" ) ; final String javaClassName = ( String ) m . get ( "javaClassName" ) ; return new RemoteException ( javaClassName , message ) ; } 
public void cubicTo ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { mPath . curveTo ( x1 , y1 , x2 , y2 , mLastX = x3 , mLastY = y3 ) ; } 
public List < PostBuyFormDataStruct > getItem ( ) { if ( item == null ) { item = new ArrayList < PostBuyFormDataStruct > ( ) ; } return this . item ; } 
public void testSerialization ( ) { CategoryAxis3D a1 = new CategoryAxis3D ( "Test-Axis" ) ; CategoryAxis3D a2 = null ; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; ObjectOutput out = new ObjectOutputStream ( buffer ) ; out . writeObject ( a1 ) ; out . close ( ) ; ObjectInput in = new ObjectInputStream ( new ByteArrayInputStream ( buffer . toByteArray ( ) ) ) ; a2 = ( CategoryAxis3D ) in . readObject ( ) ; in . close ( ) ; } catch ( Exception e ) { System . out . println ( e . toString ( ) ) ; } assertEquals ( a1 , a2 ) ; } 
public byte [ ] getEncoded ( ) { byte [ ] ret = new byte [ encodedKey . length ] ; System . arraycopy ( encodedKey , 0 , ret , 0 , ret . length ) ; return ret ; } 
void serve ( final portServer p , ServerSocket serverSocket ) throws MARSHAL , IOException { final Socket service ; service = serverSocket . accept ( ) ; if ( p . running_threads >= MAX_RUNNING_THREADS ) { serveStep ( service , true ) ; return ; } new Thread ( ) { public void run ( ) { try { synchronized ( p ) { p . running_threads ++ ; } serveStep ( service , false ) ; } finally { synchronized ( p ) { p . running_threads -- ; } } } } . start ( ) ; } 
@ Override public final StringBuffer format ( Object object , StringBuffer buffer , FieldPosition field ) { return format ( ( Object [ ] ) object , buffer , field ) ; } 
void test ( ) { log ( "test" ) ; List < ClassSymbol > nestedClasses = new LinkedList < ClassSymbol > ( ) ; for ( PackageSymbol p : packages ) { for ( Scope . Entry se = p . members_field . elems ; se != null ; se = se . sibling ) { if ( se . sym . name . toString ( ) . contains ( "$" ) ) nestedClasses . add ( ( ClassSymbol ) se . sym ) ; } } for ( int i = nestedClasses . size ( ) ; i > 0 ; i -- ) { ClassSymbol sym = nestedClasses . remove ( rgen . nextInt ( i ) ) ; log ( "adjusting-class-" + sym ) ; starImportModel . remove ( sym ) ; String s = sym . name . toString ( ) ; int dollar = s . indexOf ( "$" ) ; assert ( sym . owner . kind == PCK ) ; Name outerName = names . fromString ( s . substring ( 0 , dollar ) ) ; Scope . Entry outerEntry = sym . owner . members ( ) . lookup ( outerName ) ; ClassSymbol outer = ( ClassSymbol ) outerEntry . sym ; sym . owner . members ( ) . remove ( sym ) ; sym . name = names . fromString ( s . substring ( dollar + 1 ) ) ; outer . members ( ) . enter ( sym ) ; sym . owner = outer ; starImportModel . check ( starImportScope ) ; } } 
private int defaultThreadID ( ) { long tid = Thread . currentThread ( ) . getId ( ) ; if ( tid < MIN_SEQUENTIAL_THREAD_ID ) { return ( int ) tid ; } else { Integer id = threadIds . get ( ) ; if ( id == null ) { id = nextThreadId . getAndIncrement ( ) ; threadIds . set ( id ) ; } return id ; } } 
public static InetSocketAddress getBindAddress ( Configuration conf ) { return conf . getSocketAddr ( YarnConfiguration . RM_ADDRESS , YarnConfiguration . DEFAULT_RM_ADDRESS , YarnConfiguration . DEFAULT_RM_PORT ) ; } 
public Image getSelectedItemImage ( ) { if ( getSelectedItem ( ) == null ) { return null ; } else { return ( Image ) imageMap . get ( getSelectedItem ( ) ) ; } } 
private String getSignature ( ) { if ( signature != null ) return signature ; StringBuffer buf = new StringBuffer ( ) ; buf . append ( getName ( ) ) ; buf . append ( '(' ) ; for ( Iterator i = parameters . iterator ( ) ; i . hasNext ( ) ; ) { buf . append ( ( String ) i . next ( ) ) ; i . next ( ) ; if ( i . hasNext ( ) ) buf . append ( ',' ) ; } buf . append ( ')' ) ; return buf . toString ( ) ; } 
private void setViewDrawable ( ImageView v , Drawable drawable , int nullVisibility ) { v . setImageDrawable ( drawable ) ; if ( drawable == null ) { v . setVisibility ( nullVisibility ) ; } else { v . setVisibility ( View . VISIBLE ) ; drawable . setVisible ( false , false ) ; drawable . setVisible ( true , false ) ; } } 
public String getContentType ( ) { if ( dataSource != null ) return dataSource . getContentType ( ) ; else return objectMimeType ; } 
public Object traverse ( Object node ) throws PicoVerificationException { nestedVerificationExceptions . clear ( ) ; verifiedComponentAdapters . clear ( ) ; try { super . traverse ( node ) ; if ( ! nestedVerificationExceptions . isEmpty ( ) ) { throw new PicoVerificationException ( new ArrayList ( nestedVerificationExceptions ) ) ; } } finally { nestedVerificationExceptions . clear ( ) ; verifiedComponentAdapters . clear ( ) ; } return Void . TYPE ; } 
private static javax . naming . InitialContext getInitialContext ( final Hashtable < ? , ? > env ) throws NamingException { javax . naming . InitialContext ic = null ; if ( env == null || env . size ( ) == 0 ) { ic = new javax . naming . InitialContext ( ) ; } else { ic = new javax . naming . InitialContext ( env ) ; } return ic ; } 
public V get ( Class < ? > type ) { if ( type == null ) { return null ; } final V value = classes . get ( type ) ; if ( value != null ) { return value ; } for ( Entry < Class < ? > , V > entry : classes . entrySet ( ) ) { if ( entry . getKey ( ) . isAssignableFrom ( type ) ) { return entry . getValue ( ) ; } } return null ; } 
public void hardClose ( ) { remoteClosed = true ; closedAt = TimeUtils . timeNow ( ) ; synchronized ( retrQ ) { retrQ . clear ( ) ; retrQ . notifyAll ( ) ; } synchronized ( writeLock ) { writeCount = 0 ; writeBuffer = null ; } Logging . logCheckedInfo ( LOG , "Hard-closed." ) ; } 
public boolean contains ( String name ) { return getValue ( name ) != null ; } 
@ Override public void reset ( ) { if ( ! mIsLocked ) { super . reset ( ) ; for ( int i = 0 ; i < mElements . size ( ) ; i ++ ) mElements . get ( i ) . reset ( ) ; mCamera . reset ( ) ; } } 
public void setContentType ( String contentType ) { coyoteRequest . setContentType ( contentType ) ; } 
public void registerComponentCallbacks ( ComponentCallbacks callback ) { getApplicationContext ( ) . registerComponentCallbacks ( callback ) ; } 
@ Deprecated public static RequestAsyncTask executeMeRequestAsync ( Session session , GraphUserCallback callback ) { return newMeRequest ( session , callback ) . executeAsync ( ) ; } 
public void addGraphicalObject ( GraphicalObject graphicalObject ) { if ( graphicalObject != null ) { addSubObject ( graphicalObject ) ; } } 
public void setText ( String text ) { String oldValue = this . text ; this . text = text ; firePropertyChange ( TEXT_CHANGED_PROPERTY , oldValue , text ) ; updateDisplayedMnemonicIndex ( text , getMnemonic ( ) ) ; if ( accessibleContext != null ) { accessibleContext . firePropertyChange ( AccessibleContext . ACCESSIBLE_VISIBLE_DATA_PROPERTY , oldValue , text ) ; } if ( text == null || oldValue == null || ! text . equals ( oldValue ) ) { revalidate ( ) ; repaint ( ) ; } } 
@ Override public void printFieldIdentityClause ( Writer writer ) throws ValidationException { try { writer . write ( "-SERIAL" ) ; } catch ( IOException ioException ) { throw ValidationException . fileError ( ioException ) ; } } 
public Point createPoint ( CoordinateSequence coordinates ) { return new Point ( coordinates , this ) ; } 
public static int leerNumero ( String texto ) { System . out . print ( texto ) ; return Integer . parseInt ( scan . nextLine ( ) ) ; } 
public static boolean deleteIfExists ( File file ) throws IOException { if ( file . exists ( ) ) { if ( file . isDirectory ( ) ) { if ( file . listFiles ( ) . length > 0 ) { throw new DirectoryNotEmptyException ( ) ; } } return file . delete ( ) ; } return false ; } 
public URL find ( String classname ) { String cname = classname . replace ( '.' , '/' ) + ".class" ; ClassLoader cl = ( ClassLoader ) clref . get ( ) ; if ( cl == null ) return null ; else return cl . getResource ( cname ) ; } 
protected DoubleMatrix1D like1D ( int size , int offset , int stride ) { throw new InternalError ( ) ; } 
public static void sleep ( long duration ) { try { Thread . sleep ( ( duration * timerTicksPerSecond ) / 1000 ) ; } catch ( InterruptedException inte ) { } } 
private void configureDispatchers ( ServletConfig servletConfig ) throws ServletException { String templateConfiguration = servletConfig . getInitParameter ( BLOJSOM_DISPATCHER_MAP_CONFIGURATION_IP ) ; _dispatchers = new HashMap ( ) ; Properties templateMapProperties = new Properties ( ) ; InputStream is = servletConfig . getServletContext ( ) . getResourceAsStream ( templateConfiguration ) ; try { templateMapProperties . load ( is ) ; is . close ( ) ; Iterator templateIterator = templateMapProperties . keySet ( ) . iterator ( ) ; while ( templateIterator . hasNext ( ) ) { String templateExtension = ( String ) templateIterator . next ( ) ; String templateDispatcherClass = templateMapProperties . getProperty ( templateExtension ) ; Class dispatcherClass = Class . forName ( templateDispatcherClass ) ; BlojsomDispatcher dispatcher = ( BlojsomDispatcher ) dispatcherClass . newInstance ( ) ; dispatcher . init ( servletConfig , _blojsomConfiguration ) ; _dispatchers . put ( templateExtension , dispatcher ) ; _logger . debug ( "Added-template-dispatcher:-" + templateDispatcherClass ) ; } } catch ( InstantiationException e ) { _logger . error ( e ) ; } catch ( IllegalAccessException e ) { _logger . error ( e ) ; } catch ( ClassNotFoundException e ) { _logger . error ( e ) ; } catch ( IOException e ) { _logger . error ( e ) ; throw new ServletException ( e ) ; } catch ( BlojsomException e ) { _logger . error ( e ) ; throw new ServletException ( e ) ; } } 
public static boolean isValidName ( String name ) { if ( name . length ( ) == 0 ) return false ; char ch = name . charAt ( 0 ) ; if ( isNameStart ( ch ) == false ) return false ; for ( int i = 1 ; i < name . length ( ) ; i ++ ) { ch = name . charAt ( i ) ; if ( isName ( ch ) == false ) { return false ; } } return true ; } 
private boolean assertMasid ( final int masId ) { final int size = mMnsClients . size ( ) ; if ( masId < 0 || masId >= size ) { Log . e ( TAG , "MAS-id:-" + masId + "-is-out-of-maximum-number-of-MAS-instances:-" + size ) ; return false ; } return true ; } 
public void setBackground ( Color c ) { AccessibleContext ac = getCurrentAccessibleContext ( ) ; if ( ac instanceof AccessibleComponent ) { ( ( AccessibleComponent ) ac ) . setBackground ( c ) ; } else { Component cp = getCurrentComponent ( ) ; if ( cp != null ) { cp . setBackground ( c ) ; } } } 
public Lookup ( String name , int type , int dclass ) throws TextParseException { this ( Name . fromString ( name ) , type , dclass ) ; } 
@ Override public String [ ] getOptions ( ) { Vector < String > result = new Vector < String > ( ) ; result . add ( "-S" ) ; result . add ( m_Splitter . getClass ( ) . getName ( ) ) ; Collections . addAll ( result , super . getOptions ( ) ) ; return result . toArray ( new String [ result . size ( ) ] ) ; } 
public final void setTime ( final String sTime ) { final float fMILLISECOND = 1000.f ; this . time = Float . parseFloat ( sTime ) / fMILLISECOND ; } 
public static String extractAbsoluteHelpTopic ( String url ) { if ( url == null || ! url . startsWith ( getWikiBaseHelpUrl ( ) ) ) return null ; url = url . substring ( getWikiBaseHelpUrl ( ) . length ( ) ) ; String prefix = getHelpTopicPrefix ( LocaleType . ENGLISH ) ; if ( url . startsWith ( prefix ) ) return url ; String pattern = "/[A-Z][a-z]{1,2}(_[A-Z]{2})?:" + prefix . replaceAll ( "^|/+" , "" ) ; if ( url . matches ( pattern ) ) return url ; return null ; } 
public void setDataPath ( String data_path ) { this . data_path = Utility . unixPath ( Utility . absolutePath ( data_path ) ) + "/" ; } 
public static NewsAddress [ ] parse ( String newsgroups ) throws AddressException { StringTokenizer st = new StringTokenizer ( newsgroups , "," ) ; Vector nglist = new Vector ( ) ; while ( st . hasMoreTokens ( ) ) { String ng = st . nextToken ( ) ; nglist . addElement ( new NewsAddress ( ng ) ) ; } int size = nglist . size ( ) ; NewsAddress [ ] na = new NewsAddress [ size ] ; if ( size > 0 ) nglist . copyInto ( na ) ; return na ; } 
public int getYear ( ) { return Dispatch . get ( this , "Year" ) . toInt ( ) ; } 
public Drawable getDrawableForType ( Context context , final String accountType ) { Drawable icon = null ; if ( mAccTypeIconCache . containsKey ( accountType ) ) { return mAccTypeIconCache . get ( accountType ) ; } if ( mTypeToAuthDescription . containsKey ( accountType ) ) { try { AuthenticatorDescription desc = mTypeToAuthDescription . get ( accountType ) ; Context authContext = context . createPackageContext ( desc . packageName , 0 ) ; icon = authContext . getResources ( ) . getDrawable ( desc . iconId ) ; mAccTypeIconCache . put ( accountType , icon ) ; } catch ( PackageManager . NameNotFoundException e ) { } catch ( Resources . NotFoundException e ) { } } if ( icon == null ) { icon = context . getPackageManager ( ) . getDefaultActivityIcon ( ) ; } return icon ; } 
public void setJvmMemoryGCCall ( EnumJvmMemoryGCCall x ) throws SnmpStatusException { if ( x . intValue ( ) == JvmMemoryGCCallStart . intValue ( ) ) { final Map < Object , Object > m = JvmContextFactory . getUserData ( ) ; try { ManagementFactory . getMemoryMXBean ( ) . gc ( ) ; if ( m != null ) m . put ( "jvmMemory.getJvmMemoryGCCall" , JvmMemoryGCCallStarted ) ; } catch ( Exception ex ) { if ( m != null ) m . put ( "jvmMemory.getJvmMemoryGCCall" , JvmMemoryGCCallFailed ) ; } return ; } throw new SnmpStatusException ( SnmpDefinitions . snmpRspWrongValue ) ; } 
public void setValues ( int selection , int minimum , int maximum , int thumb , int increment , int pageIncrement ) { checkWidget ( ) ; if ( minimum < 0 ) return ; if ( maximum < 0 ) return ; if ( thumb < 1 ) return ; if ( increment < 1 ) return ; if ( pageIncrement < 1 ) return ; this . increment = increment ; this . pageIncrement = pageIncrement ; SCROLLINFO info = new SCROLLINFO ( ) ; info . cbSize = SCROLLINFO . sizeof ; info . fMask = OS . SIF_POS | OS . SIF_PAGE | OS . SIF_RANGE | OS . SIF_DISABLENOSCROLL ; info . nPos = selection ; info . nMin = minimum ; info . nMax = maximum ; info . nPage = thumb ; if ( info . nPage != 0 ) info . nPage ++ ; int hwnd = hwndScrollBar ( ) ; int type = scrollBarType ( ) ; SetScrollInfo ( hwnd , type , info , true ) ; } 
public short getShort ( Object o ) throws IllegalAccessException { return f . getShort ( o ) ; } 
protected void setSawInclude ( int depth , boolean val ) { if ( depth >= fSawInclude . length ) { boolean [ ] newarray = new boolean [ depth * 2 ] ; System . arraycopy ( fSawInclude , 0 , newarray , 0 , fSawInclude . length ) ; fSawInclude = newarray ; } fSawInclude [ depth ] = val ; } 
@ XmlElementDecl ( namespace = "http://www.omg.org/spec/BPMN/20100524/MODEL" , name = "resourceRole" ) public JAXBElement < TResourceRole > createResourceRole ( TResourceRole value ) { return new JAXBElement < TResourceRole > ( _ResourceRole_QNAME , TResourceRole . class , null , value ) ; } 
public ImportConfigDTO consultarImportConfigDTO ( final ImportarDadosDTO importarDadosDTO ) throws PersistenceException { final List < Condition > condicao = new ArrayList < > ( ) ; condicao . add ( new Condition ( "idImportarDados" , "=" , importarDadosDTO . getIdImportarDados ( ) ) ) ; final List < Order > ordenacao = new ArrayList < > ( ) ; ordenacao . add ( new Order ( "idImportConfig" ) ) ; final List < ImportConfigDTO > lista = ( List < ImportConfigDTO > ) super . findByCondition ( condicao , ordenacao ) ; if ( lista != null && ! lista . isEmpty ( ) ) { return lista . get ( 0 ) ; } else { return null ; } } 
private void parse ( BufferedReader buf_reader ) throws IOException { String line = null , prev = null ; while ( ( line = buf_reader . readLine ( ) ) != null ) { if ( prev == null ) prev = line ; else prev += line ; int end = prev . length ( ) ; if ( prev . length ( ) > 0 && prev . charAt ( end - 1 ) == '|' ) { prev = prev . substring ( 0 , end - 1 ) ; continue ; } this . parseEntry ( prev ) ; prev = null ; } if ( prev != null ) this . parseEntry ( prev ) ; } 
void installSystemApplicationInfo ( ApplicationInfo info , ClassLoader classLoader ) { assert info . packageName . equals ( "android" ) ; mApplicationInfo = info ; mClassLoader = classLoader ; } 
public static boolean isValidJavaEncoding ( String javaEncoding ) { if ( javaEncoding != null ) { int length = javaEncoding . length ( ) ; if ( length > 0 ) { for ( int i = 1 ; i < length ; i ++ ) { char c = javaEncoding . charAt ( i ) ; if ( ( c < 'A' || c > 'Z' ) && ( c < 'a' || c > 'z' ) && ( c < '0' || c > '9' ) && c != '.' && c != '_' && c != '-' ) { return false ; } } return true ; } } return false ; } 
public double [ ] getColumn ( ) { double column [ ] = new double [ columnSpec . length ] ; System . arraycopy ( columnSpec , 0 , column , 0 , column . length ) ; return column ; } 
protected static ImageIcon createImageIcon ( String path ) { java . net . URL imgURL = MenuDemo . class . getResource ( path ) ; if ( imgURL != null ) { return new ImageIcon ( imgURL ) ; } else { System . err . println ( "Couldn't-find-file:-" + path ) ; return null ; } } 
public List < Peer > getConnectedPeers ( ) { lock . lock ( ) ; try { return new ArrayList < Peer > ( peers ) ; } finally { lock . unlock ( ) ; } } 
public Processor < ContextType > findOneNode ( String pattern ) { Pattern regex = Pattern . compile ( pattern ) ; for ( Processor < ContextType > p : getNodes ( ) ) if ( regex . matcher ( p . getName ( ) ) . matches ( ) ) return p ; return null ; } 
public List < String > values ( String name ) { List < String > result = null ; for ( int i = 0 ; i < length ( ) ; i ++ ) { if ( name . equalsIgnoreCase ( getFieldName ( i ) ) ) { if ( result == null ) result = new ArrayList < String > ( 2 ) ; result . add ( getValue ( i ) ) ; } } return result != null ? Collections . unmodifiableList ( result ) : Collections . < String > emptyList ( ) ; } 
public Enumeration < ? extends ZipEntry > entries ( ) { checkNotClosed ( ) ; final Iterator < ZipEntry > iterator = mEntries . values ( ) . iterator ( ) ; return new Enumeration < ZipEntry > ( ) { public boolean hasMoreElements ( ) { checkNotClosed ( ) ; return iterator . hasNext ( ) ; } public ZipEntry nextElement ( ) { checkNotClosed ( ) ; return iterator . next ( ) ; } } ; } 
public static String extractBinaryString ( final byte [ ] buffer , final int start , final int end ) { final StringBuilder r = new StringBuilder ( end - start ) ; for ( int i = start ; i < end ; i ++ ) r . append ( ( char ) ( buffer [ i ] & 0xff ) ) ; return r . toString ( ) ; } 
public double norm1 ( ) { double f = 0 ; for ( int j = 0 ; j < n ; j ++ ) { double s = 0 ; for ( int i = 0 ; i < m ; i ++ ) { s += Math . abs ( A [ i ] [ j ] ) ; } f = Math . max ( f , s ) ; } return f ; } 
public List < User > getUsers ( ) { if ( users == null ) { users = new ArrayList < User > ( ) ; } return this . users ; } 
public XObject eval ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { PrefixResolverDefault prefixResolver = new PrefixResolverDefault ( ( namespaceNode . getNodeType ( ) == Node . DOCUMENT_NODE ) ? ( ( Document ) namespaceNode ) . getDocumentElement ( ) : namespaceNode ) ; XPath xpath = new XPath ( str , null , prefixResolver , XPath . SELECT , null ) ; int ctxtNode = xpathSupport . getDTMHandleFromNode ( contextNode ) ; return xpath . execute ( xpathSupport , ctxtNode , prefixResolver ) ; } 
private void addPatternToGroup ( final LocationPathPattern lpp ) { if ( lpp instanceof IdKeyPattern ) { addPattern ( - 1 , lpp ) ; } else { final StepPattern kernel = lpp . getKernelPattern ( ) ; if ( kernel != null ) { addPattern ( kernel . getNodeType ( ) , lpp ) ; } else if ( _rootPattern == null || lpp . noSmallerThan ( _rootPattern ) ) { _rootPattern = lpp ; } } } 
public boolean isEmpty ( ) { return assertionSets . size ( ) == 1 && assertionSets . get ( 0 ) . isEmpty ( ) ; } 
private List < Object > generateOrderedList ( Object iToRender ) { Collection < ? extends Object > toRender = ( Collection < ? > ) iToRender ; List < Object > list = new LinkedList < Object > ( ) ; if ( toRender != null ) { list . addAll ( toRender ) ; } return list ; } 
public java . sql . Blob getBlob ( int columnIndex ) throws SQLException { if ( ! this . isBinaryEncoded ) { checkRowPos ( ) ; checkColumnBounds ( columnIndex ) ; if ( this . thisRow [ columnIndex - 1 ] == null ) { this . wasNullFlag = true ; } else { this . wasNullFlag = false ; } if ( this . wasNullFlag ) { return null ; } if ( ! this . connection . getEmulateLocators ( ) ) { return new Blob ( ( byte [ ] ) this . thisRow [ columnIndex - 1 ] ) ; } return new BlobFromLocator ( this , columnIndex ) ; } return getNativeBlob ( columnIndex ) ; } 
public SolrQuery removeSort ( String itemName ) { if ( sortClauses != null ) { for ( SortClause existing : sortClauses ) { if ( existing . getItem ( ) . equals ( itemName ) ) { sortClauses . remove ( existing ) ; if ( sortClauses . isEmpty ( ) ) sortClauses = null ; serializeSorts ( ) ; break ; } } } return this ; } 
public void println ( ) { javaLine ++ ; writer . println ( "" ) ; } 
public float getAngleForPoint ( float x , float y ) { PointF c = getCenterOffsets ( ) ; double tx = x - c . x , ty = y - c . y ; double length = Math . sqrt ( tx * tx + ty * ty ) ; double r = Math . acos ( ty / length ) ; float angle = ( float ) Math . toDegrees ( r ) ; if ( x > c . x ) angle = 360f - angle ; angle = angle + 90f ; if ( angle > 360f ) angle = angle - 360f ; return angle ; } 
public double getDoubleProperty ( String name , double defaultValue ) { Bundle bundle = this . getIntent ( ) . getExtras ( ) ; if ( bundle == null ) { return defaultValue ; } name = name . toLowerCase ( Locale . getDefault ( ) ) ; Double p ; try { p = ( Double ) bundle . get ( name ) ; } catch ( ClassCastException e ) { p = Double . parseDouble ( bundle . get ( name ) . toString ( ) ) ; } if ( p == null ) { return defaultValue ; } return p . doubleValue ( ) ; } 
public boolean dispatchKeyEvent ( KeyEvent event ) { if ( ( mOnKeyListener != null ) && ( mOnKeyListener . onKey ( this , event . getKeyCode ( ) , event ) ) ) { return true ; } if ( mWindow . superDispatchKeyEvent ( event ) ) { return true ; } return event . dispatch ( this , mDecor != null ? mDecor . getKeyDispatcherState ( ) : null , this ) ; } 
private String getLoginNameForPrincipal ( String loginName , String displayName , boolean isDomainGroup ) { if ( isDomainGroup && performSidLookup && loginName . startsWith ( "c:0+.w|" ) ) { try { String groupSid = loginName . substring ( 7 ) ; String principal = adClient . getUserAccountBySid ( loginName . substring ( 7 ) ) ; if ( principal == null ) { log . log ( Level . WARNING , "Could-not-resolve-login-name-for-SID-{0}." + "-Using-display-name-{1}-as-fallback." , new Object [ ] { groupSid , displayName } ) ; return displayName ; } else { return principal ; } } catch ( IOException ex ) { log . log ( Level . WARNING , String . format ( "Error-performing-SID-lookup-for-" + "User-%s.-Returing-display-name-%s-as-fallback." , loginName , displayName ) , ex ) ; return displayName ; } } else { return decodeClaim ( loginName , displayName ) ; } } 
public Collection < String > getPublicationLabels ( ) { Collection < PublicationLabelConstruct > labels ; labels = this . getRepeatingExtension ( PublicationLabelConstruct . class ) ; ArrayList < String > ret = new ArrayList < String > ( labels . size ( ) ) ; for ( PublicationLabelConstruct l : labels ) { ret . add ( l . getValue ( ) ) ; } return ret ; } 
public void edit ( File file ) throws IOException { checkAWTPermission ( ) ; checkExec ( ) ; checkActionSupport ( Action . EDIT ) ; file . canWrite ( ) ; checkFileValidation ( file ) ; peer . edit ( file ) ; } 
@ XmlElementDecl ( namespace = "http://xmlns.oracle.com/Primavera/P6/V7/API/BusinessObjects" , name = "BaselinePlannedNonLaborCost" , scope = ActivityType . class ) public JAXBElement < Double > createActivityTypeBaselinePlannedNonLaborCost ( Double value ) { return new JAXBElement < Double > ( _ActivityTypeBaselinePlannedNonLaborCost_QNAME , Double . class , ActivityType . class , value ) ; } 
public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( ) ; newVector . add ( new Option ( "-Node-splitting-method-to-use.-" + "-(default:-weka.core.neighboursearch.kdtrees.SlidingMidPointOfWidestSide)" , "S" , 1 , "-S-<classname-and-options>" ) ) ; newVector . addElement ( new Option ( "-Set-minimal-width-of-a-box-" + "-(default:-1.0E-2)." , "W" , 0 , "-W-<value>" ) ) ; newVector . addElement ( new Option ( "-Maximal-number-of-instances-in-a-leaf-" + "-(default:-40)." , "L" , 0 , "-L" ) ) ; newVector . addElement ( new Option ( "-Normalizing-will-be-done-" + "-(Select-dimension-for-split,-with-normalising-to-universe)." , "N" , 0 , "-N" ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; } 
private static byte [ ] fromHex ( String hex ) { byte [ ] binary = new byte [ hex . length ( ) / 2 ] ; for ( int i = 0 ; i < binary . length ; i ++ ) { binary [ i ] = ( byte ) Integer . parseInt ( hex . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; } return binary ; } 
public String toStringLatex ( ) { List < List < String >> table = toStringMatrix ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < table . size ( ) ; i ++ ) { List < String > row = table . get ( i ) ; for ( int j = 0 ; j < row . size ( ) ; j ++ ) { String value = row . get ( j ) ; if ( ( i == 0 || j == 0 ) && ! value . isEmpty ( ) ) { sb . append ( "|textbf{" ) . append ( value ) . append ( "}-" ) ; } else { sb . append ( value ) ; sb . append ( "-" ) ; } if ( j < row . size ( ) - 1 ) { sb . append ( "&-" ) ; } } sb . append ( "||-" ) ; } return sb . toString ( ) ; } 
public Element getFormElement ( Element element ) { if ( elements . contains ( element ) ) return elements . get ( elements . indexOf ( element ) ) ; else return null ; } 
@ XmlElementDecl ( namespace = "urn:ebay:apis:eBLBaseComponents" , name = "AddToItemDescriptionRequest" ) public JAXBElement < AddToItemDescriptionRequestType > createAddToItemDescriptionRequest ( AddToItemDescriptionRequestType value ) { return new JAXBElement < AddToItemDescriptionRequestType > ( _AddToItemDescriptionRequest_QNAME , AddToItemDescriptionRequestType . class , null , value ) ; } 
@ Override public void setConf ( Configuration configuration ) { this . conf = configuration ; String [ ] rawScans = conf . getStrings ( SCANS ) ; if ( rawScans . length <= 0 ) { throw new IllegalArgumentException ( "There-must-be-at-least-1-scan-configuration-set-to-:-" + SCANS ) ; } List < Scan > scans = new ArrayList < Scan > ( ) ; for ( int i = 0 ; i < rawScans . length ; i ++ ) { try { scans . add ( TableMapReduceUtil . convertStringToScan ( rawScans [ i ] ) ) ; } catch ( IOException e ) { throw new RuntimeException ( "Failed-to-convert-Scan-:-" + rawScans [ i ] + "-to-string" , e ) ; } } this . setScans ( scans ) ; } 
public boolean isStandalone ( ) { return uplinks . isEmpty ( ) && downlinks . isEmpty ( ) ; } 
public void addLogin ( final String login ) { loginsExistants . add ( login ) ; } 
private void setAdd ( int y ) { setAdd ( this , y ) ; } 
public Set < String > getNonCriticalExtensions ( ) { if ( noncritical == null ) { makeOidsLists ( ) ; } return noncritical ; } 
@ Override public Value containsStrict ( Value value ) { for ( Entry entry = getHead ( ) ; entry != null ; entry = entry . getNext ( ) ) { if ( entry . getValue ( ) . eql ( value ) ) return entry . getKey ( ) ; } return NullValue . NULL ; } 
public void addColumn ( String columnName , String columnType ) { columnsMap . put ( columnName , columnType ) ; } 
public int vertexNumber ( ) { return vertices . size ( ) ; } 
@ Deprecated public void deleteLocalFiles ( ) throws IOException { String [ ] localDirs = getLocalDirs ( ) ; for ( int i = 0 ; i < localDirs . length ; i ++ ) { FileSystem . getLocal ( this ) . delete ( new Path ( localDirs [ i ] ) ) ; } } 
public Number getField ( DatatypeConstants . Field field ) { if ( field == null ) { String methodName = "javax.xml.datatype.Duration" + "#isSet(DatatypeConstants.Field-field)-" ; throw new NullPointerException ( DatatypeMessageFormatter . formatMessage ( null , "FieldCannotBeNull" , new Object [ ] { methodName } ) ) ; } if ( field == DatatypeConstants . YEARS ) { return years ; } if ( field == DatatypeConstants . MONTHS ) { return months ; } if ( field == DatatypeConstants . DAYS ) { return days ; } if ( field == DatatypeConstants . HOURS ) { return hours ; } if ( field == DatatypeConstants . MINUTES ) { return minutes ; } if ( field == DatatypeConstants . SECONDS ) { return seconds ; } String methodName = "javax.xml.datatype.Duration" + "#(getSet(DatatypeConstants.Field-field)" ; throw new IllegalArgumentException ( DatatypeMessageFormatter . formatMessage ( null , "UnknownField" , new Object [ ] { methodName , field . toString ( ) } ) ) ; } 
@ Override public void println ( int priority , String tag , String msg , Throwable tr ) { String priorityStr = null ; switch ( priority ) { case android . util . Log . VERBOSE : priorityStr = "VERBOSE" ; break ; case android . util . Log . DEBUG : priorityStr = "DEBUG" ; break ; case android . util . Log . INFO : priorityStr = "INFO" ; break ; case android . util . Log . WARN : priorityStr = "WARN" ; break ; case android . util . Log . ERROR : priorityStr = "ERROR" ; break ; case android . util . Log . ASSERT : priorityStr = "ASSERT" ; break ; default : break ; } String exceptionStr = null ; if ( tr != null ) { exceptionStr = android . util . Log . getStackTraceString ( tr ) ; } final StringBuilder outputBuilder = new StringBuilder ( ) ; String delimiter = "-" ; appendIfNotNull ( outputBuilder , priorityStr , delimiter ) ; appendIfNotNull ( outputBuilder , tag , delimiter ) ; appendIfNotNull ( outputBuilder , msg , delimiter ) ; appendIfNotNull ( outputBuilder , exceptionStr , delimiter ) ; ( ( Activity ) getContext ( ) ) . runOnUiThread ( ( new Thread ( new Runnable ( ) { @ Override public void run ( ) { appendToLog ( outputBuilder . toString ( ) ) ; } } ) ) ) ; if ( mNext != null ) { mNext . println ( priority , tag , msg , tr ) ; } } 
public FileAttribute ( String fileName , int fileSize ) throws ParameterException { if ( fileName == null || fileName . length ( ) == 0 ) { throw new ParameterException ( "FileAttribute():-Error---invalid-file-name." ) ; } if ( fileSize <= 0 ) { throw new ParameterException ( "FileAttribute():-Error---size-<=-0." ) ; } size = fileSize ; name = fileName ; Date date = CloudSim . getSimulationCalendar ( ) . getTime ( ) ; if ( date == null ) { creationTime = 0 ; } else { creationTime = date . getTime ( ) ; } ownerName = null ; id = File . NOT_REGISTERED ; checksum = 0 ; type = File . TYPE_UNKOWN ; lastUpdateTime = 0 ; cost = 0 ; resourceId = - 1 ; masterCopy = true ; readOnly = false ; } 
public int getSpan ( int index ) { return span_ . get ( index ) ; } 
@ Deprecated public void setMinutes ( int minute ) { GregorianCalendar cal = new GregorianCalendar ( milliseconds ) ; cal . set ( Calendar . MINUTE , minute ) ; milliseconds = cal . getTimeInMillis ( ) ; } 
@ Override protected Control createDialogArea ( Composite parent ) { Composite container = ( Composite ) super . createDialogArea ( parent ) ; container . setLayout ( new GridLayout ( ) ) ; if ( returnType . equals ( "boolean" ) ) { final Label label = new Label ( container , SWT . NONE ) ; GridData data = new GridData ( SWT . CENTER , SWT . BOTTOM , true , true ) ; data . widthHint = 160 ; data . heightHint = 42 ; label . setLayoutData ( data ) ; label . setText ( message ) ; final ComboViewer comboViewer = new ComboViewer ( container , SWT . BORDER ) ; combo = comboViewer . getCombo ( ) ; final GridData gd_combo = new GridData ( SWT . CENTER , SWT . FILL , false , true ) ; gd_combo . widthHint = 136 ; combo . setLayoutData ( gd_combo ) ; combo . add ( "false" ) ; combo . add ( "true" ) ; if ( expectancyValue . equals ( "false" ) ) { combo . select ( 0 ) ; } else { combo . select ( 1 ) ; } } else { text = new Text ( container , SWT . BORDER ) ; text . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , false ) ) ; text . setText ( expectancyValue ) ; text . selectAll ( ) ; } return container ; } 
public void printSortedList ( List < String > finalKeywordsList , double [ ] [ ] resultMatrix , int howManyLatents ) { Map < String , Float > latentcy = new HashMap < String , Float > ( resultMatrix . length ) ; Map < String , Float > sorted = new HashMap < String , Float > ( resultMatrix . length ) ; Utility ut = new Utility ( ) ; int columnSize = resultMatrix . length ; for ( int j = 0 ; j < howManyLatents ; j ++ ) { for ( int i = 0 ; i < columnSize ; i ++ ) { latentcy . put ( finalKeywordsList . get ( i ) , ( float ) resultMatrix [ i ] [ j ] ) ; } sorted = ut . sortByComparator ( latentcy ) ; Iterator it = sorted . entrySet ( ) . iterator ( ) ; int numToPrint = Math . min ( 10 , sorted . size ( ) ) ; for ( int wordcount = 0 ; wordcount < numToPrint ; wordcount ++ ) { if ( it . hasNext ( ) ) { Map . Entry pairs = ( Map . Entry ) it . next ( ) ; System . out . printf ( "%-22s-=-%10.8f" , pairs . getKey ( ) , pairs . getValue ( ) ) ; System . out . println ( ) ; } } System . out . println ( ) ; latentcy . clear ( ) ; sorted . clear ( ) ; } } 
public static SocketChannel open ( SocketAddress remote ) throws IOException { SocketChannel sc = open ( ) ; try { sc . connect ( remote ) ; } catch ( Throwable x ) { try { sc . close ( ) ; } catch ( Throwable suppressed ) { x . addSuppressed ( suppressed ) ; } throw x ; } assert sc . isConnected ( ) ; return sc ; } 
public void setCurrentPos ( int i ) { if ( null == m_cachedNodes ) throw new RuntimeException ( "This-NodeSetDTM-can-not-do-indexing-or-counting-functions!" ) ; m_next = i ; m_cachedNodes . setCurrentPos ( i ) ; } 
protected final boolean isNextCharUTCSign ( String buffer , int start , int end ) { if ( start < end ) { char c = buffer . charAt ( start ) ; return ( c == 'Z' || c == '+' || c == '-' ) ; } return false ; } 
public static java . text . DateFormat getDateFormat ( Context context ) { String value = Settings . System . getString ( context . getContentResolver ( ) , Settings . System . DATE_FORMAT ) ; return getDateFormatForSetting ( context , value ) ; } 
static BigInteger sanitize ( Number value , int signum ) { if ( signum == 0 || value == null ) { return BigInteger . ZERO ; } return ( signum < 0 ) ? ( ( BigInteger ) value ) . negate ( ) : ( BigInteger ) value ; } 
@ Override public int hashCode ( ) { return getName ( ) . hashCode ( ) ^ getDeclaringClass ( ) . getName ( ) . hashCode ( ) ; } 
public static void closeAll ( Closeable a , Closeable b ) throws IOException { Throwable thrown = null ; try { a . close ( ) ; } catch ( Throwable e ) { thrown = e ; } try { b . close ( ) ; } catch ( Throwable e ) { if ( thrown == null ) thrown = e ; } if ( thrown == null ) return ; if ( thrown instanceof IOException ) throw ( IOException ) thrown ; if ( thrown instanceof RuntimeException ) throw ( RuntimeException ) thrown ; if ( thrown instanceof Error ) throw ( Error ) thrown ; throw new AssertionError ( thrown ) ; } 
public final int toChars ( int [ ] src , int srcOff , int srcLen , char [ ] dest , int destOff ) { if ( srcLen < 0 ) { throw new IllegalArgumentException ( "srcLen-must-be->=-0" ) ; } int written = 0 ; for ( int i = 0 ; i < srcLen ; ++ i ) { written += Character . toChars ( src [ srcOff + i ] , dest , destOff + written ) ; } return written ; } 
public static int numberOfLeadingZeros ( long value ) { value |= value >>> 1 ; value |= value >>> 2 ; value |= value >>> 4 ; value |= value >>> 8 ; value |= value >>> 16 ; value |= value >>> 32 ; return bitCount ( ~ value ) ; } 
@ Override protected void doWriteObject ( final ObjectOutputStream out ) throws IOException { out . writeInt ( keyType . value ) ; out . writeInt ( valueType . value ) ; out . writeBoolean ( purgeValues ) ; out . writeFloat ( loadFactor ) ; out . writeInt ( data . length ) ; for ( final MapIterator < K , V > it = mapIterator ( ) ; it . hasNext ( ) ; ) { out . writeObject ( it . next ( ) ) ; out . writeObject ( it . getValue ( ) ) ; } out . writeObject ( null ) ; } 
public void setMinusSign ( char v ) { m_dfs . setMinusSign ( v ) ; } 
public String getName ( ) { return Util . convertName ( name ) ; } 
protected static String getMessagePrefix ( Mixer mixer ) { return mixer . getMixerInfo ( ) . getName ( ) ; } 
public byte nextByte ( ) { return nextByte ( currentRadix ) ; } 
public int getAD_Element_ID ( ) { Integer ii = ( Integer ) get_Value ( COLUMNNAME_AD_Element_ID ) ; if ( ii == null ) return 0 ; return ii . intValue ( ) ; } 
public final Collection < ? extends CRL > getCRLs ( CRLSelector selector ) throws CertStoreException { return spiImpl . engineGetCRLs ( selector ) ; } 
public boolean hasExtension ( String typeUri ) { return _extAliases . containsKey ( typeUri ) ; } 
public void addSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { mListeners = new ArrayList < SwipeListener > ( ) ; } mListeners . add ( listener ) ; } 
public Rectangle getBounds ( ) { return new Rectangle ( this . bounds ) ; } 
public void setSourcePaths ( List < Path > sourcePaths ) { assert sourcePaths != null && sourcePaths . size ( ) != 0 ; this . sourcePaths = sourcePaths ; } 
public static double findMax ( ArrayList < Double > matrix ) { double result = Double . NEGATIVE_INFINITY ; for ( int i = 0 ; i < matrix . size ( ) ; i ++ ) if ( result < matrix . get ( i ) ) result = matrix . get ( i ) ; return result ; } 
public static File createUniqueFile ( File directory , String filename ) throws IOException { return createUniqueFileInternal ( NewFileCreator . DEFAULT , directory , filename ) ; } 
public void setHeader ( String key , String value ) { headers . set ( key , value ) ; } 
public synchronized void print ( String str ) { if ( out == null ) { setError ( ) ; return ; } if ( str == null ) { print ( "null" ) ; return ; } try { if ( encoding == null ) { write ( str . getBytes ( ) ) ; } else { write ( str . getBytes ( encoding ) ) ; } } catch ( IOException e ) { setError ( ) ; } } 
public void startSeriesPass ( XYDataset dataset , int series , int firstItem , int lastItem , int pass , int passCount ) { this . seriesPath . reset ( ) ; this . lastPointGood = false ; super . startSeriesPass ( dataset , series , firstItem , lastItem , pass , passCount ) ; } 
public static int binarySearch ( short [ ] a , short key ) { return binarySearch0 ( a , 0 , a . length , key ) ; } 
private void determine_depths ( ) { if ( debug ) System . out . println ( "determine_depths" ) ; Loop lp = new Loop ( ) ; int i , j ; for ( i = 0 ; i < loop_count ; i ++ ) { lp = loops . get ( i ) ; for ( j = 0 ; j < loop_count ; j ++ ) loops . get ( j ) . setMark ( false ) ; lp . setDepth ( depth ( lp ) ) ; } } 
private void interruptIdleWorkers ( boolean onlyOne ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { for ( Worker w : workers ) { Thread t = w . thread ; if ( ! t . isInterrupted ( ) && w . tryLock ( ) ) { try { t . interrupt ( ) ; } catch ( SecurityException ignore ) { } finally { w . unlock ( ) ; } } if ( onlyOne ) break ; } } finally { mainLock . unlock ( ) ; } } 
public void removeClass ( JavaClass clazz ) { _loadedClasses . remove ( clazz . getClassName ( ) ) ; } 
public List < BranchSubtype > getBranchSubtype ( ) { if ( branchSubtype == null ) { branchSubtype = new ArrayList < BranchSubtype > ( ) ; } return this . branchSubtype ; } 
public void writeText ( String text ) { buffer . append ( text ) ; } 
public static boolean disjoint ( Collection < ? > c1 , Collection < ? > c2 ) { Collection < Object > oc1 = ( Collection < Object > ) c1 ; final Iterator < Object > it = oc1 . iterator ( ) ; while ( it . hasNext ( ) ) if ( c2 . contains ( it . next ( ) ) ) return false ; return true ; } 
protected void setRootPane ( JRootPane root ) { if ( rootPane != null ) { remove ( rootPane ) ; } rootPane = root ; if ( rootPane != null ) { boolean checkingEnabled = isRootPaneCheckingEnabled ( ) ; try { setRootPaneCheckingEnabled ( false ) ; add ( rootPane , BorderLayout . CENTER ) ; } finally { setRootPaneCheckingEnabled ( checkingEnabled ) ; } } } 
public final ScriptableObject initStandardObjects ( ) { return initStandardObjects ( null , false ) ; } 
public void connectDatabase ( ) { try { Class . forName ( _jdbcDriver ) ; _con = DriverManager . getConnection ( _url , _userName , _password ) ; } catch ( SQLException e ) { LOG . warn ( "UserRealm-" + getName ( ) + "-could-not-connect-to-database;-will-try-later" , e ) ; } catch ( ClassNotFoundException e ) { LOG . warn ( "UserRealm-" + getName ( ) + "-could-not-connect-to-database;-will-try-later" , e ) ; } } 
public void drawArc ( int x , int y , int width , int height , int startAngle , int arcAngle ) { if ( ( debugOptions & LOG_OPTION ) != 0 ) { logStream ( ) . println ( prefix ( ) + "-Drawing-arc:-" + new Rectangle ( x , y , width , height ) + "-startAngle:-" + startAngle + "-arcAngle:-" + arcAngle ) ; } graphics . drawArc ( x , y , width , height , startAngle , arcAngle ) ; } 
protected Scanner ( Factory fac , char [ ] input , int inputLength ) { this ( fac ) ; eofPos = inputLength ; if ( inputLength == input . length ) { if ( input . length > 0 && Character . isWhitespace ( input [ input . length - 1 ] ) ) { inputLength -- ; } else { char [ ] newInput = new char [ inputLength + 1 ] ; System . arraycopy ( input , 0 , newInput , 0 , input . length ) ; input = newInput ; } } buf = input ; buflen = inputLength ; buf [ buflen ] = EOI ; bp = - 1 ; scanChar ( ) ; } 
public static File buildNewFileName ( File file , String directory ) { if ( null == file || null == directory ) { throw new InvalidParameterException ( "File-is:" + file + ",-and-directory-is:" + directory + ",-both-must-not-be-be-null!" ) ; } String newFileName = null ; try { newFileName = DateFormatter . getFormattedStringForFileRename ( new Date ( ) ) + file . getName ( ) ; } catch ( ParseException e ) { log . error ( "Unable-to-create-a-new-file-name!" ) ; newFileName = System . currentTimeMillis ( ) + file . getName ( ) ; } return new File ( directory , newFileName ) ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public int indexOf ( String s ) { return str . indexOf ( s , index ) ; } 
public IMOps p_level ( Double black_point , Double white_point , Boolean percent ) { String oper ; StringBuffer buf = new StringBuffer ( ) ; iCmdArgs . add ( "+level" ) ; if ( black_point != null ) { buf . append ( black_point . toString ( ) ) ; } buf . append ( "," ) ; if ( white_point != null ) { buf . append ( white_point . toString ( ) ) ; } if ( percent != null ) { if ( percent . booleanValue ( ) ) buf . append ( "%" ) ; } if ( buf . length ( ) > 0 ) { iCmdArgs . add ( buf . toString ( ) ) ; } return this ; } 
public Object instantiate ( String className , ObjectName loaderName , ClassLoader loader ) throws ReflectionException , MBeanException , InstanceNotFoundException { return instantiate ( className , loaderName , ( Object [ ] ) null , ( String [ ] ) null , loader ) ; } 
private void writeStartElement ( java . lang . String prefix , java . lang . String namespace , java . lang . String localPart , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String writerPrefix = xmlWriter . getPrefix ( namespace ) ; if ( writerPrefix != null ) { xmlWriter . writeStartElement ( namespace , localPart ) ; } else { if ( namespace . length ( ) == 0 ) { prefix = "" ; } else if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; } xmlWriter . writeStartElement ( prefix , localPart , namespace ) ; xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } } 
private int getTabPositionFromNavigationItemPosition ( int navItemPos ) { switch ( navItemPos ) { case 0 : return TabState . FAVORITES ; case 1 : return TabState . ALL ; case 2 : return TabState . GROUPS ; } throw new IllegalArgumentException ( "Parameter-must-be-between-0-and-" + Integer . toString ( TabState . COUNT - 1 ) + "-inclusive." ) ; } 
final boolean tryMatchData ( ) { Object x = item ; if ( x != null && x != this && casItem ( x , null ) ) { LockSupport . unpark ( waiter ) ; return true ; } return false ; } 
private static Handler getHandler ( String key ) { checkQueue ( ) ; WeakReference < Handler > handlerReferent = null ; if ( ( handlerReferent = handlerMap . get ( key ) ) != null ) { Log . d ( TAG , key + "-has-handler" ) ; return handlerReferent . get ( ) ; } Log . w ( TAG , key + "-does-not-have-handler" ) ; return null ; } 
public static long folderSize ( File directory ) { if ( directory == null || ! directory . exists ( ) ) { return - 1 ; } if ( directory . isFile ( ) ) { return directory . length ( ) ; } long length = 0 ; for ( File file : directory . listFiles ( ) ) { if ( file . isFile ( ) ) { length += file . length ( ) ; } else { length += folderSize ( file ) ; } } return length ; } 
public static Path move ( Path source , Path target , CopyOption ... options ) throws IOException { FileSystemProvider provider = provider ( source ) ; if ( provider ( target ) == provider ) { provider . move ( source , target , options ) ; } else { CopyMoveHelper . moveToForeignTarget ( source , target , options ) ; } return target ; } 
private static boolean eq ( Object o1 , Object o2 ) { return o1 == null ? o2 == null : o1 . equals ( o2 ) ; } 
public boolean isPublic ( ) { return Modifier . isPublic ( method . getModifiers ( ) ) ; } 
@ Nonnull public JDefinedClass _implements ( @ Nonnull final AbstractJClass iface ) { m_aInterfaces . add ( iface ) ; return this ; } 
public StorageFormat findStorageFormat ( File file ) { Iterator formatsIterator = myStorageFormats . iterator ( ) ; StorageFormat currentStorageFormat ; while ( formatsIterator . hasNext ( ) ) { currentStorageFormat = ( StorageFormat ) formatsIterator . next ( ) ; if ( currentStorageFormat . getFileFilter ( ) . accept ( file ) ) { return currentStorageFormat ; } } return null ; } 
public static boolean cleanFolder ( File folder , boolean removeParent ) { if ( folder . isDirectory ( ) ) { String [ ] filenames = folder . list ( ) ; for ( String filename : filenames ) { File file = new File ( folder , filename ) ; if ( file . isDirectory ( ) ) { boolean ok = cleanFolder ( new File ( folder , filename ) , true ) ; if ( ! ok ) { return false ; } } else { boolean ok = file . delete ( ) ; if ( ! ok ) { return false ; } } } } if ( removeParent ) { return folder . delete ( ) ; } else { return true ; } } 
public OutputStream bindStream ( final OutputStream output ) { final OutputStream stream = m_streams . get ( ) ; m_streams . set ( output ) ; return stream ; } 
private Result pDeclarators$$Star1$1 ( final int yyStart ) throws IOException { Result yyResult ; Pair < Node > yyValue ; ParseError yyError = ParseError . DUMMY ; yyResult = pSymbol ( yyStart ) ; if ( yyResult . hasValue ( ) && ( ( Node ) yyResult . semanticValue ( ) ) . getTokenText ( ) . equals ( "," ) ) { final Node v$pt$1 = yyResult . semanticValue ( ) ; yyResult = pDeclarator ( yyResult . index ) ; yyError = yyResult . select ( yyError ) ; if ( yyResult . hasValue ( ) ) { final Node v$pt$2 = yyResult . semanticValue ( ) ; final Node v$el$1 = Formatting . before1 ( v$pt$1 , v$pt$2 ) ; yyResult = pDeclarators$$Star1 ( yyResult . index ) ; yyError = yyResult . select ( yyError ) ; if ( yyResult . hasValue ( ) ) { final Pair < Node > v$2 = yyResult . semanticValue ( ) ; yyValue = new Pair < Node > ( v$el$1 , v$2 ) ; return yyResult . createValue ( yyValue , yyError ) ; } } } yyValue = Pair . empty ( ) ; return new SemanticValue ( yyValue , yyStart , yyError ) ; } 
private String parseTypeString ( String typeString ) { StringBuilder result = new StringBuilder ( typeString ) ; for ( int i = 0 ; i < result . length ( ) ; i ++ ) { char c = result . charAt ( i ) ; if ( ! ( Character . isLetter ( c ) || Character . isDigit ( c ) || c == '.' ) ) { result . setCharAt ( i , '_' ) ; } } return result . toString ( ) ; } 
public Instruction accept ( NodeVisitor iVisitor ) { return iVisitor . visitDRegxNode ( this ) ; } 
public static int decode ( String data , OutputStream out ) throws IOException { return encoder . decode ( data , out ) ; } 
private void notifyConnectCompleted ( ConnectionParams cp , FailCause cause ) { Message connectionCompletedMsg = cp . onCompletedMsg ; if ( connectionCompletedMsg == null ) { return ; } long timeStamp = System . currentTimeMillis ( ) ; connectionCompletedMsg . arg1 = cid ; if ( cause == FailCause . NONE ) { createTime = timeStamp ; AsyncResult . forMessage ( connectionCompletedMsg ) ; } else { lastFailCause = cause ; lastFailTime = timeStamp ; AsyncResult . forMessage ( connectionCompletedMsg , cause , new Exception ( ) ) ; } if ( DBG ) log ( "notifyConnection-at-" + timeStamp + "-cause=" + cause ) ; connectionCompletedMsg . sendToTarget ( ) ; } 
Map < String , Queue > getInnerQueues ( ) { Map < String , Queue > l = new HashMap < String , Queue > ( ) ; if ( children == null ) { return l ; } for ( Queue child : children ) { if ( child . getChildren ( ) != null && child . getChildren ( ) . size ( ) > 0 ) { l . put ( child . getName ( ) , child ) ; l . putAll ( child . getInnerQueues ( ) ) ; } } return l ; } 
private Annotation parseAnnotation ( String signature ) throws ConfigException { int p = signature . indexOf ( '(' ) ; String className ; if ( p > 0 ) className = signature . substring ( 0 , p ) ; else className = signature ; try { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; Class cl = Class . forName ( className , false , loader ) ; Annotation ann = ( Annotation ) cl . newInstance ( ) ; return ann ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw ConfigException . create ( e ) ; } } 
protected void initBeforeApplicationStart ( String fileName ) throws FileNotFoundException , Exception { if ( fileName == null ) { return ; } List < String > classList = new ArrayList < String > ( ) ; Scanner scanner = new Scanner ( new File ( fileName ) ) ; while ( scanner . hasNextLine ( ) ) { String line = scanner . nextLine ( ) ; List < String > cl = DirectoryTraverser . getClassNames ( line ) ; if ( cl . size ( ) != 0 ) { classList . addAll ( cl ) ; } else { classList . add ( scanner . nextLine ( ) ) ; } } doModificationForClasses ( classList ) ; } 
public void setReceiverCC ( String mailToCC ) { tfMailToCC . setText ( mailToCC ) ; } 
public static File adjustExtension ( File file , String preferredExtension , String [ ] acceptableExtensions , String extension ) { File returnValue = file ; if ( file != null ) { String originalParent = file . getParent ( ) ; String originalName = file . getName ( ) ; String mainName = "" ; if ( originalParent != null ) { mainName = originalParent + File . separator ; } if ( ( extension . length ( ) > 0 ) && originalName . endsWith ( extension ) ) { mainName += originalName . substring ( 0 , originalName . length ( ) - extension . length ( ) - 1 ) ; } else { int dotIndex = originalName . lastIndexOf ( '.' ) ; if ( dotIndex > 0 && dotIndex < ( originalName . length ( ) - 1 ) ) { mainName += originalName . substring ( 0 , dotIndex ) ; extension = originalName . substring ( dotIndex + 1 ) ; } else { mainName += originalName ; extension = "" ; } } returnValue = new File ( mainName + "." + extension ) ; if ( ! checkExtension ( returnValue , acceptableExtensions ) ) returnValue = new File ( mainName + "." + preferredExtension ) ; } return returnValue ; } 
private boolean isCaptivePortal ( InetAddress server ) { HttpURLConnection urlConnection = null ; if ( ! mIsCaptivePortalCheckEnabled ) return false ; mUrl = "http://" + server . getHostAddress ( ) + "/generate_204" ; if ( DBG ) log ( "Checking-" + mUrl ) ; try { URL url = new URL ( mUrl ) ; urlConnection = ( HttpURLConnection ) url . openConnection ( ) ; urlConnection . setInstanceFollowRedirects ( false ) ; urlConnection . setConnectTimeout ( SOCKET_TIMEOUT_MS ) ; urlConnection . setReadTimeout ( SOCKET_TIMEOUT_MS ) ; urlConnection . setUseCaches ( false ) ; urlConnection . getInputStream ( ) ; return urlConnection . getResponseCode ( ) != 204 ; } catch ( IOException e ) { if ( DBG ) log ( "Probably-not-a-portal:-exception-" + e ) ; return false ; } finally { if ( urlConnection != null ) { urlConnection . disconnect ( ) ; } } } 
@ Override public long getDelay ( final TimeUnit unit ) { final long millisLeft = renewalTime - System . currentTimeMillis ( ) ; return unit . convert ( millisLeft , TimeUnit . MILLISECONDS ) ; } 
public static synchronized void resetIntCache ( ) { if ( ! freeLargeArrays . isEmpty ( ) ) { freeLargeArrays . remove ( freeLargeArrays . size ( ) - 1 ) ; } if ( ! freeSmallArrays . isEmpty ( ) ) { freeSmallArrays . remove ( freeSmallArrays . size ( ) - 1 ) ; } freeLargeArrays . addAll ( inUseLargeArrays ) ; freeSmallArrays . addAll ( inUseSmallArrays ) ; inUseLargeArrays . clear ( ) ; inUseSmallArrays . clear ( ) ; } 
public static String [ ] getNames ( JSONObject jo ) { int length = jo . length ( ) ; if ( length == 0 ) { return null ; } Iterator i = jo . keys ( ) ; String [ ] names = new String [ length ] ; int j = 0 ; while ( i . hasNext ( ) ) { names [ j ] = ( String ) i . next ( ) ; j += 1 ; } return names ; } 
public void setBooleanValue ( boolean value ) { if ( ! TYPE_BOOLEAN . equals ( fieldType ) ) throw new IllegalArgumentException ( "This-method-can-only-be-called-when-the-field-type-is-boolean" ) ; if ( ! values . isEmpty ( ) ) values . clear ( ) ; if ( value ) addValue ( "1" ) ; else addValue ( "0" ) ; } 
public static Level getLevel ( String pKey ) { char level = pKey . charAt ( pKey . length ( ) - 1 ) ; switch ( level ) { case 'S' : return Level . SEVERE ; case 'W' : return Level . WARNING ; case 'I' : return Level . INFO ; case 'C' : return Level . CONFIG ; default : return null ; } } 
public int getShotScale ( int position ) { List < Entity > entities = new ArrayList < Entity > ( ) ; if ( tanks != null ) entities = StateBasedEntityManager . getInstance ( ) . getEntitiesByState ( Tanks . GAMEPLAYSTATE ) ; else entities = Map . getInstance ( ) . getEntities ( ) ; List < Shoot > shots = new ArrayList < Shoot > ( ) ; for ( Entity entity : entities ) { if ( entity . toString ( ) . startsWith ( "Shot" ) ) { shots . add ( ( Shoot ) entity ) ; } } if ( position < 0 || position > shots . size ( ) - 1 ) return - 1 ; return ( int ) ( shots . get ( position ) . getScale ( ) * 100 ) ; } 
public static DTMAxisIterator nodesetF ( Object obj ) { if ( obj instanceof DOM ) { final DOM dom = ( DOM ) obj ; return new SingletonIterator ( dom . getDocument ( ) , true ) ; } else if ( obj instanceof DTMAxisIterator ) { return ( DTMAxisIterator ) obj ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , "node-set" , className ) ; return null ; } } 
public void writeBoolean ( boolean val ) throws IOException { bout . writeBoolean ( val ) ; } 
public NetworkInterface getNetworkInterface ( ) throws SocketException { checkClosedAndBind ( false ) ; Integer theIndex = Integer . valueOf ( 0 ) ; try { theIndex = ( Integer ) impl . getOption ( SocketOptions . IP_MULTICAST_IF2 ) ; } catch ( SocketException e ) { } if ( theIndex . intValue ( ) != 0 ) { Enumeration < NetworkInterface > theInterfaces = NetworkInterface . getNetworkInterfaces ( ) ; while ( theInterfaces . hasMoreElements ( ) ) { NetworkInterface nextInterface = theInterfaces . nextElement ( ) ; if ( nextInterface . getIndex ( ) == theIndex . intValue ( ) ) { return nextInterface ; } } } InetAddress theAddress = ( InetAddress ) impl . getOption ( SocketOptions . IP_MULTICAST_IF ) ; if ( theAddress != null ) { if ( ! theAddress . isAnyLocalAddress ( ) ) { return NetworkInterface . getByInetAddress ( theAddress ) ; } InetAddress theAddresses [ ] = new InetAddress [ 1 ] ; if ( InetAddress . preferIPv6Addresses ( ) ) { theAddresses [ 0 ] = Inet6Address . ANY ; } else { theAddresses [ 0 ] = Inet4Address . ANY ; } return new NetworkInterface ( null , null , theAddresses , NetworkInterface . UNSET_INTERFACE_INDEX ) ; } return null ; } 
public static KeyStore getKeystore ( ) { KeyStore trustStore = null ; try { trustStore = KeyStore . getInstance ( KeyStore . getDefaultType ( ) ) ; trustStore . load ( null , null ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; } return trustStore ; } 
private SequenceB1 ( ) { super ( new ArrayList < Tag > ( ) ) ; } 
public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( getSign ( ) < 0 ) { buf . append ( '-' ) ; } buf . append ( 'P' ) ; BigInteger years = ( BigInteger ) getField ( DatatypeConstants . YEARS ) ; if ( years != null ) { buf . append ( years + "Y" ) ; } BigInteger months = ( BigInteger ) getField ( DatatypeConstants . MONTHS ) ; if ( months != null ) { buf . append ( months + "M" ) ; } BigInteger days = ( BigInteger ) getField ( DatatypeConstants . DAYS ) ; if ( days != null ) { buf . append ( days + "D" ) ; } BigInteger hours = ( BigInteger ) getField ( DatatypeConstants . HOURS ) ; BigInteger minutes = ( BigInteger ) getField ( DatatypeConstants . MINUTES ) ; BigDecimal seconds = ( BigDecimal ) getField ( DatatypeConstants . SECONDS ) ; if ( hours != null || minutes != null || seconds != null ) { buf . append ( 'T' ) ; if ( hours != null ) { buf . append ( hours + "H" ) ; } if ( minutes != null ) { buf . append ( minutes + "M" ) ; } if ( seconds != null ) { buf . append ( toString ( seconds ) + "S" ) ; } } return buf . toString ( ) ; } 
private static boolean isEmptyOrNull ( CharSequence s ) { return s == null || ( s . length ( ) == 0 ) ; } 
static public Object stringToValue ( String s ) { if ( s . equals ( "" ) ) { return s ; } if ( s . equalsIgnoreCase ( "true" ) ) { return Boolean . TRUE ; } if ( s . equalsIgnoreCase ( "false" ) ) { return Boolean . FALSE ; } if ( s . equalsIgnoreCase ( "null" ) ) { return JSONObject . NULL ; } char b = s . charAt ( 0 ) ; if ( ( b >= '0' && b <= '9' ) || b == '.' || b == '-' || b == '+' ) { if ( b == '0' && s . length ( ) > 2 && ( s . charAt ( 1 ) == 'x' || s . charAt ( 1 ) == 'X' ) ) { try { return new Integer ( Integer . parseInt ( s . substring ( 2 ) , 16 ) ) ; } catch ( Exception ignore ) { } } try { if ( s . indexOf ( '.' ) > - 1 || s . indexOf ( 'e' ) > - 1 || s . indexOf ( 'E' ) > - 1 ) { return Double . valueOf ( s ) ; } else { Long myLong = new Long ( s ) ; if ( myLong . longValue ( ) == myLong . intValue ( ) ) { return new Integer ( myLong . intValue ( ) ) ; } else { return myLong ; } } } catch ( Exception ignore ) { } } return s ; } 
public String getValueAsString ( ) { return Float . toString ( value ) ; } 
public static byte [ ] splitChannels ( byte [ ] array , byte [ ] rtn , int index , int c , int bytes , boolean reverse , boolean interleaved , int channelLength ) { if ( c == 1 ) return array ; if ( rtn == null ) { rtn = new byte [ array . length / c ] ; } if ( reverse ) index = c - index - 1 ; if ( ! interleaved ) { System . arraycopy ( array , channelLength * index , rtn , 0 , channelLength ) ; } else { int next = 0 ; for ( int i = 0 ; i < array . length ; i += c * bytes ) { for ( int k = 0 ; k < bytes ; k ++ ) { if ( next < rtn . length ) rtn [ next ] = array [ i + index * bytes + k ] ; next ++ ; } } } return rtn ; } 
public Node getXPathFilterTextNode ( ) { NodeList children = this . _constructionElement . getChildNodes ( ) ; int length = children . getLength ( ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( children . item ( i ) . getNodeType ( ) == Node . TEXT_NODE ) { return children . item ( i ) ; } } return null ; } 
private Entry < E > getEntry ( E key ) { return keyToEntry . get ( key ) ; } 
public Attr getAttributeNodeNS ( String namespaceURI , String localName ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes == null ) { return null ; } return ( Attr ) attributes . getNamedItemNS ( namespaceURI , localName ) ; } 
private ActivityChooserModel ( Context context , String historyFileName ) { mContext = context . getApplicationContext ( ) ; if ( ! TextUtils . isEmpty ( historyFileName ) && ! historyFileName . endsWith ( HISTORY_FILE_EXTENSION ) ) { mHistoryFileName = historyFileName + HISTORY_FILE_EXTENSION ; } else { mHistoryFileName = historyFileName ; } } 
static String parsePrefix ( String key ) { if ( key == null ) return null ; boolean inquotes = false ; for ( int i = 0 ; i < key . length ( ) ; i ++ ) { char c = key . charAt ( i ) ; if ( c == '"' ) { inquotes = ! inquotes ; } else if ( ( c == '[' || c == '.' ) && ! inquotes ) { return key . substring ( 0 , i ) ; } } return null ; } 
@ XmlElementDecl ( namespace = "http://ws.raul.com/" , name = "echo" ) public JAXBElement < Echo > createEcho ( Echo value ) { return new JAXBElement < Echo > ( _Echo_QNAME , Echo . class , null , value ) ; } 
@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public static void main ( String [ ] args ) throws Exception { String [ ] newArgs = new String [ args . length - 1 ] ; System . arraycopy ( args , 1 , newArgs , 0 , args . length - 1 ) ; Class clazz = Class . forName ( args [ 0 ] ) ; Method main = clazz . getMethod ( "main" , newArgs . getClass ( ) ) ; main . invoke ( null , ( Object ) newArgs ) ; } 
public void clear ( ) { currentStatus . clear ( ) ; } 
private void FillAttr ( Attribute Attr , JComponent JTF ) throws PDException { if ( Attr . getType ( ) == Attribute . tSTRING ) { Attr . setValue ( ( ( JTextField ) JTF ) . getText ( ) ) ; } else if ( Attr . getType ( ) == Attribute . tTHES ) { Attr . setValue ( ( ( ThesField ) JTF ) . getUseTerm ( ) . getPDId ( ) ) ; } else if ( Attr . getType ( ) == Attribute . tDATE ) { Attr . setValue ( ( Date ) ( ( JFormattedTextField ) JTF ) . getValue ( ) ) ; } else if ( Attr . getType ( ) == Attribute . tTIMESTAMP ) { Attr . setValue ( ( Date ) ( ( JFormattedTextField ) JTF ) . getValue ( ) ) ; } else if ( Attr . getType ( ) == Attribute . tBOOLEAN ) { Boolean Act ; if ( ( ( JCheckBox ) JTF ) . isSelected ( ) ) Act = new Boolean ( true ) ; else Act = new Boolean ( false ) ; Attr . setValue ( Act ) ; } else if ( Attr . getType ( ) == Attribute . tINTEGER ) { Long l = ( Long ) ( ( JFormattedTextField ) JTF ) . getValue ( ) ; if ( l != null ) Attr . setValue ( new Integer ( l . intValue ( ) ) ) ; } else Attr . setValue ( "Error" ) ; } 
private void removeStopCodonPeptides ( List peptides , List startIndices , List endIndices ) { Iterator pepIter = peptides . iterator ( ) ; Iterator startIter = startIndices . iterator ( ) ; Iterator endIter = endIndices . iterator ( ) ; while ( pepIter . hasNext ( ) ) { String peptide = ( String ) pepIter . next ( ) ; startIter . next ( ) ; endIter . next ( ) ; if ( peptide . indexOf ( "_" ) >= 0 ) { pepIter . remove ( ) ; startIter . remove ( ) ; endIter . remove ( ) ; } } } 
public void pickRandomSong ( ) { if ( this . backgroundSong != null ) return ; Cursor audioCursor = this . context . getContentResolver ( ) . query ( MediaStore . Audio . Media . EXTERNAL_CONTENT_URI , new String [ ] { MediaStore . Audio . Media . DATA } , null , null , null ) ; final int numRows = audioCursor . getCount ( ) ; if ( numRows > 0 ) { final int randomIndex = new Random ( ) . nextInt ( numRows - 1 ) ; audioCursor . moveToPosition ( randomIndex ) ; final String fn = audioCursor . getString ( audioCursor . getColumnIndex ( MediaStore . Audio . Media . DATA ) ) ; this . backgroundSong = Uri . parse ( fn ) ; } else this . backgroundSong = INTERNAL_FALLBACK_SONG ; audioCursor . close ( ) ; Log . i ( "AudioHelper.pickRandomSong" , "backgroundSong=" + this . backgroundSong . toString ( ) ) ; } 
private Method getMethod ( Class clazz , String name , Class [ ] params ) { try { return clazz . getMethod ( name , params ) ; } catch ( SecurityException e ) { return null ; } catch ( NoSuchMethodException e ) { return null ; } } 
public boolean isImportantForAccessibility ( ) { final int mode = ( mPrivateFlags2 & IMPORTANT_FOR_ACCESSIBILITY_MASK ) >> IMPORTANT_FOR_ACCESSIBILITY_SHIFT ; switch ( mode ) { case IMPORTANT_FOR_ACCESSIBILITY_YES : return true ; case IMPORTANT_FOR_ACCESSIBILITY_NO : return false ; case IMPORTANT_FOR_ACCESSIBILITY_AUTO : return isActionableForAccessibility ( ) || hasListenersForAccessibility ( ) ; default : throw new IllegalArgumentException ( "Unknow-important-for-accessibility-mode:-" + mode ) ; } } 
protected void removeTag ( short tagId ) { mExifTags . remove ( tagId ) ; } 
public static int createAudioPatch ( AudioPatch [ ] patch , AudioPortConfig [ ] sources , AudioPortConfig [ ] sinks ) { return AudioSystem . createAudioPatch ( patch , sources , sinks ) ; } 
public boolean accept ( File fileOrDirectory ) { if ( fileOrDirectory . isDirectory ( ) ) { return true ; } String fileOrDirectoryName = fileOrDirectory . getName ( ) ; int dotIndex = fileOrDirectoryName . lastIndexOf ( '.' ) ; if ( dotIndex < 0 ) { return false ; } String extension = fileOrDirectoryName . substring ( dotIndex ) ; if ( extension . equalsIgnoreCase ( ".gif" ) ) { return true ; } else { return false ; } } 
public static boolean isLocalFile ( Class clazz ) { String path = PlasticInternalUtils . toClassPath ( clazz . getName ( ) ) ; ClassLoader loader = clazz . getClassLoader ( ) ; if ( loader == null ) return false ; URL classFileURL = loader . getResource ( path ) ; return classFileURL != null && classFileURL . getProtocol ( ) . equals ( "file" ) ; } 
public static void main ( String [ ] args ) { GLProfile glp = GLProfile . getDefault ( ) ; GLCapabilities caps = new GLCapabilities ( glp ) ; GLCanvas canvas = new GLCanvas ( caps ) ; transMain myMain = new transMain ( canvas ) ; Frame frame = new Frame ( "CG1---3D-Transformation-and-Viewing" ) ; frame . setSize ( 512 , 512 ) ; frame . add ( canvas ) ; frame . setVisible ( true ) ; frame . addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { System . exit ( 0 ) ; } } ) ; } 
public static short readShort ( ) { return scanner . nextShort ( ) ; } 
public List < String > toNameValueBlock ( ) { Set < String > names = new HashSet < String > ( ) ; List < String > result = new ArrayList < String > ( ) ; for ( int i = 0 ; i < namesAndValues . size ( ) ; i += 2 ) { String name = namesAndValues . get ( i ) . toLowerCase ( Locale . US ) ; String value = namesAndValues . get ( i + 1 ) ; if ( name . equals ( "connection" ) || name . equals ( "host" ) || name . equals ( "keep-alive" ) || name . equals ( "proxy-connection" ) || name . equals ( "transfer-encoding" ) ) { continue ; } if ( names . add ( name ) ) { result . add ( name ) ; result . add ( value ) ; continue ; } for ( int j = 0 ; j < result . size ( ) ; j += 2 ) { if ( name . equals ( result . get ( j ) ) ) { result . set ( j + 1 , result . get ( j + 1 ) + " " + value ) ; break ; } } } return result ; } 
public void loadSkin ( ) { callContactMenu . setIcon ( new ImageIcon ( ImageLoader . getImage ( ImageLoader . CALL_16x16_ICON ) ) ) ; if ( addContactComponent instanceof JMenuItem ) { ( ( JMenuItem ) addContactComponent ) . setIcon ( new ImageIcon ( ImageLoader . getImage ( ImageLoader . ADD_CONTACT_16x16_ICON ) ) ) ; } } 
CNBindingEnumeration ( CNCtx ctx , boolean isLookedUpCtx , Hashtable env ) { String batch = ( env != null ? ( String ) env . get ( javax . naming . Context . BATCHSIZE ) : null ) ; if ( batch != null ) { try { batchsize = Integer . parseInt ( batch ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Batch-size-not-numeric:-" + batch ) ; } } _ctx = ctx ; _ctx . incEnumCount ( ) ; this . isLookedUpCtx = isLookedUpCtx ; _env = env ; _bindingList = new BindingListHolder ( ) ; BindingIteratorHolder _bindingIterH = new BindingIteratorHolder ( ) ; _ctx . _nc . list ( 0 , _bindingList , _bindingIterH ) ; _bindingIter = _bindingIterH . value ; if ( _bindingIter != null ) { more = _bindingIter . next_n ( batchsize , _bindingList ) ; } else { more = false ; } counter = 0 ; } 
public void setVisible ( boolean b ) { AccessibleContext ac = getCurrentAccessibleContext ( ) ; if ( ac instanceof AccessibleComponent ) { ( ( AccessibleComponent ) ac ) . setVisible ( b ) ; } else { Component c = getCurrentComponent ( ) ; if ( c != null ) { c . setVisible ( b ) ; } } } 
public synchronized List < List < V >> getRows ( ) { List < List < V >> copy = new ArrayList < List < V >> ( ) ; for ( List < V > row : rows ) { copy . add ( new ArrayList < V > ( row ) ) ; } return copy ; } 
public static WaveData create ( AudioInputStream ais ) { AudioFormat audioformat = ais . getFormat ( ) ; int channels = 0 ; if ( audioformat . getChannels ( ) == 1 ) { if ( audioformat . getSampleSizeInBits ( ) == 8 ) { channels = AL10 . AL_FORMAT_MONO8 ; } else if ( audioformat . getSampleSizeInBits ( ) == 16 ) { channels = AL10 . AL_FORMAT_MONO16 ; } else { throw new RuntimeException ( "Illegal-sample-size" ) ; } } else if ( audioformat . getChannels ( ) == 2 ) { if ( audioformat . getSampleSizeInBits ( ) == 8 ) { channels = AL10 . AL_FORMAT_STEREO8 ; } else if ( audioformat . getSampleSizeInBits ( ) == 16 ) { channels = AL10 . AL_FORMAT_STEREO16 ; } else { throw new RuntimeException ( "Illegal-sample-size" ) ; } } else { throw new RuntimeException ( "Only-mono-or-stereo-is-supported" ) ; } byte [ ] buf = new byte [ audioformat . getChannels ( ) * ( int ) ais . getFrameLength ( ) * audioformat . getSampleSizeInBits ( ) / 8 ] ; int read = 0 , total = 0 ; try { while ( ( read = ais . read ( buf , total , buf . length - total ) ) != - 1 && total < buf . length ) { total += read ; } } catch ( IOException ioe ) { return null ; } ByteBuffer buffer = convertAudioBytes ( buf , audioformat . getSampleSizeInBits ( ) == 16 ) ; WaveData wavedata = new WaveData ( buffer , channels , ( int ) audioformat . getSampleRate ( ) ) ; try { ais . close ( ) ; } catch ( IOException ioe ) { } return wavedata ; } 
void clearCaches ( ) { cache . clear ( ) ; foundAnyCache . clear ( ) ; } 
private static final byte [ ] toByteArray ( InputStream inputStream ) throws IOException { int size = 4096 ; int read = 0 ; int counter = 0 ; byte [ ] buffer = new byte [ size ] ; byte [ ] newBuffer = null ; while ( ( read = inputStream . read ( buffer , counter , buffer . length - counter ) ) > 0 ) { counter += read ; if ( inputStream . available ( ) > buffer . length - counter ) { newBuffer = new byte [ buffer . length * 2 ] ; System . arraycopy ( buffer , 0 , newBuffer , 0 , counter ) ; buffer = newBuffer ; } } if ( buffer . length != counter ) { newBuffer = new byte [ counter ] ; System . arraycopy ( buffer , 0 , newBuffer , 0 , counter ) ; buffer = newBuffer ; } return buffer ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public void addNameLabelChangeListener ( LabelChangeListener l ) { nameChangeListeners . add ( l ) ; } 
public void readExternal ( ObjectInput in ) throws IOException , ClassNotFoundException { _bitSize = in . readInt ( ) ; _intSize = ( _bitSize >>> 5 ) + 1 ; _mask = in . readInt ( ) ; _bits = ( int [ ] ) in . readObject ( ) ; } 
public Attribute setArray3 ( ArrayBuffer values , AttrDataType type , boolean normalized ) { return setArray ( values , AttrDataSize . THREE , type , normalized , 0 , 0 ) ; } 
public V remove ( Object key ) { key = xform ( key ) ; int h = hash ( key ) ; if ( table [ h ] == key ) { modCount ++ ; size -- ; Object r = unxform ( table [ h + 1 ] ) ; removeAtIndex ( h ) ; return ( V ) r ; } return null ; } 
public boolean getBoolean ( String key ) throws JSONException { Object o = get ( key ) ; if ( o . equals ( Boolean . FALSE ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( o . equals ( Boolean . TRUE ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "]-is-not-a-Boolean." ) ; } 
public static Path getStagingJobHistoryFile ( Path dir , String jobId , int attempt ) { return new Path ( dir , jobId + "_" + attempt + JOB_HISTORY_FILE_EXTENSION ) ; } 
public void setGreenf ( float fGreen ) { setGreen ( Math . round ( fGreen * MAX_INT_VALUE ) ) ; } 
public List < SearchColumnSelectField > getMemberItem ( ) { if ( memberItem == null ) { memberItem = new ArrayList < SearchColumnSelectField > ( ) ; } return this . memberItem ; } 
@ Override public long longValue ( ) { return ( ( scale <= - 64 ) || ( scale > approxPrecision ( ) ) ? 0L : toBigInteger ( ) . longValue ( ) ) ; } 
public synchronized void setTotalResource ( Resource resource ) { this . totalResourceCapability = resource ; this . availableResource = Resources . subtract ( totalResourceCapability , this . usedResource ) ; } 
public void setMax ( float theValue ) { _myMax = theValue ; _myValueRange = _myMax - _myMin ; update ( ) ; } 
protected Frame newFrame ( final int nLocals , final int nStack ) { return new Frame ( nLocals , nStack ) ; } 
public int getClipX ( ) { Rect rect = this . canvas . getClipBounds ( ) ; return rect . left ; } 
public static ArrayList < Die > getInternalMOD ( String dc ) { ArrayList < Die > dies = new ArrayList < Die > ( ) ; connect ( ) ; try { String sql = "SELECT-MOD_Number,-Revolutions,-DueDate-FROM-mod_int-WHERE-DC_Number=?-" + "AND-Removed=0-AND-DieLineChecked=1-AND-DamageChecked=1-AND-SampleChecked=1" ; PreparedStatement prepStmt = con . prepareStatement ( sql ) ; prepStmt . setString ( 1 , dc ) ; rs = prepStmt . executeQuery ( ) ; while ( rs . next ( ) ) { dies . add ( new Die ( rs . getString ( "MOD_Number" ) , rs . getInt ( "Revolutions" ) , rs . getDate ( "DueDate" ) ) ) ; } closeConnection ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } catch ( NullPointerException n ) { } return dies ; } 
public static RequestAsyncTask executePlacesSearchRequestAsync ( Session session , Location location , int radiusInMeters , int resultsLimit , String searchText , GraphPlaceListCallback callback ) { return newPlacesSearchRequest ( session , location , radiusInMeters , resultsLimit , searchText , callback ) . executeAsync ( ) ; } 
@ XmlElementDecl ( namespace = "http://schemas.openxmlformats.org/officeDocument/2006/bibliography" , name = "Publisher" , scope = CTSourceType . class ) public JAXBElement < String > createCTSourceTypePublisher ( String value ) { return new JAXBElement < String > ( _CTSourceTypePublisher_QNAME , String . class , CTSourceType . class , value ) ; } 
public static int getExponent ( float f ) { return ( ( Float . floatToRawIntBits ( f ) & FloatConsts . EXP_BIT_MASK ) >> ( FloatConsts . SIGNIFICAND_WIDTH - 1 ) ) - FloatConsts . EXP_BIAS ; } 
public AccessibleStateSet getAccessibleStateSet ( ) { if ( isVisible ( ) ) states . add ( AccessibleState . VISIBLE ) ; if ( tree . isCollapsed ( tp ) ) states . add ( AccessibleState . COLLAPSED ) ; if ( tree . isEditable ( ) ) states . add ( AccessibleState . EDITABLE ) ; if ( mod != null && ! mod . isLeaf ( tp . getLastPathComponent ( ) ) ) states . add ( AccessibleState . EXPANDABLE ) ; if ( tree . isExpanded ( tp ) ) states . add ( AccessibleState . EXPANDED ) ; if ( isFocusable ( ) ) states . add ( AccessibleState . FOCUSABLE ) ; if ( hasFocus ( ) ) states . add ( AccessibleState . FOCUSED ) ; if ( tree . getSelectionModel ( ) . getSelectionMode ( ) != TreeSelectionModel . SINGLE_TREE_SELECTION ) states . add ( AccessibleState . MULTISELECTABLE ) ; if ( tree . isOpaque ( ) ) states . add ( AccessibleState . OPAQUE ) ; if ( tree . isPathSelected ( tp ) ) states . add ( AccessibleState . SELECTED ) ; if ( isShowing ( ) ) states . add ( AccessibleState . SHOWING ) ; states . add ( AccessibleState . SELECTABLE ) ; return states ; } 
public static boolean isIdentifierIgnorable ( int codePoint ) { if ( codePoint < 0x600 ) { return ( codePoint >= 0 && codePoint <= 8 ) || ( codePoint >= 0xe && codePoint <= 0x1b ) || ( codePoint >= 0x7f && codePoint <= 0x9f ) || ( codePoint == 0xad ) ; } return isIdentifierIgnorableImpl ( codePoint ) ; } 
@ Override protected Class < ? > findClass ( final String className ) throws ClassNotFoundException { String partialName = className . replace ( '.' , '/' ) ; final String classFileName = new StringBuilder ( partialName ) . append ( ".class" ) . toString ( ) ; String packageName = null ; int position = partialName . lastIndexOf ( '/' ) ; if ( ( position = partialName . lastIndexOf ( '/' ) ) != - 1 ) { packageName = partialName . substring ( 0 , position ) ; } int n = 0 ; while ( true ) { URLHandler handler = getHandler ( n ++ ) ; if ( handler == null ) { break ; } Class < ? > res = handler . findClass ( packageName , classFileName , className ) ; if ( res != null ) { return res ; } } throw new ClassNotFoundException ( className ) ; } 
public static void addRowTotals ( String [ ] [ ] spreadsheet ) { for ( int i = 1 ; i < spreadsheet . length - 1 ; i ++ ) { double rowTotal = 0 ; for ( int j = 1 ; j < spreadsheet [ i ] . length - 1 ; j ++ ) { rowTotal += Double . parseDouble ( spreadsheet [ i ] [ j ] ) ; } spreadsheet [ i ] [ 11 ] = Double . toString ( Math . round ( rowTotal / spreadsheet [ i ] . length - 1 ) ) ; } } 
public final void yyclose ( ) throws java . io . IOException { zzAtEOF = true ; zzEndRead = zzStartRead ; if ( zzReader != null ) zzReader . close ( ) ; } 
public void poolClean ( Connection c ) throws BadServerResponse , XenAPIException , XmlRpcException { String method_call = "pool_patch.pool_clean" ; String session = c . getSessionReference ( ) ; Object [ ] method_params = { Marshalling . toXMLRPC ( session ) , Marshalling . toXMLRPC ( this . ref ) } ; Map response = c . dispatch ( method_call , method_params ) ; return ; } 
public Enumeration getListeners ( ) { return this . listeners . elements ( ) ; } 
public String toString ( ) { return genes . toString ( ) ; } 
@ Override public List < String > getAllProviders ( ) { ArrayList < String > out ; synchronized ( mLock ) { out = new ArrayList < String > ( mProviders . size ( ) ) ; for ( LocationProviderInterface provider : mProviders ) { String name = provider . getName ( ) ; if ( LocationManager . FUSED_PROVIDER . equals ( name ) ) { continue ; } out . add ( name ) ; } } if ( D ) Log . d ( TAG , "getAllProviders()=" + out ) ; return out ; } 
public static String getXPath ( Element element ) { String str = "" ; if ( element . isRootElement ( ) ) { return "/" + element . getName ( ) ; } while ( ! element . isRootElement ( ) ) { Element parent = element . getParent ( ) ; List children = parent . getChildren ( element . getName ( ) ) ; int index = children . indexOf ( element ) + 1 ; String temp = element . getName ( ) + '[' + index + ']' ; if ( str . equals ( "" ) ) { str = temp ; } else { str = temp + '/' + str ; } element = parent ; } return "/" + element . getName ( ) + '/' + str ; } 
public ImmutableOpenMap < String , DiscoveryNode > masterAndDataNodes ( ) { ImmutableOpenMap . Builder < String , DiscoveryNode > nodes = ImmutableOpenMap . builder ( dataNodes ) ; nodes . putAll ( masterNodes ) ; return nodes . build ( ) ; } 
public static String encodeBase64String ( final byte [ ] binaryData ) { return newString ( encodeBase64 ( binaryData , false ) , UTF_8 ) ; } 
protected Object basicRun ( String [ ] args ) throws Exception { Class clazz = getBootLoader ( bootLocation ) ; Method method = clazz . getDeclaredMethod ( "run" , new Class [ ] { String . class , URL . class , String . class , String [ ] . class } ) ; try { return method . invoke ( clazz , new Object [ ] { application , pluginPathLocation , location , args } ) ; } catch ( InvocationTargetException e ) { if ( e . getTargetException ( ) instanceof Error ) throw ( Error ) e . getTargetException ( ) ; throw e ; } } 
public void addSelectEventListener ( SelectEventListener listener ) { if ( listener != null ) { listeners . add ( listener ) ; } } 
public int getSize ( ) { return db . size ( ) ; } 
protected short _type ( int identity ) { int info = _exptype ( identity ) ; if ( NULL != info ) return m_expandedNameTable . getType ( info ) ; else return NULL ; } 
@ Override protected javax . swing . JButton createIncreaseButton ( int orientation ) { return new BasicArrowButton ( orientation ) { private static final long serialVersionUID = 2812753955642319448L ; @ Override public void paint ( Graphics g ) { g . drawImage ( new ImageIcon ( PIC_DOWN ) . getImage ( ) , 0 , 0 , getWidth ( ) , getHeight ( ) , null ) ; } } ; } 
public void setSnmpAdaptorName ( ObjectName name , SnmpOid [ ] oids ) throws InstanceNotFoundException , ServiceNotFoundException { if ( server == null ) { throw new ServiceNotFoundException ( mibName + "-is-not-registered-in-the-MBean-server" ) ; } if ( adaptor != null ) { adaptor . removeMib ( this ) ; } Object [ ] params = { this , oids } ; String [ ] signature = { "com.sun.jmx.snmp.agent.SnmpMibAgent" , oids . getClass ( ) . getName ( ) } ; try { adaptor = ( SnmpMibHandler ) ( server . invoke ( name , "addMib" , params , signature ) ) ; } catch ( InstanceNotFoundException e ) { throw new InstanceNotFoundException ( name . toString ( ) ) ; } catch ( ReflectionException e ) { throw new ServiceNotFoundException ( name . toString ( ) ) ; } catch ( MBeanException e ) { } adaptorName = name ; } 
public com . google . protobuf . ByteString getOutputTypeBytes ( ) { java . lang . Object ref = outputType_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; outputType_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
final Entry < V > locateKey ( final float k ) { Entry < V > e = tree , last = tree ; int cmp = 0 ; while ( e != null && ( cmp = compare ( k , e . key ) ) != 0 ) { last = e ; e = cmp < 0 ? e . left ( ) : e . right ( ) ; } return cmp == 0 ? e : last ; } 
private void removeFromQueue ( int x , int y ) { Position p = new Position ( x , y ) ; if ( moveQueue . contains ( p ) ) { moveQueue . remove ( p ) ; } } 
@ Override public String getCaptionByDateOfMonth ( Date date , Locale locale , TimeZone timezone ) { String s = ZksampleDateFormat . getDayNumberFormater ( ) . format ( date ) ; if ( date . getDate ( ) == 1 ) { return ZksampleDateFormat . getMonth3DigitsFormater ( ) . format ( date ) + "-" + s ; } else return s ; } 
public static AnimatorProxy wrap ( View view ) { AnimatorProxy proxy = PROXIES . get ( view ) ; if ( proxy == null || proxy != view . getAnimation ( ) ) { proxy = new AnimatorProxy ( view ) ; PROXIES . put ( view , proxy ) ; } return proxy ; } 
private void writeStartElement ( java . lang . String prefix , java . lang . String namespace , java . lang . String localPart , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String writerPrefix = xmlWriter . getPrefix ( namespace ) ; if ( writerPrefix != null ) { xmlWriter . writeStartElement ( namespace , localPart ) ; } else { if ( namespace . length ( ) == 0 ) { prefix = "" ; } else if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; } xmlWriter . writeStartElement ( prefix , localPart , namespace ) ; xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } } 
public String toString ( String sep ) { if ( isEmpty ( ) ) { return "" ; } else { StringBuffer buf = new StringBuffer ( ) ; buf . append ( head ) ; for ( List < A > l = tail ; l . nonEmpty ( ) ; l = l . tail ) { buf . append ( sep ) ; buf . append ( l . head ) ; } return buf . toString ( ) ; } } 
public void getSecondaryColors ( float [ ] cols ) { if ( color2s != null ) System . arraycopy ( color2s , 0 , cols , 0 , numRequiredCoords * 3 ) ; } 
protected List < ExifTag > getAllTags ( ) { ArrayList < ExifTag > ret = new ArrayList < ExifTag > ( ) ; for ( IfdData d : mIfdDatas ) { if ( d != null ) { ExifTag [ ] tags = d . getAllTags ( ) ; if ( tags != null ) { for ( ExifTag t : tags ) { ret . add ( t ) ; } } } } return ret ; } 
private static < L > void renderTree ( Tree < L > tree , int indent , boolean parentLabelNull , boolean firstSibling , boolean leftSiblingPreTerminal , boolean topLevel , StringBuilder sb ) { final boolean suppressIndent = ( parentLabelNull || ( firstSibling && tree . isPreTerminal ( ) ) || ( leftSiblingPreTerminal && tree . isPreTerminal ( ) && ( tree . getLabel ( ) == null || ! tree . getLabel ( ) . toString ( ) . startsWith ( "CC" ) ) ) ) ; if ( suppressIndent ) { sb . append ( '-' ) ; } else { if ( ! topLevel ) { sb . append ( '|n' ) ; } for ( int i = 0 ; i < indent ; i ++ ) { sb . append ( "-" ) ; } } if ( tree . isLeaf ( ) || tree . isPreTerminal ( ) ) { renderFlat ( tree , sb ) ; return ; } sb . append ( '(' ) ; sb . append ( tree . getLabel ( ) ) ; renderChildren ( tree . getChildren ( ) , indent + 1 , tree . getLabel ( ) == null || tree . getLabel ( ) . toString ( ) == null , sb ) ; sb . append ( ')' ) ; } 
public XMLInputSource resolveEntity ( XMLResourceIdentifier resourceIdentifier ) throws XNIException , IOException { String resolvedId = resolveIdentifier ( resourceIdentifier ) ; if ( resolvedId != null ) { return new XMLInputSource ( resourceIdentifier . getPublicId ( ) , resolvedId , resourceIdentifier . getBaseSystemId ( ) ) ; } return null ; } 
private void assignChildren ( ) { for ( Cluster c : clusters ) { c . clearChildren ( ) ; } for ( TaggedSurfFeature f : this . featurePool ) { getClosestCluster ( f ) . addChild ( f ) ; } } 
public String getOrbSignature ( Map props ) { TreeMap map = new TreeMap ( ) ; map . putAll ( props ) ; CPStringBuilder b = new CPStringBuilder ( 50 * props . size ( ) ) ; Iterator iter = map . entrySet ( ) . iterator ( ) ; Map . Entry m ; while ( iter . hasNext ( ) ) { m = ( Map . Entry ) iter . next ( ) ; b . append ( m . getKey ( ) ) ; b . append ( '=' ) ; b . append ( m . getValue ( ) ) ; } return b . toString ( ) ; } 
public static String formatOutputDouble ( double d ) { if ( ( Double . isNaN ( d ) ) || ( Double . isInfinite ( d ) ) || ( d == HdpsVariable . INVALID ) ) return "." ; return String . format ( Locale . US , "%.10f" , d ) ; } 
public void recycle ( Connection connection ) { if ( connection . isSpdy ( ) ) { return ; } if ( ! connection . isAlive ( ) ) { Util . closeQuietly ( connection ) ; return ; } try { Platform . get ( ) . untagSocket ( connection . getSocket ( ) ) ; } catch ( SocketException e ) { Platform . get ( ) . logW ( "Unable-to-untagSocket():-" + e ) ; Util . closeQuietly ( connection ) ; return ; } synchronized ( this ) { connections . addFirst ( connection ) ; connection . resetIdleStartTime ( ) ; } executorService . submit ( connectionsCleanupCallable ) ; } 
public Point getLocation ( ) { checkWidget ( ) ; return new Point ( bounds . x , bounds . y ) ; } 
public boolean matchId ( String identifier ) { String ident = selector . getId ( ) ; if ( ident != null ) return ident . equals ( identifier ) ; return false ; } 
@ Override public SelectCode unmarshal ( Element element ) throws Exception { if ( element == null ) { return null ; } SelectCode selectCode = new SelectCode ( ) ; SelectCodePK selectCodePK = new SelectCodePK ( ) ; selectCodePK . setSelect_name ( element . getLocalName ( ) ) ; NodeList idNodeList = element . getElementsByTagName ( "id" ) ; if ( idNodeList . getLength ( ) > 0 ) { Node node = idNodeList . item ( 0 ) ; selectCodePK . setCode ( node . getTextContent ( ) ) ; } selectCode . setId ( selectCodePK ) ; NodeList nameNodeList = element . getElementsByTagName ( "name" ) ; if ( nameNodeList . getLength ( ) > 0 ) { Node node = nameNodeList . item ( 0 ) ; selectCode . setDescription ( ( node . getTextContent ( ) ) ) ; } return selectCode ; } 
public void append ( final ByteArrayBuffer b , int off , int len ) { if ( b == null ) { return ; } append ( b . buffer ( ) , off , len ) ; } 
public CallSpec < Company , HttpError > addCompany ( String name , String title , FormOfEmployment formOfEmployment ) { return Resource . < Company , HttpError > newPostSpec ( api , "/v1/users/me/professional_experience/companies" , true ) . responseAs ( single ( Company . class , "company" ) ) . formField ( "name" , name ) . formField ( "title" , title ) . formField ( "form_of_employment" , formOfEmployment ) . build ( ) ; } 
public void setStrokeJoin ( Join join ) { native_setStrokeJoin ( mNativePaint , join . nativeInt ) ; } 
public void removeListener ( EventListener listener ) { listeners . remove ( listener ) ; } 
public void setApproveButtonText ( String approveButtonText ) { if ( this . approveButtonText == approveButtonText ) { return ; } String oldValue = this . approveButtonText ; this . approveButtonText = approveButtonText ; firePropertyChange ( APPROVE_BUTTON_TEXT_CHANGED_PROPERTY , oldValue , approveButtonText ) ; } 
public boolean getEnabled ( ) { checkWidget ( ) ; return ( state & DISABLED ) == 0 ; } 
public String nextTo ( char d ) { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = next ( ) ; if ( c == d || c == 0 || c == '|n' || c == '|r' ) { if ( c != 0 ) { back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } } 
public static String sqlEscapeString ( String value ) { StringBuilder escaper = new StringBuilder ( ) ; DatabaseUtils . appendEscapedSQLString ( escaper , value ) ; return escaper . toString ( ) ; } 
public void addMetadataContent ( org . jdom . Element mdataJdomElement , Object contentObject ) { ArrayList catGenConfigList = ( ArrayList ) contentObject ; Iterator iter = catGenConfigList . iterator ( ) ; while ( iter . hasNext ( ) ) { CatalogGenConfig cgc = ( CatalogGenConfig ) iter . next ( ) ; mdataJdomElement . addContent ( createCatGenConfigElement ( cgc ) ) ; } } 
@ XmlElementDecl ( namespace = "http://www.xbrl.org/tw/fr/gaap/tw-gaap-basi-2010-03-31-cr" , name = "AcquisitionDebtInvestmentsNoActiveMarket" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < MonetaryItemType > createAcquisitionDebtInvestmentsNoActiveMarket ( MonetaryItemType value ) { return new JAXBElement < MonetaryItemType > ( _AcquisitionDebtInvestmentsNoActiveMarket_QNAME , MonetaryItemType . class , null , value ) ; } 
public boolean isFileTypeSupported ( int fileType , Sequence sequence ) { int types [ ] = getMidiFileTypes ( sequence ) ; for ( int i = types . length ; i > 0 ; ) { if ( types [ -- i ] == fileType ) return true ; } return false ; } 
public InetSocketAddress getListenerAddress ( ) { return listener . getAddress ( ) ; } 
private Chunk setAttribute ( String name , Object obj ) { if ( attributes == null ) attributes = new HashMap ( ) ; attributes . put ( name , obj ) ; return this ; } 
public boolean equals ( Object o ) { return ( o == this || ( o instanceof Set && ( ( Set ) o ) . size ( ) == size ( ) && containsAll ( ( Collection ) o ) ) ) ; } 
public long getHeaderFieldDate ( String name , long Default ) { String value = getHeaderField ( name ) ; try { return Date . parse ( value ) ; } catch ( Exception e ) { } return Default ; } 
public void dumpAsync ( final FileDescriptor fd , final String [ ] args ) { final FileOutputStream fout = new FileOutputStream ( fd ) ; final PrintWriter pw = new FastPrintWriter ( fout ) ; Thread thr = new Thread ( "Binder.dumpAsync" ) { public void run ( ) { try { dump ( fd , pw , args ) ; } finally { pw . flush ( ) ; } } } ; thr . start ( ) ; } 
public ListNode get ( int index ) { return m_List . get ( index ) ; } 
public int getLargestPoolSize ( ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { return largestPoolSize ; } finally { mainLock . unlock ( ) ; } } 
public void testCase8 ( ) { byte aBytes [ ] = { 10 , 20 , 30 , 40 , 50 , 60 , 70 , 10 , 20 , 30 } ; byte bBytes [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; byte rBytes [ ] = { 1 , 2 , 3 , 4 , 15 , 26 , 37 , 41 , 52 , 63 , 74 , 15 , 26 , 37 } ; BigInteger aNumber = new BigInteger ( aBytes ) ; BigInteger bNumber = new BigInteger ( bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = 0 ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( "incorrect-sign" , 1 , result . signum ( ) ) ; } 
@ Override public boolean equals ( Object obj ) { if ( obj instanceof Date ) { Date d = ( Date ) obj ; if ( d . isSame ( this ) && d . getOrder ( ) == getOrder ( ) ) { return true ; } } return false ; } 
void commitEdit ( ) throws ParseException { JFormattedTextField ftf = getFormattedTextField ( ) ; if ( ftf != null ) { ftf . commitEdit ( ) ; } } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public Map < String , Integer > getDisplayNames ( int field , int style , Locale locale ) { checkStyle ( style ) ; complete ( ) ; Map < String , Integer > result = new HashMap < String , Integer > ( ) ; if ( style == SHORT || style == ALL_STYLES ) { insertValuesInMap ( result , getDisplayNameArray ( field , SHORT , locale ) ) ; } if ( style == LONG || style == ALL_STYLES ) { insertValuesInMap ( result , getDisplayNameArray ( field , LONG , locale ) ) ; } return result . isEmpty ( ) ? null : result ; } 
public static void errms ( StreamTokenizer tokenizer , String theMsg ) throws IOException { throw new IOException ( theMsg + ",-read-" + tokenizer . toString ( ) ) ; } 
public List < School > getSchools ( ) { String [ ] [ ] schools = library . university_getUniversities ( ) ; List < School > returnSchools = new ArrayList < School > ( ) ; for ( String [ ] currentSchool : schools ) { returnSchools . add ( new School ( currentSchool [ 0 ] , currentSchool [ 1 ] , currentSchool [ 2 ] , currentSchool [ 3 ] , Integer . parseInt ( currentSchool [ 4 ] ) , Double . parseDouble ( currentSchool [ 5 ] ) , Double . parseDouble ( currentSchool [ 6 ] ) , Double . parseDouble ( currentSchool [ 7 ] ) , Double . parseDouble ( currentSchool [ 8 ] ) , Double . parseDouble ( currentSchool [ 9 ] ) , Integer . parseInt ( currentSchool [ 10 ] ) , Double . parseDouble ( currentSchool [ 11 ] ) , Double . parseDouble ( currentSchool [ 12 ] ) , Integer . parseInt ( currentSchool [ 13 ] ) , Integer . parseInt ( currentSchool [ 14 ] ) , Integer . parseInt ( currentSchool [ 15 ] ) , getEmphasesForSchoolName ( currentSchool [ 0 ] ) ) ) ; } return returnSchools ; } 
public int length ( ) { return nameValuePairs . size ( ) ; } 
public Collection < Registration > getRegistrations ( TransportType transportType ) { List < Long > registrationIDs = new ArrayList < Long > ( ) ; Connection con = null ; PreparedStatement pstmt = null ; ResultSet rs = null ; try { con = DbConnectionManager . getConnection ( ) ; pstmt = con . prepareStatement ( ALL_GATEWAY_REGISTRATIONS ) ; pstmt . setString ( 1 , transportType . name ( ) ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { registrationIDs . add ( rs . getLong ( 1 ) ) ; } } catch ( SQLException sqle ) { Log . error ( sqle ) ; } finally { DbConnectionManager . closeConnection ( rs , pstmt , con ) ; } if ( registrationIDs . isEmpty ( ) ) { return Collections . emptyList ( ) ; } else { return new RegistrationCollection ( registrationIDs ) ; } } 
public @ NonNull List < MediaController > getActiveSessionsForUser ( @ Nullable ComponentName notificationListener , int userId ) { ArrayList < MediaController > controllers = new ArrayList < MediaController > ( ) ; try { List < IBinder > binders = mService . getSessions ( notificationListener , userId ) ; int size = binders . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { MediaController controller = new MediaController ( mContext , ISessionController . Stub . asInterface ( binders . get ( i ) ) ) ; controllers . add ( controller ) ; } } catch ( RemoteException e ) { Log . e ( TAG , "Failed-to-get-active-sessions:-" , e ) ; } return controllers ; } 
public String getNodeName ( int nodeIndex ) { return getNodeName ( nodeIndex , true ) ; } 
private void parseDictionaryElement ( String s ) throws JFugueException { int indexOfEquals = s . indexOf ( "=" ) ; String word = s . substring ( 1 , indexOfEquals ) ; String definition = s . substring ( indexOfEquals + 1 , s . length ( ) ) ; definition . replace ( '~' , '-' ) ; word = word . toUpperCase ( ) ; trace ( "Dictionary-Definition-element:-word-=-" , word , ",-value-=-" , definition ) ; dictionaryMap . put ( word , definition ) ; } 
public String getTextContent ( ) throws DOMException { return getNodeValue ( ) ; } 
public void setRowHeight ( int row , int rowHeight ) { if ( rowHeight <= 0 ) { throw new IllegalArgumentException ( "New-row-height-less-than-1" ) ; } getRowModel ( ) . setSize ( row , rowHeight ) ; if ( sortManager != null ) { sortManager . setViewRowHeight ( row , rowHeight ) ; } resizeAndRepaint ( ) ; } 
public static Trie load ( InputStream stemmerTable ) throws IOException { DataInputStream in = null ; try { in = new DataInputStream ( new BufferedInputStream ( stemmerTable ) ) ; String method = in . readUTF ( ) . toUpperCase ( Locale . ROOT ) ; if ( method . indexOf ( 'M' ) < 0 ) { return new org . egothor . stemmer . Trie ( in ) ; } else { return new org . egothor . stemmer . MultiTrie2 ( in ) ; } } finally { in . close ( ) ; } } 
public void setCategoryDao ( final CategoryDao categoryDao ) { m_writeLock . lock ( ) ; try { m_categoryDao = categoryDao ; } finally { m_writeLock . unlock ( ) ; } } 
public static String floatToString ( float f ) { String s = Float . toString ( f ) ; s = s . replaceAll ( "([0-9]+|.[0-9]+)00+[0-9]+" , "$1" ) ; s = s . replaceAll ( "0+$" , "" ) ; s = s . replaceAll ( "|.$" , "" ) ; return s ; } 
public void endElement ( String qName ) throws SAXException { if ( ! namespaces ) { if ( contentHandler != null ) { contentHandler . endElement ( "" , "" , qName . intern ( ) ) ; } return ; } String names [ ] = processName ( qName , false , false ) ; if ( contentHandler != null ) { contentHandler . endElement ( names [ 0 ] , names [ 1 ] , names [ 2 ] ) ; Enumeration prefixes = nsSupport . getDeclaredPrefixes ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; contentHandler . endPrefixMapping ( prefix ) ; } } nsSupport . popContext ( ) ; } 
public static Map parseForm ( Reader oInput , boolean bURLEncoded ) throws ParserException , IOException { Tokenizer oTokenizer = new Tokenizer ( oInput ) ; Map oForm = new HashMap ( ) ; if ( oTokenizer . nextToken ( ) ) { ParameterSpec oParameterSpec ; oParameterSpec = parseParameterSpec ( oTokenizer , null ) ; parseEQUALS ( oTokenizer , oParameterSpec . getIdentifier ( ) ) ; addParameter2Form ( oForm , oParameterSpec , parseData ( oTokenizer ) , bURLEncoded ) ; while ( oTokenizer . hasMoreTokens ( ) ) { parseAMPERSAND ( oTokenizer ) ; oParameterSpec = parseParameterSpec ( oTokenizer , null ) ; parseEQUALS ( oTokenizer , oParameterSpec . getIdentifier ( ) ) ; addParameter2Form ( oForm , oParameterSpec , parseData ( oTokenizer ) , bURLEncoded ) ; } } return oForm ; } 
public static Message message ( String catalogue , String key ) { return new Message ( catalogue , key ) ; } 
public static void sendTempFile ( File file , HttpServletResponse response ) throws IOException { String mimeType = null ; String filename = file . getName ( ) ; if ( filename . length ( ) > 5 ) { if ( filename . substring ( filename . length ( ) - 5 , filename . length ( ) ) . equals ( ".jpeg" ) ) { mimeType = "image/jpeg" ; } else if ( filename . substring ( filename . length ( ) - 4 , filename . length ( ) ) . equals ( ".png" ) ) { mimeType = "image/png" ; } } ServletUtilities . sendTempFile ( file , response , mimeType ) ; } 
public void paint ( Graphics a , JComponent b ) { for ( int i = 0 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . paint ( a , b ) ; } } 
@ LayoutlibDelegate static long elapsedRealtimeNanos ( ) { return System . nanoTime ( ) - sBootTimeNano ; } 
private void addComposedChars ( ) throws ParseException { ComposedCharIter iter = new ComposedCharIter ( ) ; int c ; while ( ( c = iter . next ( ) ) != ComposedCharIter . DONE ) { if ( getCharOrder ( c ) == RBCollationTables . UNMAPPED ) { String s = iter . decomposition ( ) ; if ( s . length ( ) == 1 ) { int order = getCharOrder ( s . charAt ( 0 ) ) ; if ( order != RBCollationTables . UNMAPPED ) { addOrder ( c , order ) ; } continue ; } else if ( s . length ( ) == 2 ) { char ch0 = s . charAt ( 0 ) ; if ( Character . isHighSurrogate ( ch0 ) ) { int order = getCharOrder ( s . codePointAt ( 0 ) ) ; if ( order != RBCollationTables . UNMAPPED ) { addOrder ( c , order ) ; } continue ; } } int contractOrder = getContractOrder ( s ) ; if ( contractOrder != RBCollationTables . UNMAPPED ) { addOrder ( c , contractOrder ) ; } else { boolean allThere = true ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( getCharOrder ( s . charAt ( i ) ) == RBCollationTables . UNMAPPED ) { allThere = false ; break ; } } if ( allThere ) { addExpandOrder ( c , s , RBCollationTables . UNMAPPED ) ; } } } } } 
public static String readFromFile ( URL source ) throws IOException { char [ ] chars = new char [ 4092 ] ; InputStreamReader contentsReader = null ; StringBuilder buffer = new StringBuilder ( ) ; if ( ! new java . io . File ( source . getFile ( ) ) . exists ( ) ) { throw new FileNotFoundException ( MessageFormat . format ( TemplateEngineMessages . getString ( "ProcessHelper.fileNotFound" ) , source . getFile ( ) ) ) ; } else { contentsReader = new InputStreamReader ( source . openStream ( ) ) ; int c ; do { c = contentsReader . read ( chars ) ; if ( c == - 1 ) break ; buffer . append ( chars , 0 , c ) ; } while ( c != - 1 ) ; contentsReader . close ( ) ; } return buffer . toString ( ) ; } 
public char getMnemonic ( String key ) { String s = getStringRecursive ( key ) ; return ( s == null || s . length ( ) == 0 ) ? '|0' : s . charAt ( 0 ) ; } 
public static String getLocalJobFilePath ( JobID jobId ) { return System . getProperty ( "hadoop.log.dir" ) + File . separator + jobId + CONF_FILE_NAME_SUFFIX ; } 
public String getNextRadioButton ( ) { if ( radioButtonGroup == null ) return null ; CheckboxGroup cg = ( CheckboxGroup ) ( radioButtonGroup . elementAt ( radioButtonIndex ) ) ; radioButtonIndex ++ ; Checkbox checkbox = cg . getSelectedCheckbox ( ) ; String item = "null" ; if ( checkbox != null ) item = checkbox . getLabel ( ) ; if ( macro ) { String label = ( String ) labels . get ( ( Object ) cg ) ; item = Macro . getValue ( macroOptions , label , item ) ; } if ( recorderOn ) recordOption ( cg , item ) ; return item ; } 
public static int readSingleByte ( InputStream in ) throws IOException { byte [ ] buffer = new byte [ 1 ] ; int result = in . read ( buffer , 0 , 1 ) ; return ( result != - 1 ) ? buffer [ 0 ] & 0xff : - 1 ; } 
private static void processDependencies ( Element dependenciesTag , Bundle bundle ) throws IOException { Set result = new HashSet ( ) ; NodeList children = dependenciesTag . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { Element e = ( Element ) child ; String tagName = e . getTagName ( ) ; if ( tagName . equals ( "bundle" ) ) { String dependency = e . getAttribute ( "ref" ) ; if ( dependency . length ( ) == 0 ) throw new RuntimeException ( "missing-'ref'-attribute-" + "on-bundle-tag" ) ; result . add ( dependency ) ; } else throw new RuntimeException ( "unrecognized-tag:-" + tagName ) ; } } StringBuilder value = new StringBuilder ( ) ; Iterator i = result . iterator ( ) ; while ( i . hasNext ( ) ) { if ( value . length ( ) > 0 ) value . append ( ',' ) ; value . append ( i . next ( ) ) ; } putBundleProperty ( bundle . getName ( ) , DownloadManager . DEPENDENCIES_PROPERTY , value . toString ( ) ) ; } 
public synchronized void schedule ( ) { if ( timer != null ) { timer . cancel ( ) ; } timer = new Timer ( true ) ; TimerTask task = new TimerTask ( ) { public void run ( ) { createIndex ( ) ; } } ; long daysBetween = settingsService . getIndexCreationInterval ( ) ; int hour = settingsService . getIndexCreationHour ( ) ; if ( daysBetween == - 1 ) { LOG . info ( "Automatic-index-creation-disabled." ) ; return ; } Date now = new Date ( ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( now ) ; cal . set ( Calendar . HOUR_OF_DAY , hour ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; if ( cal . getTime ( ) . before ( now ) ) { cal . add ( Calendar . DATE , 1 ) ; } Date firstTime = cal . getTime ( ) ; long period = daysBetween * 24L * 3600L * 1000L ; timer . schedule ( task , firstTime , period ) ; LOG . info ( "Automatic-index-creation-scheduled-to-run-every-" + daysBetween + "-day(s),-starting-at-" + firstTime ) ; } 
public String getShortDescription ( ) { return shortDescription == null ? getDisplayName ( ) : shortDescription ; } 
public final void setFrameNumber ( int frameNumber ) { this . currentFrameNumber = Math . max ( 0 , Math . min ( frameNumber , numberOfFrames - 1 ) ) ; calculateFramePosition ( currentFrameNumber ) ; } 
public static String stackTraceToString ( Throwable ex ) { StringBuffer traceBuf = new StringBuffer ( ) ; traceBuf . append ( Messages . getString ( "Util.1" ) ) ; if ( ex != null ) { traceBuf . append ( ex . getClass ( ) . getName ( ) ) ; String message = ex . getMessage ( ) ; if ( message != null ) { traceBuf . append ( Messages . getString ( "Util.2" ) ) ; traceBuf . append ( message ) ; } StringWriter out = new StringWriter ( ) ; PrintWriter printOut = new PrintWriter ( out ) ; ex . printStackTrace ( printOut ) ; traceBuf . append ( Messages . getString ( "Util.3" ) ) ; traceBuf . append ( out . toString ( ) ) ; } traceBuf . append ( Messages . getString ( "Util.4" ) ) ; return traceBuf . toString ( ) ; } 
public void add ( SdkSourceCategory category , SdkSource source ) { synchronized ( mSources ) { ArrayList < SdkSource > list = mSources . get ( category ) ; if ( list == null ) { list = new ArrayList < SdkSource > ( ) ; mSources . put ( category , list ) ; } list . add ( source ) ; } } 
public static String getVersion ( ) { Package pkg = SpringVersion . class . getPackage ( ) ; return ( pkg != null ? pkg . getImplementationVersion ( ) : null ) ; } 
public void _write ( OutputStream output ) { MultipleComponentProfileHelper . write ( output , value ) ; } 
public double getLatitude ( ) { if ( location != null ) { latitude = location . getLatitude ( ) ; } return latitude ; } 
public String getDescription ( String itemName ) { if ( itemName == null ) { return null ; } return nameToDescription . get ( itemName ) ; } 
void s2ch ( String str , char [ ] ch , int offset ) { int j = 0 ; for ( int i = offset ; i < 80 && i < str . length ( ) + offset ; i ++ ) ch [ i ] = str . charAt ( j ++ ) ; } 
public static String createMovieName ( int fileType ) { final String filename ; switch ( fileType ) { case MediaProperties . FILE_MP4 : { filename = "movie_" + StringUtils . randomStringOfNumbers ( 6 ) + ".mp4" ; break ; } case MediaProperties . FILE_3GP : { filename = "movie_" + StringUtils . randomStringOfNumbers ( 6 ) + ".3gp" ; break ; } default : { throw new IllegalArgumentException ( "Unsupported-file-type:-" + fileType ) ; } } final File moviesDirectory = Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_MOVIES ) ; if ( ! moviesDirectory . exists ( ) ) { moviesDirectory . mkdirs ( ) ; } final File f = new File ( moviesDirectory , filename ) ; return f . getAbsolutePath ( ) ; } 
private void updateViewAfterSvgInput ( Element referentElement , Element elementToUpdate ) { if ( referentElement != null ) { String isWellFormedLabelVal = resources . getString ( "IsWellFormedLabel.wellFormed" ) ; isWellFormedLabel . setText ( isWellFormedLabelVal ) ; getApplyButton ( ) . setEnabled ( true ) ; attributesTable . setEnabled ( true ) ; updateElementAttributes ( elementToUpdate , referentElement ) ; shouldProcessUpdate = false ; updateAttributesTable ( elementToUpdate ) ; shouldProcessUpdate = true ; } else { String isWellFormedLabelVal = resources . getString ( "IsWellFormedLabel.notWellFormed" ) ; isWellFormedLabel . setText ( isWellFormedLabelVal ) ; getApplyButton ( ) . setEnabled ( false ) ; attributesTable . setEnabled ( false ) ; } } 
public Float getValue ( ) { return Float . valueOf ( this . value ) ; } 
public static void registrationComplete ( ) { synchronized ( mHandlerMap ) { mRegistrationComplete = true ; mHandlerMap . notifyAll ( ) ; } } 
public DateTimeFormatterBuilder appendOptional ( DateTimeParser parser ) { checkParser ( parser ) ; DateTimeParser [ ] parsers = new DateTimeParser [ ] { parser , null } ; return append0 ( null , new MatchingParser ( parsers ) ) ; } 
public void setReadOnly ( ) { checkPermission ( _READ_ONLY ) ; readOnly = true ; } 
public void add ( String name , Object value ) { attribute a = new attribute ( name , value . toString ( ) ) ; attributes . add ( ( Object ) a ) ; } 
public static String ascii_utf8 ( String ascii ) { if ( ascii == null ) return null ; return new Decoder ( Util . byteSignatureFromString ( ascii ) ) . getString ( ) ; } 
public static void print ( int x ) { out . print ( x ) ; out . flush ( ) ; } 
public void removeFromOtherConfig ( Connection c , String key ) throws BadServerResponse , XenAPIException , XmlRpcException { String method_call = "VM_guest_metrics.remove_from_other_config" ; String session = c . getSessionReference ( ) ; Object [ ] method_params = { Marshalling . toXMLRPC ( session ) , Marshalling . toXMLRPC ( this . ref ) , Marshalling . toXMLRPC ( key ) } ; Map response = c . dispatch ( method_call , method_params ) ; return ; } 
public StringBuilder encodeBody ( StringBuilder encoding ) { return encoding . append ( token ) ; } 
public void redrawPlay ( Graphics gc , int px , int py , int view_dx , int view_dy , int walk_step , int view_offset , RangeSet rset , int ang ) { this . gc = gc ; this . rset = rset ; this . view_dx = view_dx ; this . view_dy = view_dy ; this . ang = ang ; viewx = ( px * map_unit + map_unit / 2 ) + viewd_unscale ( view_dx * ( step_size * walk_step - view_offset ) ) ; viewy = ( py * map_unit + map_unit / 2 ) + viewd_unscale ( view_dy * ( step_size * walk_step - view_offset ) ) ; gc . setColor ( Color . black ) ; gc . fillRect ( 0 , 0 , view_width , view_height / 2 ) ; gc . setColor ( Color . darkGray ) ; gc . fillRect ( 0 , view_height / 2 , view_width , view_height / 2 ) ; gc . setColor ( Color . white ) ; rset . set ( 0 , view_width - 1 ) ; traverse_node_ct = traverse_ssector_ct = drawrect_ct = drawrect_late_ct = drawrect_segment_ct = 0 ; traverse_node ( bsp_root ) ; } 
private String groupname ( int ch ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( Character . toChars ( ch ) ) ; while ( ASCII . isLower ( ch = read ( ) ) || ASCII . isUpper ( ch ) || ASCII . isDigit ( ch ) ) { sb . append ( Character . toChars ( ch ) ) ; } if ( sb . length ( ) == 0 ) throw error ( "named-capturing-group-has-0-length-name" ) ; if ( ch != '>' ) throw error ( "named-capturing-group-is-missing-trailing-'>'" ) ; return sb . toString ( ) ; } 
public void copyTo ( char [ ] destination , int destOffset ) { System . arraycopy ( array , offset , destination , destOffset , count ) ; } 
public List < DRelComparcFinanziamenti > getDRelComparcFinanziamenti ( ) { if ( dRelComparcFinanziamenti == null ) { dRelComparcFinanziamenti = new ArrayList < DRelComparcFinanziamenti > ( ) ; } return this . dRelComparcFinanziamenti ; } 
protected JobFactory ( JobSubmitter submitter , JobStoryProducer jobProducer , Path scratch , Configuration conf , CountDownLatch startFlag , UserResolver userResolver ) { sequence = new AtomicInteger ( 0 ) ; this . scratch = scratch ; this . rateFactor = conf . getFloat ( Gridmix . GRIDMIX_SUB_MUL , 1.0f ) ; this . jobProducer = jobProducer ; this . conf = new Configuration ( conf ) ; this . submitter = submitter ; this . startFlag = startFlag ; this . rThread = createReaderThread ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "-The-submission-thread-name-is-" + rThread . getName ( ) ) ; } this . userResolver = userResolver ; this . jobCreator = JobCreator . getPolicy ( conf , JobCreator . LOADJOB ) ; } 
public static MappedByteBuffer map ( File file , MapMode mode ) throws IOException { checkNotNull ( file ) ; checkNotNull ( mode ) ; if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . toString ( ) ) ; } return map ( file , mode , file . length ( ) ) ; } 
public static String getCurrentDirectory ( ) { return System . getProperty ( "user.dir" ) ; } 
public static boolean writeUserSelectedFile ( ) { if ( fileDialog == null ) fileDialog = new JFileChooser ( ) ; fileDialog . setDialogTitle ( "Select-File-for-Output" ) ; File selectedFile ; while ( true ) { int option = fileDialog . showSaveDialog ( null ) ; if ( option != JFileChooser . APPROVE_OPTION ) return false ; selectedFile = fileDialog . getSelectedFile ( ) ; if ( selectedFile . exists ( ) ) { int response = JOptionPane . showConfirmDialog ( null , "The-file-"" + selectedFile . getName ( ) + ""-already-exists.-Do-you-want-to-replace-it?" , "Replace-existing-file?" , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( response == JOptionPane . YES_OPTION ) break ; } else { break ; } } PrintWriter newout ; try { newout = new PrintWriter ( new FileWriter ( selectedFile ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Can't-open-file-"" + selectedFile . getName ( ) + ""-for-output.-" + "(Error-:" + e + ")" ) ; } if ( ! writingStandardOutput ) { try { out . close ( ) ; } catch ( Exception e ) { } } out = newout ; writingStandardOutput = false ; outputFileName = selectedFile . getName ( ) ; outputErrorCount = 0 ; return true ; } 
@ Override public void run ( ) { if ( ActiveMQRASession . trace ) { ActiveMQRALogger . LOGGER . trace ( "run()" ) ; } throw new Error ( "Method-not-allowed" ) ; } 
private void checkReadPrimitiveTypes ( ) throws IOException { if ( primitiveData == input || primitiveData . available ( ) > 0 ) { return ; } do { int next = 0 ; if ( hasPushbackTC ) { hasPushbackTC = false ; } else { next = input . read ( ) ; pushbackTC = ( byte ) next ; } switch ( pushbackTC ) { case TC_BLOCKDATA : primitiveData = new ByteArrayInputStream ( readBlockData ( ) ) ; return ; case TC_BLOCKDATALONG : primitiveData = new ByteArrayInputStream ( readBlockDataLong ( ) ) ; return ; case TC_RESET : resetState ( ) ; break ; default : if ( next != - 1 ) { pushbackTC ( ) ; } return ; } } while ( true ) ; } 
public void warning ( TransformerException exception ) throws TransformerException { PrintWriter pw = getErrorWriter ( ) ; printLocation ( pw , exception ) ; pw . println ( exception . getMessage ( ) ) ; } 
public JSONObject increment ( String key ) throws JSONException { Object value = this . opt ( key ) ; if ( value == null ) { this . put ( key , 1 ) ; } else if ( value instanceof Integer ) { this . put ( key , ( ( Integer ) value ) . intValue ( ) + 1 ) ; } else if ( value instanceof Long ) { this . put ( key , ( ( Long ) value ) . longValue ( ) + 1 ) ; } else if ( value instanceof Double ) { this . put ( key , ( ( Double ) value ) . doubleValue ( ) + 1 ) ; } else if ( value instanceof Float ) { this . put ( key , ( ( Float ) value ) . floatValue ( ) + 1 ) ; } else { throw new JSONException ( "Unable-to-increment-[" + quote ( key ) + "]." ) ; } return this ; } 
@ Override public void configureInstance ( Component c , Object imp , String containerName ) { if ( imp . equals ( ClusterContainerManager . class ) ) { c . setInterface ( new String [ ] { IClusterContainerServices . class . getName ( ) } , null ) ; c . add ( createServiceDependency ( ) . setService ( IClusterServices . class ) . setCallbacks ( "setClusterService" , "unsetClusterService" ) . setRequired ( true ) ) ; c . add ( createContainerServiceDependency ( containerName ) . setService ( ICacheUpdateAware . class ) . setCallbacks ( "setCacheUpdateAware" , "unsetCacheUpdateAware" ) . setRequired ( false ) ) ; c . add ( createContainerServiceDependency ( containerName ) . setService ( ICoordinatorChangeAware . class ) . setCallbacks ( "setCoordinatorChangeAware" , "unsetCoordinatorChangeAware" ) . setRequired ( false ) ) ; } } 
private ReceiveSubscriber ( int queueSize , boolean useProps , String initialContextFactory , String providerUrl , String connfactory , String destinationName , String durableSubscriptionId , String clientId , String jmsSelector , boolean useAuth , String securityPrincipal , String securityCredentials , boolean useMessageListener ) throws NamingException , JMSException { boolean initSuccess = false ; try { Context ctx = InitialContextFactory . getContext ( useProps , initialContextFactory , providerUrl , useAuth , securityPrincipal , securityCredentials ) ; connection = Utils . getConnection ( ctx , connfactory ) ; if ( ! isEmpty ( clientId ) ) { connection . setClientID ( clientId ) ; } session = connection . createSession ( false , Session . AUTO_ACKNOWLEDGE ) ; Destination dest = Utils . lookupDestination ( ctx , destinationName ) ; subscriber = createSubscriber ( session , dest , durableSubscriptionId , jmsSelector ) ; if ( useMessageListener ) { if ( queueSize <= 0 ) { queue = new LinkedBlockingQueue < > ( ) ; } else { queue = new LinkedBlockingQueue < > ( queueSize ) ; } subscriber . setMessageListener ( this ) ; } else { queue = null ; } log . debug ( "<init>-complete" ) ; initSuccess = true ; } finally { if ( ! initSuccess ) { close ( ) ; } } } 
public void fixWhiteSpace ( ) { final int index = mOutputBuilder . length ( ) - 1 ; if ( index >= 0 ) { final char lastCharacter = mOutputBuilder . charAt ( index ) ; if ( ! Character . isWhitespace ( lastCharacter ) ) { mOutputBuilder . append ( "-" ) ; } } } 
public void testCouplingOfCursorFetch ( ) throws Exception { if ( ! versionMeetsMinimum ( 5 , 0 ) ) { return ; } Connection fetchConn = null ; try { Properties props = new Properties ( ) ; props . setProperty ( "useServerPrepStmts" , "false" ) ; props . setProperty ( "useCursorFetch" , "true" ) ; fetchConn = getConnectionWithProps ( props ) ; String classname = "com.mysql.jdbc.ServerPreparedStatement" ; if ( Util . isJdbc4 ( ) ) { classname = "com.mysql.jdbc.JDBC4ServerPreparedStatement" ; } assertEquals ( classname , fetchConn . prepareStatement ( "SELECT-1" ) . getClass ( ) . getName ( ) ) ; } finally { if ( fetchConn != null ) { fetchConn . close ( ) ; } } } 
private void reverseLookUp ( LinkedList < NextWord > terminalNodes , final WordCallback callback ) { Node node ; int freq ; for ( NextWord nextWord : terminalNodes ) { node = nextWord . word ; freq = nextWord . frequency ; if ( freq >= UserBigramDictionary . SUGGEST_THRESHOLD ) { sb . setLength ( 0 ) ; do { sb . insert ( 0 , node . code ) ; node = node . parent ; } while ( node != null ) ; callback . addWord ( sb . toString ( ) . toCharArray ( ) , 0 , sb . length ( ) , freq , mDicTypeId , DataType . BIGRAM ) ; } } } 
public Calendar validate ( String value ) { return ( Calendar ) parse ( value , ( String ) null , ( Locale ) null , ( TimeZone ) null ) ; } 
@ XmlElementDecl ( namespace = "http://Service/" , name = "getTraderDetailsByBrockerResponse" ) public JAXBElement < GetTraderDetailsByBrockerResponse > createGetTraderDetailsByBrockerResponse ( GetTraderDetailsByBrockerResponse value ) { return new JAXBElement < GetTraderDetailsByBrockerResponse > ( _GetTraderDetailsByBrockerResponse_QNAME , GetTraderDetailsByBrockerResponse . class , null , value ) ; } 
public static Comparator getResultComparator ( ) { if ( resultComparator == null ) { resultComparator = new Comparator < Participant > ( ) { public int compare ( Participant o1 , Participant o2 ) { double r1 = o1 . getResult ( ) ; double r2 = o2 . getResult ( ) ; return - Double . compare ( r1 , r2 ) ; } public boolean equals ( Object obj ) { return obj == this ; } } ; } return resultComparator ; } 
final Entry locateKey ( final int k ) { Entry e = tree , last = tree ; int cmp = 0 ; while ( e != null && ( cmp = compare ( k , e . key ) ) != 0 ) { last = e ; e = cmp < 0 ? e . left ( ) : e . right ( ) ; } return cmp == 0 ? e : last ; } 
public String segmentCodeToVMString ( byte code ) { return ( String ) segmentStrings . get ( new Byte ( code ) ) ; } 
private boolean hasNextPostponed ( ) { return ! postponedRoutes . isEmpty ( ) ; } 
public List < String > getElements ( ) { return Collections . unmodifiableList ( elements ) ; } 
private Intent ( @ JsonProperty ( "name" ) final String name , @ JsonProperty ( "slots" ) final Map < String , Slot > slots ) { this . name = name ; if ( slots != null ) { this . slots = Collections . unmodifiableMap ( slots ) ; } else { this . slots = Collections . emptyMap ( ) ; } } 
public String toString ( ) { if ( soid == null ) { StringBuilder sb = new StringBuilder ( 4 * oid . length ) ; for ( int i = 0 ; i < oid . length - 1 ; ++ i ) { sb . append ( oid [ i ] ) ; sb . append ( '.' ) ; } sb . append ( oid [ oid . length - 1 ] ) ; soid = sb . toString ( ) ; } return soid ; } 
protected HttpHost determineProxy ( HttpHost target , HttpRequest request , HttpContext context ) throws HttpException { ProxySelector psel = this . proxySelector ; if ( psel == null ) psel = ProxySelector . getDefault ( ) ; if ( psel == null ) return null ; URI targetURI = null ; try { targetURI = new URI ( target . toURI ( ) ) ; } catch ( URISyntaxException usx ) { throw new HttpException ( "Cannot-convert-host-to-URI:-" + target , usx ) ; } List < Proxy > proxies = psel . select ( targetURI ) ; Proxy p = chooseProxy ( proxies , target , request , context ) ; HttpHost result = null ; if ( p . type ( ) == Proxy . Type . HTTP ) { if ( ! ( p . address ( ) instanceof InetSocketAddress ) ) { throw new HttpException ( "Unable-to-handle-non-Inet-proxy-address:-" + p . address ( ) ) ; } final InetSocketAddress isa = ( InetSocketAddress ) p . address ( ) ; result = new HttpHost ( getHost ( isa ) , isa . getPort ( ) ) ; } return result ; } 
public void _read ( InputStream input ) { value = TaggedComponentHelper . read ( input ) ; } 
public String getContentAsString ( ) { return new String ( getContent ( ) , Charsets . UTF_8 ) ; } 
public boolean remove ( String jobId ) { return jobs . remove ( jobId ) != null ; } 
public static String toHex ( byte [ ] ba ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintStream ps = new PrintStream ( baos ) ; for ( byte b : ba ) { ps . printf ( "%x" , b ) ; } return baos . toString ( ) ; } 
public boolean check ( String appName , int smsWaiting ) { synchronized ( mSmsStamp ) { removeExpiredTimestamps ( ) ; ArrayList < Long > sentList = mSmsStamp . get ( appName ) ; if ( sentList == null ) { sentList = new ArrayList < Long > ( ) ; mSmsStamp . put ( appName , sentList ) ; } return isUnderLimit ( sentList , smsWaiting ) ; } } 
public static void writeXMLFile ( File file , Document doc ) throws Exception { try { FileOutputStream fos = new FileOutputStream ( file ) ; OutputFormat format = new OutputFormat ( doc ) ; format . setIndent ( 3 ) ; XMLSerializer serial = new XMLSerializer ( fos , format ) ; serial . asDOMSerializer ( ) ; serial . serialize ( doc . getDocumentElement ( ) ) ; fos . close ( ) ; } catch ( Exception e ) { logger . error ( "Failed-serializing-document-to-file" , e ) ; throw e ; } } 
public boolean isSetDone ( ) { return __isset_bit_vector . get ( __DONE_ISSET_ID ) ; } 
public void setVersion ( int ver ) { a . set ( ver ) ; } 
public String encode ( ) { return new StringBuffer ( scheme ) . append ( SP ) . append ( authParams . encode ( ) ) . toString ( ) ; } 
public void setCenter ( Point newCenter ) { Point oldCenter = getCenter ( ) ; move ( newCenter . x - oldCenter . x , newCenter . y - oldCenter . y ) ; } 
private void loadZipData ( ) { missingEntry ( this , zip ) ; for ( Enumeration E = zip . entries ( ) ; E . hasMoreElements ( ) ; ) { ZipEntry next = ( ZipEntry ) E . nextElement ( ) ; addZipEntry ( next ) ; } } 
public FnbUser ( String name , Link link , int myID , long glLength , long glIn , long glOut , double init_time , int resID ) throws Exception { super ( name , link ) ; this . GridletSubmittedList_ = new ArrayList ( ) ; receivedGridletCounter = 0 ; droppedGridletsCounter = 0 ; ToS_ = 0 ; this . myID_ = myID ; gridletLength = glLength ; gridletInput = glIn ; gridletOutput = glOut ; this . init_time = init_time ; this . resID = resID ; } 
public boolean contains ( String header ) { return headers . contains ( header ) ; } 
@ XmlElementDecl ( namespace = "http://xmlns.oracle.com/oracle/apps/marketing/leadMgmt/leads/leadService/" , name = "ProdNameOrGroupName" , scope = MklLead . class ) public JAXBElement < String > createMklLeadProdNameOrGroupName ( String value ) { return new JAXBElement < String > ( _MklLeadProdNameOrGroupName_QNAME , String . class , MklLead . class , value ) ; } 
public final int getAndDecrement ( int i ) { return getAndAdd ( i , - 1 ) ; } 
public boolean isViaLoadBundle ( ) { return ( null != laodBundle ) && laodBundle . getSelection ( ) ; } 
public boolean dispatchKeyEvent ( KeyEvent event ) { onUserInteraction ( ) ; Window win = getWindow ( ) ; if ( win . superDispatchKeyEvent ( event ) ) { return true ; } View decor = mDecor ; if ( decor == null ) decor = win . getDecorView ( ) ; return event . dispatch ( this , decor != null ? decor . getKeyDispatcherState ( ) : null , this ) ; } 
private Result pCIdentifier$Identifier$1 ( final int yyStart ) throws IOException { Result yyResult ; String yyValue ; ParseError yyError = ParseError . DUMMY ; yyResult = pCIdentifier$Word ( yyStart ) ; yyError = yyResult . select ( yyError ) ; if ( yyResult . hasValue ( ) ) { yyValue = yyResult . semanticValue ( ) ; if ( ! contains ( C_KEYWORDS , toText ( yyValue ) ) ) { return yyResult . createValue ( yyValue , yyError ) ; } } yyError = yyError . select ( "identifier-expected" , yyStart ) ; return yyError ; } 
public boolean blocksPathForUA ( String path , String ua ) { final String lcua = ua . toLowerCase ( ) ; if ( rules . containsKey ( lcua ) ) { return blocksPath ( path , ua , rules . get ( lcua ) ) ; } if ( rules . containsKey ( GLOBAL_USER_AGENT ) ) { return blocksPath ( path , GLOBAL_USER_AGENT , rules . get ( GLOBAL_USER_AGENT ) ) ; } return false ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
private Date timeOffset ( long offset ) { return new Date ( System . currentTimeMillis ( ) + offset ) ; } 
public void characters ( String s ) throws org . xml . sax . SAXException { if ( m_inEntityRef && ! m_expandDTDEntities ) return ; final int length = s . length ( ) ; if ( length > m_charsBuff . length ) { m_charsBuff = new char [ length * 2 + 1 ] ; } s . getChars ( 0 , length , m_charsBuff , 0 ) ; characters ( m_charsBuff , 0 , length ) ; } 
public static byte parseHexByte ( String s ) { if ( s . length ( ) != 2 ) throw newFatal ( "Hex-string-must-be-exactly-two-characters." ) ; s = s . toUpperCase ( ) ; char c ; byte b ; c = s . charAt ( 0 ) ; b = ( byte ) HEX_CHAR_STRING . indexOf ( c ) ; c = s . charAt ( 1 ) ; b = ( byte ) ( b << 4 | ( byte ) HEX_CHAR_STRING . indexOf ( c ) ) ; return b ; } 
protected final void writeB ( ByteBuffer buf , byte [ ] data ) { buf . put ( data ) ; } 
public void sort ( ) { Collections . sort ( this ) ; } 
public void setUserName ( String userName ) { this . userName = new StringBuffer ( userName ) ; } 
public synchronized void configureObjectKeyMap ( Configuration config ) { final String prefix = "jacorb.orb.objectKeyMap." ; final List names = config . getAttributeNamesWithPrefix ( prefix ) ; try { for ( Iterator i = names . iterator ( ) ; i . hasNext ( ) ; ) { final String property = ( String ) i . next ( ) ; final String key_name = property . substring ( prefix . length ( ) ) ; final String full_path = config . getAttribute ( property ) ; addObjectKey ( key_name , full_path ) ; } } catch ( ConfigurationException e ) { throw new RuntimeException ( "should-never-happen" , e ) ; } } 
public static String folio ( ) { try { Thread . sleep ( 20 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } long time = System . currentTimeMillis ( ) ; String res = "20" + StringUtils . substring ( String . valueOf ( time ) , - 6 ) ; return res ; } 
public void addQueue ( JobQueue queue ) { jobQueues . put ( queue . getName ( ) , queue ) ; } 
protected void installDefaults ( ) { list . setLayout ( null ) ; LookAndFeel . installBorder ( list , "List.border" ) ; LookAndFeel . installColorsAndFont ( list , "List.background" , "List.foreground" , "List.font" ) ; LookAndFeel . installProperty ( list , "opaque" , Boolean . TRUE ) ; if ( list . getCellRenderer ( ) == null ) { list . setCellRenderer ( ( ListCellRenderer ) ( UIManager . get ( "List.cellRenderer" ) ) ) ; } Color sbg = list . getSelectionBackground ( ) ; if ( sbg == null || sbg instanceof UIResource ) { list . setSelectionBackground ( UIManager . getColor ( "List.selectionBackground" ) ) ; } Color sfg = list . getSelectionForeground ( ) ; if ( sfg == null || sfg instanceof UIResource ) { list . setSelectionForeground ( UIManager . getColor ( "List.selectionForeground" ) ) ; } Long l = ( Long ) UIManager . get ( "List.timeFactor" ) ; timeFactor = ( l != null ) ? l . longValue ( ) : 1000L ; updateIsFileList ( ) ; } 
public List < UtilizationSequenceSample > optimize ( long currentTime ) { List < UtilizationSequenceSample > move = new ArrayList < > ( ) ; for ( UtilizationSequenceSample s : samples ) { if ( s . getEndTimestamp ( ) <= currentTime ) move . add ( s ) ; } List < Long > oldTimestamps = new ArrayList < > ( ) ; for ( long ts : timestamps ) { if ( ts <= currentTime ) oldTimestamps . add ( ts ) ; } timestamps . removeAll ( oldTimestamps ) ; samples . removeAll ( move ) ; return move ; } 
public void addActionItem ( ActionItem action ) { actionList . add ( action ) ; } 
public static Conversation get ( Context context , long threadId , boolean allowQuery ) { if ( DEBUG ) { Log . v ( TAG , "Conversation-get-by-threadId:-" + threadId ) ; } Conversation conv = Cache . get ( threadId ) ; if ( conv != null ) return conv ; conv = new Conversation ( context , threadId , allowQuery ) ; try { Cache . put ( conv ) ; } catch ( IllegalStateException e ) { LogTag . error ( "Tried-to-add-duplicate-Conversation-to-Cache-(from-threadId):-" + conv ) ; if ( ! Cache . replace ( conv ) ) { LogTag . error ( "get-by-threadId-cache.replace-failed-on-" + conv ) ; } } return conv ; } 
@ Override public boolean addAll ( Collection < ? extends E > collection ) { Object [ ] newPart = collection . toArray ( ) ; int newPartSize = newPart . length ; if ( newPartSize == 0 ) { return false ; } Object [ ] a = array ; int s = size ; int newSize = s + newPartSize ; if ( newSize > a . length ) { int newCapacity = newCapacity ( newSize - 1 ) ; Object [ ] newArray = new Object [ newCapacity ] ; System . arraycopy ( a , 0 , newArray , 0 , s ) ; array = a = newArray ; } System . arraycopy ( newPart , 0 , a , s , newPartSize ) ; size = newSize ; modCount ++ ; return true ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public void defaultReadObject ( ) throws ClassNotFoundException , IOException , NotActiveException { if ( this . currentObject == null || this . currentObjectStreamClass == null ) throw new NotActiveException ( "defaultReadObject-called-by-non-active" + "-class-and/or-object" ) ; if ( fieldsAlreadyRead ) throw new NotActiveException ( "defaultReadObject-called-but-fields-" + "already-read-from-stream-(by-" + "defaultReadObject-or-readFields)" ) ; boolean oldmode = setBlockDataMode ( false ) ; readFields ( this . currentObject , this . currentObjectStreamClass ) ; setBlockDataMode ( oldmode ) ; fieldsAlreadyRead = true ; } 
public void createIndicators ( IndicatorsMap im , Properties properties ) throws IOException { gitPath = properties . getProperty ( "GitPath" ) ; initialDate = properties . getProperty ( "Git_InitialDate" ) ; repositoryURI = properties . getProperty ( "GitRepositoryURI" ) ; String repositoryName = new File ( repositoryURI ) . getName ( ) ; repositoryLocalPath = new File ( properties . getProperty ( "GitLocalDirectory" ) , repositoryName ) ; GitLogStatistics statistics = getStatistics ( ) ; storeAllMeasures ( im , statistics ) ; } 
public void addPropertyChangeListener ( PropertyChangeListener listener ) { if ( changeSupport == null ) { changeSupport = new PropertyChangeSupport ( this ) ; } changeSupport . addPropertyChangeListener ( listener ) ; } 
public static boolean equals ( String str1 , String str2 ) { return ( str1 == null ? str2 == null : str1 . equals ( str2 ) ) ; } 
@ XmlElementDecl ( namespace = "http://www.hr-xml.org/3" , name = "TaxCredit" ) public JAXBElement < TaxCreditType > createTaxCredit ( TaxCreditType value ) { return new JAXBElement < TaxCreditType > ( _TaxCredit_QNAME , TaxCreditType . class , null , value ) ; } 
private void checkPermittedIP ( Set permitted , byte [ ] ip ) throws PKIXNameConstraintValidatorException { if ( permitted == null ) { return ; } Iterator it = permitted . iterator ( ) ; while ( it . hasNext ( ) ) { byte [ ] ipWithSubnet = ( byte [ ] ) it . next ( ) ; if ( isIPConstrained ( ip , ipWithSubnet ) ) { return ; } } if ( ip . length == 0 && permitted . size ( ) == 0 ) { return ; } throw new PKIXNameConstraintValidatorException ( "IP-is-not-from-a-permitted-subtree." ) ; } 
private int readUTFChar ( StringBuilder sbuf , long utflen ) throws IOException { int b1 , b2 , b3 ; b1 = readByte ( ) & 0xFF ; switch ( b1 >> 4 ) { case 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : sbuf . append ( ( char ) b1 ) ; return 1 ; case 12 : case 13 : if ( utflen < 2 ) { throw new UTFDataFormatException ( ) ; } b2 = readByte ( ) ; if ( ( b2 & 0xC0 ) != 0x80 ) { throw new UTFDataFormatException ( ) ; } sbuf . append ( ( char ) ( ( ( b1 & 0x1F ) << 6 ) | ( ( b2 & 0x3F ) << 0 ) ) ) ; return 2 ; case 14 : if ( utflen < 3 ) { if ( utflen == 2 ) { readByte ( ) ; } throw new UTFDataFormatException ( ) ; } b2 = readByte ( ) ; b3 = readByte ( ) ; if ( ( b2 & 0xC0 ) != 0x80 || ( b3 & 0xC0 ) != 0x80 ) { throw new UTFDataFormatException ( ) ; } sbuf . append ( ( char ) ( ( ( b1 & 0x0F ) << 12 ) | ( ( b2 & 0x3F ) << 6 ) | ( ( b3 & 0x3F ) << 0 ) ) ) ; return 3 ; default : throw new UTFDataFormatException ( ) ; } } 
public final void replaceStream ( OutputStream replacementStream ) throws IOException { if ( ! isRecoverable ( ) ) { throw new IllegalStateException ( ) ; } if ( this . out == replacementStream ) { return ; } replayBuffer . writeTo ( replacementStream ) ; Util . closeQuietly ( out ) ; out = replacementStream ; } 
public String optString ( String key , String defaultValue ) { Object object = this . opt ( key ) ; return NULL . equals ( object ) ? defaultValue : object . toString ( ) ; } 
private String promptPassword ( SecurityLevels . PHYSICAL_THREAT_LEVEL newThreatLevel , PASSWORD_PROMPT type ) { if ( type == PASSWORD_PROMPT . DECRYPT_WRONG ) { System . err . println ( "Wrong-password!" ) ; } StringBuilder destination = new StringBuilder ( FirstTimeWizardToadlet . WIZARD_STEP . SECURITY_PHYSICAL + "&error=pass&newThreatLevel=" ) . append ( newThreatLevel . name ( ) ) . append ( "&type=" ) . append ( type . name ( ) ) ; return destination . toString ( ) ; } 
public static < T > Collection < T > applyFilter ( Iterable < ? extends T > elements , GridClientPredicate < ? super T > ... filters ) { assert filters != null ; Collection < T > res = new LinkedList < > ( ) ; for ( T e : elements ) { boolean add = true ; for ( GridClientPredicate < ? super T > filter : filters ) if ( filter != null && ! filter . apply ( e ) ) { add = false ; break ; } if ( add ) res . add ( e ) ; } return res ; } 
public boolean hasNext ( ) { try { while ( ! childrenOrSelf . hasPrevious ( ) ) { if ( stack . isEmpty ( ) ) { while ( ! precedingSibling . hasNext ( ) ) { if ( ! ancestorOrSelf . hasNext ( ) ) { return false ; } Object contextNode = ancestorOrSelf . next ( ) ; precedingSibling = new PrecedingSiblingAxisIterator ( contextNode , navigator ) ; } Object node = precedingSibling . next ( ) ; childrenOrSelf = childrenOrSelf ( node ) ; } else { childrenOrSelf = ( ListIterator ) stack . remove ( stack . size ( ) - 1 ) ; } } return true ; } catch ( UnsupportedAxisException e ) { throw new JaxenRuntimeException ( e ) ; } } 
public ServerSocket ( ) throws IOException { setImpl ( ) ; } 
public Class < ? > getValueClass ( ) { return data . getValueClass ( ) ; } 
public static void upgrade ( Nodemapper node ) { node . map = new HashMap < String , Nodemapper > ( ) ; node . map . put ( node . key , node . value ) ; node . key = null ; node . value = null ; } 
public void setDeprecatedProperties ( ) { DeprecationContext deprecations = deprecationContext . get ( ) ; Properties props = getProps ( ) ; Properties overlay = getOverlay ( ) ; for ( Map . Entry < String , DeprecatedKeyInfo > entry : deprecations . getDeprecatedKeyMap ( ) . entrySet ( ) ) { String depKey = entry . getKey ( ) ; if ( ! overlay . contains ( depKey ) ) { for ( String newKey : entry . getValue ( ) . newKeys ) { String val = overlay . getProperty ( newKey ) ; if ( val != null ) { props . setProperty ( depKey , val ) ; overlay . setProperty ( depKey , val ) ; break ; } } } } } 
public void set ( T value ) { Thread currentThread = Thread . currentThread ( ) ; Values values = values ( currentThread ) ; if ( values == null ) { values = initializeValues ( currentThread ) ; } values . put ( this , value ) ; } 
static public boolean isSyncEnabled ( Context context ) { Cursor cursor = null ; try { cursor = context . getContentResolver ( ) . query ( CONTENT_URI , new String [ ] { VALUE } , KEY + "=?" , new String [ ] { KEY_SYNC_ENABLED } , null ) ; if ( cursor == null || ! cursor . moveToFirst ( ) ) { return false ; } return cursor . getInt ( 0 ) != 0 ; } finally { if ( cursor != null ) cursor . close ( ) ; } } 
public Region getUnion ( Region r ) { if ( r . isEmpty ( ) || r . isInsideQuickCheck ( this ) ) { return this ; } if ( this . isEmpty ( ) || this . isInsideQuickCheck ( r ) ) { return r ; } Region ret = new Region ( ( r . lox > this . lox ) ? this . lox : r . lox , ( r . loy > this . loy ) ? this . loy : r . loy , ( r . hix < this . hix ) ? this . hix : r . hix , ( r . hiy < this . hiy ) ? this . hiy : r . hiy ) ; ret . filterSpans ( this , r , INCLUDE_A | INCLUDE_B | INCLUDE_COMMON ) ; return ret ; } 
public void backPatch ( InstructionHandle target ) { if ( _elements != null ) { final int n = _elements . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { BranchHandle bh = ( BranchHandle ) _elements . elementAt ( i ) ; bh . setTarget ( target ) ; } _elements . clear ( ) ; } } 
@ Override public void write ( byte [ ] theBytes , int off , int len ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theBytes , off , len ) ; return ; } for ( int i = 0 ; i < len ; i ++ ) { write ( theBytes [ off + i ] ) ; } } 
public String [ ] getAttributeValues ( String elementName , String attributeName , String greatGrandParentElementName ) { if ( greatGrandParentElementName != null ) { String key = String . format ( "(%1$s,%2$s,%3$s)" , greatGrandParentElementName , elementName , attributeName ) ; String [ ] values = mAttributeValues . get ( key ) ; if ( values != null ) { return values ; } } return getAttributeValues ( elementName , attributeName ) ; } 
public static Query fromView ( View view ) { return Query . select ( view . qualifiedFields ( ) ) . from ( view ) ; } 
public boolean detectWebkit ( ) { if ( ( this . initCompleted == true ) || ( this . isWebkit == true ) ) return this . isWebkit ; if ( userAgent . indexOf ( engineWebKit ) != - 1 ) { return true ; } return false ; } 
public int findDimensionIndex ( String name ) { for ( int i = 0 ; i < dimensions . size ( ) ; i ++ ) { Dimension d = dimensions . get ( i ) ; if ( name . equals ( d . getName ( ) ) ) return i ; } return - 1 ; } 
public Boolean isEmpty ( ) { return ( routes == null || routes . isEmpty ( ) ) ; } 
@ Override public final int hashCode ( ) { if ( addr == null ) { return hostname . hashCode ( ) + port ; } return addr . hashCode ( ) + port ; } 
public static ExtendedIterator < Triple > findAll ( Graph g ) { return g . find ( Triple . ANY ) ; } 
public ArrayList < UUID > readFriendListFromIndex ( UUID uuid ) { if ( index . containsKey ( uuid ) ) { return index . get ( uuid ) ; } return null ; } 
public void startGeneralEntity ( String name , XMLResourceIdentifier id , String encoding , Augmentations augs ) throws XNIException { EntityReference entityRef = fDocument . createEntityReference ( name ) ; fCurrentNode . appendChild ( entityRef ) ; fCurrentNode = entityRef ; } 
public boolean equals ( State o ) { for ( int i = 0 ; i < DIM ; i ++ ) if ( ! Arrays . equals ( this . state [ i ] , o . state [ i ] ) ) return false ; return true ; } 
@ Override public AttributedCharacterIterator formatToCharacterIterator ( Object object ) { if ( object == null ) { throw new NullPointerException ( ) ; } if ( object instanceof Date ) { return formatToCharacterIteratorImpl ( ( Date ) object ) ; } if ( object instanceof Number ) { return formatToCharacterIteratorImpl ( new Date ( ( ( Number ) object ) . longValue ( ) ) ) ; } throw new IllegalArgumentException ( ) ; } 
public void addTextArea ( String name , String label , String theValue , Color background , Color foreground ) { addTextArea ( name , label , theValue , background , foreground , _height , _width ) ; } 
protected Transferable createTransferable ( JComponent comp ) { exportComp = ( JTextComponent ) comp ; shouldRemove = true ; p0 = exportComp . getSelectionStart ( ) ; p1 = exportComp . getSelectionEnd ( ) ; return ( p0 != p1 ) ? ( new TextTransferable ( exportComp , p0 , p1 ) ) : null ; } 
public int getCount ( ) { return contentItem . size ( ) ; } 
public int discard ( int length ) { if ( AppiaConfig . quotaOn && ( ( size - length ) > 0 ) ) unBind ( Math . min ( length , size ) ) ; int r = length > size ? size : length ; int newsize = size - r ; while ( ( size > newsize ) && ( first != null ) ) { if ( ! ro_mode && ( first . refs > 1 ) ) { ro_mode = true ; ro_off = first . off ; ro_len = first . len ; } if ( ro_mode ) { if ( ( size - newsize ) >= ro_len ) { size -= ro_len ; first . refs -- ; first = first . next ; if ( first != null ) { ro_off = first . off ; ro_len = first . len ; } else { ro_mode = false ; ro_off = 0 ; ro_len = 0 ; } } else { int remove = size - newsize ; ro_off += remove ; ro_len -= remove ; size -= remove ; } } else { if ( ( size - newsize ) >= first . len ) { size -= first . len ; first = first . next ; } else { int remove = size - newsize ; first . off += remove ; first . len -= remove ; size -= remove ; } } } return r ; } 
public int compareTo ( BigDecimal val ) { if ( scale == val . scale ) { long xs = intCompact ; long ys = val . intCompact ; if ( xs != INFLATED && ys != INFLATED ) return xs != ys ? ( ( xs > ys ) ? 1 : - 1 ) : 0 ; } int xsign = this . signum ( ) ; int ysign = val . signum ( ) ; if ( xsign != ysign ) return ( xsign > ysign ) ? 1 : - 1 ; if ( xsign == 0 ) return 0 ; int cmp = compareMagnitude ( val ) ; return ( xsign > 0 ) ? cmp : - cmp ; } 
public String toXML ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( "<it-label-formatref="" ) ; buffer . append ( getFormat ( ) . getID ( ) ) ; buffer . append ( "">" ) ; buffer . append ( super . toXML ( ) ) ; buffer . append ( "</it-label>" ) ; return buffer . toString ( ) ; } 
private String parseTypeString ( String typeString ) { StringBuilder result = new StringBuilder ( typeString ) ; for ( int i = 0 ; i < result . length ( ) ; i ++ ) { char c = result . charAt ( i ) ; if ( ! ( Character . isLetter ( c ) || Character . isDigit ( c ) || c == '.' ) ) { result . setCharAt ( i , '_' ) ; } } return result . toString ( ) ; } 
public void submitScore ( String playerName , int i ) { try { output = new FileWriter ( "highscore.txt" , true ) ; output . write ( String . valueOf ( i ) ) ; output . append ( "-" + playerName ) ; output . append ( "-" ) ; output . close ( ) ; } catch ( IOException e ) { } } 
@ Override public void dragFinished ( DragSourceEvent event ) { if ( dragSourceImage != null ) dragSourceImage . dispose ( ) ; dragSourceImage = null ; } 
public void paint ( Graphics g ) { Graphics2D g2 = ( Graphics2D ) g ; g2 . addRenderingHints ( new RenderingHints ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ) ; if ( active ) { g2 . setColor ( getBorderColor ( ) . brighter ( ) ) ; } else { g2 . setColor ( getBorderColor ( ) ) ; } g2 . fill ( body ) ; if ( active ) { g2 . setColor ( Comment . background . brighter ( ) ) ; } else { g2 . setColor ( Comment . background ) ; } g2 . fill ( textarea ) ; if ( active ) { g2 . setColor ( Color . white ) ; } else { g2 . setColor ( Color . lightGray ) ; } g2 . draw ( textarea ) ; if ( active ) { g2 . setColor ( Color . lightGray . brighter ( ) ) ; } else { g2 . setColor ( Color . lightGray ) ; } g2 . fill ( resize ) ; super . paint ( g ) ; } 
public byte [ ] toBytes ( ) throws UnsupportedEncodingException { StringBuilder result = new StringBuilder ( 256 ) ; result . append ( requestLine ) . append ( "-" ) ; for ( int i = 0 ; i < namesAndValues . size ( ) ; i += 2 ) { result . append ( namesAndValues . get ( i ) ) . append ( ":-" ) . append ( namesAndValues . get ( i + 1 ) ) . append ( "-" ) ; } result . append ( "-" ) ; return result . toString ( ) . getBytes ( "ISO-8859-1" ) ; } 
public void reset ( ) { int builderOffset = builder . getCurrentOffset ( ) ; while ( markers . size ( ) > 0 ) { NestedRangeStartMarker lastMarker = markers . peek ( ) ; if ( lastMarker . getOffset ( ) >= builderOffset ) { markers . pop ( ) ; if ( depth > 0 ) depth -- ; } else { break ; } } } 
protected void remoteControlDisplayWantsPlaybackPositionSync ( IRemoteControlDisplay rcd , boolean wantsSync ) { synchronized ( mRCStack ) { boolean rcdRegistered = false ; final Iterator < DisplayInfoForServer > displayIterator = mRcDisplays . iterator ( ) ; while ( displayIterator . hasNext ( ) ) { final DisplayInfoForServer di = ( DisplayInfoForServer ) displayIterator . next ( ) ; if ( di . mRcDisplay . asBinder ( ) . equals ( rcd . asBinder ( ) ) ) { di . mWantsPositionSync = wantsSync ; rcdRegistered = true ; break ; } } if ( ! rcdRegistered ) { return ; } final Iterator < RemoteControlStackEntry > stackIterator = mRCStack . iterator ( ) ; while ( stackIterator . hasNext ( ) ) { final RemoteControlStackEntry rcse = stackIterator . next ( ) ; if ( rcse . mRcClient != null ) { try { rcse . mRcClient . setWantsSyncForDisplay ( rcd , wantsSync ) ; } catch ( RemoteException e ) { Log . e ( TAG , "Error-setting-position-sync-flag-for-RCD-on-RCC:-" , e ) ; } } } } } 
public void lockNodes ( NodeView [ ] nodes ) { for ( int i = 0 ; i < nodes . length ; ++ i ) { staticNodes . add ( nodes [ i ] ) ; } } 
@ XmlElementDecl ( namespace = "http://xmlns.oracle.com/apps/cdm/foundation/parties/relationshipService/" , name = "Role" , scope = Relationship . class ) public JAXBElement < String > createRelationshipRole ( String value ) { return new JAXBElement < String > ( _RelationshipRole_QNAME , String . class , Relationship . class , value ) ; } 
public ResultMetaData getResultMetaData ( ) { switch ( type ) { case StatementTypes . DELETE_WHERE : case StatementTypes . INSERT : case StatementTypes . UPDATE_WHERE : case StatementTypes . MERGE : return ResultMetaData . emptyResultMetaData ; default : throw Error . runtimeError ( ErrorCode . U_S0500 , "StatementDMQL" ) ; } } 
public Request setDestinationInExternalPublicDir ( String dirType , String subPath ) { File file = Environment . getExternalStoragePublicDirectory ( dirType ) ; if ( file == null ) { throw new IllegalStateException ( "Failed-to-get-external-storage-public-directory" ) ; } else if ( file . exists ( ) ) { if ( ! file . isDirectory ( ) ) { throw new IllegalStateException ( file . getAbsolutePath ( ) + "-already-exists-and-is-not-a-directory" ) ; } } else { if ( ! file . mkdirs ( ) ) { throw new IllegalStateException ( "Unable-to-create-directory:-" + file . getAbsolutePath ( ) ) ; } } setDestinationFromBase ( file , subPath ) ; return this ; } 
public synchronized Progress phase ( ) { return phases . get ( currentPhase ) ; } 
private void executeTasks ( ArrayList < SlaveComputer > computers , List < Callable < Boolean >> callables , final BuildListener listener ) throws IOException { ExecutorService es = Executors . newFixedThreadPool ( computers . size ( ) ) ; try { List < Future < Boolean >> futures = es . invokeAll ( callables ) ; if ( ! futureAll ( futures ) ) { throw new IOException ( "Some-slaves-are-still-in-a-previous-state" ) ; } } catch ( Exception e ) { throw new IOException ( "Node-waiting-failed" , e ) ; } listener . getLogger ( ) . format ( "Successfully-awaited-%d-slaves-" , computers . size ( ) ) ; } 
public static WritableRaster createPackedRaster ( DataBuffer dataBuffer , int width , int height , int bitsPerPixel , Point location ) { return Raster . createPackedRaster ( dataBuffer , width , height , bitsPerPixel , location ) ; } 
public static Element BOOLEAN ( RenderScript rs ) { if ( rs . mElement_BOOLEAN == null ) { rs . mElement_BOOLEAN = createUser ( rs , DataType . BOOLEAN ) ; } return rs . mElement_BOOLEAN ; } 
public String toString ( ) { return m_Content . toString ( ) ; } 
protected void putWord ( String word ) { String code = getCode ( word ) ; LinkedList list = ( LinkedList ) mainDictionary . get ( code ) ; if ( list != null ) { list . add ( word ) ; } else { list = new LinkedList ( ) ; list . add ( word ) ; mainDictionary . put ( code , list ) ; } } 
private void scaleByInd ( ) { double l_x , h_x ; Edge e ; Node r , s ; r = m_groups [ 0 ] . m_p ; r . setCenter ( .5 ) ; double m_scale ; for ( int noa = 0 ; noa < m_levelNum ; noa ++ ) { l_x = m_groups [ m_levels [ noa ] . m_start ] . m_left ; h_x = m_groups [ m_levels [ noa ] . m_end ] . m_right ; m_scale = h_x - l_x + 1 ; for ( int nob = m_levels [ noa ] . m_start ; nob <= m_levels [ noa ] . m_end ; nob ++ ) { r = m_groups [ nob ] . m_p ; for ( int noc = 0 ; ( e = r . getChild ( noc ) ) != null ; noc ++ ) { s = e . getTarget ( ) ; if ( s . getParent ( 0 ) == e ) { s . setCenter ( ( s . getCenter ( ) - l_x ) / m_scale ) ; } } } } } 
private Set < String > parseStringToSet ( final String data ) { String [ ] splits ; if ( data != null && data . length ( ) > 0 ) { splits = data . split ( "," ) ; } else { splits = new String [ ] { } ; } Set < String > set = new HashSet < String > ( ) ; if ( splits . length > 0 ) { for ( String split : splits ) { set . add ( split . trim ( ) ) ; } } return set ; } 
public static Button createRadioButton ( Composite parent , String label , int hspan ) { Button button = new Button ( parent , SWT . RADIO ) ; button . setFont ( parent . getFont ( ) ) ; if ( label != null ) { button . setText ( label ) ; } GridData gd = new GridData ( GridData . BEGINNING ) ; gd . horizontalSpan = hspan ; button . setLayoutData ( gd ) ; SWTUtil . setButtonDimensionHint ( button ) ; return button ; } 
public static FuncResult < CharSequence > readEntireFile ( Path file ) { FuncResult < CharSequence > res = new FuncResult < > ( ) ; BufferedReader br = null ; try { StringBuilder sb = new StringBuilder ( ) ; br = Files . newBufferedReader ( file , Charset . forName ( "UTF-8" ) ) ; String line = br . readLine ( ) ; while ( line != null ) { sb . append ( line ) ; sb . append ( "-" ) ; line = br . readLine ( ) ; } res . setResult ( sb ) ; } catch ( IOException x ) { res . error ( "Unabled-to-read-file-" + file + ",-error:-" + x ) ; } finally { closeQuietly ( br ) ; } return res ; } 
private void zzDoEOF ( ) throws java . io . IOException { if ( ! zzEOFDone ) { zzEOFDone = true ; yyclose ( ) ; } } 
synchronized Status stat ( ) throws IOException { Response r = simpleCommand ( "STAT" ) ; Status s = new Status ( ) ; if ( r . ok && r . data != null ) { try { StringTokenizer st = new StringTokenizer ( r . data ) ; s . total = Integer . parseInt ( st . nextToken ( ) ) ; s . size = Integer . parseInt ( st . nextToken ( ) ) ; } catch ( Exception e ) { } } return s ; } 
public static int queryDownloadStatus ( ContentResolver resolver , long id ) { final Cursor cursor = resolver . query ( ContentUris . withAppendedId ( Downloads . Impl . ALL_DOWNLOADS_CONTENT_URI , id ) , new String [ ] { Downloads . Impl . COLUMN_STATUS } , null , null , null ) ; try { if ( cursor . moveToFirst ( ) ) { return cursor . getInt ( 0 ) ; } else { return Downloads . Impl . STATUS_PENDING ; } } finally { cursor . close ( ) ; } } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public static String getSystemLookAndFeelClassName ( ) { String osName = System . getProperty ( "os.name" ) ; if ( osName . startsWith ( "Windows" ) ) return Options . JGOODIES_WINDOWS_NAME ; else if ( osName . startsWith ( "Mac" ) ) return UIManager . getSystemLookAndFeelClassName ( ) ; else return getCrossPlatformLookAndFeelClassName ( ) ; } 
private JComponent buildBundlePanel ( ) { table . setColumnSelectionAllowed ( true ) ; table . setCellSelectionEnabled ( true ) ; table . setAutoCreateColumnsFromModel ( true ) ; table . getTableHeader ( ) . setUpdateTableInRealTime ( false ) ; table . setModel ( model ) ; table . setColumnModel ( new BundleTableColumnData ( ) ) ; refreshTableData ( ) ; table . addMouseListener ( new MouseAdapter ( ) { @ Override public void mousePressed ( MouseEvent me ) { maybeShowPopup ( me ) ; } @ Override public void mouseReleased ( MouseEvent me ) { maybeShowPopup ( me ) ; } private void maybeShowPopup ( MouseEvent me ) { if ( me . isPopupTrigger ( ) && table . isEnabled ( ) ) { Point p = new Point ( me . getX ( ) , me . getY ( ) ) ; int rowNum = table . rowAtPoint ( p ) ; if ( rowNum >= 0 && rowNum < table . getRowCount ( ) ) { JPopupMenu contextMenu = createContextMenu ( rowNum ) ; if ( contextMenu != null && contextMenu . getComponentCount ( ) > 0 ) { contextMenu . show ( table , p . x , p . y ) ; } } } } } ) ; JScrollPane ret = new JScrollPane ( ) ; ret . doLayout ( ) ; ret . getViewport ( ) . setBackground ( table . getBackground ( ) ) ; ret . getViewport ( ) . add ( table ) ; return ret ; } 
public int findTimeIndexFromDate ( java . util . Date d ) { int n = timeDates . length ; long m = d . getTime ( ) ; int index = 0 ; while ( index < n ) { if ( m < timeDates [ index ] . getTime ( ) ) break ; index ++ ; } return Math . max ( 0 , index - 1 ) ; } 
private void unsubscribeBookListeners ( ) { Book book = spreadsheet . getBook ( ) ; if ( book == null ) { for ( EventListener listener : bookListeners . keySet ( ) ) { bookListeners . put ( listener , Boolean . FALSE ) ; } return ; } for ( EventListener listener : bookListeners . keySet ( ) ) { boolean subscribed = bookListeners . get ( listener ) ; if ( subscribed ) { book . unsubscribe ( listener ) ; bookListeners . put ( listener , Boolean . FALSE ) ; } } } 
public boolean hasWaiters ( Condition condition ) { if ( condition == null ) throw new NullPointerException ( ) ; if ( ! ( condition instanceof AbstractQueuedSynchronizer . ConditionObject ) ) throw new IllegalArgumentException ( "not-owner" ) ; return sync . hasWaiters ( ( AbstractQueuedSynchronizer . ConditionObject ) condition ) ; } 
public static File [ ] listFiles ( File f ) { return f . listFiles ( ) ; } 
private int nextTlsMode ( ) { if ( nextTlsMode == TLS_MODE_MODERN ) { nextTlsMode = TLS_MODE_COMPATIBLE ; return TLS_MODE_MODERN ; } else if ( nextTlsMode == TLS_MODE_COMPATIBLE ) { nextTlsMode = TLS_MODE_NULL ; return TLS_MODE_COMPATIBLE ; } else { throw new AssertionError ( ) ; } } 
public static byte [ ] getAsciiBytes ( final String data ) { if ( data == null ) { throw new IllegalArgumentException ( "Parameter-may-not-be-null" ) ; } try { return data . getBytes ( HTTP . US_ASCII ) ; } catch ( UnsupportedEncodingException e ) { throw new Error ( "HttpClient-requires-ASCII-support" ) ; } } 
public void setHorizontalGroup ( Group group ) { if ( group == null ) { throw new IllegalArgumentException ( "Group-must-be-non-null" ) ; } horizontalGroup = createTopLevelGroup ( group ) ; invalidateHost ( ) ; } 
public boolean detectWebkit ( ) { if ( userAgent . indexOf ( engineWebKit ) != - 1 ) { return true ; } return false ; } 
void addCont ( Chain c ) { cont = Code . mergeChains ( c , cont ) ; } 
public static String buildShareResults ( Context context , String time , long [ ] laps ) { StringBuilder b = new StringBuilder ( context . getString ( R . string . sw_share_main , time ) ) ; b . append ( "-" ) ; int lapsNum = laps == null ? 0 : laps . length ; if ( lapsNum == 0 ) { return b . toString ( ) ; } b . append ( context . getString ( R . string . sw_share_laps ) ) ; b . append ( "-" ) ; for ( int i = 1 ; i <= lapsNum ; i ++ ) { b . append ( getTimeText ( context , laps [ lapsNum - i ] , i ) ) ; b . append ( "-" ) ; } return b . toString ( ) ; } 
protected synchronized void clearStatus ( String text ) { String methodName = MODULE_NAME + "clearStatus(String)" ; Logger . log ( methodName + "-text:-" + text , Logger . INFO ) ; try { synchronized ( statusRegion ) { if ( statusRegion . getText ( ) . trim ( ) . equals ( text ) ) { Logger . log ( methodName + "-Clearing-the-text." , Logger . INFO ) ; statusRegion . setText ( "" ) ; } } } catch ( Exception e ) { FusionUtils . logError ( methodName , "failed" , e ) ; } } 
public static JComponent localizeToolTip ( JComponent comp , String key ) { comp . setToolTipText ( Messages . message ( key ) ) ; return comp ; } 
protected void aboutAction ( ) { String close = "Close" ; JOptionPane . showOptionDialog ( mMainPanel , "<html><center><font-color=black>The-HTML-Parser-<font-color=blue><b>FilterBuilder</b></font><br><i>by-Derrick-Oswald</i>&nbsp;&nbsp;<b>DerrickOswald@users.sourceforge.net</b><br>http://htmlparser.org<br><br><font-size=-2>Copyright-&copy;-2005</font></center></html>" , "About-FilterBuilder" , JOptionPane . DEFAULT_OPTION , JOptionPane . INFORMATION_MESSAGE , null , new String [ ] { close } , close ) ; } 
@ InterfaceAudience . LimitedPrivate ( { "HDFS" } ) public String getCanonicalServiceName ( ) { return ( dtService != null ) ? dtService . toString ( ) : null ; } 
private static KlassMetadata [ ] removeStrippedKlassesFromMetadata ( KlassMetadata [ ] originalMetadatas , SquawkHashtable deadClasses ) { if ( originalMetadatas == null ) { return null ; } Vector metadatasV = new Vector ( originalMetadatas . length ) ; for ( int i = 0 ; i < originalMetadatas . length ; i ++ ) { KlassMetadata metadata = originalMetadatas [ i ] ; if ( metadata != null ) { if ( deadClasses . contains ( metadata . getDefinedClass ( ) ) ) { } else { metadatasV . addElement ( metadata ) ; } } } KlassMetadata [ ] newmetadatas = new KlassMetadata [ metadatasV . size ( ) ] ; metadatasV . copyInto ( newmetadatas ) ; return newmetadatas ; } 
public void _write ( OutputStream output ) { output . write_long ( value ) ; } 
final public List nameList ( ) throws ParseException { final List list = new LinkedList ( ) ; Object obj ; obj = name ( ) ; list . add ( obj ) ; label_5 : while ( true ) { switch ( this . jj_ntk == - 1 ? jj_ntk ( ) : this . jj_ntk ) { case COMMA : ; break ; default : this . jj_la1 [ 11 ] = this . jj_gen ; break label_5 ; } jj_consume_token ( COMMA ) ; obj = name ( ) ; list . add ( obj ) ; } { if ( true ) { return list ; } } throw new Error ( "Missing-return-statement-in-function" ) ; } 
public Cursor swapCursor ( Cursor newCursor ) { if ( newCursor == mCursor ) { return null ; } Cursor oldCursor = mCursor ; if ( oldCursor != null ) { if ( mChangeObserver != null ) oldCursor . unregisterContentObserver ( mChangeObserver ) ; if ( mDataSetObserver != null ) oldCursor . unregisterDataSetObserver ( mDataSetObserver ) ; } mCursor = newCursor ; if ( newCursor != null ) { if ( mChangeObserver != null ) newCursor . registerContentObserver ( mChangeObserver ) ; if ( mDataSetObserver != null ) newCursor . registerDataSetObserver ( mDataSetObserver ) ; mRowIDColumn = newCursor . getColumnIndexOrThrow ( "_id" ) ; mDataValid = true ; notifyDataSetChanged ( ) ; } else { mRowIDColumn = - 1 ; mDataValid = false ; notifyDataSetInvalidated ( ) ; } return oldCursor ; } 
private static Object newInstance ( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { try { Class spiClass ; if ( classLoader == null ) { spiClass = Class . forName ( className ) ; } else { try { spiClass = Class . forName ( className , false , classLoader ) ; } catch ( ClassNotFoundException ex ) { LOGGER . log ( Level . FINE , "Unable-to-load-provider-class-" + className + "-using-custom-classloader-" + classLoader . getClass ( ) . getName ( ) + "-trying-again-with-current-classloader." , ex ) ; spiClass = Class . forName ( className ) ; } } return spiClass . newInstance ( ) ; } catch ( ClassNotFoundException x ) { throw x ; } catch ( Exception x ) { throw new ClassNotFoundException ( "Provider-" + className + "-could-not-be-instantiated:-" + x , x ) ; } } 
@ Override public String getText ( Object object ) { String label = ( ( Identifiable ) object ) . getName ( ) ; return label == null || label . length ( ) == 0 ? getString ( "_UI_Identifiable_type" ) : label ; } 
public int countRedos ( UndoOwner [ ] owners ) { if ( owners == null ) { return mRedos . size ( ) ; } int count = 0 ; int i = 0 ; while ( ( i = findNextState ( mRedos , owners , i ) ) >= 0 ) { count ++ ; i ++ ; } return count ; } 
public int getDefaultScreenBrightnessSetting ( ) { return mContext . getResources ( ) . getInteger ( com . android . internal . R . integer . config_screenBrightnessSettingDefault ) ; } 
public static byte [ ] decodeFromFile ( String filename ) { byte [ ] decodedData = null ; Base64 . InputStream bis = null ; try { java . io . File file = new java . io . File ( filename ) ; byte [ ] buffer = null ; int length = 0 ; int numBytes = 0 ; if ( file . length ( ) > Integer . MAX_VALUE ) { System . err . println ( "File-is-too-big-for-this-convenience-method-(" + file . length ( ) + "-bytes)." ) ; return null ; } buffer = new byte [ ( int ) file . length ( ) ] ; bis = new Base64 . InputStream ( new java . io . BufferedInputStream ( new java . io . FileInputStream ( file ) ) , Base64 . DECODE ) ; while ( ( numBytes = bis . read ( buffer , length , 4096 ) ) >= 0 ) length += numBytes ; decodedData = new byte [ length ] ; System . arraycopy ( buffer , 0 , decodedData , 0 , length ) ; } catch ( java . io . IOException e ) { System . err . println ( "Error-decoding-from-file-" + filename ) ; } finally { try { bis . close ( ) ; } catch ( Exception e ) { } } return decodedData ; } 
private void paranoidWipe ( final byte [ ] passwd ) { shaker . nextBytes ( passwd ) ; } 
@ Override public Object parseObject ( String string , ParsePosition position ) { return parse ( string , position ) ; } 
@ Override public String toString ( ) { final StringBuilder sbuf = new StringBuilder ( ) ; sbuf . append ( '[' ) ; sbuf . append ( path [ 0 ] ) ; for ( int i = 1 ; i < path . length ; i ++ ) { sbuf . append ( ':' ) ; sbuf . append ( path [ i ] ) ; } sbuf . append ( ']' ) ; return sbuf . toString ( ) ; } 
public static String extractNetworkPortion ( String phoneNumber ) { if ( phoneNumber == null ) { return null ; } int len = phoneNumber . length ( ) ; StringBuilder ret = new StringBuilder ( len ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = phoneNumber . charAt ( i ) ; int digit = Character . digit ( c , 10 ) ; if ( digit != - 1 ) { ret . append ( digit ) ; } else if ( c == '+' ) { String prefix = ret . toString ( ) ; if ( prefix . length ( ) == 0 || prefix . equals ( CLIR_ON ) || prefix . equals ( CLIR_OFF ) ) { ret . append ( c ) ; } } else if ( isDialable ( c ) ) { ret . append ( c ) ; } else if ( isStartsPostDial ( c ) ) { break ; } } return ret . toString ( ) ; } 
public boolean checkStationaryFunctionValue ( final double fxOld , final double fxNew , final int statStateIterations , final Type ecType ) { if ( Math . abs ( fxNew - fxOld ) >= functionEpsilon_ ) { this . statStateIterations = 0 ; return false ; } this . statStateIterations ++ ; if ( statStateIterations <= maxStationaryStateIterations_ ) return false ; this . ecType = Type . StationaryFunctionValue ; return true ; } 
public static void setSearchPath ( String path ) { mLibrarySearchPaths . clear ( ) ; mLibrarySearchPaths . addAll ( Arrays . asList ( path . split ( ":" ) ) ) ; } 
public void start ( ) { if ( treeMaker . editor == null ) sleepDuration = slowSleep ; else sleepDuration = fastTime ; thread = new Thread ( this ) ; thread . start ( ) ; stop = false ; System . out . println ( "Auto-refresh-ON." ) ; } 
public void setReadPermissions ( String ... permissions ) { properties . setReadPermissions ( Arrays . asList ( permissions ) ) ; } 
public static int LEN ( String string ) { return string == null ? - 1 : string . length ( ) ; } 
public static void disposeImages ( ) { { for ( Image image : m_imageMap . values ( ) ) { image . dispose ( ) ; } m_imageMap . clear ( ) ; } for ( int i = 0 ; i < m_decoratedImageMap . length ; i ++ ) { Map < Image , Map < Image , Image >> cornerDecoratedImageMap = m_decoratedImageMap [ i ] ; if ( cornerDecoratedImageMap != null ) { for ( Map < Image , Image > decoratedMap : cornerDecoratedImageMap . values ( ) ) { for ( Image image : decoratedMap . values ( ) ) { image . dispose ( ) ; } decoratedMap . clear ( ) ; } cornerDecoratedImageMap . clear ( ) ; } } } 
private View getHandleFromCoordinates ( float x , float y ) { final View [ ] handles = { mLeftHandle , mRightHandle , mTopHandle , mBottomHandle } ; for ( View v : handles ) { if ( ( v . getLeft ( ) - mExtraHandlingSpace ) < x && ( v . getRight ( ) + mExtraHandlingSpace ) > x && ( v . getTop ( ) - mExtraHandlingSpace ) < y && ( v . getBottom ( ) + mExtraHandlingSpace ) > y ) { return v ; } } return null ; } 
public synchronized void start ( Callback callback ) { if ( callback == null ) throw new IllegalArgumentException ( "callback-should-not-be-null" ) ; if ( mThread != null || mProcess != null ) throw new IllegalStateException ( "logcat-is-already-started" ) ; mCallback = callback ; mRun = true ; mThread = new Thread ( this ) ; mThread . start ( ) ; } 
public static void setMultiValueProperty ( String key , Set < String > values ) { multiValuePropertyMap . put ( key , new HashSet < String > ( values ) ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
protected static String makeIdentifiableString ( ModelObject < ? > target , Object ... objs ) { if ( target == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; if ( objs != null ) { for ( Object obj : objs ) { if ( obj != null ) { String str = obj . toString ( ) ; sb . append ( str ) ; sb . append ( "---" ) ; } } } return String . format ( "%s[%s]:-%s" , target . getClass ( ) . getSimpleName ( ) , target . getId ( ) , sb ) ; } 
public static void main ( String [ ] args ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { radiobutton window = new radiobutton ( ) ; window . frame . setVisible ( true ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; } 
public static < K > Comparator < ? super Map . Entry < K , ? >> entryComparator ( final Comparator < K > comparator ) { return new Comparator < Map . Entry < K , ? >> ( ) { public int compare ( Map . Entry < K , ? > x , Map . Entry < K , ? > y ) { return comparator . compare ( x . getKey ( ) , y . getKey ( ) ) ; } } ; } 
public boolean supportsSubqueriesInQuantifieds ( ) throws SQLException { return this . conn . versionMeetsMinimum ( 4 , 1 , 0 ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public void addProperty ( String propertyName , IndexedPropertyPeer propertyPeer ) { if ( propertyNameToPeerMap == null ) { propertyNameToPeerMap = new HashMap ( ) ; } if ( indexedPropertyNameSet == null ) { indexedPropertyNameSet = new HashSet ( ) ; } indexedPropertyNameSet . add ( propertyName ) ; } 
public Elements append ( String html ) { for ( Element element : contents ) { element . append ( html ) ; } return this ; } 
@ SuppressWarnings ( "unchecked" ) public final Object getContent ( Class [ ] types ) throws IOException { return openConnection ( ) . getContent ( types ) ; } 
public static void civilMechEmergency ( ) { System . out . print ( Util . lineWrap ( "Seemingly-fed-up-with-its-attacks-failing,-the-Civil-Control-Mech-takes-a-step-back-and-then-opens-a-hidden-hatch-on-its-front-side." , lineLength ) ) ; Util . skitPause ( ) ; System . out . print ( Util . lineWrap ( "And-out-of-it...-emerges-an-Alpha-Cannon!" , lineLength ) ) ; Util . skitPause ( ) ; System . out . print ( Util . lineWrap ( "Seeing-that-the-mech-seems-to-have-finally-resorted-to-actual-force,-you-decide-to-do-the-same---otherwise-known-as-smashing-it-into-smithereens!" , lineLength ) ) ; Util . skitPause ( ) ; } 
public String getUserInfo ( ) { return this . iNamespacePath == null ? null : this . iNamespacePath . getUserInfo ( ) ; } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; elementList . add ( new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2012-08-15/" , "networkInterfaceId" ) ) ; if ( localNetworkInterfaceId != null ) { elementList . add ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( localNetworkInterfaceId ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "networkInterfaceId-cannot-be-null!!" ) ; } elementList . add ( new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2012-08-15/" , "ModifyNetworkInterfaceAttributeTypeChoice_type0" ) ) ; if ( localModifyNetworkInterfaceAttributeTypeChoice_type0 == null ) { throw new org . apache . axis2 . databinding . ADBException ( "ModifyNetworkInterfaceAttributeTypeChoice_type0-cannot-be-null!!" ) ; } elementList . add ( localModifyNetworkInterfaceAttributeTypeChoice_type0 ) ; return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
protected boolean isValidRange ( String range ) { if ( range == null ) { return false ; } int hyphenIndex ; if ( ( hyphenIndex = range . indexOf ( '-' ) ) >= 0 ) { if ( isValidRange ( range . substring ( 0 , hyphenIndex ) ) && isValidRange ( range . substring ( hyphenIndex + 1 ) ) ) { return true ; } return false ; } if ( range . toLowerCase ( ) . equals ( "first" ) ) { return true ; } if ( range . toLowerCase ( ) . equals ( "last" ) ) { return true ; } try { int index = Integer . parseInt ( range ) ; if ( ( index > 0 ) && ( index <= m_Upper + 1 ) ) { return true ; } return false ; } catch ( NumberFormatException ex ) { return false ; } } 
protected void onContentChanged ( ) { if ( mAutoRequery && mCursor != null && ! mCursor . isClosed ( ) ) { if ( false ) Log . v ( "Cursor" , "Auto-requerying-" + mCursor + "-due-to-update" ) ; mDataValid = mCursor . requery ( ) ; } } 
public void setValue ( final Object value ) { Object oldValue = this . value ; this . value = value ; updateFactory ( ) ; updateFormatter ( true ) ; revertValue ( ) ; firePropertyChange ( VALUE_PROPERTY_NAME , oldValue , value ) ; } 
public synchronized ODataHoleInfo getHole ( final int iPosition ) { final ODataHoleInfo hole = availableHolesList . get ( iPosition ) ; if ( hole . dataOffset == - 1 ) return null ; return hole ; } 
public String [ ] args ( ) { int size = mSelectionArgs . size ( ) ; if ( size == 0 ) return null ; return mSelectionArgs . toArray ( new String [ size ] ) ; } 
public Scalpel remove ( ) { comments . removeAll ( used ) ; final Set < Comment > unique = new LinkedHashSet < > ( comments ) ; comments . clear ( ) ; comments . addAll ( unique ) ; if ( comments . isEmpty ( ) ) r . remove ( base , g ) ; else { final List < ASTNode > $ = new ArrayList < > ( ) ; for ( final Comment c : comments ) $ . add ( 0 , r . createStringPlaceholder ( s . substring ( c . getStartPosition ( ) , c . getStartPosition ( ) + c . getLength ( ) ) , ASTNode . BLOCK ) ) ; r . replace ( base , r . createGroupNode ( $ . toArray ( new ASTNode [ $ . size ( ) ] ) ) , g ) ; } for ( final ASTNode a : additionals ) r . remove ( a , g ) ; return this ; } 
private int getDistance ( Vector2 v1 , Vector2 v2 ) { int distance = Math . abs ( v1 . x - v2 . x ) + Math . abs ( v1 . y - v2 . y ) ; return distance ; } 
static public void assertHorizontalCenterAligned ( View reference , View test ) { int [ ] xy = new int [ 2 ] ; reference . getLocationOnScreen ( xy ) ; int referenceLeft = xy [ 0 ] ; test . getLocationOnScreen ( xy ) ; int testLeft = xy [ 0 ] ; int center = ( reference . getMeasuredWidth ( ) - test . getMeasuredWidth ( ) ) / 2 ; int delta = testLeft - referenceLeft ; assertEquals ( "views-are-not-horizontally-center-aligned" , center , delta ) ; } 
public static < T > T newInstance ( Class < T > clazz ) { Constructor < T > ctor = null ; if ( classConstructorCache . containsKey ( clazz ) ) { ctor = ( Constructor < T > ) classConstructorCache . get ( clazz ) ; } else { try { ctor = clazz . getConstructor ( ) ; } catch ( Exception e ) { } try { ctor = clazz . getDeclaredConstructor ( ) ; ctor . setAccessible ( true ) ; } catch ( Exception e ) { } classConstructorCache . put ( clazz , ctor ) ; } if ( ctor != null ) { try { return ctor . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( "Cannot-instantiate-" + clazz , e ) ; } } else { throw new RuntimeException ( "No-default-constructor-for-" + clazz ) ; } } 
private static void mergeSort ( int [ ] a , int [ ] tmpArray , int left , int right ) { if ( left < right ) { int center = ( left + right ) / 2 ; mergeSort ( a , tmpArray , left , center ) ; mergeSort ( a , tmpArray , center + 1 , right ) ; merge ( a , tmpArray , left , center + 1 , right ) ; } } 
public static void checkState ( boolean isValid , String message , Object ... args ) throws IllegalStateException { if ( ! isValid ) { throw new IllegalStateException ( String . format ( String . valueOf ( message ) , strings ( args ) ) ) ; } } 
public void actionPerformed ( ActionEvent ae ) { if ( scrollBar == null || ! scrollBar . getValueIsAdjusting ( ) ) { if ( timer != null ) timer . stop ( ) ; updateSize ( ) ; timer = null ; scrollBar = null ; } } 
protected List < DataFlavor > getCurrentDataFlavorsAsList ( ) { return Arrays . asList ( getCurrentDataFlavors ( ) ) ; } 
private static void assertEquals ( Object a1 , Object a2 ) { if ( ! a1 . equals ( a2 ) ) { throw new RuntimeException ( "TEST-FAILS:-" + a1 + "-should-be-" + a2 ) ; } } 
private void stageFile ( int rawId , File file ) throws Exception { new File ( file . getParent ( ) ) . mkdirs ( ) ; InputStream in = null ; OutputStream out = null ; try { in = getContext ( ) . getResources ( ) . openRawResource ( rawId ) ; out = new FileOutputStream ( file ) ; Streams . copy ( in , out ) ; } finally { IoUtils . closeQuietly ( in ) ; IoUtils . closeQuietly ( out ) ; } } 
public static < E > boolean isEmpty ( CharSequence c ) { return ( c == null ) || c . length ( ) == 0 ; } 
private String bml2ssml ( String bml ) throws Exception { StreamSource bmlSource = new StreamSource ( new StringReader ( bml ) ) ; StringWriter ssmlWriter = new StringWriter ( ) ; StreamResult ssmlResult = new StreamResult ( ssmlWriter ) ; Transformer transformer = bml2ssmlStylesheet . newTransformer ( ) ; transformer . transform ( bmlSource , ssmlResult ) ; return ssmlWriter . toString ( ) ; } 
public static double ceil ( double a ) { return StrictMath . ceil ( a ) ; } 
public void testSerialization ( ) { AreaRenderer r1 = new AreaRenderer ( ) ; AreaRenderer r2 = null ; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; ObjectOutput out = new ObjectOutputStream ( buffer ) ; out . writeObject ( r1 ) ; out . close ( ) ; ObjectInput in = new ObjectInputStream ( new ByteArrayInputStream ( buffer . toByteArray ( ) ) ) ; r2 = ( AreaRenderer ) in . readObject ( ) ; in . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } assertEquals ( r1 , r2 ) ; } 
@ Override public void close ( ) throws java . io . IOException { flushBase64 ( ) ; super . close ( ) ; buffer = null ; out = null ; } 
public void clear ( ) { bytes . clear ( ) ; floats . clear ( ) ; ints . clear ( ) ; } 
public void captureChildView ( View childView , int activePointerId ) { if ( childView . getParent ( ) != mParentView ) { throw new IllegalArgumentException ( "captureChildView:-parameter-must-be-a-descendant-" + "of-the-ViewDragHelper's-tracked-parent-view-(" + mParentView + ")" ) ; } mCapturedView = childView ; mActivePointerId = activePointerId ; mCallback . onViewCaptured ( childView , activePointerId ) ; setDragState ( STATE_DRAGGING ) ; } 
public long ramBytesUsed ( ) { return ( fst != null ) ? fst . sizeInBytes ( ) : 0 ; } 
public void accept ( Visitor v ) { v . visitVariableLengthInstruction ( this ) ; v . visitUnconditionalBranch ( this ) ; v . visitBranchInstruction ( this ) ; v . visitGotoInstruction ( this ) ; v . visitGOTO ( this ) ; } 
public static Date parseIso8601DateTime ( String datestr ) throws ParseException { return new SimpleDateFormat ( ISO8601_DATETIME_PATTERN ) . parse ( datestr ) ; } 
private void addLibraryProjects ( @ NonNull Collection < Project > collection , @ NonNull Set < Project > seen , @ NonNull Set < Project > path ) { for ( Project library : mDirectLibraries ) { if ( seen . contains ( library ) ) { if ( path . contains ( library ) ) { mClient . log ( Severity . WARNING , null , "Internal-lint-error:-cyclic-library-dependency-for-%1$s" , library ) ; } continue ; } collection . add ( library ) ; seen . add ( library ) ; path . add ( library ) ; library . addLibraryProjects ( collection , seen , path ) ; path . remove ( library ) ; } } 
public static Path getJobJar ( Path jobSubmitDir ) { return new Path ( jobSubmitDir , "job.jar" ) ; } 
int getFolderIndex ( String name ) { for ( Folder folder : this . folders ) if ( folder . name . equals ( name ) ) return folder . id ; return - 1 ; } 
public void keyPressed ( KeyEvent e ) { ( ( KeyListener ) a ) . keyPressed ( e ) ; ( ( KeyListener ) b ) . keyPressed ( e ) ; } 
public List < Component > getCustomChildren ( ) { final List < Component > children = new ArrayList < Component > ( customChildren . size ( ) ) ; final Iterator < WeakReference < Component >> iterator = customChildren . iterator ( ) ; while ( iterator . hasNext ( ) ) { final WeakReference < Component > next = iterator . next ( ) ; final Component component = next . get ( ) ; if ( component == null ) { iterator . remove ( ) ; } else { children . add ( component ) ; } } return children ; } 
@ Override public void finish ( ) throws IOException { if ( out == null ) { throw new IOException ( "Stream-is-closed" ) ; } if ( cDir == null ) { return ; } if ( entries . isEmpty ( ) ) { throw new ZipException ( "No-entries" ) ; } if ( currentEntry != null ) { closeEntry ( ) ; } int cdirSize = cDir . size ( ) ; writeLong ( cDir , ENDSIG ) ; writeShort ( cDir , 0 ) ; writeShort ( cDir , 0 ) ; writeShort ( cDir , entries . size ( ) ) ; writeShort ( cDir , entries . size ( ) ) ; writeLong ( cDir , cdirSize ) ; writeLong ( cDir , offset ) ; writeShort ( cDir , commentBytes . length ) ; if ( commentBytes . length > 0 ) { cDir . write ( commentBytes ) ; } cDir . writeTo ( out ) ; cDir = null ; } 
public static boolean DownloadFromUrl ( String targetUrl , File file ) { try { URL url = new URL ( targetUrl ) ; Log . d ( LOG_TAG , "Download-begining" ) ; Log . d ( LOG_TAG , "Download-url:" + url ) ; Log . d ( LOG_TAG , "Downloaded-file-name:" + file . getAbsolutePath ( ) ) ; URLConnection ucon = url . openConnection ( ) ; InputStream is = ucon . getInputStream ( ) ; BufferedInputStream bis = new BufferedInputStream ( is ) ; ByteArrayBuffer baf = new ByteArrayBuffer ( 50 ) ; int current = 0 ; while ( ( current = bis . read ( ) ) != - 1 ) { baf . append ( ( byte ) current ) ; } FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( baf . toByteArray ( ) ) ; fos . close ( ) ; } catch ( IOException e ) { Log . d ( LOG_TAG , "Failed-to-download-file-with-error:-" + e ) ; return false ; } return true ; } 
String getNext ( ) { start = end ; while ( latlon . charAt ( start ) == '-' ) start ++ ; end = start ; while ( latlon . charAt ( end ) != '-' ) end ++ ; return latlon . substring ( start , end ) ; } 
private static String createName ( Bundle bundle ) { if ( bundle == null ) { throw new IllegalArgumentException ( "bundle-must-not-be-null" ) ; } StringBuffer sb = new StringBuffer ( "(id=" ) ; sb . append ( bundle . getBundleId ( ) ) ; sb . append ( ")" ) ; return sb . toString ( ) ; } 
public static final void log ( Object component , int category , String message , byte [ ] data , int offset , int length ) { if ( message == null ) message = "(null)" ; if ( component == null ) { throw new NullPointerException ( "component" ) ; } if ( ( traceOn_ && traceCategory ( category ) ) || ( findLogger ( ) && logger_ . isLoggable ( category ) ) ) { if ( logger_ == null || userSpecifiedDestination_ ) { PrintWriter pw = ( PrintWriter ) printWriterHash_ . get ( component ) ; if ( pw == null ) { pw = new PrintWriter ( System . out , true ) ; printWriterHash_ . put ( component , pw ) ; } synchronized ( pw ) { logTimeStamp ( component , pw ) ; pw . println ( message ) ; printByteArray ( pw , data , offset , length ) ; if ( category == ERROR ) { new Throwable ( ) . printStackTrace ( pw ) ; } } } log ( category , message , data , offset , length ) ; } } 
public void setNodeCompleted ( String nodeId , float complete ) { if ( graphElementMap . containsKey ( nodeId ) ) { GraphElement graphElement = graphElementMap . get ( nodeId ) ; graphElement . setCompleted ( complete ) ; } } 
public int indexOf ( String str , int fromIndex ) { return m_str . indexOf ( str , fromIndex ) ; } 
public static Callable < Object > callable ( final PrivilegedAction < ? > action ) { if ( action == null ) throw new NullPointerException ( ) ; return new Callable < Object > ( ) { public Object call ( ) { return action . run ( ) ; } } ; } 
public void closeRealPreparedStatement ( ) throws SQLException { realPreparedStatement . close ( ) ; } 
public void fitToBounds ( int padding ) { Rectangle viewBounds = getVisibleRect ( ) ; Rectangle automatonBounds ; if ( drawer != null && drawer . getBounds ( ) != null ) automatonBounds = new Rectangle ( drawer . getBounds ( ) ) ; else automatonBounds = new Rectangle ( 0 , 0 ) ; automatonBounds . grow ( padding , padding ) ; viewBounds . x = viewBounds . y = 0 ; State [ ] states = drawer . getAutomaton ( ) . getStates ( ) ; for ( int i = 0 ; i < states . length ; i ++ ) { Point p = states [ i ] . getPoint ( ) ; p . setLocation ( ( p . getX ( ) - automatonBounds . getX ( ) ) * ( viewBounds . getWidth ( ) / automatonBounds . getWidth ( ) ) , ( p . getY ( ) - automatonBounds . getY ( ) ) * ( viewBounds . getHeight ( ) / automatonBounds . getHeight ( ) ) ) ; states [ i ] . setPoint ( p ) ; } } 
private JCheckBox getChkRightPost ( ) { if ( chkRightPost == null ) { chkRightPost = new JCheckBox ( ) ; chkRightPost . setText ( "Post" ) ; } return chkRightPost ; } 
public static Object valueOf ( Class < ? > type , String value ) { try { if ( type . equals ( java . lang . String . class ) ) return value ; Method m = class2Value . get ( type ) ; if ( m != null ) return m . invoke ( null , value ) ; if ( type . equals ( java . lang . Character . TYPE ) || type . equals ( java . lang . Character . class ) ) return new Character ( value . charAt ( 0 ) ) ; Constructor < ? > c = type . getConstructor ( java . lang . String . class ) ; return c . newInstance ( value ) ; } catch ( NoSuchMethodException e ) { } catch ( IllegalAccessException e ) { } catch ( InstantiationException e ) { } catch ( InvocationTargetException e ) { if ( e . getTargetException ( ) instanceof Error ) throw ( Error ) ( e . getTargetException ( ) ) ; } return null ; } 
public boolean containsAccountConfig ( AccountConfig accountConfig ) { return accountConfigs . contains ( accountConfig ) ; } 
public static short [ ] copyOfRange ( short [ ] original , int from , int to ) { int newLength = to - from ; if ( newLength < 0 ) throw new IllegalArgumentException ( from + "->-" + to ) ; short [ ] copy = new short [ newLength ] ; System . arraycopy ( original , from , copy , 0 , Math . min ( original . length - from , newLength ) ) ; return copy ; } 
public void setRequestMethod ( String method ) throws ProtocolException { if ( connected ) { throw new ProtocolException ( "Connection-already-established" ) ; } for ( String permittedUserMethod : HttpURLConnectionImpl . PERMITTED_USER_METHODS ) { if ( permittedUserMethod . equals ( method ) ) { this . method = permittedUserMethod ; return ; } } throw new ProtocolException ( ) ; } 
public RecordedRequest takeRequest ( ) throws InterruptedException { return requestQueue . take ( ) ; } 
public final String getNameFor ( final int code ) { final String name = ( String ) m_codeMap . get ( new Integer ( code ) ) ; if ( null == name ) { final String message = "Unknown-code-" + code ; throw new IllegalArgumentException ( message ) ; } return name ; } 
@ Override public void writeDataToPipe ( ParcelFileDescriptor output , Uri uri , String mimeType , Bundle opts , Cursor c ) { FileOutputStream fout = new FileOutputStream ( output . getFileDescriptor ( ) ) ; PrintWriter pw = null ; try { pw = new PrintWriter ( new OutputStreamWriter ( fout , "UTF-8" ) ) ; pw . println ( c . getString ( READ_NOTE_TITLE_INDEX ) ) ; pw . println ( "" ) ; pw . println ( c . getString ( READ_NOTE_NOTE_INDEX ) ) ; } catch ( UnsupportedEncodingException e ) { Log . w ( TAG , "Ooops" , e ) ; } finally { c . close ( ) ; if ( pw != null ) { pw . flush ( ) ; } try { fout . close ( ) ; } catch ( IOException e ) { } } } 
@ XmlElementDecl ( namespace = "http://www.imsglobal.org/xsd/imsld_v1p0" , name = "activity-description" ) public JAXBElement < ItemModel > createActivityDescription ( ItemModel value ) { return new JAXBElement < ItemModel > ( _ActivityDescription_QNAME , ItemModel . class , null , value ) ; } 
private static void reportJavaLevelDeadlocks ( Set < String > deadlockSet , StringBuffer reportStr ) { if ( deadlockSet . size ( ) == 0 ) { return ; } for ( String deadlockStr : deadlockSet ) { reportStr . append ( "-" + deadlockStr ) ; } } 
public void drawChars ( char data [ ] , int offset , int length , int x , int y ) { drawString ( new String ( data , offset , length ) , x , y ) ; } 
public void setMinSizeWriter ( int min_buffer_size ) { min_buffer_size = Math . max ( min_buffer_size , MIN_BUFFER_SIZE ) ; min_buffer_size_ = min_buffer_size ; if ( MAX_BUFFER_SIZE < min_buffer_size ) { throw new IllegalArgumentException ( "Bad-buffer-size:-" + min_buffer_size + "-not-less-than-" + MAX_BUFFER_SIZE ) ; } if ( write_buf_ != null && write_buf_ . position ( ) == 0 && write_buf_ . capacity ( ) < min_buffer_size_ ) { write_buf_ = null ; } } 
public void setupFirstThreeGlyphs ( ) { usedGlyphs . put ( new Integer ( 0 ) , new Integer ( 0 ) ) ; usedGlyphsIndex . put ( new Integer ( 0 ) , new Integer ( 0 ) ) ; usedGlyphsCount ++ ; usedGlyphs . put ( new Integer ( 1 ) , new Integer ( 1 ) ) ; usedGlyphsIndex . put ( new Integer ( 1 ) , new Integer ( 1 ) ) ; usedGlyphsCount ++ ; usedGlyphs . put ( new Integer ( 2 ) , new Integer ( 2 ) ) ; usedGlyphsIndex . put ( new Integer ( 2 ) , new Integer ( 2 ) ) ; usedGlyphsCount ++ ; } 
@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( 10 ) ; format ( ( getYear ( ) + 1900 ) , 4 , sb ) ; sb . append ( '-' ) ; format ( ( getMonth ( ) + 1 ) , 2 , sb ) ; sb . append ( '-' ) ; format ( getDate ( ) , 2 , sb ) ; return sb . toString ( ) ; } 
public byte [ ] getLabel ( int n ) { int pos = offset ( n ) ; byte len = ( byte ) ( name [ pos ] + 1 ) ; byte [ ] label = new byte [ len ] ; System . arraycopy ( name , pos , label , 0 , len ) ; return label ; } 
protected void configureConnection ( ) throws SQLException { conn . setAutoCommit ( false ) ; } 
public final int getWaitQueueLength ( ConditionObject condition ) { if ( ! owns ( condition ) ) throw new IllegalArgumentException ( "Not-owner" ) ; return condition . getWaitQueueLength ( ) ; } 
public static String getLicenseText ( String licenseFile ) { InputStream is = null ; InputStreamReader ir = null ; BufferedReader br = null ; try { is = new FileInputStream ( licenseFile ) ; ir = new InputStreamReader ( is , "UTF-8" ) ; br = new BufferedReader ( ir ) ; String lineIn ; license = "" ; while ( ( lineIn = br . readLine ( ) ) != null ) { license = license + lineIn + '|n' ; } } catch ( IOException e ) { log . error ( "Can't-load-configuration" , e ) ; throw new IllegalStateException ( "Failed-to-read-default-license." , e ) ; } finally { if ( br != null ) { try { br . close ( ) ; } catch ( IOException ioe ) { } } if ( ir != null ) { try { ir . close ( ) ; } catch ( IOException ioe ) { } } if ( is != null ) { try { is . close ( ) ; } catch ( IOException ioe ) { } } } return license ; } 
private void drawMultipleEllipse ( Point2D point , double boxWidth , double oRadius , Graphics2D g2 ) { Ellipse2D dot1 = new Ellipse2D . Double ( point . getX ( ) - ( boxWidth / 2 ) + oRadius , point . getY ( ) , oRadius , oRadius ) ; Ellipse2D dot2 = new Ellipse2D . Double ( point . getX ( ) + ( boxWidth / 2 ) , point . getY ( ) , oRadius , oRadius ) ; g2 . draw ( dot1 ) ; g2 . draw ( dot2 ) ; } 
private Entry readTree ( final java . io . ObjectInputStream s , final int n , final Entry pred , final Entry succ ) throws java . io . IOException , ClassNotFoundException { if ( n == 1 ) { final Entry top = new Entry ( s . readShort ( ) , s . readDouble ( ) ) ; top . pred ( pred ) ; top . succ ( succ ) ; return top ; } if ( n == 2 ) { final Entry top = new Entry ( s . readShort ( ) , s . readDouble ( ) ) ; top . right ( new Entry ( s . readShort ( ) , s . readDouble ( ) ) ) ; top . right . pred ( top ) ; top . balance ( 1 ) ; top . pred ( pred ) ; top . right . succ ( succ ) ; return top ; } final int rightN = n / 2 , leftN = n - rightN - 1 ; final Entry top = new Entry ( ) ; top . left ( readTree ( s , leftN , pred , top ) ) ; top . key = s . readShort ( ) ; top . value = s . readDouble ( ) ; top . right ( readTree ( s , rightN , top , succ ) ) ; if ( n == ( n & - n ) ) top . balance ( 1 ) ; return top ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public Toolkit getToolkit ( ) { return Toolkit . getDefaultToolkit ( ) ; } 
public final static String encode ( String s ) { return encode ( s . getBytes ( ) ) ; } 
private void rebindWapPushManager ( ) { if ( mWapPushMan != null ) return ; final ServiceConnection wapPushConnection = this ; new Thread ( ) { public void run ( ) { while ( mWapPushMan == null ) { mOwner . bindService ( new Intent ( IWapPushManager . class . getName ( ) ) , wapPushConnection , Context . BIND_AUTO_CREATE ) ; try { Thread . sleep ( BIND_RETRY_INTERVAL ) ; } catch ( InterruptedException e ) { if ( false ) Log . v ( LOG_TAG , "sleep-interrupted." ) ; } } } } . start ( ) ; } 
private void ensureStackCapacity ( int newElementDepth ) { if ( newElementDepth == fElementContentState . length ) { boolean [ ] newStack = new boolean [ newElementDepth * 2 ] ; System . arraycopy ( this . fElementContentState , 0 , newStack , 0 , newElementDepth ) ; fElementContentState = newStack ; } } 
public void removeLibraryListener ( LibraryListener listener ) { libraryListeners . remove ( listener ) ; } 
private ZipInputStream openZipStreamAt ( URL url , String ext ) throws IOException { ZipInputStream zis = new ZipInputStream ( url . openStream ( ) ) ; ZipEntry entry = zis . getNextEntry ( ) ; while ( entry != null && ! entry . getName ( ) . endsWith ( ext ) ) { entry = zis . getNextEntry ( ) ; } if ( entry == null ) { zis . close ( ) ; return null ; } return zis ; } 
private boolean isNextCharacterEscapedQuote ( String nextLine , boolean inQuotes , int i ) { return inQuotes && nextLine . length ( ) > ( i + 1 ) && nextLine . charAt ( i + 1 ) == quotechar ; } 
public String getBackgroundImage ( ) { return getAttributeAsString ( "backgroundImage" ) ; } 
public String getXmlVersion ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return version ; } 
public double getDouble ( String key ) throws JSONException { Object o = get ( key ) ; if ( o == null ) return 0 ; try { if ( o instanceof Number ) { return ( ( Number ) o ) . doubleValue ( ) ; } else if ( o . toString ( ) . length ( ) > 0 ) { return Double . valueOf ( ( o . toString ( ) ) ) ; } else return 0 ; } catch ( Exception e ) { throw new JSONException ( "JSONObject[" + quote ( key ) + "]-is-not-a-number." ) ; } } 
public String getRandomMessage ( ) { Random random = new Random ( ) ; return messages . get ( random . nextInt ( messages . size ( ) ) - 1 ) ; } 
public boolean isValueForbidden ( int value ) { if ( forbiddenValues . contains ( value ) ) { return true ; } for ( Integer [ ] range : forbiddenRanges ) { if ( value >= range [ 0 ] && value <= range [ 1 ] ) { return true ; } } return false ; } 
public static boolean equals ( double x , double y , int maxUlps ) { long xInt = Double . doubleToLongBits ( x ) ; long yInt = Double . doubleToLongBits ( y ) ; if ( xInt < 0 ) { xInt = SGN_MASK - xInt ; } if ( yInt < 0 ) { yInt = SGN_MASK - yInt ; } final boolean isEqual = FastMath . abs ( xInt - yInt ) <= maxUlps ; return isEqual && ! Double . isNaN ( x ) && ! Double . isNaN ( y ) ; } 
protected void paintText ( Graphics g , JMenuItem menuItem , Rectangle textRect , String text ) { ButtonModel model = menuItem . getModel ( ) ; FontMetrics fm = SwingUtilities2 . getFontMetrics ( menuItem , g ) ; int mnemIndex = menuItem . getDisplayedMnemonicIndex ( ) ; if ( ! model . isEnabled ( ) ) { if ( UIManager . get ( "MenuItem.disabledForeground" ) instanceof Color ) { g . setColor ( UIManager . getColor ( "MenuItem.disabledForeground" ) ) ; SwingUtilities2 . drawStringUnderlineCharAt ( menuItem , g , text , mnemIndex , textRect . x , textRect . y + fm . getAscent ( ) ) ; } else { g . setColor ( menuItem . getBackground ( ) . brighter ( ) ) ; SwingUtilities2 . drawStringUnderlineCharAt ( menuItem , g , text , mnemIndex , textRect . x , textRect . y + fm . getAscent ( ) ) ; g . setColor ( menuItem . getBackground ( ) . darker ( ) ) ; SwingUtilities2 . drawStringUnderlineCharAt ( menuItem , g , text , mnemIndex , textRect . x - 1 , textRect . y + fm . getAscent ( ) - 1 ) ; } } else { if ( model . isArmed ( ) || ( menuItem instanceof JMenu && model . isSelected ( ) ) ) { g . setColor ( selectionForeground ) ; } SwingUtilities2 . drawStringUnderlineCharAt ( menuItem , g , text , mnemIndex , textRect . x , textRect . y + fm . getAscent ( ) ) ; } } 
public SAAJResult ( String protocol ) throws SOAPException { this ( MessageFactory . newInstance ( protocol ) . createMessage ( ) ) ; } 
public List < String > getLocationNames ( ) { List < String > names = new ArrayList < String > ( ) ; for ( Location l : this . locations ) { names . add ( l . getName ( ) ) ; } return names ; } 
public boolean isAdjacent ( double [ ] coordinate , double radius ) { return ( ! Entity . collides ( coordinate , radius , this ) ) && Entity . collides ( coordinate , radius * 1.1 , this ) ; } 
public static void copy ( Reader input , OutputStream output ) throws IOException { OutputStreamWriter out = new OutputStreamWriter ( output ) ; copy ( input , out ) ; out . flush ( ) ; } 
public static SourceLineAnnotation fromVisitedInstruction ( JavaClass jclass , Method method , int pc ) { LineNumberTable lineNumberTable = method . getCode ( ) . getLineNumberTable ( ) ; String className = jclass . getClassName ( ) ; String sourceFile = jclass . getSourceFileName ( ) ; if ( lineNumberTable == null ) return createUnknown ( className , sourceFile , pc , pc ) ; int startLine = lineNumberTable . getSourceLine ( pc ) ; return new SourceLineAnnotation ( className , sourceFile , startLine , startLine , pc , pc ) ; } 
public boolean hasText ( ) { return ( text != null && text . length ( ) > 0 ) ; } 
private synchronized void setState ( int state ) { if ( D ) Log . d ( TAG , "setState()-" + mState + "-->-" + state ) ; mState = state ; mHandler . obtainMessage ( GestureSpeaker . MESSAGE_STATE_CHANGE , state , - 1 ) . sendToTarget ( ) ; } 
public Item getItemById ( String id ) { EList < Item > items = opfPackage . getManifest ( ) . getItems ( ) ; for ( Item item : items ) { if ( item . getId ( ) . equals ( id ) ) { return item ; } } return null ; } 
public Map capabilities ( ) throws MessagingException { Map c ; synchronized ( this ) { c = capabilities ; } if ( c != null ) return Collections . unmodifiableMap ( c ) ; else return Collections . EMPTY_MAP ; } 
private void waitForStages ( HashMap < String , StageExecutionStatus > runningStages , final HashMap < String , StageExecutionStatus > completedStages ) throws InterruptedException , ExecutionException { long delay = 1 ; while ( runningStages . size ( ) > 0 ) { synchronized ( this ) { for ( String name : runningStages . keySet ( ) ) { StageExecutionStatus status = runningStages . get ( name ) ; if ( status . isDone ( ) ) { List < Exception > exceptions = status . getExceptions ( ) ; System . err . format ( "Stage-%s-completed-with-%d-errors.-" , name , exceptions . size ( ) ) ; if ( exceptions . size ( ) > 0 ) { for ( Exception e : exceptions ) { System . err . println ( e . toString ( ) ) ; } throw new RuntimeException ( "Stage-threw-an-exception:-" , exceptions . get ( 0 ) ) ; } completedStages . put ( name , status ) ; runningStages . remove ( name ) ; return ; } } } delay = Math . min ( delay * 2 , 10000 ) ; poll ( ) ; Thread . sleep ( delay ) ; } } 
public int getSize ( ) { return fElements . size ( ) ; } 
public final Collection < ? extends Certificate > getCertificates ( CertSelector selector ) throws CertStoreException { return storeSpi . engineGetCertificates ( selector ) ; } 
public Frame copy ( ) { Frame frame = new Frame ( locals . length , stack . length ) ; System . arraycopy ( locals , 0 , frame . locals , 0 , locals . length ) ; System . arraycopy ( stack , 0 , frame . stack , 0 , stack . length ) ; frame . top = top ; return frame ; } 
static void drawFlush3DBorder ( Graphics g , int x , int y , int w , int h ) { g . translate ( x , y ) ; g . setColor ( MetalLookAndFeel . getControlDarkShadow ( ) ) ; g . drawRect ( 0 , 0 , w - 2 , h - 2 ) ; g . setColor ( MetalLookAndFeel . getControlHighlight ( ) ) ; g . drawRect ( 1 , 1 , w - 2 , h - 2 ) ; g . setColor ( MetalLookAndFeel . getControl ( ) ) ; g . drawLine ( 0 , h - 1 , 1 , h - 2 ) ; g . drawLine ( w - 1 , 0 , w - 2 , 1 ) ; g . translate ( - x , - y ) ; } 
protected List < String > parseRobotsTxt ( InputStream is ) throws IOException { List < String > disallows = new ArrayList < > ( ) ; BufferedReader r = new BufferedReader ( new InputStreamReader ( is , StandardCharsets . UTF_8 ) ) ; String l ; while ( ( l = r . readLine ( ) ) != null ) { String [ ] arr = l . split ( "#" ) ; if ( arr . length == 0 ) continue ; l = arr [ 0 ] . trim ( ) ; if ( l . startsWith ( DISALLOW ) ) { l = l . substring ( DISALLOW . length ( ) ) . trim ( ) ; if ( l . length ( ) == 0 ) continue ; disallows . add ( l ) ; } } is . close ( ) ; return disallows ; } 
public String getPollPathByName ( String name ) { return filesDirectory + "/" + pollsOnDisk . get ( name ) ; } 
@ Support ( { ASE , CUBRID , DB2 , DERBY , FIREBIRD , H2 , HSQLDB , INGRES , MYSQL , ORACLE , POSTGRES , SQLSERVER , SYBASE } ) public static Field < BigDecimal > atan ( Field < ? extends Number > field ) { return function ( "atan" , SQLDataType . NUMERIC , nullSafe ( field ) ) ; } 
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj instanceof LocalDateTime ) { LocalDateTime other = ( LocalDateTime ) obj ; return date . equals ( other . date ) && time . equals ( other . time ) ; } return false ; } 
public static final String fileNameFromGeneration ( String base , String ext , long gen ) { if ( gen == SegmentInfo . NO ) { return null ; } else if ( gen == SegmentInfo . WITHOUT_GEN ) { return segmentFileName ( base , ext ) ; } else { StringBuilder res = new StringBuilder ( base . length ( ) + 6 + ext . length ( ) ) . append ( base ) . append ( '_' ) . append ( Long . toString ( gen , Character . MAX_RADIX ) ) ; if ( ext . length ( ) > 0 ) { res . append ( '.' ) . append ( ext ) ; } return res . toString ( ) ; } } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public double distance ( double x , double y , double z ) { double dx = this . x - x ; double dy = this . y - y ; double dz = this . z - z ; return Math . sqrt ( dx * dx + dy * dy + dz * dz ) ; } 
public double nextChiSquare ( double df ) { return new ChiSquaredDistribution ( getRan ( ) , df , ChiSquaredDistribution . DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample ( ) ; } 
private String buildCookieHeader ( List < String > cookies ) { if ( cookies . size ( ) == 1 ) return cookies . get ( 0 ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookies . size ( ) ; i ++ ) { if ( i > 0 ) sb . append ( ";-" ) ; sb . append ( cookies . get ( i ) ) ; } return sb . toString ( ) ; } 
public InstructionHandle insert ( InstructionHandle ih , Instruction i ) { return insert ( ih , new InstructionList ( i ) ) ; } 
public double getMaximumExplodePercent ( ) { if ( this . dataset == null ) { return 0.0 ; } double result = 0.0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Comparable key = ( Comparable ) iterator . next ( ) ; Number explode = ( Number ) this . explodePercentages . get ( key ) ; if ( explode != null ) { result = Math . max ( result , explode . doubleValue ( ) ) ; } } return result ; } 
public void setBoolean ( Object object , boolean value ) throws IllegalAccessException , IllegalArgumentException { setZField ( object , declaringClass , type , slot , flag , TYPE_BOOLEAN , value ) ; } 
@ OneToMany ( targetEntity = ProfileElement . class , cascade = { CascadeType . ALL } ) @ JoinColumn ( name = "ELEMENTS_PROFILESTRUCTURE_HJ_0" ) public List < ProfileElement > getElements ( ) { if ( elements == null ) { elements = new ArrayList < ProfileElement > ( ) ; } return this . elements ; } 
public SocketAddress getLocalSocketAddress ( ) { if ( ! isBound ( ) ) { return null ; } return new InetSocketAddress ( getLocalAddress ( ) , getLocalPort ( ) ) ; } 
public double getCoercedValue ( double v ) { Range range = scale . getRange ( ) ; if ( range . inRange ( v ) ) return v ; else { if ( range . getUpper ( ) >= range . getLower ( ) ) return v > range . getUpper ( ) ? range . getUpper ( ) : range . getLower ( ) ; else return v > range . getLower ( ) ? range . getLower ( ) : range . getUpper ( ) ; } } 
public View findTopChildUnder ( int x , int y ) { final int childCount = mParentView . getChildCount ( ) ; for ( int i = childCount - 1 ; i >= 0 ; i -- ) { final View child = mParentView . getChildAt ( mCallback . getOrderedChildIndex ( i ) ) ; if ( x >= child . getLeft ( ) && x < child . getRight ( ) && y >= child . getTop ( ) && y < child . getBottom ( ) ) { return child ; } } return null ; } 
public String getHome ( String user ) { return ( ( String ) homes . get ( user ) ) ; } 
public void maybeShare ( Connection connection ) { executorService . submit ( connectionsCleanupCallable ) ; if ( ! connection . isSpdy ( ) ) { return ; } if ( connection . isAlive ( ) ) { synchronized ( this ) { connections . addFirst ( connection ) ; } } } 
public List < Double > getValues ( ) { if ( values == null ) { values = new ArrayList < Double > ( ) ; } return this . values ; } 
@ SuppressWarnings ( "unchecked" ) public Class < ? extends OutputFormat < ? , ? >> getOutputFormatClass ( ) throws ClassNotFoundException { return ( Class < ? extends OutputFormat < ? , ? >> ) conf . getClass ( OUTPUT_FORMAT_CLASS_ATTR , TextOutputFormat . class ) ; } 
public JTextArea addTextArea ( String name , String label , String theValue , Color background , Color foreground , int height , int width ) { JLabel lbl = new JLabel ( label + ":-" ) ; lbl . setBackground ( _background ) ; JTextArea textArea = new JTextArea ( theValue , height , width ) ; textArea . setEditable ( true ) ; textArea . setBackground ( background ) ; textArea . setForeground ( foreground ) ; QueryScrollPane textPane = new QueryScrollPane ( textArea ) ; _addPair ( name , lbl , textPane , textPane ) ; textArea . addFocusListener ( new QueryFocusListener ( this , name ) ) ; return textArea ; } 
@ Override public String getMessage ( ) { String msg = super . getMessage ( ) ; if ( detail != null ) { msg = msg + ";-" + detail . toString ( ) ; } return msg ; } 
@ SuppressWarnings ( "unchecked" ) public static < A extends Annotation > A find ( Method m , Class < A > type ) { if ( m . getDeclaredAnnotations ( ) . length > 0 ) { for ( Annotation anno : m . getDeclaredAnnotations ( ) ) { if ( type . isAssignableFrom ( anno . getClass ( ) ) ) { return ( A ) anno ; } } } return null ; } 
public List < SearchColumnEnumSelectField > getBillCountry ( ) { if ( billCountry == null ) { billCountry = new ArrayList < SearchColumnEnumSelectField > ( ) ; } return this . billCountry ; } 
public static types . Target . Builder newBuilder ( ) { return new types . Target . Builder ( ) ; } 
public static final void parseExtendedAttribute ( ProjectFile file , FieldContainer mpx , String value , FieldType mpxFieldID ) { if ( mpxFieldID != null ) { switch ( mpxFieldID . getDataType ( ) ) { case STRING : { mpx . set ( mpxFieldID , value ) ; break ; } case DATE : { mpx . set ( mpxFieldID , parseExtendedAttributeDate ( value ) ) ; break ; } case CURRENCY : { mpx . set ( mpxFieldID , parseExtendedAttributeCurrency ( value ) ) ; break ; } case BOOLEAN : { mpx . set ( mpxFieldID , parseExtendedAttributeBoolean ( value ) ) ; break ; } case NUMERIC : { mpx . set ( mpxFieldID , parseExtendedAttributeNumber ( value ) ) ; break ; } case DURATION : { mpx . set ( mpxFieldID , parseDuration ( file , null , value ) ) ; break ; } default : { break ; } } } } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
private void controlSlot ( final int num , final Account account ) { synchronized ( CTRLLOCK ) { if ( account == null ) { int was = maxFree . get ( ) ; maxFree . set ( Math . min ( Math . max ( 1 , maxFree . addAndGet ( num ) ) , totalMaxSimultanFreeDownload . get ( ) ) ) ; logger . info ( "maxFree-was-=-" + was + "-&&-maxFree-now-=-" + maxFree . get ( ) ) ; } else { int was = maxPrem . get ( ) ; maxPrem . set ( Math . min ( Math . max ( 1 , maxPrem . addAndGet ( num ) ) , account . getIntegerProperty ( "totalMaxSim" , 20 ) ) ) ; logger . info ( "maxPrem-was-=-" + was + "-&&-maxPrem-now-=-" + maxPrem . get ( ) ) ; } } } 
public void setCanceledOnTouchOutside ( boolean cancel ) { if ( cancel && ! mCancelable ) { mCancelable = true ; } mWindow . setCloseOnTouchOutside ( cancel ) ; } 
public Iterator < FormField > getFields ( ) { return Collections . unmodifiableList ( new ArrayList < FormField > ( fields ) ) . iterator ( ) ; } 
protected void setStripBytes ( int index , byte [ ] strip ) { if ( index < mStripBytes . size ( ) ) { mStripBytes . set ( index , strip ) ; } else { for ( int i = mStripBytes . size ( ) ; i < index ; i ++ ) { mStripBytes . add ( null ) ; } mStripBytes . add ( strip ) ; } } 
private static byte [ ] concat ( final byte [ ] arrayA , final byte [ ] arrayB ) { final byte [ ] result = new byte [ arrayA . length + arrayB . length ] ; System . arraycopy ( arrayA , 0 , result , 0 , arrayA . length ) ; System . arraycopy ( arrayB , 0 , result , arrayA . length , arrayB . length ) ; return result ; } 
public void stop ( ) { Enumeration en = m_listenees . keys ( ) ; while ( en . hasMoreElements ( ) ) { Object tempO = m_listenees . get ( en . nextElement ( ) ) ; if ( tempO instanceof BeanCommon ) { ( ( BeanCommon ) tempO ) . stop ( ) ; } } if ( m_buildThread != null ) { m_buildThread . interrupt ( ) ; m_buildThread . stop ( ) ; m_buildThread = null ; m_visual . setStatic ( ) ; } } 
public void indent ( int indent ) { for ( int i = 0 ; i < indent ; i ++ ) reportFile . print ( "&nbsp;" ) ; } 
public Future < Void > putAttributesAsync ( final PutAttributesRequest putAttributesRequest ) throws AmazonServiceException , AmazonClientException { return executorService . submit ( new Callable < Void > ( ) { public Void call ( ) throws Exception { putAttributes ( putAttributesRequest ) ; return null ; } } ) ; } 
public final void dump ( DataOutputStream file ) throws IOException { super . dump ( file ) ; file . writeShort ( signature_index ) ; } 
public static List < HttpCookie > parse ( String header ) { int version = guessCookieVersion ( header ) ; if ( startsWithIgnoreCase ( header , SET_COOKIE2 ) ) { header = header . substring ( SET_COOKIE2 . length ( ) ) ; } else if ( startsWithIgnoreCase ( header , SET_COOKIE ) ) { header = header . substring ( SET_COOKIE . length ( ) ) ; } List < HttpCookie > cookies = new java . util . ArrayList < HttpCookie > ( ) ; if ( version == 0 ) { HttpCookie cookie = parseInternal ( header ) ; cookie . setVersion ( 0 ) ; cookies . add ( cookie ) ; } else { List < String > cookieStrings = splitMultiCookies ( header ) ; for ( String cookieStr : cookieStrings ) { HttpCookie cookie = parseInternal ( cookieStr ) ; cookie . setVersion ( 1 ) ; cookies . add ( cookie ) ; } } return cookies ; } 
static byte [ ] passwordHashStage2 ( byte [ ] hashedPassword , byte [ ] salt ) throws NoSuchAlgorithmException { MessageDigest md = MessageDigest . getInstance ( "SHA-1" ) ; md . update ( salt , 0 , 4 ) ; md . update ( hashedPassword , 0 , SHA1_HASH_SIZE ) ; return md . digest ( ) ; } 
public synchronized void stop ( ) { if ( playthread != null && playthread . isAlive ( ) ) { playthread . stop ( ) ; } } 
public String toString ( boolean cutOfMilliseconds ) { String theString = this . getTimestamp ( ) . toString ( ) ; if ( cutOfMilliseconds ) { return theString . substring ( 0 , 19 ) ; } else { return theString ; } } 
public static Annotation makeInnerClass ( CstString name , int accessFlags ) { Annotation result = new Annotation ( INNER_CLASS_TYPE , SYSTEM ) ; Constant nameCst = ( name != null ) ? name : CstKnownNull . THE_ONE ; result . put ( new NameValuePair ( NAME_STRING , nameCst ) ) ; result . put ( new NameValuePair ( ACCESS_FLAGS_STRING , CstInteger . make ( accessFlags ) ) ) ; result . setImmutable ( ) ; return result ; } 
@ Override public boolean shouldVisit ( Page referringPage , WebURL url ) { String href = url . getURL ( ) . toLowerCase ( ) ; return ! FILTERS . matcher ( href ) . matches ( ) && href . startsWith ( "http://download.cnet.com/" ) && ! href . contains ( "?" ) && ! href . startsWith ( "http://download.cnet.com/s/" ) && ! href . startsWith ( "http://download.cnet.com/blog/" ) && ! href . startsWith ( "http://download.cnet.com/security-center/" ) ; } 
private void showFile ( final FileObject file , final String prefix ) throws Exception { StringBuffer msg = new StringBuffer ( prefix ) ; msg . append ( file . getName ( ) . getBaseName ( ) ) ; if ( file . exists ( ) ) { msg . append ( "-(" ) ; msg . append ( file . getType ( ) . getName ( ) ) ; msg . append ( ")" ) ; } else { msg . append ( "-(unknown)" ) ; } log ( msg . toString ( ) ) ; if ( file . exists ( ) ) { final String newPrefix = prefix + INDENT ; if ( file . getType ( ) . hasContent ( ) ) { final FileContent content = file . getContent ( ) ; log ( newPrefix + "Content-Length:-" + content . getSize ( ) ) ; log ( newPrefix + "Last-Modified" + new Date ( content . getLastModifiedTime ( ) ) ) ; if ( showContent ) { log ( newPrefix + "Content:" ) ; logContent ( file , newPrefix ) ; } } if ( file . getType ( ) . hasChildren ( ) ) { final FileObject [ ] children = file . getChildren ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { FileObject child = children [ i ] ; if ( recursive ) { showFile ( child , newPrefix ) ; } else { log ( newPrefix + child . getName ( ) . getBaseName ( ) ) ; } } } } } 
protected void layout ( ) { if ( layoutManager != null ) layoutManager . layout ( this ) ; } 
public synchronized Hashtable getFilterHash ( ) { if ( filterHash == null ) { filterHash = new Hashtable ( getFilters ( ) . size ( ) ) ; for ( Enumeration e = getFilters ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { Filter filter = ( Filter ) e . nextElement ( ) ; filterHash . put ( filter . getToken ( ) , filter . getValue ( ) ) ; } } return filterHash ; } 
public PDFPaint getPaint ( float [ ] components ) { float [ ] rgb = cs . toRGB ( components ) ; return PDFPaint . getColorPaint ( new Color ( rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ) ; } 
public void _write ( OutputStream output ) { output . write_short ( value ) ; } 
public List < String > getOtherInfoOnMeta ( ) { if ( otherInfoOnMeta == null ) { otherInfoOnMeta = new ArrayList < String > ( ) ; } return this . otherInfoOnMeta ; } 
private void writeObject ( java . io . ObjectOutputStream s ) throws java . io . IOException { s . defaultWriteObject ( ) ; } 
@ Override public String toString ( ) { return "Thread[" + name + "," + priority + "," + group . getName ( ) + "]" ; } 
public void set ( int fromIndex , int toIndex , boolean state ) { if ( state ) { set ( fromIndex , toIndex ) ; } else { clear ( fromIndex , toIndex ) ; } } 
public static void formatLabelAsTitle ( JLabel label ) { if ( ! SystemUtils . IS_OS_LINUX ) { label . setFont ( label . getFont ( ) . deriveFont ( 14f ) ) ; } else { label . setFont ( label . getFont ( ) . deriveFont ( Font . BOLD , 14f ) ) ; } label . setForeground ( new Color ( 35 , 107 , 178 ) ) ; } 
private int socksGetServerPort ( ) { InetSocketAddress addr = ( InetSocketAddress ) proxy . address ( ) ; return addr . getPort ( ) ; } 
private boolean available ( int n ) throws IOException { if ( ! NON_BLOCKING_INPUT ) { return true ; } throwPendingException ( ) ; if ( eofSeen || n <= dis . available ( ) ) { return true ; } new DataSucker ( this , n ) . start ( ) ; return false ; } 
public org . omg . CORBA . TypeCode _type ( ) { return ORB . init ( ) . get_primitive_tc ( TCKind . tk_double ) ; } 
public static int nextNonWhiteSpace ( String s , int start ) { if ( s . charAt ( start ) <= '-' ) { int end = s . length ( ) ; while ( ++ start < end && s . charAt ( start ) <= '-' ) { } } return start ; } 
public List < Float > getHalf4X3 ( ) { if ( half4X3 == null ) { half4X3 = new ArrayList < Float > ( ) ; } return this . half4X3 ; } 
private static File constructFilePaths ( String file1 , String file2 ) { File newPath ; if ( file2 . startsWith ( file1 ) ) { newPath = new File ( file2 ) ; } else { newPath = new File ( file1 + "/" + file2 ) ; } return newPath ; } 
@ Override public String getHostAddress ( ) { final StringBuilder hostAddress = new StringBuilder ( ) ; for ( int i = 0 ; i < 4 ; i ++ ) { hostAddress . append ( ipaddress [ i ] & 255 ) ; if ( i != 3 ) { hostAddress . append ( '.' ) ; } } return hostAddress . toString ( ) ; } 
public URLStreamHandler createURLStreamHandler ( final String protocol ) { if ( ! protocol . equals ( "http" ) && ! protocol . equals ( "https" ) ) return null ; return new URLStreamHandler ( ) { @ Override protected URLConnection openConnection ( URL url ) { return open ( url ) ; } @ Override protected URLConnection openConnection ( URL url , Proxy proxy ) { return open ( url , proxy ) ; } @ Override protected int getDefaultPort ( ) { if ( protocol . equals ( "http" ) ) return 80 ; if ( protocol . equals ( "https" ) ) return 443 ; throw new AssertionError ( ) ; } } ; } 
public void addReview ( Review theRev ) { myReviews . add ( theRev ) ; } 
static public Name formFullName ( Name name , Symbol owner ) { if ( owner == null ) return name ; if ( ( ( owner . kind != ERR ) ) && ( ( owner . kind & ( VAR | MTH ) ) != 0 || ( owner . kind == TYP && owner . type . tag == TYPEVAR ) ) ) return name ; Name prefix = owner . getQualifiedName ( ) ; if ( prefix == null || prefix == prefix . table . names . empty ) return name ; else return prefix . append ( '.' , name ) ; } 
public static File [ ] listFiles ( File dir ) throws IOException { File [ ] files = dir . listFiles ( ) ; if ( files == null ) { throw new IOException ( "Invalid-directory-or-I/O-error-occurred-for-dir:-" + dir . toString ( ) ) ; } return files ; } 
public void kill ( ) throws IOException { System . out . println ( "Killing-node-[" + address + "]" ) ; this . messages . clear ( ) ; this . messages = null ; if ( input != null && ! input . isClosed ( ) ) input . close ( ) ; if ( output != null && ! output . isClosed ( ) ) output . close ( ) ; writer . close ( ) ; } 
public static void identityToString ( StringBuffer buffer , Object object ) { if ( object == null ) { throw new NullPointerException ( "Cannot-get-the-toString-of-a-null-identity" ) ; } buffer . append ( object . getClass ( ) . getName ( ) ) . append ( '@' ) . append ( Integer . toHexString ( System . identityHashCode ( object ) ) ) ; } 
protected synchronized void enqueueKeyEvents ( long after , Component untilFocused ) { if ( untilFocused == null ) { return ; } if ( focusLog . isLoggable ( Level . FINER ) ) { focusLog . log ( Level . FINER , "Enqueue-at-{0}-for-{1}" , new Object [ ] { after , String . valueOf ( untilFocused ) } ) ; } int insertionIndex = 0 , i = typeAheadMarkers . size ( ) ; ListIterator iter = typeAheadMarkers . listIterator ( i ) ; for ( ; i > 0 ; i -- ) { TypeAheadMarker marker = ( TypeAheadMarker ) iter . previous ( ) ; if ( marker . after <= after ) { insertionIndex = i ; break ; } } typeAheadMarkers . add ( insertionIndex , new TypeAheadMarker ( after , untilFocused ) ) ; } 
private Map < String , String > createParameterMap ( String queryString ) { Map < String , String > map = new HashMap < String , String > ( ) ; String [ ] pairs = queryString . split ( "&" ) ; for ( String pair : pairs ) { if ( pair . length ( ) < 1 ) { continue ; } String [ ] tokens = pair . split ( "=" , 2 ) ; for ( int j = 0 ; j < tokens . length ; j ++ ) { try { tokens [ j ] = URLDecoder . decode ( tokens [ j ] , UTF8_CHARSET ) ; } catch ( UnsupportedEncodingException e ) { } } switch ( tokens . length ) { case 1 : { if ( pair . charAt ( 0 ) == '=' ) { map . put ( "" , tokens [ 0 ] ) ; } else { map . put ( tokens [ 0 ] , "" ) ; } break ; } case 2 : { map . put ( tokens [ 0 ] , tokens [ 1 ] ) ; break ; } } } return map ; } 
static int stringSize ( String string ) { int size = 0 ; if ( string != null ) { size += HEADERS + 4 * 4 ; size += HEADERS + 2 * string . length ( ) ; } return size ; } 
@ Override public String getMessage ( ) { if ( ! specialConstructor ) { return super . getMessage ( ) ; } StringBuffer expected = new StringBuffer ( ) ; int maxSize = 0 ; for ( int i = 0 ; i < expectedTokenSequences . length ; i ++ ) { if ( maxSize < expectedTokenSequences [ i ] . length ) { maxSize = expectedTokenSequences [ i ] . length ; } for ( int j = 0 ; j < expectedTokenSequences [ i ] . length ; j ++ ) { expected . append ( tokenImage [ expectedTokenSequences [ i ] [ j ] ] ) . append ( "-" ) ; } if ( expectedTokenSequences [ i ] [ expectedTokenSequences [ i ] . length - 1 ] != 0 ) { expected . append ( "..." ) ; } expected . append ( eol ) . append ( "-" ) ; } String retval = "Encountered-"" ; Token tok = currentToken . next ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i != 0 ) retval += "-" ; if ( tok . kind == 0 ) { retval += tokenImage [ 0 ] ; break ; } retval += add_escapes ( tok . image ) ; tok = tok . next ; } retval += ""-at-line-" + currentToken . next . beginLine + ",-column-" + currentToken . next . beginColumn ; retval += "." + eol ; if ( expectedTokenSequences . length == 1 ) { retval += "Was-expecting:" + eol + "-" ; } else { retval += "Was-expecting-one-of:" + eol + "-" ; } retval += expected . toString ( ) ; return retval ; } 
@ Override public String toString ( ) { return Integer . toString ( this . value ) ; } 
protected void append ( String s ) { BufferedWriter writer ; if ( m_LogFile == null ) return ; try { writer = new BufferedWriter ( new FileWriter ( m_LogFile , true ) ) ; writer . write ( s ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( Exception e ) { } } 
protected ResultSet executeQuery ( JDBCConfiguration conf , Connection conn , PreparedStatement stmnt , SQLBuffer buf ) throws SQLException { return stmnt . executeQuery ( ) ; } 
private void setColUpdated ( int idx ) { colsChanged . set ( idx ) ; } 
@ XmlElementDecl ( namespace = "http://www.fortify.com/schema/fws" , name = "MyAlertDefinitionsListRequest" ) public JAXBElement < Object > createMyAlertDefinitionsListRequest ( Object value ) { return new JAXBElement < Object > ( _MyAlertDefinitionsListRequest_QNAME , Object . class , null , value ) ; } 
public String toString ( ) { StringBuffer buf = new StringBuffer ( 32 ) ; switch ( this . eventType ) { case TYPE_EXECUTE : buf . append ( "EXECUTE" ) ; break ; case TYPE_FETCH : buf . append ( "FETCH" ) ; break ; case TYPE_OBJECT_CREATION : buf . append ( "CONSTRUCT" ) ; break ; case TYPE_PREPARE : buf . append ( "PREPARE" ) ; break ; case TYPE_QUERY : buf . append ( "QUERY" ) ; break ; case TYPE_WARN : buf . append ( "WARN" ) ; break ; case TYPE_SLOW_QUERY : buf . append ( "SLOW-QUERY" ) ; break ; default : buf . append ( "UNKNOWN" ) ; } buf . append ( "-created:-" ) ; buf . append ( new Date ( this . eventCreationTime ) ) ; buf . append ( "-duration:-" ) ; buf . append ( this . eventDuration ) ; buf . append ( "-connection:-" ) ; buf . append ( this . connectionId ) ; buf . append ( "-statement:-" ) ; buf . append ( this . statementId ) ; buf . append ( "-resultset:-" ) ; buf . append ( this . resultSetId ) ; if ( this . message != null ) { buf . append ( "-message:-" ) ; buf . append ( this . message ) ; } if ( this . eventCreationPointDesc != null ) { buf . append ( "-Event-Created-at:-" ) ; buf . append ( this . eventCreationPointDesc ) ; } return buf . toString ( ) ; } 
public static void saveChartAsPNG ( File file , JFreeChart chart , int width , int height , ChartRenderingInfo info , boolean encodeAlpha , int compression ) throws IOException { if ( file == null ) { throw new IllegalArgumentException ( "Null-'file'-argument." ) ; } if ( chart == null ) { throw new IllegalArgumentException ( "Null-'chart'-argument." ) ; } OutputStream out = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; try { writeChartAsPNG ( out , chart , width , height , info , encodeAlpha , compression ) ; } finally { out . close ( ) ; } } 
public void configure ( JobConf job ) { destPath = new Path ( job . get ( DST_DIR_LABEL , "/" ) ) ; try { destFileSys = destPath . getFileSystem ( job ) ; } catch ( IOException ex ) { throw new RuntimeException ( "Unable-to-get-the-named-file-system." , ex ) ; } sizeBuf = job . getInt ( "copy.buf.size" , 128 * 1024 ) ; buffer = new byte [ sizeBuf ] ; ignoreReadFailures = job . getBoolean ( Options . IGNORE_READ_FAILURES . propertyname , false ) ; preserve_status = job . getBoolean ( Options . PRESERVE_STATUS . propertyname , false ) ; if ( preserve_status ) { preseved = FileAttribute . parse ( job . get ( PRESERVE_STATUS_LABEL ) ) ; } update = job . getBoolean ( Options . UPDATE . propertyname , false ) ; overwrite = ! update && job . getBoolean ( Options . OVERWRITE . propertyname , false ) ; skipCRCCheck = job . getBoolean ( Options . SKIPCRC . propertyname , false ) ; this . job = job ; } 
boolean compareStateFile ( ParcelFileDescriptor oldState ) { FileInputStream instream = new FileInputStream ( oldState . getFileDescriptor ( ) ) ; DataInputStream in = new DataInputStream ( instream ) ; try { int stateVersion = in . readInt ( ) ; if ( stateVersion > AGENT_VERSION ) { return true ; } int lastFilling = in . readInt ( ) ; boolean lastMayo = in . readBoolean ( ) ; boolean lastTomato = in . readBoolean ( ) ; return ( lastFilling != mFilling ) || ( lastTomato != mAddTomato ) || ( lastMayo != mAddMayo ) ; } catch ( IOException e ) { return true ; } } 
@ Override public Enumeration < String > enumerateRequests ( ) { Vector < String > newVector = new Vector < String > ( 0 ) ; if ( m_executorPool != null && ( m_executorPool . getQueue ( ) . size ( ) > 0 || m_executorPool . getActiveCount ( ) > 0 ) ) { newVector . addElement ( "Stop" ) ; } if ( ( m_executorPool == null || ( m_executorPool . getQueue ( ) . size ( ) == 0 && m_executorPool . getActiveCount ( ) == 0 ) ) && m_Classifier != null ) { newVector . addElement ( "Save-model" ) ; } if ( m_executorPool == null || ( m_executorPool . getQueue ( ) . size ( ) == 0 && m_executorPool . getActiveCount ( ) == 0 ) ) { newVector . addElement ( "Load-model" ) ; } return newVector . elements ( ) ; } 
public static byte [ ] decodeWebSafe ( byte [ ] source , int off , int len ) throws Base64DecoderException { return decode ( source , off , len , WEBSAFE_DECODABET ) ; } 
private static void writeWorkspaceVersion ( ) { Location instanceLoc = Platform . getInstanceLocation ( ) ; if ( instanceLoc == null || instanceLoc . isReadOnly ( ) ) { return ; } File versionFile = getVersionFile ( instanceLoc . getURL ( ) , true ) ; if ( versionFile == null ) { return ; } OutputStream output = null ; try { String versionLine = WORKSPACE_VERSION_KEY + '=' + WORKSPACE_VERSION_VALUE ; output = new FileOutputStream ( versionFile ) ; output . write ( versionLine . getBytes ( "UTF-8" ) ) ; } catch ( IOException e ) { Logger logger = new WorkbenchLogger ( PLUGIN_ID ) ; logger . error ( e ) ; } finally { try { if ( output != null ) { output . close ( ) ; } } catch ( IOException e ) { } } } 
public synchronized void addReproductionOperator ( ReproductionOperator a_operatorToAdd ) throws InvalidConfigurationException { verifyChangesAllowed ( ) ; if ( a_operatorToAdd == null ) throw new InvalidConfigurationException ( "ReproductionOperator-instance-may-not-be-null." ) ; reproductionOperators . add ( a_operatorToAdd ) ; } 
private void loadFromDB ( Connection conn ) throws SQLException { String querySRS = "SELECT-coordsys_name,-organization,-organization_coordsys_id,-" + "-definition" + "-FROM-db2gse.st_spatial_reference_systems" + "-WHERE-srs_id-=-" + this . srsId ; Statement stmt = conn . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( querySRS ) ; if ( rs . next ( ) ) { this . coordsysName = rs . getString ( 1 ) ; this . organization = rs . getString ( 2 ) ; this . coordsysId = rs . getInt ( 3 ) ; this . definition = rs . getString ( 4 ) ; } else { throw new SQLException ( "Unrecognized-srid-'" + this . srsId + "'" ) ; } rs . close ( ) ; stmt . close ( ) ; } 
public final V accumulateAndGet ( V x , BinaryOperator < V > accumulatorFunction ) { V prev , next ; do { prev = get ( ) ; next = accumulatorFunction . apply ( prev , x ) ; } while ( ! compareAndSet ( prev , next ) ) ; return next ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public Long getLong ( AttributeInfo attribute ) { return System . currentTimeMillis ( ) ; } 
protected void updatePicture ( int frameNum ) { if ( images [ frameNumber ] == null ) { images [ frameNumber ] = createImageIcon ( "images/doggy/T" + frameNumber + ".gif" ) ; } if ( images [ frameNumber ] != null ) { picture . setIcon ( images [ frameNumber ] ) ; } else { picture . setText ( "image-#" + frameNumber + "-not-found" ) ; } } 
private void loadActivitiesLocked ( ) { mActivites . clear ( ) ; if ( mIntent != null ) { List < ResolveInfo > resolveInfos = mContext . getPackageManager ( ) . queryIntentActivities ( mIntent , 0 ) ; final int resolveInfoCount = resolveInfos . size ( ) ; for ( int i = 0 ; i < resolveInfoCount ; i ++ ) { ResolveInfo resolveInfo = resolveInfos . get ( i ) ; mActivites . add ( new ActivityResolveInfo ( resolveInfo ) ) ; } sortActivities ( ) ; } else { notifyChanged ( ) ; } } 
private static File constructFilePaths ( String file1 , String file2 ) { File newPath ; if ( file2 . startsWith ( file1 ) ) { newPath = new File ( file2 ) ; } else { newPath = new File ( file1 + "/" + file2 ) ; } return newPath ; } 
public Collection < Compartment > getUsedCompartments ( ) { return Collections . unmodifiableCollection ( usedCompartments ) ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public boolean equals ( Object other ) { if ( this == other ) { return true ; } if ( other instanceof CertPath ) { CertPath o = ( CertPath ) other ; if ( getType ( ) . equals ( o . getType ( ) ) ) { if ( getCertificates ( ) . equals ( o . getCertificates ( ) ) ) { return true ; } } } return false ; } 
private static void processNetwork ( ShowInfo showInfo , Element eShowInfo ) { NodeList nlNetwork = eShowInfo . getElementsByTagName ( "network" ) ; for ( int nodeLoop = 0 ; nodeLoop < nlNetwork . getLength ( ) ; nodeLoop ++ ) { Node nShowInfo = nlNetwork . item ( nodeLoop ) ; if ( nShowInfo . getNodeType ( ) == Node . ELEMENT_NODE ) { Element eNetwork = ( Element ) nShowInfo ; CountryDetail newNetwork = new CountryDetail ( ) ; newNetwork . setCountry ( eNetwork . getAttribute ( "country" ) ) ; newNetwork . setDetail ( eNetwork . getTextContent ( ) ) ; showInfo . addNetwork ( newNetwork ) ; } } } 
private Long getMessageId ( MessageContext messageContext ) { Long id = null ; id = ( Long ) messageContext . getProperty ( SOAPMonitorConstants . SOAP_MONITOR_ID ) ; return id ; } 
public static String convertToRGB ( int color ) { String red = Integer . toHexString ( Color . red ( color ) ) ; String green = Integer . toHexString ( Color . green ( color ) ) ; String blue = Integer . toHexString ( Color . blue ( color ) ) ; if ( red . length ( ) == 1 ) { red = "0" + red ; } if ( green . length ( ) == 1 ) { green = "0" + green ; } if ( blue . length ( ) == 1 ) { blue = "0" + blue ; } return "#" + red + green + blue ; } 
private static boolean hasProtocol ( String systemId ) { return systemId != null && HAS_PROTOCOL . matcher ( systemId ) . find ( ) ; } 
public final void addAction ( String action ) { if ( ! mActions . contains ( action ) ) { mActions . add ( action . intern ( ) ) ; } } 
public static void setNodeText ( Node n , String s ) { if ( n == null || s == null || s . length ( ) == 0 ) { System . err . println ( "An-argument-is-null" ) ; return ; } if ( n . getNodeType ( ) == Node . TEXT_NODE ) { n . setNodeValue ( s ) ; return ; } NodeList nl = n . getChildNodes ( ) ; for ( int i = 0 ; i < nl . getLength ( ) ; i ++ ) { Node cn = nl . item ( i ) ; if ( cn == null ) continue ; if ( cn . getNodeType ( ) == Node . TEXT_NODE ) { cn . setNodeValue ( s ) ; break ; } } } 
public static String chompLast ( String str , String sep ) { if ( str . length ( ) == 0 ) { return str ; } String sub = str . substring ( str . length ( ) - sep . length ( ) ) ; if ( sep . equals ( sub ) ) { return str . substring ( 0 , str . length ( ) - sep . length ( ) ) ; } else { return str ; } } 
public String nextValue ( ) { return iterator . next ( ) ; } 
public static Type getNullType ( ) { return NullType . instance ( ) ; } 
protected void saveNumFrequentsFromCursor ( Cursor cursor ) { mNumFrequents = cursor . getCount ( ) - mNumStarred ; } 
public void checkScheme ( URI uri , String supportedScheme ) { String scheme = uri . getScheme ( ) ; if ( scheme == null ) { throw new HadoopIllegalArgumentException ( "Uri-without-scheme:-" + uri ) ; } if ( ! scheme . equals ( supportedScheme ) ) { throw new HadoopIllegalArgumentException ( "Uri-scheme-" + uri + "-does-not-match-the-scheme-" + supportedScheme ) ; } } 
public JavaClass loadClass ( Class clazz ) throws ClassNotFoundException { String className = clazz . getName ( ) ; String name = className ; int i = name . lastIndexOf ( '.' ) ; if ( i > 0 ) { name = name . substring ( i + 1 ) ; } return loadClass ( clazz . getResourceAsStream ( name + ".class" ) , className ) ; } 
public java . lang . Integer save ( com . liveneo . plat . hibernate . dao . KbmsClass kbmsClass ) { return ( java . lang . Integer ) super . save ( kbmsClass ) ; } 
public static int toTitleCase ( int codePoint ) { return toTitleCaseImpl ( codePoint ) ; } 
public String toString ( ) { return toXMLFormat ( ) ; } 
public void removeWindow ( View view ) { mWindowsLock . writeLock ( ) . lock ( ) ; try { mWindows . remove ( view . getRootView ( ) ) ; } finally { mWindowsLock . writeLock ( ) . unlock ( ) ; } fireWindowsChangedEvent ( ) ; } 
public int getMetaFromState ( IBlockState state ) { int var2 = 0 ; if ( ( ( Boolean ) state . getValue ( field_176293_a ) ) . booleanValue ( ) ) { var2 |= 1 ; } if ( ( ( Boolean ) state . getValue ( field_176290_b ) ) . booleanValue ( ) ) { var2 |= 2 ; } if ( ( ( Boolean ) state . getValue ( field_176294_M ) ) . booleanValue ( ) ) { var2 |= 4 ; } if ( ( ( Boolean ) state . getValue ( field_176295_N ) ) . booleanValue ( ) ) { var2 |= 8 ; } return var2 ; } 
public double getValue ( ) throws JMException { Class cls = java . lang . String . class ; String name = cls . getName ( ) ; Configuration . logger_ . severe ( "Class-" + name + "-does-not-implement-" + "method-getValue" ) ; throw new JMException ( "Exception-in-" + name + ".getValue()" ) ; } 
Edge ( int startPos , Terminal head ) { this . startPos = startPos ; this . endPos = startPos + 1 ; this . head = head ; this . body = new Category [ 0 ] ; this . externalAnteList = new Category [ 0 ] ; this . internalAnteList = new Category [ 0 ] ; this . annotation = new Annotation ( ) ; this . scopeclosing = false ; this . links = new ArrayList < Edge > ( ) ; } 
protected void copySourceStream ( InputStream in , byte [ ] buffer ) throws IOException , InterruptedException { int read ; while ( ( read = in . read ( buffer ) ) != - 1 && ! getAudioBuffer ( ) . isClosed ( ) ) { getAudioBuffer ( ) . addChunk ( buffer , 0 , read ) ; } in . close ( ) ; } 
public static float min ( float f1 , float f2 ) { if ( f1 > f2 ) return f2 ; if ( f1 < f2 ) return f1 ; if ( f1 != f2 ) return Float . NaN ; if ( f1 == 0.0f && ( ( Float . floatToIntBits ( f1 ) | Float . floatToIntBits ( f2 ) ) & 0x80000000 ) != 0 ) return 0.0f * ( - 1.0f ) ; return f1 ; } 
public void mark ( int readAheadLimit ) throws IOException { fInputStream . mark ( readAheadLimit ) ; } 
public void setDataset ( File value ) { if ( ! value . exists ( ) ) throw new IllegalArgumentException ( "Dataset-'" + value . getAbsolutePath ( ) + "'-does-not-exist!" ) ; else m_Dataset = value ; } 
protected void unconfigureEnclosingScrollPane ( ) { Container p = getParent ( ) ; if ( p instanceof JViewport ) { Container gp = p . getParent ( ) ; if ( gp instanceof JScrollPane ) { JScrollPane scrollPane = ( JScrollPane ) gp ; JViewport viewport = scrollPane . getViewport ( ) ; if ( viewport == null || viewport . getView ( ) != this ) { return ; } scrollPane . setColumnHeaderView ( null ) ; Component corner = scrollPane . getCorner ( JScrollPane . UPPER_TRAILING_CORNER ) ; if ( corner instanceof UIResource ) { scrollPane . setCorner ( JScrollPane . UPPER_TRAILING_CORNER , null ) ; } } } } 
public Map < String , Object > toMap ( ) { return toMap ( DEFAULT_MAX_COLS ) ; } 
public void sort ( ArrayList < Value [ ] > rows , int offset , int limit ) { int rowsSize = rows . size ( ) ; if ( rows . isEmpty ( ) || offset >= rowsSize || limit == 0 ) { return ; } if ( offset < 0 ) { offset = 0 ; } if ( offset + limit > rowsSize ) { limit = rowsSize - offset ; } if ( limit == 1 && offset == 0 ) { rows . set ( 0 , Collections . min ( rows , this ) ) ; return ; } Value [ ] [ ] arr = rows . toArray ( new Value [ rowsSize ] [ ] ) ; Utils . sortTopN ( arr , offset , limit , this ) ; for ( int i = 0 , end = Math . min ( offset + limit , rowsSize ) ; i < end ; i ++ ) { rows . set ( i , arr [ i ] ) ; } } 
private String getUsernamePassword ( HttpServletRequest request ) { try { String authHeader = request . getHeader ( "Authorization" ) ; if ( authHeader != null ) { StringTokenizer st = new StringTokenizer ( authHeader ) ; if ( st . hasMoreTokens ( ) ) { String basic = st . nextToken ( ) ; if ( basic . equalsIgnoreCase ( "Basic" ) ) { String credentials = st . nextToken ( ) ; String userPass = new String ( Base64 . decodeBase64 ( credentials . getBytes ( ) ) ) ; return userPass ; } } } } catch ( Exception e ) { log . debug ( e . toString ( ) ) ; } return null ; } 
public double getSignificance ( ) throws MathException { return 2d * ( 1.0 - distribution . cumulativeProbability ( Math . abs ( getSlope ( ) ) / getSlopeStdErr ( ) ) ) ; } 
static void deleteContents ( File dir ) throws IOException { File [ ] files = dir . listFiles ( ) ; if ( files == null ) { throw new IOException ( "not-a-readable-directory:-" + dir ) ; } for ( File file : files ) { if ( file . isDirectory ( ) ) { deleteContents ( file ) ; } if ( ! file . delete ( ) ) { throw new IOException ( "failed-to-delete-file:-" + file ) ; } } } 
public final void addIdleHandler ( IdleHandler handler ) { if ( handler == null ) { throw new NullPointerException ( "Can't-add-a-null-IdleHandler" ) ; } synchronized ( this ) { mIdleHandlers . add ( handler ) ; } } 
public Integer evaluate ( List < Integer > data ) { if ( data == null || data . size ( ) == 0 ) { return null ; } int sum = 0 ; for ( Integer d : data ) { sum += d ; } return sum ; } 
private void removeLastEntry ( ) { Entry entry = ( Entry ) indexToEntry . remove ( size ( ) - 1 ) ; keyToEntry . remove ( entry . key ) ; } 
public void setProxyPort ( int proxyPort ) { this . proxyPort = Configuration . getProxyPort ( proxyPort ) ; } 
private static String booleanParameter ( boolean value ) { return Boolean . valueOf ( value ) . toString ( ) . toUpperCase ( ) ; } 
public void write ( byte b [ ] , int off , int len ) { if ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) > b . length ) || ( ( off + len ) < 0 ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len == 0 ) { return ; } int newcount = count + len ; if ( newcount > buf . length ) { buf = Utils . copyOf ( buf , Math . max ( buf . length << 1 , newcount ) ) ; } System . arraycopy ( b , off , buf , count , len ) ; count = newcount ; } 
public void moveToPosition ( final List < T > objects , final Map < Integer , T > positionToObjects ) { for ( final T o : positionToObjects . values ( ) ) { objects . remove ( o ) ; } for ( final Map . Entry < Integer , T > entry : positionToObjects . entrySet ( ) ) { objects . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } } 
public long roundTripTime ( long timeout , TimeUnit unit ) throws InterruptedException { if ( latch . await ( timeout , unit ) ) { return received - sent ; } else { return - 2 ; } } 
public void setGlassPane ( final Component glassPane ) { getRootPane ( ) . setGlassPane ( glassPane ) ; } 
public void setCurve ( double [ ] coords , int offset ) { setCurve ( coords [ offset + 0 ] , coords [ offset + 1 ] , coords [ offset + 2 ] , coords [ offset + 3 ] , coords [ offset + 4 ] , coords [ offset + 5 ] ) ; } 
public boolean isInitialized ( ) { return isOctetStream ( ) || isNodeSet ( ) ; } 
public void paint ( Graphics a , JComponent b ) { for ( int i = 0 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . paint ( a , b ) ; } } 
private void handleResponsePacket ( DatagramPacket packet ) { String strPacket = new String ( packet . getData ( ) , 0 , packet . getLength ( ) ) ; String tokens [ ] = strPacket . trim ( ) . split ( "|s+" ) ; if ( tokens . length != 3 ) { Log . w ( LOG_TAG , "Malformed-response:-expected-3-tokens,-got-" + tokens . length ) ; return ; } BroadcastAdvertisement advert ; try { String serviceType = tokens [ 0 ] ; if ( ! serviceType . equals ( DESIRED_SERVICE ) ) { return ; } String serviceName = tokens [ 1 ] ; int port = Integer . parseInt ( tokens [ 2 ] ) ; InetAddress addr = packet . getAddress ( ) ; Log . v ( LOG_TAG , "Broadcast-response:-" + serviceName + ",-" + addr + ",-" + port ) ; advert = new BroadcastAdvertisement ( serviceName , addr , port ) ; } catch ( NumberFormatException e ) { return ; } Message message = mHandler . obtainMessage ( DeviceFinder . BROADCAST_RESPONSE , advert ) ; mHandler . sendMessage ( message ) ; } 
private String getDescAttribute ( ) { if ( mXmlNode != null && mXmlNode instanceof Element && mXmlNode . hasAttributes ( ) ) { Element elem = ( Element ) mXmlNode ; String attr = _Element_getAttributeNS ( elem , SdkConstants . NS_RESOURCES , AndroidManifestDescriptors . ANDROID_NAME_ATTR ) ; if ( attr == null || attr . length ( ) == 0 ) { attr = _Element_getAttributeNS ( elem , SdkConstants . NS_RESOURCES , AndroidManifestDescriptors . ANDROID_LABEL_ATTR ) ; } else if ( mXmlNode . getNodeName ( ) . equals ( SdkConstants . VIEW_FRAGMENT ) ) { attr = attr . substring ( attr . lastIndexOf ( '.' ) + 1 ) ; } if ( attr == null || attr . length ( ) == 0 ) { attr = _Element_getAttributeNS ( elem , SdkConstants . NS_RESOURCES , OtherXmlDescriptors . PREF_KEY_ATTR ) ; } if ( attr == null || attr . length ( ) == 0 ) { attr = _Element_getAttributeNS ( elem , null , SdkConstants . ATTR_NAME ) ; } if ( attr == null || attr . length ( ) == 0 ) { attr = _Element_getAttributeNS ( elem , SdkConstants . NS_RESOURCES , SdkConstants . ATTR_ID ) ; if ( attr != null && attr . length ( ) > 0 ) { for ( String prefix : ID_PREFIXES ) { if ( attr . startsWith ( prefix ) ) { attr = attr . substring ( prefix . length ( ) ) ; break ; } } } } if ( attr != null && attr . length ( ) > 0 ) { return attr ; } } return null ; } 
public MBeanNotificationInfo [ ] getNotifications ( ) { MBeanNotificationInfo [ ] ns = nonNullNotifications ( ) ; if ( ns . length == 0 ) return ns ; else return ns . clone ( ) ; } 
private static CRL getCRL ( byte [ ] encoding ) throws CRLException , IOException { if ( encoding . length < CRL_CACHE_SEED_LENGTH ) { throw new CRLException ( "encoding.length-<-CRL_CACHE_SEED_LENGTH" ) ; } synchronized ( CRL_CACHE ) { long hash = CRL_CACHE . getHash ( encoding ) ; if ( CRL_CACHE . contains ( hash ) ) { X509CRL res = ( X509CRL ) CRL_CACHE . get ( hash , encoding ) ; if ( res != null ) { return res ; } } X509CRL res = new X509CRLImpl ( encoding ) ; CRL_CACHE . put ( hash , encoding , res ) ; return res ; } } 
private static String toUnicodeLowerCase ( String s ) { int n = s . length ( ) ; char [ ] result = new char [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { result [ i ] = Character . toLowerCase ( s . charAt ( i ) ) ; } return new String ( result ) ; } 
@ XmlElementDecl ( namespace = "http://model.amani.com" , name = "name" , scope = Designer . class ) public JAXBElement < String > createDesignerName ( String value ) { return new JAXBElement < String > ( _StaffHairDesignerInfoName_QNAME , String . class , Designer . class , value ) ; } 
public Float evaluate ( float fraction , Number startValue , Number endValue ) { float startFloat = startValue . floatValue ( ) ; return startFloat + fraction * ( endValue . floatValue ( ) - startFloat ) ; } 
public static void closeQuietly ( ServerSocket serverSocket ) { if ( serverSocket != null ) { try { serverSocket . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } 
public static void PrintTrace ( Throwable p_throwableObj ) { try { if ( p_throwableObj != null ) { StackTraceElement [ ] l_elements = p_throwableObj . getStackTrace ( ) ; int lineCount = Math . min ( LOG_LEVEL , l_elements . length ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( "TRACE:-" ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { sb . append ( l_elements [ i ] ) ; } sb . append ( TRACE_LOG_FINISH ) ; m_stackLogger . info ( sb . toString ( ) ) ; } } catch ( Exception e ) { System . err . println ( "This-is-an-irony.-An-error-within-an-error." ) ; Fatal ( Log . class , "This-is-an-irony.-An-error-within-an-error." ) ; System . exit ( 2 ) ; } } 
public static Integer getMaximumSearchResults ( ) { try { return Integer . valueOf ( Context . getAdministrationService ( ) . getGlobalProperty ( OpenmrsConstants . GLOBAL_PROPERTY_PERSON_SEARCH_MAX_RESULTS , String . valueOf ( OpenmrsConstants . GLOBAL_PROPERTY_PERSON_SEARCH_MAX_RESULTS_DEFAULT_VALUE ) ) ) ; } catch ( Exception e ) { log . warn ( "Unable-to-convert-the-global-property-" + OpenmrsConstants . GLOBAL_PROPERTY_PERSON_SEARCH_MAX_RESULTS + "to-a-valid-integer.-Returning-the-default-" + OpenmrsConstants . GLOBAL_PROPERTY_PERSON_SEARCH_MAX_RESULTS_DEFAULT_VALUE ) ; } return OpenmrsConstants . GLOBAL_PROPERTY_PERSON_SEARCH_MAX_RESULTS_DEFAULT_VALUE ; } 
public int getPosition ( T item ) { return mObjects . indexOf ( item ) ; } 
private synchronized void release ( SelectorInfo info ) { long now = System . currentTimeMillis ( ) ; trimIdleSelectors ( now ) ; info . lastActivityTime = now ; info . queue . addLast ( info ) ; } 
protected List < T > getObjects ( ContextDb db , C fromKey , C toKey ) throws ApplicationException { CacheKey < C > fromCk ; CacheKey < C > toCk ; try { fromCk = new CacheKey < C > ( db , fromKey ) ; toCk = new CacheKey < C > ( db , toKey ) ; } catch ( ApplicationException e ) { logInvalidKey ( e ) ; return null ; } Set < Map . Entry < CacheKey < C > , T >> entries = cacheMap . subMap ( fromCk , toCk ) . entrySet ( ) ; List < T > list = new ArrayList < T > ( ) ; for ( Map . Entry < CacheKey < C > , T > entry : entries ) { CacheKey < C > ck = entry . getKey ( ) ; T object = entry . getValue ( ) ; assertKeyIsUnchanged ( object , entry . getKey ( ) ) ; list . add ( object ) ; } return list ; } 
public void post ( Runnable action ) { if ( handler == null || action == null ) return ; handler . post ( action ) ; } 
public static void moveDirectoryToDirectory ( File src , File destDir , boolean createDestDir ) throws IOException { if ( src == null ) { throw new NullPointerException ( "Source-must-not-be-null" ) ; } if ( destDir == null ) { throw new NullPointerException ( "Destination-directory-must-not-be-null" ) ; } if ( ! destDir . exists ( ) && createDestDir ) { destDir . mkdirs ( ) ; } if ( ! destDir . exists ( ) ) { throw new FileNotFoundException ( "Destination-directory-'" + destDir + "'-does-not-exist-[createDestDir=" + createDestDir + "]" ) ; } if ( ! destDir . isDirectory ( ) ) { throw new IOException ( "Destination-'" + destDir + "'-is-not-a-directory" ) ; } moveDirectory ( src , new File ( destDir , src . getName ( ) ) ) ; } 
public void setComment ( String comment ) { byte [ ] commentBytes ; try { commentBytes = comment . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { throw new AssertionError ( uee ) ; } if ( commentBytes . length > 0xffff ) throw new IllegalArgumentException ( "Comment-too-long." ) ; zipComment = commentBytes ; } 
public double upperCumulativeProbability ( int x ) { double ret ; final int [ ] domain = getDomain ( populationSize , numberOfSuccesses , sampleSize ) ; if ( x < domain [ 0 ] ) { ret = 1.0 ; } else if ( x > domain [ 1 ] ) { ret = 0.0 ; } else { ret = innerCumulativeProbability ( domain [ 1 ] , x , - 1 , populationSize , numberOfSuccesses , sampleSize ) ; } return ret ; } 
public void addProductType ( ProductType productType ) { productTypes . add ( productType ) ; } 
public synchronized void close ( ) throws IOException { data . close ( ) ; index . close ( ) ; } 
private static void cleanDirectoryOnExit ( File directory ) throws IOException { if ( ! directory . exists ( ) ) { String message = directory + "-does-not-exist" ; throw new IllegalArgumentException ( message ) ; } if ( ! directory . isDirectory ( ) ) { String message = directory + "-is-not-a-directory" ; throw new IllegalArgumentException ( message ) ; } File [ ] files = directory . listFiles ( ) ; if ( files == null ) { throw new IOException ( "Failed-to-list-contents-of-" + directory ) ; } IOException exception = null ; for ( File file : files ) { try { forceDeleteOnExit ( file ) ; } catch ( IOException ioe ) { exception = ioe ; } } if ( null != exception ) { throw exception ; } } 
public void useItem ( String itemName ) { hasItem = false ; if ( invent . isEmpty ( ) ) { gameDialog = new Dialog ( "No-item-in-inventory" ) ; gameDialog . showErrorMsg ( ) ; } else { for ( Item item : invent ) { if ( item . getName ( ) . equalsIgnoreCase ( itemName ) ) { invent . remove ( item ) ; hasItem = true ; break ; } else { hasItem = false ; } } if ( ! hasItem ) { gameDialog = new Dialog ( "Does-not-have-Item" ) ; gameDialog . showErrorMsg ( ) ; } } if ( itemName . equalsIgnoreCase ( "Potion" ) && ! hasItem == false ) { potionCount -- ; } else if ( itemName . equalsIgnoreCase ( "MagicStone" ) && ! hasItem == false ) { stoneCount -- ; } else if ( itemName . equalsIgnoreCase ( "UltimaStone" ) && ! hasItem == false ) { ultiCount -- ; } } 
public static void main ( String [ ] args ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { JavaKey window = new JavaKey ( ) ; window . frame . setVisible ( true ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; } 
SchemaFuture installHandlers ( XMLReader in , SchemaReceiverImpl sr ) { Handler h = new Handler ( sr ) ; in . setContentHandler ( h ) ; return h ; } 
protected int unwrapKey ( Object key ) { return ( ( Integer ) key ) . intValue ( ) ; } 
private static void convertUrlParams ( String url , Properties info ) { if ( url == null ) { return ; } int iQuestionMark = url . indexOf ( "?" ) ; if ( iQuestionMark == - 1 ) { return ; } String propString = url . substring ( iQuestionMark + 1 ) ; StringTokenizer st = new StringTokenizer ( propString , "&;" ) ; while ( st . hasMoreTokens ( ) ) { String propertyString = st . nextToken ( ) ; int iIs = propertyString . indexOf ( "=" ) ; if ( iIs > - 1 ) { String property = propertyString . substring ( 0 , iIs ) ; String value = propertyString . substring ( iIs + 1 ) ; info . setProperty ( property , value ) ; } else { info . setProperty ( propertyString , "" ) ; } } } 
public Slice readBytes ( int length ) { if ( length == 0 ) { return Slices . EMPTY_SLICE ; } Slice value = slice . slice ( position , length ) ; position += length ; return value ; } 
public static String xmlToCamelCase ( String s ) { if ( s == null ) { return null ; } StringBuilder sb = new StringBuilder ( s ) ; int offset = 0 ; int i ; while ( ( i = sb . indexOf ( "-" , offset ) ) >= 0 ) { sb . deleteCharAt ( i ) ; if ( sb . length ( ) > i ) { sb . setCharAt ( i , Character . toUpperCase ( sb . charAt ( i ) ) ) ; offset = i ; } } return sb . toString ( ) ; } 
public AbstractColorChooserPanel removeChooserPanel ( AbstractColorChooserPanel panel ) { int index = - 1 ; for ( int i = 0 ; i < chooserPanels . length ; i ++ ) if ( panel == chooserPanels [ i ] ) { index = i ; break ; } if ( index == - 1 ) return null ; AbstractColorChooserPanel [ ] old = chooserPanels ; if ( chooserPanels . length == 1 ) chooserPanels = null ; else { AbstractColorChooserPanel [ ] newPanels = new AbstractColorChooserPanel [ chooserPanels . length - 1 ] ; System . arraycopy ( chooserPanels , 0 , newPanels , 0 , index ) ; System . arraycopy ( chooserPanels , index , newPanels , index - 1 , chooserPanels . length - index ) ; chooserPanels = newPanels ; } panel . uninstallChooserPanel ( this ) ; firePropertyChange ( CHOOSER_PANELS_PROPERTY , old , chooserPanels ) ; return panel ; } 
public static Properties toProperties ( String key , String value ) { Properties props = new Properties ( ) ; props . setProperty ( key , value ) ; return props ; } 
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = 0 ; i < length ; i += 1 ) { c = s . charAt ( i ) ; if ( c < '-' || c == '+' || c == '%' || c == '=' || c == ';' ) { sb . append ( '%' ) ; sb . append ( Character . forDigit ( ( char ) ( ( c >>> 4 ) & 0x0f ) , 16 ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & 0x0f ) , 16 ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } 
public static String getHash ( byte [ ] data ) throws NoSuchAlgorithmException { MessageDigest digest = MessageDigest . getInstance ( "MD5" ) ; byte [ ] hash = digest . digest ( data ) ; String hexHash = byte2hex ( hash ) ; return hexHash ; } 
@ XmlElementDecl ( namespace = "" , name = "fffff" , scope = Dynamics . class ) public JAXBElement < Empty > createDynamicsFffff ( Empty value ) { return new JAXBElement < Empty > ( _DynamicsFffff_QNAME , Empty . class , Dynamics . class , value ) ; } 
public String resolveSystem ( String systemId ) throws MalformedURLException , IOException { String resolved = super . resolveSystem ( systemId ) ; if ( resolved != null ) { return resolved ; } Enumeration en = catalogEntries . elements ( ) ; while ( en . hasMoreElements ( ) ) { CatalogEntry e = ( CatalogEntry ) en . nextElement ( ) ; if ( e . getEntryType ( ) == RESOLVER ) { resolved = resolveExternalSystem ( systemId , e . getEntryArg ( 0 ) ) ; if ( resolved != null ) { return resolved ; } } else if ( e . getEntryType ( ) == SYSTEMSUFFIX ) { String suffix = e . getEntryArg ( 0 ) ; String result = e . getEntryArg ( 1 ) ; if ( suffix . length ( ) <= systemId . length ( ) && systemId . substring ( systemId . length ( ) - suffix . length ( ) ) . equals ( suffix ) ) { return result ; } } } return resolveSubordinateCatalogs ( Catalog . SYSTEM , null , null , systemId ) ; } 
public synchronized void save ( ) { ( ( QProportional ) qcontroller ) . kp = ( Double ) kp . getValue ( ) ; return ; } 
public Map values ( ) { return Collections . unmodifiableMap ( this . flagMap ) ; } 
public void computeGlobalStats ( ) throws JAXBException { Ce ce ; rbChoices = RealTimeMonitor . getRBList ( ) ; voChoices = RealTimeMonitor . getVOList ( ) ; int scheduled = 0 ; int running = 0 ; for ( Iterator iter = CElist . iterator ( ) ; iter . hasNext ( ) ; ) { ce = ( Ce ) iter . next ( ) ; if ( isChosen ( ce ) ) { running += ( ( State ) ce . getState ( ) ) . getRunning ( ) . intValue ( ) ; scheduled += ( ( State ) ce . getState ( ) ) . getScheduled ( ) . intValue ( ) ; } } System . out . println ( "-Running-" + running + "-Scheduled-" + scheduled + "(list-size:-" + CElist . size ( ) + ")" ) ; } 
public void clearAttributeSpecs ( ) { if ( m_attributeSpecs == null ) { m_attributeSpecs = new ArrayList < AttributeSpec > ( ) ; } m_attributeSpecs . clear ( ) ; } 
public Polygon to ( Point thePoint ) { if ( thePoint == null ) throw new NullPointerException ( ) ; return addEndpoint ( thePoint ) ; } 
public OutputStream newOutputStream ( Path path , OpenOption ... options ) throws IOException { int len = options . length ; Set < OpenOption > opts = new HashSet < OpenOption > ( len + 3 ) ; if ( len == 0 ) { opts . add ( StandardOpenOption . CREATE ) ; opts . add ( StandardOpenOption . TRUNCATE_EXISTING ) ; } else { for ( OpenOption opt : options ) { if ( opt == StandardOpenOption . READ ) throw new IllegalArgumentException ( "READ-not-allowed" ) ; opts . add ( opt ) ; } } opts . add ( StandardOpenOption . WRITE ) ; return Channels . newOutputStream ( newByteChannel ( path , opts ) ) ; } 
public static int enumerate ( Thread tarray [ ] ) { return currentThread ( ) . getThreadGroup ( ) . enumerate ( tarray ) ; } 
public Color getHighlightColor ( Component c ) { return highlight != null ? highlight : c . getBackground ( ) . brighter ( ) ; } 
public void removeIIOReadProgressListener ( IIOReadProgressListener listener ) { if ( listener == null || progressListeners == null ) { return ; } progressListeners = removeFromList ( progressListeners , listener ) ; } 
public List < Descriptor > getMessageTypes ( ) { return Collections . unmodifiableList ( Arrays . asList ( messageTypes ) ) ; } 
private String validateImport ( String importEntry ) { if ( importEntry . indexOf ( ';' ) > - 1 ) { throw new IllegalArgumentException ( Localizer . getMessage ( "jsp.error.page.invalid.import" ) ) ; } return importEntry . trim ( ) ; } 
public SocketOutputBuffer ( final Socket socket , int buffersize , final HttpParams params ) throws IOException { super ( ) ; if ( socket == null ) { throw new IllegalArgumentException ( "Socket-may-not-be-null" ) ; } if ( buffersize < 0 ) { buffersize = socket . getSendBufferSize ( ) ; } if ( buffersize < 1024 ) { buffersize = 1024 ; } init ( socket . getOutputStream ( ) , buffersize , params ) ; } 
public void stop ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( false , true ) ) { return ; } List < WebSocket > socketsToClose = null ; synchronized ( connections ) { socketsToClose = new ArrayList < WebSocket > ( connections ) ; } for ( WebSocket ws : socketsToClose ) { ws . close ( CloseFrame . GOING_AWAY ) ; } synchronized ( this ) { if ( selectorthread != null ) { if ( Thread . currentThread ( ) != selectorthread ) { } if ( selectorthread != Thread . currentThread ( ) ) { if ( socketsToClose . size ( ) > 0 ) selectorthread . join ( timeout ) ; selectorthread . interrupt ( ) ; selectorthread . join ( ) ; } } } } 
private synchronized void setOptionsFromSystemProperties ( ) { if ( isCleanup == null ) { String propValue = System . getProperty ( ISCLEANUP_PROPERTY , "false" ) ; isCleanup = Boolean . valueOf ( propValue ) ; } if ( taskId == null ) { taskId = System . getProperty ( TASKID_PROPERTY ) ; } if ( maxEvents == null ) { String propValue = System . getProperty ( LOGSIZE_PROPERTY , "0" ) ; setTotalLogFileSize ( Long . valueOf ( propValue ) ) ; } } 
protected void toSAX_CHECKOUT ( ResultSet resultSet , ContentHandler contentHandler ) throws Exception { final String METHOD_NAME = "toSAX_CHECKOUT-(ResultSet-resultSet,-ContentHandler-contentHandler)" ; this . getLogger ( ) . debug ( METHOD_NAME + "-1/2:-Started.-resultSet-=-" + resultSet ) ; this . rootElementStartToSAX ( contentHandler ) ; this . nameToSAX ( resultSet , contentHandler ) ; this . descriptionToSAX ( resultSet , contentHandler ) ; this . vcThreadToSAX ( resultSet , contentHandler ) ; this . versionToSAX ( resultSet , contentHandler ) ; this . copyrightToSAX ( resultSet , contentHandler ) ; this . lastModifiedToSAX ( resultSet , contentHandler ) ; this . createdToSAX ( resultSet , contentHandler ) ; this . containedInToSAX ( resultSet , contentHandler ) ; this . contentTypeToSAX ( resultSet , contentHandler ) ; this . contentLengthToSAX ( resultSet , contentHandler ) ; this . infoPageToSAX ( resultSet , contentHandler ) ; this . readPermissionsToSAX ( contentHandler ) ; this . componentsToSAX ( contentHandler ) ; this . linksToSAX ( contentHandler ) ; this . contentToSAX ( resultSet , contentHandler ) ; this . rootElementEndToSAX ( contentHandler ) ; this . getLogger ( ) . debug ( METHOD_NAME + "-2/2:-Done" ) ; } 
public static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( ParserConfigurationException pce ) { String message = "Error-obtaining-document-builder" ; LOG . error ( message , pce ) ; throw new RuntimeException ( message , pce ) ; } } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public EndpointStudyRecord . ScientificPart . TOREPEATEDINHAL . TESTMAT . Set createEndpointStudyRecordScientificPartTOREPEATEDINHALTESTMATSet ( ) { return new EndpointStudyRecord . ScientificPart . TOREPEATEDINHAL . TESTMAT . Set ( ) ; } 
@ Override public String getDescription ( ) { String path ; if ( extractType == FileExtractType . UPLOAD_FILE ) { path = fileUploadReceiver . getPath ( ) ; } else { path = textFieldPath . getValue ( ) . trim ( ) ; } StringBuilder description = new StringBuilder ( ) ; description . append ( "Extract-from:-" ) ; description . append ( path ) ; return description . toString ( ) ; } 
public static int arraycode ( Type type ) { switch ( type . tag ) { case BYTE : return 8 ; case BOOLEAN : return 4 ; case SHORT : return 9 ; case CHAR : return 5 ; case INT : return 10 ; case LONG : return 11 ; case FLOAT : return 6 ; case DOUBLE : return 7 ; case CLASS : return 0 ; case ARRAY : return 1 ; default : throw new AssertionError ( "arraycode-" + type ) ; } } 
public void showMessages ( Canvas canvas ) { removeExpiredMessages ( ) ; float y = 10.0f ; List < String > l = new ArrayList < String > ( ) ; l . addAll ( mMessages . keySet ( ) ) ; Collections . sort ( l ) ; Iterator < String > iter = l . iterator ( ) ; while ( iter . hasNext ( ) ) { String key = iter . next ( ) ; String text = mMessages . get ( key ) . getText ( ) ; canvas . drawText ( text , 10.0f , y , mPaint ) ; y += MESSAGE_Y_SPACING ; } } 
private org . apache . axiom . soap . SOAPEnvelope toEnvelope ( org . apache . axiom . soap . SOAPFactory factory ) { return factory . getDefaultEnvelope ( ) ; } 
public static < T > T doPrivileged ( PrivilegedAction < T > action ) { if ( action == null ) { throw new NullPointerException ( "action-==-null" ) ; } return doPrivileged ( action , null ) ; } 
private E unlinkLast ( ) { Node < E > l = last ; if ( l == null ) return null ; Node < E > p = l . prev ; E item = l . item ; l . item = null ; l . prev = l ; last = p ; if ( p == null ) first = null ; else p . next = null ; -- count ; notFull . signal ( ) ; return item ; } 
@ XmlElementDecl ( namespace = "http://schemas.datacontract.org/2004/07/Microsoft.BingAds.Advertiser.AdInsight.Api.DataContract.Entity" , name = "Predicate" ) public JAXBElement < Predicate > createPredicate ( Predicate value ) { return new JAXBElement < Predicate > ( _Predicate_QNAME , Predicate . class , null , value ) ; } 
public final float [ ] getFractions ( ) { return Arrays . copyOf ( fractions , fractions . length ) ; } 
public static Number [ ] createNumberArray ( double [ ] data ) { Number [ ] result = new Number [ data . length ] ; for ( int i = 0 ; i < data . length ; i ++ ) { result [ i ] = new Double ( data [ i ] ) ; } return result ; } 
public static Map readParams ( String path ) { Map < String , String > settings = new HashMap < String , String > ( ) ; try { File file = new File ( path ) ; Scanner s = new Scanner ( file ) ; while ( s . hasNextLine ( ) ) { String line = s . nextLine ( ) ; if ( line . startsWith ( "%" ) ) { continue ; } line = line . replaceAll ( "|s" , "" ) ; if ( line . length ( ) == 0 ) { continue ; } String [ ] tokens = line . split ( "=" ) ; settings . put ( tokens [ 0 ] , tokens [ 1 ] ) ; } } catch ( FileNotFoundException ex ) { Logger . getLogger ( DBInfo . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } return settings ; } 
public final static List < String > parseAny ( final String s , final String delimeter , final boolean ignoreNulls ) { final Vector < String > V = new Vector < String > ( 1 ) ; if ( ( s == null ) || ( s . isEmpty ( ) ) ) return V ; if ( ( delimeter == null ) || ( delimeter . isEmpty ( ) ) ) { V . add ( s . trim ( ) ) ; return V ; } int last = 0 ; int next = s . indexOf ( delimeter ) ; if ( next < 0 ) { V . add ( s . trim ( ) ) ; return V ; } while ( next >= 0 ) { final String sub = s . substring ( last , next ) . trim ( ) ; if ( ! ignoreNulls || ( sub . length ( ) > 0 ) ) V . add ( sub ) ; last = next + delimeter . length ( ) ; next = s . indexOf ( delimeter , last ) ; } final String sub = ( last >= s . length ( ) ) ? "" : s . substring ( last , s . length ( ) ) . trim ( ) ; if ( ! ignoreNulls || ( sub . length ( ) > 0 ) ) V . add ( sub ) ; return V ; } 
private boolean doAcquireSharedNanos ( int arg , long nanosTimeout ) throws InterruptedException { long lastTime = System . nanoTime ( ) ; final Node node = addWaiter ( Node . SHARED ) ; boolean failed = true ; try { for ( ; ; ) { final Node p = node . predecessor ( ) ; if ( p == head ) { int r = tryAcquireShared ( arg ) ; if ( r >= 0 ) { setHeadAndPropagate ( node , r ) ; p . next = null ; failed = false ; return true ; } } if ( nanosTimeout <= 0 ) return false ; if ( shouldParkAfterFailedAcquire ( p , node ) && nanosTimeout > spinForTimeoutThreshold ) LockSupport . parkNanos ( nanosTimeout ) ; long now = System . nanoTime ( ) ; nanosTimeout -= now - lastTime ; lastTime = now ; if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; } } finally { if ( failed ) cancelAcquire ( node ) ; } } 
private void smallRound ( MathContext mc , int discardedPrecision ) { long sizeOfFraction = MathUtils . LONG_POWERS_OF_TEN [ discardedPrecision ] ; long newScale = ( long ) scale - discardedPrecision ; long unscaledVal = smallValue ; long integer = unscaledVal / sizeOfFraction ; long fraction = unscaledVal % sizeOfFraction ; int compRem ; if ( fraction != 0 ) { compRem = longCompareTo ( Math . abs ( fraction ) * 2 , sizeOfFraction ) ; integer += roundingBehavior ( ( ( int ) integer ) & 1 , Long . signum ( fraction ) * ( 5 + compRem ) , mc . getRoundingMode ( ) ) ; if ( Math . log10 ( Math . abs ( integer ) ) >= mc . getPrecision ( ) ) { integer /= 10 ; newScale -- ; } } scale = safeLongToInt ( newScale ) ; precision = mc . getPrecision ( ) ; smallValue = integer ; bitLength = bitLength ( integer ) ; intVal = null ; } 
private Runnable getTask ( ) { boolean timedOut = false ; for ( ; ; ) { int c = ctl . get ( ) ; int rs = runStateOf ( c ) ; if ( rs >= SHUTDOWN && ( rs >= STOP || workQueue . isEmpty ( ) ) ) { decrementWorkerCount ( ) ; return null ; } int wc = workerCountOf ( c ) ; boolean timed = allowCoreThreadTimeOut || wc > corePoolSize ; if ( ( wc > maximumPoolSize || ( timed && timedOut ) ) && ( wc > 1 || workQueue . isEmpty ( ) ) ) { if ( compareAndDecrementWorkerCount ( c ) ) return null ; continue ; } try { Runnable r = timed ? workQueue . poll ( keepAliveTime , TimeUnit . NANOSECONDS ) : workQueue . take ( ) ; if ( r != null ) return r ; timedOut = true ; } catch ( InterruptedException retry ) { timedOut = false ; } } } 
public static WarningValue [ ] getWarningValues ( Header h ) { List < WarningValue > out = new ArrayList < WarningValue > ( ) ; String src = h . getValue ( ) ; int offs = 0 ; while ( offs < src . length ( ) ) { try { WarningValue wv = new WarningValue ( src , offs ) ; out . add ( wv ) ; offs = wv . offs ; } catch ( IllegalArgumentException e ) { final int nextComma = src . indexOf ( ',' , offs ) ; if ( nextComma == - 1 ) break ; offs = nextComma + 1 ; } } WarningValue [ ] wvs = { } ; return out . toArray ( wvs ) ; } 
void start ( ) throws IOException { curTxn ++ ; if ( curTxn == _maxTxns ) { synchronizeLogFromMemory ( ) ; curTxn = 0 ; } txns [ curTxn ] = new ArrayList ( ) ; } 
public void lock ( ) { sync . lock ( ) ; } 
private void compilePredicates ( int opPos , Expression [ ] predicates ) throws TransformerException { for ( int i = 0 ; OpCodes . OP_PREDICATE == getOp ( opPos ) ; i ++ ) { predicates [ i ] = predicate ( opPos ) ; opPos = getNextOpPos ( opPos ) ; } } 
protected void dispatchVisibilityChanged ( @ NonNull View changedView , @ Visibility int visibility ) { onVisibilityChanged ( changedView , visibility ) ; } 
public static boolean isEqual ( final Object object1 , final Object object2 ) { boolean result = false ; if ( object1 == object2 ) { result = true ; } else { if ( ( object1 != null ) && object1 . getClass ( ) . isArray ( ) ) { if ( ( object2 != null ) && object2 . getClass ( ) . isArray ( ) && ( object2 . getClass ( ) == object1 . getClass ( ) ) ) { result = ( Array . getLength ( object1 ) == Array . getLength ( object2 ) ) ; if ( result ) { for ( int i = 0 , icount = Array . getLength ( object1 ) ; result && ( i < icount ) ; i ++ ) { result = isEqual ( Array . get ( object1 , i ) , Array . get ( object2 , i ) ) ; } } } } else { result = ( object1 != null ) && ( object2 != null ) && ( ( compareWithConversion ( object1 , object2 ) == 0 ) || object1 . equals ( object2 ) ) ; } } return result ; } 
public void addStandardOutputDataHandler ( EventHandler handler ) { this . addEventHandler ( ProgressEvent . STANDARD_OUTPUT_DATA , handler ) ; } 
static public void listFilesR ( ) { File dir = new File ( "directoryName" ) ; String [ ] children = dir . list ( ) ; File [ ] files = dir . listFiles ( ) ; FileFilter fileFilter = new FileFilter ( ) { public boolean accept ( File file ) { return file . isDirectory ( ) ; } } ; files = dir . listFiles ( fileFilter ) ; } 
public void error ( Object message ) { log ( Level . SEVERE , String . valueOf ( message ) , null ) ; } 
public Dex ( File file ) throws IOException { if ( FileUtils . hasArchiveSuffix ( file . getName ( ) ) ) { ZipFile zipFile = new ZipFile ( file ) ; ZipEntry entry = zipFile . getEntry ( DexFormat . DEX_IN_JAR_NAME ) ; if ( entry != null ) { loadFrom ( zipFile . getInputStream ( entry ) ) ; zipFile . close ( ) ; } else { throw new DexException ( "Expected-" + DexFormat . DEX_IN_JAR_NAME + "-in-" + file ) ; } } else if ( file . getName ( ) . endsWith ( ".dex" ) ) { loadFrom ( new FileInputStream ( file ) ) ; } else { throw new DexException ( "unknown-output-extension:-" + file ) ; } } 
public void yypushback ( int number ) { if ( number > yylength ( ) ) zzScanError ( ZZ_PUSHBACK_2BIG ) ; zzMarkedPos -= number ; } 
public void println ( Object o ) { println ( String . valueOf ( o ) ) ; } 
protected final void removeMessages ( int what ) { mSmHandler . removeMessages ( what ) ; } 
public boolean equals ( Object object ) { if ( object == this ) { return true ; } if ( ! ( object instanceof CollationKey ) ) { return false ; } return compareTo ( ( CollationKey ) object ) == 0 ; } 
public void addRenderingHints ( Map < ? , ? > hints ) { boolean customHintPresent = false ; Iterator < ? > iter = hints . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Object key = iter . next ( ) ; if ( key == SunHints . KEY_RENDERING || key == SunHints . KEY_ANTIALIASING || key == SunHints . KEY_TEXT_ANTIALIASING || key == SunHints . KEY_FRACTIONALMETRICS || key == SunHints . KEY_TEXT_ANTIALIAS_LCD_CONTRAST || key == SunHints . KEY_STROKE_CONTROL || key == SunHints . KEY_INTERPOLATION ) { setRenderingHint ( ( Key ) key , hints . get ( key ) ) ; } else { customHintPresent = true ; } } if ( customHintPresent ) { if ( this . hints == null ) { this . hints = makeHints ( hints ) ; } else { this . hints . putAll ( hints ) ; } } } 
public static Reader newPlatformReader ( File file ) throws FileNotFoundException { return new FileReader ( file ) ; } 
public Scanner skip ( Pattern pattern ) { checkOpen ( ) ; checkNotNull ( pattern ) ; matcher . usePattern ( pattern ) ; matcher . region ( findStartIndex , bufferLength ) ; while ( true ) { if ( matcher . lookingAt ( ) ) { boolean matchInBuffer = matcher . end ( ) < bufferLength || ( matcher . end ( ) == bufferLength && inputExhausted ) ; if ( matchInBuffer ) { matchSuccessful = true ; findStartIndex = matcher . end ( ) ; break ; } } else { if ( inputExhausted ) { matchSuccessful = false ; throw new NoSuchElementException ( ) ; } } if ( ! inputExhausted ) { readMore ( ) ; resetMatcher ( ) ; } } return this ; } 
private void writeShort ( short v ) throws IOException { raf . writeByte ( ( 0xff & v ) ) ; raf . writeByte ( ( 0xff & ( v >>> 8 ) ) ) ; } 
public void close ( ) throws IOException { try { super . close ( ) ; } finally { if ( closeBranch ) { branch . close ( ) ; } } } 
public void setGENAPPLSUMHD ( JAXBElement < Object > value ) { this . genapplsumhd = ( ( JAXBElement < Object > ) value ) ; } 
private JsonWriter close ( JsonScope empty , JsonScope nonempty , String closeBracket ) throws IOException { JsonScope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new IllegalStateException ( "Nesting-problem:-" + stack ) ; } stack . remove ( stack . size ( ) - 1 ) ; if ( context == nonempty ) { newline ( ) ; } out . write ( closeBracket ) ; return this ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
@ Override public Value callMethod ( Env env , StringValue methodName , int hash , Value [ ] args ) { return _value . callMethod ( env , methodName , hash , args ) ; } 
public java . lang . Integer save ( com . floreantpos . model . CreditCardTransaction creditCardTransaction ) { return ( java . lang . Integer ) super . save ( creditCardTransaction ) ; } 
private void loadControl ( String controlFQCN ) throws Exception { if ( getControlFactories ( ) . containsKey ( controlFQCN ) ) { LOG . debug ( "Factory-for-control-{}-was-already-loaded" , controlFQCN ) ; return ; } Class < ? > [ ] types = new Class < ? > [ ] { LdapApiService . class } ; @ SuppressWarnings ( "unchecked" ) Class < ? extends ControlFactory < ? >> clazz = ( Class < ? extends ControlFactory < ? >> ) Class . forName ( controlFQCN . trim ( ) ) ; Constructor < ? > constructor = clazz . getConstructor ( types ) ; ControlFactory < ? > factory = ( ControlFactory < ? > ) constructor . newInstance ( new Object [ ] { this } ) ; getControlFactories ( ) . put ( factory . getOid ( ) , factory ) ; LOG . info ( "Registered-control-factory:-{}" , factory . getOid ( ) ) ; } 
public synchronized void setComponent ( Component c ) { if ( component != null && dragGestureListener != null ) unregisterListeners ( ) ; component = c ; if ( component != null && dragGestureListener != null ) registerListeners ( ) ; } 
protected void searchUpdate ( ) { m_queryF . setBackground ( Color . decode ( "0xA4D3EE" ) ) ; String query = m_queryF . getText ( ) ; synchronized ( m_lock ) { if ( query . length ( ) == 0 ) query = "~~~~~~~" ; else m_queryF . setBackground ( Color . white ) ; if ( ( m_searcher . getQuery ( ) . length ( ) == 0 && m_searcher . getQuery ( ) != "" ) || query . length ( ) == 0 ) { m_resultL . setText ( null ) ; } else if ( query . length ( ) > 0 ) { m_searcher . search ( query ) ; m_queryF . setBackground ( Color . white ) ; int r = m_searcher . getTupleCount ( ) ; if ( query . equalsIgnoreCase ( "~~~~~~~" ) ) m_resultL . setText ( "" ) ; else m_resultL . setText ( r + "-match" + ( r == 1 ? "" : "es" ) ) ; } } } 
public double [ ] getValues ( int index ) { return mValues . get ( index ) ; } 
public final boolean requestFocusFromTouch ( ) { if ( isInTouchMode ( ) ) { ViewRootImpl viewRoot = getViewRootImpl ( ) ; if ( viewRoot != null ) { viewRoot . ensureTouchMode ( false ) ; } } return requestFocus ( View . FOCUS_DOWN ) ; } 
public boolean removeContainerAndCancelIfNecessary ( ImageContainer container ) { mContainers . remove ( container ) ; if ( mContainers . size ( ) == 0 ) { mRequest . cancel ( ) ; return true ; } return false ; } 
public static boolean areAssignable ( Class to , Class from ) { if ( to . isPrimitive ( ) || from . isPrimitive ( ) ) { return objectClass ( to ) . isAssignableFrom ( objectClass ( from ) ) ; } return to . isAssignableFrom ( from ) ; } 
void unregisterOnActivityResultListener ( OnActivityResultListener listener ) { synchronized ( this ) { if ( mActivityResultListeners != null ) { mActivityResultListeners . remove ( listener ) ; } } } 
public void setSTUDYDESIGNHD ( JAXBElement < Object > value ) { this . studydesignhd = ( ( JAXBElement < Object > ) value ) ; } 
@ XmlElementDecl ( namespace = "" , name = "spiccato" , scope = Articulations . class ) public JAXBElement < EmptyPlacement > createArticulationsSpiccato ( EmptyPlacement value ) { return new JAXBElement < EmptyPlacement > ( _ArticulationsSpiccato_QNAME , EmptyPlacement . class , Articulations . class , value ) ; } 
public Region getTranslatedTouchableArea ( Region touchableArea ) { if ( mTouchableAreaBuffer == null ) mTouchableAreaBuffer = new Region ( ) ; mTouchableAreaBuffer . set ( touchableArea ) ; mTouchableAreaBuffer . scale ( applicationScale ) ; return mTouchableAreaBuffer ; } 
public String toString ( ) { StringBuffer text = new StringBuffer ( ) ; if ( ( m_classAttribute == null ) ) { return "SMO:-No-model-built-yet." ; } try { text . append ( "SMO-" ) ; text . append ( "Kernel-used:-" + m_kernel . toString ( ) + "-" ) ; for ( int i = 0 ; i < m_classAttribute . numValues ( ) ; i ++ ) { for ( int j = i + 1 ; j < m_classAttribute . numValues ( ) ; j ++ ) { text . append ( "Classifier-for-classes:-" + m_classAttribute . value ( i ) + ",-" + m_classAttribute . value ( j ) + "-" ) ; text . append ( m_classifiers [ i ] [ j ] ) ; if ( m_fitLogisticModels ) { text . append ( "-" ) ; if ( m_classifiers [ i ] [ j ] . m_logistic == null ) { text . append ( "No-logistic-model-has-been-fit.-" ) ; } else { text . append ( m_classifiers [ i ] [ j ] . m_logistic ) ; } } text . append ( "-" ) ; } } } catch ( Exception e ) { return "Can't-print-SMO-classifier." ; } return text . toString ( ) ; } 
public static < T > List < T > immutableList ( List < T > list ) { return Collections . unmodifiableList ( new ArrayList < T > ( list ) ) ; } 
public int getAccessibleChildrenCount ( ) { Component [ ] children = getMenuComponents ( ) ; int count = 0 ; for ( Component child : children ) { if ( child instanceof Accessible ) { count ++ ; } } return count ; } 
public synchronized void publish ( LogRecord record ) { if ( ! isLoggable ( record ) ) { return ; } super . publish ( record ) ; flush ( ) ; if ( limit > 0 && meter . written >= limit ) { AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { rotate ( ) ; return null ; } } ) ; } } 
ChunkHandler isResponseToUs ( int id ) { synchronized ( mOutstandingReqs ) { ChunkHandler handler = mOutstandingReqs . get ( id ) ; if ( handler != null ) { if ( Log . Config . LOGV ) Log . v ( "ddms" , "Found-0x" + Integer . toHexString ( id ) + "-in-request-set---" + handler ) ; return handler ; } } return null ; } 
@ Deprecated public HFileScanner getScanner ( boolean cacheBlocks , boolean pread , boolean isCompaction ) { return reader . getScanner ( cacheBlocks , pread , isCompaction ) ; } 
protected void cleanupIO ( ) { try { if ( m_procWriter != null ) { m_procWriter . close ( ) ; } if ( m_procReader != null ) { m_procReader . close ( ) ; } m_procReader = null ; m_procWriter = null ; if ( ! m_debug && ( m_modelFilename != null ) ) { File modelFile = new File ( m_modelFilename ) ; modelFile . delete ( ) ; } } catch ( Exception e ) { System . out . println ( "Problems-when-cleaning-up-IO" ) ; e . printStackTrace ( ) ; } } 
public void writeStringList ( DataOutput out , List stringList ) throws IOException { if ( stringList == null ) { out . writeInt ( - 1 ) ; } else { out . writeInt ( stringList . size ( ) ) ; for ( int i = 0 , n = stringList . size ( ) ; i < n ; i ++ ) { ExternalizableHelper . writeSafeUTF ( out , ( String ) stringList . get ( i ) ) ; } } } 
protected final void begin ( ) { Thread . currentThread ( ) . pushInterruptAction$ ( interruptAndCloseRunnable ) ; } 
@ Override public Object getObjectInstance ( Object obj , Name name , Context nameCtx , Hashtable < ? , ? > environment ) throws NamingException { Object result = super . getObjectInstance ( obj , name , nameCtx , environment ) ; if ( result != null ) { Reference ref = ( Reference ) obj ; RefAddr userAttr = ref . get ( "username" ) ; RefAddr passAttr = ref . get ( "password" ) ; if ( userAttr . getContent ( ) != null && passAttr . getContent ( ) != null ) { result = wrapDataSource ( result , userAttr . getContent ( ) . toString ( ) , passAttr . getContent ( ) . toString ( ) ) ; } } return result ; } 
public String getMacroName ( ) { return contextStack . peek ( ) . getName ( ) ; } 
public static int generateViewId ( ) { for ( ; ; ) { final int result = sNextGeneratedId . get ( ) ; int newValue = result + 1 ; if ( newValue > 0x00FFFFFF ) newValue = 1 ; if ( sNextGeneratedId . compareAndSet ( result , newValue ) ) { return result ; } } } 
private void notifySelection ( final String a_value ) { m_configItem . setText ( a_value ) ; } 
public boolean isExpired ( long keepAliveDurationNs ) { return isIdle ( ) && System . nanoTime ( ) - getIdleStartTimeNs ( ) > keepAliveDurationNs ; } 
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof Map . Entry == false ) { return false ; } Map . Entry other = ( Map . Entry ) obj ; Object value = getValue ( ) ; return ( key == null ? other . getKey ( ) == null : key . equals ( other . getKey ( ) ) ) && ( value == null ? other . getValue ( ) == null : value . equals ( other . getValue ( ) ) ) ; } 
public static synchronized void setContext ( Properties properties ) throws NamingException { log . info ( "Instantiate-naming-context,-properties:-" + properties ) ; if ( properties != null ) { ctx = new InitialContext ( properties ) ; } else { ctx = new InitialContext ( ) ; } prop = properties ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public static Color darker ( Color c , double p ) { if ( c == null ) { return null ; } double r = c . getRed ( ) ; double g = c . getGreen ( ) ; double b = c . getBlue ( ) ; r -= ( r * p ) / 100.0 ; g -= ( g * p ) / 100.0 ; b -= ( b * p ) / 100.0 ; return createColor ( ( int ) r , ( int ) g , ( int ) b ) ; } 
public static org . apache . hadoop . mapreduce . jobhistory . Event . Builder newBuilder ( org . apache . hadoop . mapreduce . jobhistory . Event . Builder other ) { return new org . apache . hadoop . mapreduce . jobhistory . Event . Builder ( other ) ; } 
public static boolean isFileExists ( String filename ) { File root = android . os . Environment . getExternalStorageDirectory ( ) ; File dir = new File ( root . getAbsolutePath ( ) + "/" + AuroraConsts . AURORA_DATA_ROOT ) ; File f_toload = new File ( dir , filename ) ; return f_toload . exists ( ) ; } 
@ Override public String operationString ( Formatter operandFmt ) { return "[" + opcode . name ( ) + "]-" + super . operationString ( operandFmt ) ; } 
private void appendKoreanNameConsonantsLookup ( IndexBuilder builder , String name ) { int position = 0 ; int consonantLength = 0 ; int character ; final int stringLength = name . length ( ) ; mStringBuilder . setLength ( 0 ) ; do { character = name . codePointAt ( position ++ ) ; if ( ( character == 0x20 ) || ( character == 0x2c ) || ( character == 0x2E ) ) { continue ; } if ( ( character < 0x1100 ) || ( character > 0x1112 && character < 0x3131 ) || ( character > 0x314E && character < 0xAC00 ) || ( character > 0xD7A3 ) ) { break ; } if ( character >= 0xAC00 ) { character = 0x1100 + ( character - 0xAC00 ) / 588 ; } else if ( character >= 0x3131 ) { if ( character - 0x3131 >= KOREAN_JAUM_CONVERT_MAP . length ) { break ; } character = KOREAN_JAUM_CONVERT_MAP [ character - 0x3131 ] ; if ( character == 0 ) { break ; } } mStringBuilder . appendCodePoint ( character ) ; consonantLength ++ ; } while ( position < stringLength ) ; if ( consonantLength > 1 ) { builder . appendName ( mStringBuilder . toString ( ) ) ; } } 
@ Override public String toString ( ) { StringBuffer buff = new StringBuffer ( ) ; Iterator < BinaryItem > i = m_items . iterator ( ) ; while ( i . hasNext ( ) ) { buff . append ( i . next ( ) . toString ( ) + "-" ) ; } buff . append ( ":-" + m_support ) ; return buff . toString ( ) ; } 
public void writeString ( byte string [ ] ) { try { uncompData . write ( string ) ; } catch ( IOException e ) { throw new ExceptionConverter ( e ) ; } } 
public static String getSubmitButton ( HttpServletRequest request , String def ) { Enumeration e = request . getParameterNames ( ) ; while ( e . hasMoreElements ( ) ) { String parameterName = ( String ) e . nextElement ( ) ; if ( parameterName . startsWith ( "submit" ) ) { return parameterName ; } } return def ; } 
private void copyTables ( ) { if ( prefixTable != null ) { prefixTable = ( Hashtable ) prefixTable . clone ( ) ; } else { prefixTable = new Hashtable ( ) ; } if ( uriTable != null ) { uriTable = ( Hashtable ) uriTable . clone ( ) ; } else { uriTable = new Hashtable ( ) ; } elementNameTable = new Hashtable ( ) ; attributeNameTable = new Hashtable ( ) ; declSeen = true ; } 
protected String valuesParams ( String [ ] fields ) { if ( ( fields == null ) || ( fields . length == 0 ) ) return "" ; StringBuilder buf = new StringBuilder ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { buf . append ( "-?," ) ; } return buf . toString ( ) ; } 
private Document readDocument ( File f , String characterSet ) throws IOException { ProgressMonitorInputStream pin = new ProgressMonitorInputStream ( this , "Reading-" + f . getName ( ) , new FileInputStream ( f ) ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( pin , characterSet ) ) ; try { StyledDocument doc = createDocument ( ) ; MutableAttributeSet attrs = ( ( StyledEditorKit ) editor . getEditorKit ( ) ) . getInputAttributes ( ) ; String line ; boolean isFirst = true ; while ( ( line = in . readLine ( ) ) != null ) { if ( isFirst ) { isFirst = false ; } else { doc . insertString ( doc . getLength ( ) , "-" , attrs ) ; } doc . insertString ( doc . getLength ( ) , line , attrs ) ; } return doc ; } catch ( BadLocationException e ) { throw new IOException ( e . getMessage ( ) ) ; } catch ( OutOfMemoryError e ) { System . err . println ( "out-of-memory!" ) ; throw new IOException ( "Out-of-memory." ) ; } finally { in . close ( ) ; } } 
public void schedule ( TimerTask task , Date time ) { TimerTaskWrapper taskWrapper = new TimerTaskWrapper ( task ) ; synchronized ( wrappedTasks ) { wrappedTasks . put ( task , taskWrapper ) ; } timer . schedule ( taskWrapper , time ) ; } 
public Enumeration listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( "-Turn-on-debugging-output." , "D" , 0 , "-D" ) ) ; result . addElement ( new Option ( "-Silent-mode---prints-nothing-to-stdout." , "S" , 0 , "-S" ) ) ; return result . elements ( ) ; } 
public Point translateToJava2D ( double angleDegrees , double radius , ValueAxis axis , Rectangle2D dataArea ) { if ( counterClockwise ) { angleDegrees = - angleDegrees ; } double radians = Math . toRadians ( angleDegrees + this . angleOffset ) ; double minx = dataArea . getMinX ( ) + this . margin ; double maxx = dataArea . getMaxX ( ) - this . margin ; double miny = dataArea . getMinY ( ) + this . margin ; double maxy = dataArea . getMaxY ( ) - this . margin ; double halfWidth = ( maxx - minx ) / 2.0 ; double halfHeight = ( maxy - miny ) / 2.0 ; double midX = minx + halfWidth ; double midY = miny + halfHeight ; double l = Math . min ( halfWidth , halfHeight ) ; Rectangle2D quadrant = new Rectangle2D . Double ( midX , midY , l , l ) ; double axisMin = axis . getLowerBound ( ) ; double adjustedRadius = Math . max ( radius , axisMin ) ; double length = axis . valueToJava2D ( adjustedRadius , quadrant , RectangleEdge . BOTTOM ) - midX ; float x = ( float ) ( midX + Math . cos ( radians ) * length ) ; float y = ( float ) ( midY + Math . sin ( radians ) * length ) ; int ix = Math . round ( x ) ; int iy = Math . round ( y ) ; Point p = new Point ( ix , iy ) ; return p ; } 
private boolean retryAfterDisconnected ( String reason ) { boolean retry = true ; if ( Phone . REASON_RADIO_TURNED_OFF . equals ( reason ) ) { retry = false ; } return retry ; } 
private static int next ( int v , ByteBuffer in , int inPos ) { return ( v << 8 ) | ( in . get ( inPos + 2 ) & 255 ) ; } 
public static String getOlderTimeString ( String created ) { try { return DATE_FORMAT_OLDER . format ( DATE_FORMAT . parse ( created ) ) ; } catch ( ParseException e ) { return created ; } } 
public List < RouteInfo > getAllRoutes ( ) { List < RouteInfo > routes = new ArrayList ( ) ; routes . addAll ( mRoutes ) ; for ( LinkProperties stacked : mStackedLinks . values ( ) ) { routes . addAll ( stacked . getAllRoutes ( ) ) ; } return routes ; } 
protected int indexOf ( Object o ) { synchronized ( storage ) { return storage . indexOf ( o ) ; } } 
public WebAppDescriptor removeAllFilterMapping ( ) { model . removeChildren ( "filter-mapping" ) ; return this ; } 
public int createDeferredElementDefinition ( String elementName ) { int nodeIndex = createNode ( NodeImpl . ELEMENT_DEFINITION_NODE ) ; int chunk = nodeIndex >> CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; setChunkValue ( fNodeName , elementName , chunk , index ) ; return nodeIndex ; } 
protected void pathWasExpanded ( TreePath path ) { if ( tree != null ) { tree . fireTreeExpanded ( path ) ; } } 
StreamHandlingThread ( Object [ ] args ) { super ( NAME + "[initializing]" ) ; this . args = args ; retryHistory = new ArrayList < Long > ( retryPerMinutes ) ; } 
public boolean quickReject ( float left , float top , float right , float bottom , EdgeType type ) { return native_quickReject ( mNativeCanvas , left , top , right , bottom ) ; } 
protected Attr [ ] sortAttributes ( NamedNodeMap attrs ) { int len = ( attrs != null ) ? attrs . getLength ( ) : 0 ; Attr array [ ] = new Attr [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { array [ i ] = ( Attr ) attrs . item ( i ) ; } for ( int i = 0 ; i < len - 1 ; i ++ ) { String name = array [ i ] . getNodeName ( ) ; int index = i ; for ( int j = i + 1 ; j < len ; j ++ ) { String curName = array [ j ] . getNodeName ( ) ; if ( curName . compareTo ( name ) < 0 ) { name = curName ; index = j ; } } if ( index != i ) { Attr temp = array [ i ] ; array [ i ] = array [ index ] ; array [ index ] = temp ; } } return array ; } 
protected void addDestroyShortcutsCommand ( ICompositeCommand cmd , View view ) { assert view . getEAnnotation ( "Shortcut" ) == null ; for ( Iterator it = view . getDiagram ( ) . getChildren ( ) . iterator ( ) ; it . hasNext ( ) ; ) { View nextView = ( View ) it . next ( ) ; if ( nextView . getEAnnotation ( "Shortcut" ) == null || ! nextView . isSetElement ( ) || nextView . getElement ( ) != view . getElement ( ) ) { continue ; } cmd . add ( new DeleteCommand ( getEditingDomain ( ) , nextView ) ) ; } } 
public static String unqualifiedClassName ( Class type ) { if ( type . isArray ( ) ) { return unqualifiedClassName ( type . getComponentType ( ) ) + "Array" ; } String name = type . getName ( ) ; return name . substring ( name . lastIndexOf ( '.' ) + 1 ) ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; javax . xml . namespace . NamespaceContext nsContext = xmlWriter . getNamespaceContext ( ) ; while ( true ) { java . lang . String uri = nsContext . getNamespaceURI ( prefix ) ; if ( uri == null || uri . length ( ) == 0 ) { break ; } prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public void close ( ) { LOG . info ( Thread . currentThread ( ) . getName ( ) + "-closing-leases" ) ; this . stopRequested = true ; synchronized ( leaseQueue ) { leaseQueue . clear ( ) ; leases . clear ( ) ; leaseQueue . notifyAll ( ) ; } LOG . info ( Thread . currentThread ( ) . getName ( ) + "-closed-leases" ) ; } 
@ SuppressWarnings ( "deprecation" ) public static boolean connectRemoteDebugger ( int debugPort , AndroidLaunch launch , IProgressMonitor monitor ) throws CoreException { int connectTimeout = JavaRuntime . getPreferences ( ) . getInt ( JavaRuntime . PREF_CONNECT_TIMEOUT ) ; HashMap < String , String > newMap = new HashMap < String , String > ( ) ; newMap . put ( "hostname" , "localhost" ) ; newMap . put ( "port" , Integer . toString ( debugPort ) ) ; newMap . put ( "timeout" , Integer . toString ( connectTimeout ) ) ; IVMConnector connector = JavaRuntime . getDefaultVMConnector ( ) ; connector . connect ( newMap , monitor , launch ) ; if ( monitor . isCanceled ( ) ) { IDebugTarget [ ] debugTargets = launch . getDebugTargets ( ) ; for ( IDebugTarget target : debugTargets ) { if ( target . canDisconnect ( ) ) { target . disconnect ( ) ; } } return false ; } return true ; } 
void setUIProperty ( String propertyName , Object value ) { if ( propertyName . equals ( "dividerSize" ) ) { if ( ! clientDividerSizeSet ) { setDividerSize ( ( ( Integer ) value ) . intValue ( ) ) ; clientDividerSizeSet = false ; } } else if ( propertyName . equals ( "oneTouchExpandable" ) ) { if ( ! clientOneTouchExpandableSet ) { setOneTouchExpandable ( ( ( Boolean ) value ) . booleanValue ( ) ) ; clientOneTouchExpandableSet = false ; } } else { super . setUIProperty ( propertyName , value ) ; } } 
public static String getFinalArg ( final String [ ] args , final Integer start ) { final StringBuilder stringBuilder = new StringBuilder ( ) ; for ( int i = start ; i < args . length ; i ++ ) { if ( i != start ) { stringBuilder . append ( "-" ) ; } stringBuilder . append ( args [ i ] ) ; } return stringBuilder . toString ( ) ; } 
protected void doClick ( MenuSelectionManager msm ) { if ( ! isInternalFrameSystemMenu ( ) ) { BasicLookAndFeel . playSound ( menuItem , getPropertyPrefix ( ) + ".commandSound" ) ; } if ( msm == null ) { msm = MenuSelectionManager . defaultManager ( ) ; } msm . clearSelectedPath ( ) ; menuItem . doClick ( 0 ) ; } 
public List < testVoiceProviderInfo > getProvider ( ) { if ( provider == null ) { provider = new ArrayList < testVoiceProviderInfo > ( ) ; } return this . provider ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
void setDefaultStyleSheetType ( String contentType ) { putProperty ( StyleType , contentType ) ; } 
public boolean containsService ( String resourceName ) { return resources . containsResource ( resourceName ) ; } 
public scannerOpenWithStop_args setStartRow ( byte [ ] startRow ) { setStartRow ( startRow == null ? ( ByteBuffer ) null : ByteBuffer . wrap ( startRow ) ) ; return this ; } 
public int getToolTipCount ( int list ) { int result = 0 ; List tooltips = ( List ) this . toolTipSeries . get ( list ) ; if ( tooltips != null ) { result = tooltips . size ( ) ; } return result ; } 
@ Override public UriBuilder replaceMatrix ( String matrix ) throws IllegalArgumentException { CharSequence mpcs = null ; if ( matrix != null ) { mpcs = EncodeOrCheck . fullMatrix ( matrix ) ; } final StringBuilder path = getPath ( ) ; final int beginLastPs = path . lastIndexOf ( "/" ) ; if ( beginLastPs >= 0 ) { final int beginMp = path . indexOf ( ";" , beginLastPs ) ; if ( beginMp >= 0 ) { path . delete ( beginMp , path . length ( ) ) ; } } if ( mpcs == null ) { return this ; } if ( ( mpcs . length ( ) == 0 ) || ( mpcs . charAt ( 0 ) != ';' ) ) { path . append ( ";" ) ; } path . append ( mpcs ) ; return this ; } 
boolean shouldSpin ( SNode s ) { SNode h = head ; return ( h == s || h == null || isFulfilling ( h . mode ) ) ; } 
public void addLast ( E e ) { if ( e == null ) throw new NullPointerException ( "e-==-null" ) ; elements [ tail ] = e ; if ( ( tail = ( tail + 1 ) & ( elements . length - 1 ) ) == head ) doubleCapacity ( ) ; } 
public void drawFlashLabel ( ) { flashMessage = new Label ( "" , context . getSkin ( ) ) ; flashMessage . setPosition ( 450 , TaxeGame . HEIGHT - 24 ) ; flashMessage . setAlignment ( 0 ) ; context . getStage ( ) . addActor ( flashMessage ) ; } 
@ Deprecated public static String encodePostBody ( Bundle parameters , String boundary ) { if ( parameters == null ) return "" ; StringBuilder sb = new StringBuilder ( ) ; for ( String key : parameters . keySet ( ) ) { Object parameter = parameters . get ( key ) ; if ( ! ( parameter instanceof String ) ) { continue ; } sb . append ( "Content-Disposition:-form-data;-name="" + key + ""-" + ( String ) parameter ) ; sb . append ( "-" + "--" + boundary + "-" ) ; } return sb . toString ( ) ; } 
public static void shuffle ( List < Song > list , boolean albumShuffle ) { int size = list . size ( ) ; if ( size < 2 ) return ; Random random = getRandom ( ) ; if ( albumShuffle ) { List < Song > tempList = new ArrayList < Song > ( list ) ; Collections . sort ( tempList ) ; Map < Long , Integer > albumStartIndices = new HashMap < Long , Integer > ( ) ; int index = 0 ; for ( Song song : tempList ) { if ( ! albumStartIndices . containsKey ( song . albumId ) ) { albumStartIndices . put ( song . albumId , index ) ; } index ++ ; } List < Long > shuffledAlbums = new ArrayList < Long > ( albumStartIndices . keySet ( ) ) ; Collections . shuffle ( shuffledAlbums , random ) ; list . clear ( ) ; for ( Long albumId : shuffledAlbums ) { int songIndex = albumStartIndices . get ( albumId ) ; Song song = tempList . get ( songIndex ) ; do { list . add ( song ) ; songIndex ++ ; if ( songIndex < size ) { song = tempList . get ( songIndex ) ; } else { break ; } } while ( albumId == song . albumId ) ; } } else { Collections . shuffle ( list , random ) ; } } 
void setupEndValue ( Object target ) { setupValue ( target , mKeyframeSet . mKeyframes . get ( mKeyframeSet . mKeyframes . size ( ) - 1 ) ) ; } 
static String parseAuthority ( String uriString , int ssi ) { int length = uriString . length ( ) ; if ( length > ssi + 2 && uriString . charAt ( ssi + 1 ) == '/' && uriString . charAt ( ssi + 2 ) == '/' ) { int end = ssi + 3 ; LOOP : while ( end < length ) { switch ( uriString . charAt ( end ) ) { case '/' : case '?' : case '#' : break LOOP ; } end ++ ; } return uriString . substring ( ssi + 3 , end ) ; } else { return null ; } } 
public int getChildCount ( ) { return children == null ? 0 : children . size ( ) ; } 
public static double hypot ( double a , double b ) { double r ; if ( Math . abs ( a ) > Math . abs ( b ) ) { r = b / a ; r = Math . abs ( a ) * Math . sqrt ( 1 + r * r ) ; } else if ( b != 0 ) { r = a / b ; r = Math . abs ( b ) * Math . sqrt ( 1 + r * r ) ; } else { r = 0.0 ; } return r ; } 
private void resolveAllProperties ( Properties fileprops ) throws BuildException { for ( Enumeration e = fileprops . keys ( ) ; e . hasMoreElements ( ) ; ) { String name = ( String ) e . nextElement ( ) ; String value = fileprops . getProperty ( name ) ; boolean resolved = false ; while ( ! resolved ) { Vector fragments = new Vector ( ) ; Vector propertyRefs = new Vector ( ) ; ProjectHelper . parsePropertyString ( value , fragments , propertyRefs ) ; resolved = true ; if ( propertyRefs . size ( ) != 0 ) { StringBuffer sb = new StringBuffer ( ) ; Enumeration i = fragments . elements ( ) ; Enumeration j = propertyRefs . elements ( ) ; while ( i . hasMoreElements ( ) ) { String fragment = ( String ) i . nextElement ( ) ; if ( fragment == null ) { String propertyName = ( String ) j . nextElement ( ) ; if ( propertyName . equals ( name ) ) { throw new BuildException ( "Property-" + name + "-was-circularly-" + "defined." ) ; } fragment = getProject ( ) . getProperty ( propertyName ) ; if ( fragment == null ) { if ( fileprops . containsKey ( propertyName ) ) { fragment = fileprops . getProperty ( propertyName ) ; resolved = false ; } else { fragment = "${" + propertyName + "}" ; } } } sb . append ( fragment ) ; } value = sb . toString ( ) ; fileprops . put ( name , value ) ; } } } } 
public final static DateFormat getTimeInstance ( int style , Locale locale ) { checkTimeStyle ( style ) ; com . ibm . icu . text . DateFormat icuFormat = com . ibm . icu . text . DateFormat . getTimeInstance ( style , locale ) ; return new SimpleDateFormat ( locale , ( com . ibm . icu . text . SimpleDateFormat ) icuFormat ) ; } 
private static String getResult ( URL url ) throws IOException { Log . d ( "Locator" , url . toString ( ) ) ; HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setDoInput ( true ) ; conn . setDoOutput ( true ) ; InputStream is = conn . getInputStream ( ) ; String result = toString ( is ) ; return result ; } 
@ XmlElementDecl ( namespace = "http://xmlns.oracle.com/apps/cdm/foundation/parties/contactPointService/" , name = "LastUpdateLogin" , scope = Web . class ) public JAXBElement < String > createWebLastUpdateLogin ( String value ) { return new JAXBElement < String > ( _WebLastUpdateLogin_QNAME , String . class , Web . class , value ) ; } 
public void setSelected ( ButtonModel m , boolean b ) { if ( b && m != null && m != selection ) { ButtonModel oldSelection = selection ; selection = m ; if ( oldSelection != null ) { oldSelection . setSelected ( false ) ; } m . setSelected ( true ) ; } } 
protected ObjectInputStream ( ) throws IOException , SecurityException { SecurityManager sec_man = System . getSecurityManager ( ) ; if ( sec_man != null ) sec_man . checkPermission ( SUBCLASS_IMPLEMENTATION_PERMISSION ) ; this . useSubclassMethod = true ; } 
public String getValue ( int index ) { int valueIndex = index * 2 + 1 ; if ( valueIndex < 0 || valueIndex >= namesAndValues . size ( ) ) { return null ; } return namesAndValues . get ( valueIndex ) ; } 
public double value ( double x ) { return evaluate ( coefficients , x ) ; } 
protected void paintEmptyRows ( Graphics g ) { final int rowCount = getRowCount ( ) ; final Rectangle clip = g . getClipBounds ( ) ; final int height = clip . y + clip . height ; if ( rowCount * rowHeight < height ) { for ( int i = rowCount ; i <= height / rowHeight ; ++ i ) { g . setColor ( colorForRow ( i ) ) ; g . fillRect ( clip . x , i * rowHeight , clip . width , rowHeight ) ; } if ( System . getProperty ( "os.name" ) . contains ( "Mac" ) && getShowVerticalLines ( ) ) { g . setColor ( MAC_UNFOCUSED_UNSELECTED_VERTICAL_LINE_COLOR ) ; TableColumnModel columnModel = getColumnModel ( ) ; int x = 0 ; for ( int i = 0 ; i < columnModel . getColumnCount ( ) ; ++ i ) { TableColumn column = columnModel . getColumn ( i ) ; x += column . getWidth ( ) ; g . drawLine ( x - 1 , rowCount * rowHeight , x - 1 , height ) ; } } } } 
public void transfer ( E e ) throws InterruptedException { if ( xfer ( e , true , SYNC , 0 ) != null ) { Thread . interrupted ( ) ; throw new InterruptedException ( ) ; } } 
public static String [ ] unpackCipherSuites ( String ciphers ) { if ( ciphers == null ) return null ; Vector c = new Vector ( ) ; int i = ciphers . indexOf ( ',' ) ; int j = 0 ; while ( i > - 1 ) { c . add ( ciphers . substring ( j , i ) ) ; j = i + 1 ; i = ciphers . indexOf ( ',' , j ) ; } c . add ( ciphers . substring ( j ) ) ; String [ ] s = new String [ c . size ( ) ] ; c . toArray ( s ) ; return s ; } 
public static double min ( double d1 , double d2 ) { if ( d1 > d2 ) return d2 ; if ( d1 < d2 ) return d1 ; if ( d1 != d2 ) return Double . NaN ; if ( d1 == 0.0 && ( ( Double . doubleToLongBits ( d1 ) | Double . doubleToLongBits ( d2 ) ) & 0x8000000000000000l ) != 0 ) return 0.0 * ( - 1.0 ) ; return d1 ; } 
public Shape createTabCloseIcon ( int x , int y , int w , int h ) { final double xMid = x + w / 2.0 ; final double yMid = y + h / 2.0 ; path . reset ( ) ; final double xOffsetL = w / 2.0 ; final double xOffsetS = w / 2.0 - 1 ; final double yOffsetL = h / 2.0 ; final double yOffsetS = h / 2.0 - 1 ; final double offsetC = 1 ; path . moveTo ( xMid , yMid - offsetC ) ; path . lineTo ( xMid + xOffsetS , yMid - yOffsetL ) ; path . lineTo ( yMid + xOffsetL , yMid - yOffsetS ) ; path . lineTo ( xMid + offsetC , yMid ) ; path . lineTo ( xMid + xOffsetL , yMid + yOffsetS ) ; path . lineTo ( xMid + xOffsetS , yMid + yOffsetL ) ; path . lineTo ( xMid , yMid + offsetC ) ; path . lineTo ( xMid - xOffsetS , yMid + yOffsetL ) ; path . lineTo ( xMid - xOffsetL , yMid + yOffsetS ) ; path . lineTo ( xMid - offsetC , yMid ) ; path . lineTo ( xMid - xOffsetL , yMid - yOffsetS ) ; path . lineTo ( xMid - xOffsetS , yMid - yOffsetL ) ; path . closePath ( ) ; return path ; } 
int readSubstitutions ( String filename , Pattern [ ] patterns , String [ ] subs ) { int subCount = 0 ; try { File file = new File ( filename ) ; if ( file . exists ( ) ) { FileInputStream fstream = new FileInputStream ( filename ) ; subCount = readSubstitutionsFromInputStream ( fstream , patterns , subs ) ; fstream . close ( ) ; } } catch ( Exception e ) { System . err . println ( "Error:-" + e . getMessage ( ) ) ; } return ( subCount ) ; } 
@ Override public void close ( ) throws IOException { buf = null ; InputStream localIn = in ; in = null ; if ( localIn != null ) { localIn . close ( ) ; } } 
Object dereference ( ReferenceType referenceType , Object reference ) { return referenceType == STRONG ? reference : ( ( Reference ) reference ) . get ( ) ; } 
public boolean connect ( String ip , String port ) { connection = new Connection ( ) ; return connection . connect ( ip , port ) ; } 
private File crearFitxer ( ) { String timeStamp = new SimpleDateFormat ( "yyyyMMdd_HHmmss" ) . format ( new Date ( ) ) ; String imageFileName = "foto" + timeStamp + ".jpg" ; File path = new File ( Environment . getExternalStorageDirectory ( ) , this . getPackageName ( ) ) ; if ( ! path . exists ( ) ) path . mkdirs ( ) ; return new File ( path , imageFileName ) ; } 
public Enumeration elements ( ) { return permissions . elements ( ) ; } 
private final void printCharacter ( final int c ) throws IOException { if ( c == '|t' ) { char cbuf [ ] = new char [ TAB_WIDTH ] ; Arrays . fill ( cbuf , '-' ) ; out . write ( cbuf ) ; return ; } out . write ( c ) ; } 
public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } TabularData other ; try { other = ( TabularData ) obj ; } catch ( ClassCastException e ) { return false ; } if ( ! this . getTabularType ( ) . equals ( other . getTabularType ( ) ) ) { return false ; } if ( this . size ( ) != other . size ( ) ) { return false ; } for ( Iterator iter = this . values ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { CompositeData value = ( CompositeData ) iter . next ( ) ; if ( ! other . containsValue ( value ) ) { return false ; } } return true ; } 
public static String getAttachmentUrl ( String applicationId , UUID callId , String attachmentName ) { return String . format ( "%s%s/%s/%s" , ATTACHMENT_URL_BASE , applicationId , callId . toString ( ) , attachmentName ) ; } 
public boolean equals ( String ns , String localPart ) { String thisnamespace = getNamespaceURI ( ) ; return getLocalName ( ) . equals ( localPart ) && ( ( ( null != thisnamespace ) && ( null != ns ) ) ? thisnamespace . equals ( ns ) : ( ( null == thisnamespace ) && ( null == ns ) ) ) ; } 
void appendEndElement ( ) { if ( previousSiblingWasParent ) nodes . writeEntry ( previousSibling , 2 , NULL ) ; previousSibling = currentParent ; nodes . readSlot ( currentParent , gotslot ) ; currentParent = gotslot [ 1 ] & 0xFFFF ; previousSiblingWasParent = true ; } 
public static String [ ] getNames ( Object object ) { if ( object == null ) { return null ; } Class klass = object . getClass ( ) ; Field [ ] fields = klass . getFields ( ) ; int length = fields . length ; if ( length == 0 ) { return null ; } String [ ] names = new String [ length ] ; for ( int i = 0 ; i < length ; i += 1 ) { names [ i ] = fields [ i ] . getName ( ) ; } return names ; } 
public int getColumnDisplaySize ( int column ) throws SQLException { Field f = getField ( column ) ; int lengthInBytes = clampedGetLength ( f ) ; return lengthInBytes / f . getMaxBytesPerCharacter ( ) ; } 
private boolean hasNextPostponed ( ) { return ! postponedRoutes . isEmpty ( ) ; } 
@ Override public void setUp ( ) { Context cx = Context . enter ( ) ; try { global = cx . initStandardObjects ( ) ; String [ ] names = { "f" , "g" } ; global . defineFunctionProperties ( names , DefineFunctionPropertiesTest . class , ScriptableObject . DONTENUM ) ; } finally { Context . exit ( ) ; } } 
protected Map < String , String > getParametersToDisplay ( List < ParameterSetOperation > params ) { Map < String , String > paramMap = new TreeMap < String , String > ( new StringAsIntegerComparator ( ) ) ; for ( ParameterSetOperation param : params ) { String key = getParameterKeyToDisplay ( param ) ; String value = getParameterValueToDisplay ( param ) ; paramMap . put ( key , value ) ; } return paramMap ; } 
@ Override public Set < Map . Entry < K , V >> entries ( ) { return ( Set < Map . Entry < K , V >> ) super . entries ( ) ; } 
public synchronized Vector < TaskInProgress > reportCleanupTIPs ( boolean shouldBeComplete ) { Vector < TaskInProgress > results = new Vector < TaskInProgress > ( ) ; for ( int i = 0 ; i < cleanup . length ; i ++ ) { if ( cleanup [ i ] . isComplete ( ) == shouldBeComplete ) { results . add ( cleanup [ i ] ) ; } } return results ; } 
public void setGlassPane ( Component glassPane ) { getRootPane ( ) . setGlassPane ( glassPane ) ; } 
public FileProgressStatus getProgress ( UUID fileId ) { synchronized ( fileToProgressInfo ) { return fileToProgressInfo . get ( fileId ) ; } } 
public void push ( String [ ] local , FileEntry remote , ISyncProgressMonitor monitor ) throws SyncException , IOException , TimeoutException { if ( remote . isDirectory ( ) == false ) { throw new SyncException ( SyncError . REMOTE_IS_FILE ) ; } ArrayList < File > files = new ArrayList < File > ( ) ; for ( String path : local ) { files . add ( new File ( path ) ) ; } File [ ] fileArray = files . toArray ( new File [ files . size ( ) ] ) ; int total = getTotalLocalFileSize ( fileArray ) ; monitor . start ( total ) ; doPush ( fileArray , remote . getFullPath ( ) , monitor ) ; monitor . stop ( ) ; } 
public Transforms getTransforms ( ) throws XMLSecurityException { try { Element transformsElem = XMLUtils . selectDsNode ( this . constructionElement . getFirstChild ( ) , Constants . _TAG_TRANSFORMS , 0 ) ; if ( transformsElem != null ) { return new Transforms ( transformsElem , this . baseURI ) ; } return null ; } catch ( XMLSignatureException ex ) { throw new XMLSecurityException ( "empty" , ex ) ; } } 
JCExpression parExpression ( ) { accept ( LPAREN ) ; JCExpression t = expression ( ) ; accept ( RPAREN ) ; return t ; } 
public boolean addCreationDate ( ) { try { final SimpleDateFormat sdf = new SimpleDateFormat ( "EEE-MMM-dd-HH:mm:ss-zzz-yyyy" ) ; return add ( new Meta ( Element . CREATIONDATE , sdf . format ( new Date ( ) ) ) ) ; } catch ( DocumentException de ) { throw new ExceptionConverter ( de ) ; } } 
public int size ( boolean reduced ) { if ( ! reduced ) { return super . size ( ) ; } else { return indexWithReduction . size ( ) ; } } 
public static BufferedImage makeLinearBufferedImage ( int width , int height , boolean premult ) { ColorModel cm = makeLinear_sRGBCM ( premult ) ; WritableRaster wr = cm . createCompatibleWritableRaster ( width , height ) ; return new BufferedImage ( cm , wr , premult , null ) ; } 
public Task execute ( ) { return execute ( getClass ( ) . getName ( ) ) ; } 
public static long getSmsThreadId ( Context context , Uri uri ) { Cursor cursor = SqliteWrapper . query ( context , context . getContentResolver ( ) , uri , SMS_THREAD_ID_PROJECTION , null , null , null ) ; if ( cursor == null ) { if ( DEBUG ) { Log . d ( TAG , "getSmsThreadId-uri:-" + uri + "-NULL-cursor!-returning-THREAD_NONE" ) ; } return THREAD_NONE ; } try { if ( cursor . moveToFirst ( ) ) { int columnIndex = cursor . getColumnIndex ( Sms . THREAD_ID ) ; if ( columnIndex < 0 ) { if ( DEBUG ) { Log . d ( TAG , "getSmsThreadId-uri:-" + uri + "-Couldn't-read-row-0,-col--1!-returning-THREAD_NONE" ) ; } return THREAD_NONE ; } long threadId = cursor . getLong ( columnIndex ) ; if ( DEBUG ) { Log . d ( TAG , "getSmsThreadId-uri:-" + uri + "-returning-threadId:-" + threadId ) ; } return threadId ; } else { if ( DEBUG ) { Log . d ( TAG , "getSmsThreadId-uri:-" + uri + "-NULL-cursor!-returning-THREAD_NONE" ) ; } return THREAD_NONE ; } } finally { cursor . close ( ) ; } } 
public Request getRequestForPagedResults ( PagingDirection direction ) { String link = null ; if ( graphObject != null ) { PagedResults pagedResults = graphObject . cast ( PagedResults . class ) ; PagingInfo pagingInfo = pagedResults . getPaging ( ) ; if ( pagingInfo != null ) { if ( direction == PagingDirection . NEXT ) { link = pagingInfo . getNext ( ) ; } else { link = pagingInfo . getPrevious ( ) ; } } } if ( Utility . isNullOrEmpty ( link ) ) { return null ; } if ( link != null && link . equals ( request . getUrlForSingleRequest ( ) ) ) { return null ; } Request pagingRequest ; try { pagingRequest = new Request ( request . getSession ( ) , new URL ( link ) ) ; } catch ( MalformedURLException e ) { return null ; } return pagingRequest ; } 
public int size ( ) { return cache . size ( ) ; } 
public PasswordHash ( final String inPassword ) throws NoSuchAlgorithmException , InvalidKeySpecException { byte [ ] salt = SecureRandom . getInstance ( SALT_ALGORITHM ) . generateSeed ( SALT_LEN ) ; this . hash = hash ( inPassword , salt ) ; this . salt = Base64 . encodeBase64String ( salt ) ; } 
public static void removeTransitions ( CSSStyleDeclaration style ) { style . removeProperty ( "-webkit-transition-property" ) ; style . removeProperty ( "-moz-transition-property" ) ; style . removeProperty ( "-webkit-transition-duration" ) ; style . removeProperty ( "-moz-transition-duration" ) ; } 
private void handleArgumentField ( int begin , int end , int argIndex , FieldPosition position , List < FieldContainer > fields ) { if ( fields != null ) { fields . add ( new FieldContainer ( begin , end , Field . ARGUMENT , Integer . valueOf ( argIndex ) ) ) ; } else { if ( position != null && position . getFieldAttribute ( ) == Field . ARGUMENT && position . getEndIndex ( ) == 0 ) { position . setBeginIndex ( begin ) ; position . setEndIndex ( end ) ; } } } 
public int getObjectTokensCount ( ) { return objectTokens_ . size ( ) ; } 
public static Map < String , String > parseAsQueryString ( HttpResponse response ) throws VDiskException { HttpEntity entity = response . getEntity ( ) ; if ( entity == null ) { throw new VDiskParseException ( "Bad-response-from-VDisk." ) ; } Scanner scanner ; try { scanner = new Scanner ( entity . getContent ( ) ) . useDelimiter ( "&" ) ; } catch ( IOException e ) { throw new VDiskIOException ( e ) ; } Map < String , String > result = new HashMap < String , String > ( ) ; while ( scanner . hasNext ( ) ) { String nameValue = scanner . next ( ) ; String [ ] parts = nameValue . split ( "=" ) ; if ( parts . length != 2 ) { throw new VDiskParseException ( "Bad-query-string-from-VDisk." ) ; } result . put ( parts [ 0 ] , parts [ 1 ] ) ; } return result ; } 
public void addKey ( L key ) { keys . add ( key ) ; } 
@ Override public synchronized int hashCode ( ) { int hashCode = getID ( ) . hashCode ( ) + rawOffset ; if ( useDaylight ) { hashCode += startYear + startMonth + startDay + startDayOfWeek + startTime + startMode + endMonth + endDay + endDayOfWeek + endTime + endMode + dstSavings ; } return hashCode ; } 
public double getContinuous ( int i ) { return data . get ( i ) ; } 
public JList boxList ( ) { if ( boxList == null ) { boxList = ui . createList ( data . boxes ( ) ) ; boxList . addListSelectionListener ( mediator ) ; } return boxList ; } 
@ Override public AutocompletePrediction getItem ( int position ) { return mResultList . get ( position ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public void setValues ( PropertyValuesHolder ... values ) { int numValues = values . length ; mValues = values ; mValuesMap = new HashMap < String , PropertyValuesHolder > ( numValues ) ; for ( int i = 0 ; i < numValues ; ++ i ) { PropertyValuesHolder valuesHolder = values [ i ] ; mValuesMap . put ( valuesHolder . getPropertyName ( ) , valuesHolder ) ; } mInitialized = false ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public void addFriend ( Friend friend ) { friends . add ( friend ) ; } 
private void setTimeInternal ( int parameterIndex , Time x , Calendar targetCalendar , TimeZone tz , boolean rollForward ) throws java . sql . SQLException { if ( x == null ) { setNull ( parameterIndex , java . sql . Types . TIME ) ; } else { checkClosed ( ) ; if ( ! this . useLegacyDatetimeCode ) { newSetTimeInternal ( parameterIndex , x , targetCalendar ) ; } else { Calendar sessionCalendar = getCalendarInstanceForSessionOrNew ( ) ; synchronized ( sessionCalendar ) { x = TimeUtil . changeTimezone ( this . connection , sessionCalendar , targetCalendar , x , tz , this . connection . getServerTimezoneTZ ( ) , rollForward ) ; } setInternal ( parameterIndex , "'" + x . toString ( ) + "'" ) ; } this . parameterTypes [ parameterIndex - 1 + getParameterIndexOffset ( ) ] = Types . TIME ; } } 
private void setSelectedBarGraphBarVisible ( Graph graph , Point point ) { int barY = point . y ; int barWidth = point . width ; int barX = point . x - barWidth ; float barHeight = getCurrentZeroCoordinate ( ) - point . y ; HTML bar = bars . get ( currentGraphs . indexOf ( graph ) ) ; bar . setWidth ( barWidth + "px" ) ; bar . setHeight ( barHeight + "px" ) ; bar . setVisible ( true ) ; displayComponentPanel . setWidgetPosition ( bar , barX , barY ) ; } 
public double density ( final double x ) { return probability ( x ) ; } 
@ Deprecated protected String getPostParamsEncoding ( ) { return getParamsEncoding ( ) ; } 
public void setSmallTabs ( boolean b ) { bundleProperties . addJavaProperty ( "com.apple.smallTabs" , new Boolean ( b ) . toString ( ) ) ; } 
public void run ( ) { try { _runnable . run ( ) ; } catch ( Throwable e ) { ptolemy . util . MessageHandler . error ( ptolemy . util . MessageHandler . shortDescription ( e ) , e ) ; } } 
private String chooseFile ( String title ) { dlg . setDialogTitle ( title ) ; File CWD = null ; String dir = SecurityUtilities . getSystemProperty ( "user.dir" ) ; if ( dir != null ) { CWD = new File ( dir ) ; } if ( CWD != null ) { dlg . setCurrentDirectory ( CWD ) ; } int returnVal = dlg . showOpenDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { try { String result = dlg . getSelectedFile ( ) . getCanonicalPath ( ) ; CWD = dlg . getSelectedFile ( ) . getParentFile ( ) ; Properties props = System . getProperties ( ) ; props . put ( "user.dir" , CWD . getPath ( ) ) ; System . setProperties ( props ) ; return result ; } catch ( IOException ignored ) { } catch ( SecurityException ignored ) { } } return null ; } 
public void processingInstruction ( String target , XMLString data , Augmentations augs ) throws XNIException { if ( fPerformValidation && fElementDepth >= 0 && fDTDGrammar != null ) { fDTDGrammar . getElementDecl ( fCurrentElementIndex , fTempElementDecl ) ; if ( fTempElementDecl . type == XMLElementDecl . TYPE_EMPTY ) { fErrorReporter . reportError ( XMLMessageFormatter . XML_DOMAIN , "MSG_CONTENT_INVALID_SPECIFIED" , new Object [ ] { fCurrentElement . rawname , "EMPTY" , "processing-instruction" } , XMLErrorReporter . SEVERITY_ERROR ) ; } } if ( fDocumentHandler != null ) { fDocumentHandler . processingInstruction ( target , data , augs ) ; } } 
public boolean isSet ( _Fields field ) { if ( field == null ) { throw new IllegalArgumentException ( ) ; } switch ( field ) { case SENDER_USER_NAME : return isSetSender_user_name ( ) ; case FEED_ID : return isSetFeed_id ( ) ; case CONTENT : return isSetContent ( ) ; case TIMESTAMP : return isSetTimestamp ( ) ; } throw new IllegalStateException ( ) ; } 
public static void paintComponent ( Graphics g , Component c , Container p , int x , int y , int w , int h ) { getCellRendererPane ( c , p ) . paintComponent ( g , c , p , x , y , w , h , false ) ; } 
public E peek ( ) throws EmptyStackException { int n = size ( ) ; if ( n <= 0 ) { throw new EmptyStackException ( ) ; } else { return get ( n - 1 ) ; } } 
void accepted ( ) throws SocketException { isCreated = isBound = isConnected = true ; cacheLocalAddress ( ) ; } 
private javax . swing . JScrollPane getTableScrollPane ( ) { if ( ivjTableScrollPane == null ) { try { ivjTableScrollPane = new javax . swing . JScrollPane ( ) ; ivjTableScrollPane . setName ( "TableScrollPane" ) ; ivjTableScrollPane . setVerticalScrollBarPolicy ( javax . swing . JScrollPane . VERTICAL_SCROLLBAR_AS_NEEDED ) ; ivjTableScrollPane . setHorizontalScrollBarPolicy ( javax . swing . JScrollPane . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ; getTableScrollPane ( ) . setViewportView ( getScrollPaneTable ( ) ) ; } catch ( java . lang . Throwable ivjExc ) { handleException ( ivjExc ) ; } } return ivjTableScrollPane ; } 
public final int getCurrentNode ( ) { return m_currentNodes . peek ( ) ; } 
public Instruction createConstant ( Object value ) { PUSH push ; if ( value instanceof Number ) push = new PUSH ( cp , ( Number ) value ) ; else if ( value instanceof String ) push = new PUSH ( cp , ( String ) value ) ; else if ( value instanceof Boolean ) push = new PUSH ( cp , ( Boolean ) value ) ; else if ( value instanceof Character ) push = new PUSH ( cp , ( Character ) value ) ; else throw new ClassGenException ( "Illegal-type:-" + value . getClass ( ) ) ; return push . getInstruction ( ) ; } 
private static void usage ( ) { System . err . println ( "Usage:-java-benchmarks.determinism.pj.edu.rit.compbio.phyl.Upgma-<file>" ) ; System . exit ( 1 ) ; } 
public void setAttributeIndices ( String rangeList ) { m_SelectedCols . setRanges ( rangeList ) ; } 
private boolean canDispathEventLocked ( Service service , AccessibilityEvent event , int handledFeedbackTypes ) { if ( ! service . isConfigured ( ) ) { return false ; } int eventType = event . getEventType ( ) ; if ( ( service . mEventTypes & eventType ) != eventType ) { return false ; } Set < String > packageNames = service . mPackageNames ; CharSequence packageName = event . getPackageName ( ) ; if ( packageNames . isEmpty ( ) || packageNames . contains ( packageName ) ) { int feedbackType = service . mFeedbackType ; if ( ( handledFeedbackTypes & feedbackType ) != feedbackType || feedbackType == AccessibilityServiceInfo . FEEDBACK_GENERIC ) { return true ; } } return false ; } 
public static SnmpOid toOid ( long [ ] index , int start ) throws SnmpStatusException { try { return new SnmpOid ( index [ start ] ) ; } catch ( IndexOutOfBoundsException e ) { throw new SnmpStatusException ( SnmpStatusException . noSuchName ) ; } } 
public V put ( K key , V value ) { MyEntry entry = new MyEntry ( key , value ) ; int hashCode = Math . abs ( key . hashCode ( ) ) ; int mapping = hashCode % ( table . length ) ; LinkedList < MyEntry > bucket = table [ mapping ] ; V ret = null ; if ( bucket . contains ( entry ) ) { int index = bucket . indexOf ( entry ) ; ret = bucket . get ( index ) . value ; bucket . set ( index , entry ) ; } else bucket . add ( entry ) ; size ++ ; if ( ( ( double ) size ) / ( ( double ) table . length ) >= loadFactor ) resize ( ) ; return ret ; } 
public void setExpandEntityReferences ( boolean expandEntityRef ) { documentBuilderFactory . setExpandEntityReferences ( expandEntityRef ) ; } 
public static void drag ( Robot robot , Point startPoint , Point endPoint , int button ) { if ( ! ( button == InputEvent . BUTTON1_MASK || button == InputEvent . BUTTON2_MASK || button == InputEvent . BUTTON3_MASK ) ) { throw new IllegalArgumentException ( "invalid-mouse-button" ) ; } robot . mouseMove ( startPoint . x , startPoint . y ) ; robot . mousePress ( button ) ; try { mouseMove ( robot , startPoint , endPoint ) ; } finally { robot . mouseRelease ( button ) ; } } 
public static void skipFully ( final InputStream fd , long toSkip ) throws IOException { while ( toSkip > 0 ) { final long r = fd . skip ( toSkip ) ; if ( r <= 0 ) throw new EOFException ( "Short-skip-of-block" ) ; toSkip -= r ; } } 
@ XmlElement ( name = "Actions" , namespace = XmlConfigUtils . NAMESPACE ) @ XmlList public Action [ ] getActions ( ) { return ( actions == null ) ? null : actions . clone ( ) ; } 
public static boolean isArray ( final Object obj ) { if ( obj != null ) return obj . getClass ( ) . isArray ( ) ; return false ; } 
private static void escapeString ( String str , StringBuffer output ) { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = str . charAt ( i ) ; switch ( c ) { case '"' : case '|' : output . append ( '|' ) ; output . append ( c ) ; break ; case '|r' : output . append ( "|r" ) ; break ; case '|n' : output . append ( "|n" ) ; break ; default : output . append ( c ) ; break ; } } } 
public Set < Tag > findTags ( ) { final HashSet < Tag > tags = new HashSet < Tag > ( ) ; synchronized ( node_layer_map ) { for ( final Set < Node < T >> nodes : node_layer_map . values ( ) ) { for ( final Node < T > node : nodes ) { final Set < Tag > t = node . getTags ( ) ; if ( null == t ) continue ; tags . addAll ( t ) ; } } } return tags ; } 
@ Override @ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2014-06-21T04:08:14-04:00" , comments = "JAXB-RI-v2.2.7" ) public String toString ( ) { return ToStringBuilder . reflectionToString ( this , JAXBToStringStyle . MULTI_LINE_STYLE ) ; } 
private long getNextByteIndex ( String rangeHeader ) { if ( rangeHeader == null ) { return 0L ; } return Long . parseLong ( rangeHeader . substring ( rangeHeader . indexOf ( '-' ) + 1 , rangeHeader . indexOf ( '/' ) ) ) + 1 ; } 
private void writeObject ( ObjectOutputStream s ) throws IOException { s . defaultWriteObject ( ) ; if ( getUIClassID ( ) . equals ( uiClassID ) ) { byte count = JComponent . getWriteObjCounter ( this ) ; JComponent . setWriteObjCounter ( this , -- count ) ; if ( count == 0 && ui != null ) { ui . installUI ( this ) ; } } } 
public long resume ( ) { mStopTimeInFuture = mPauseTime + SystemClock . elapsedRealtime ( ) ; mPaused = false ; mHandler . sendMessage ( mHandler . obtainMessage ( MSG ) ) ; return mPauseTime ; } 
public boolean match ( CRL crl ) { if ( ! ( crl instanceof X509CRL ) ) { return false ; } X509CRL crlist = ( X509CRL ) crl ; if ( ( issuerNames != null ) && ! ( issuerNames . contains ( crlist . getIssuerX500Principal ( ) . getName ( X500Principal . CANONICAL ) ) ) ) { return false ; } if ( ( minCRL != null ) || ( maxCRL != null ) ) { try { byte [ ] bytes = crlist . getExtensionValue ( "2.5.29.20" ) ; bytes = ( byte [ ] ) ASN1OctetString . getInstance ( ) . decode ( bytes ) ; BigInteger crlNumber = new BigInteger ( ( byte [ ] ) ASN1Integer . getInstance ( ) . decode ( bytes ) ) ; if ( ( minCRL != null ) && ( crlNumber . compareTo ( minCRL ) < 0 ) ) { return false ; } if ( ( maxCRL != null ) && ( crlNumber . compareTo ( maxCRL ) > 0 ) ) { return false ; } } catch ( IOException e ) { return false ; } } if ( dateAndTime != - 1 ) { Date thisUp = crlist . getThisUpdate ( ) ; Date nextUp = crlist . getNextUpdate ( ) ; if ( ( thisUp == null ) || ( nextUp == null ) ) { return false ; } if ( ( dateAndTime < thisUp . getTime ( ) ) || ( dateAndTime > nextUp . getTime ( ) ) ) { return false ; } } return true ; } 
public static void startMethodTracing ( String traceName , int bufferSize , int flags ) { String pathName = traceName ; if ( pathName . charAt ( 0 ) != '/' ) pathName = DEFAULT_TRACE_PATH_PREFIX + pathName ; if ( ! pathName . endsWith ( DEFAULT_TRACE_EXTENSION ) ) pathName = pathName + DEFAULT_TRACE_EXTENSION ; VMDebug . startMethodTracing ( pathName , bufferSize , flags ) ; } 
boolean isUndeployed ( ) { assert Thread . holdsLock ( mux ) == true : "ASSERTION-[line=1229,-file=src/java/org/gridgain/grid/kernal/managers/deployment/GridDeploymentPerVersionStore.java]" ; return undeployed ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public static synchronized void setDefaultSearchPath ( final String [ ] domains ) throws TextParseException { if ( domains == null ) { defaultSearchPath = null ; return ; } Name [ ] newdomains = new Name [ domains . length ] ; for ( int i = 0 ; i < domains . length ; i ++ ) { newdomains [ i ] = Name . fromString ( domains [ i ] , Name . root ) ; } defaultSearchPath = newdomains ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public static String escapeEnter ( String str ) { return str . replaceAll ( "[-]" , "-" ) ; } 
public int getGroupCount ( ) { Integer count = ( Integer ) groupMetaCache . get ( GROUP_COUNT_KEY ) ; if ( count == null ) { synchronized ( GROUP_COUNT_KEY . intern ( ) ) { count = ( Integer ) groupMetaCache . get ( GROUP_COUNT_KEY ) ; if ( count == null ) { count = provider . getGroupCount ( ) ; groupMetaCache . put ( GROUP_COUNT_KEY , count ) ; } } } return count ; } 
public int getPaddingEnd ( ) { if ( ! isPaddingResolved ( ) ) { resolvePadding ( ) ; } return ( getLayoutDirection ( ) == LAYOUT_DIRECTION_RTL ) ? mPaddingLeft : mPaddingRight ; } 
public static boolean isRightTurn ( Point p1 , Point p2 , Point p3 ) { if ( p1 . equals ( p2 ) || p2 . equals ( p3 ) ) { return false ; } double val = ( p2 . x * p3 . y + p1 . x * p2 . y + p3 . x * p1 . y ) - ( p2 . x * p1 . y + p3 . x * p2 . y + p1 . x * p3 . y ) ; return val > 0 ; } 
synchronized void setFinished ( boolean success ) { this . lastActivity = System . currentTimeMillis ( ) ; this . hasFinished = true ; this . hasSucceeded = success ; this . hasStarted = true ; this . isTotalFinalized = true ; } 
public Collection < List < ? >> getPathToNames ( ) { if ( pathToNames == null ) { return null ; } ArrayList result = new ArrayList ( ) ; Iterator it = pathToNames . iterator ( ) ; while ( it . hasNext ( ) ) { GeneralName name = ( GeneralName ) it . next ( ) ; result . add ( name . getAsList ( ) ) ; } return result ; } 
public synchronized boolean isConsumer ( ImageConsumer ic ) { return theConsumers . contains ( ic ) ; } 
public boolean remove ( final URI uri ) { boolean removed = this . unique . remove ( uri ) ; if ( removed ) { Iterator < URI > it = this . all . iterator ( ) ; while ( it . hasNext ( ) ) { URI current = it . next ( ) ; if ( current . equals ( uri ) ) { it . remove ( ) ; } } } return removed ; } 
public static void invokeLater ( Runnable r ) { if ( r != null ) { EventQueue . invokeLater ( r ) ; } } 
public void close ( ) throws IOException { if ( baos != null ) { baos . close ( ) ; baos = null ; } if ( dos != null ) { dos . close ( ) ; dos = null ; } } 
private static boolean isInHorizontalTargetZone ( float x , float y , float handleXStart , float handleXEnd , float handleY , float targetRadius ) { if ( x > handleXStart && x < handleXEnd && Math . abs ( y - handleY ) <= targetRadius ) { return true ; } return false ; } 
public boolean cancel ( boolean mayInterruptIfRunning ) { setCompletion ( CANCELLED ) ; return ( status & COMPLETION_MASK ) == CANCELLED ; } 
public Set < String > getParameterNames ( ) { return mParamsMap . keySet ( ) ; } 
private boolean loadWallImages ( ) { final Image wallsImage = new ImageIcon ( GeneralConsts . DATAS_DIRECTORY + "walls.gif" ) . getImage ( ) ; if ( wallsImage . getWidth ( null ) < GeneralConsts . WALL_WIDTH + 2 || wallsImage . getHeight ( null ) < ( GeneralConsts . WALL_HEIGHT + 1 ) * Map . WALLS_COUNT + 1 ) return false ; final BufferedImage wallsBufferedImage = GameSceen . createCompatibleImage ( wallsImage . getWidth ( null ) , wallsImage . getHeight ( null ) ) ; wallsBufferedImage . getGraphics ( ) . drawImage ( wallsImage , 0 , 0 , null ) ; for ( int wallImageIndex = 0 ; wallImageIndex < wallImages . length ; wallImageIndex ++ ) wallImages [ wallImageIndex ] = wallsBufferedImage . getSubimage ( 1 , wallImageIndex * ( GeneralConsts . WALL_HEIGHT + 1 ) + 1 , GeneralConsts . WALL_WIDTH , GeneralConsts . WALL_HEIGHT ) ; for ( int wallRGBRepresenterIndex = 0 ; wallRGBRepresenterIndex < wallRGBRepresenters . length ; wallRGBRepresenterIndex ++ ) wallRGBRepresenters [ wallRGBRepresenterIndex ] = ( ( BufferedImage ) wallImages [ wallRGBRepresenterIndex ] ) . getRGB ( 1 , 1 ) ; return true ; } 
public static IOFileFilter ageFileFilter ( Date cutoffDate ) { return new AgeFileFilter ( cutoffDate ) ; } 
public String getUniqueKeyAccountNumber_SEQ ( ) { PreparedStatement preStmt = null ; ResultSet rs = null ; String keyAccount = null ; try { preStmt = conn . prepareStatement ( "select-nextval-for-KEY_ACCOUNT_NUMBER_SEQ-as-col1-from-sysibm.sysdummy1" ) ; rs = preStmt . executeQuery ( ) ; if ( rs . next ( ) ) { keyAccount = "KEYACNT" + rs . getString ( 1 ) ; } } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } finally { try { if ( preStmt != null ) preStmt . close ( ) ; } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } try { if ( rs != null ) rs . close ( ) ; } catch ( SQLException sqle ) { sqle . printStackTrace ( ) ; } } return keyAccount . toString ( ) ; } 
public void error ( SAXParseException e ) throws SAXException { javax . xml . transform . ErrorListener errorListener = m_transformer . getErrorListener ( ) ; if ( errorListener instanceof ErrorHandler ) { ( ( ErrorHandler ) errorListener ) . error ( e ) ; if ( null != m_errorHandler ) m_errorHandler . error ( e ) ; } else { try { errorListener . error ( new javax . xml . transform . TransformerException ( e ) ) ; if ( null != m_errorHandler ) m_errorHandler . error ( e ) ; } catch ( javax . xml . transform . TransformerException te ) { throw e ; } } } 
public static void setPenColor ( Color color ) { penColor = color ; offscreen . setColor ( penColor ) ; } 
static String makeRelative ( Path root , Path absPath ) { if ( ! absPath . isAbsolute ( ) ) { throw new IllegalArgumentException ( "!absPath.isAbsolute(),-absPath=" + absPath ) ; } String p = absPath . toUri ( ) . getPath ( ) ; StringTokenizer pathTokens = new StringTokenizer ( p , "/" ) ; for ( StringTokenizer rootTokens = new StringTokenizer ( root . toUri ( ) . getPath ( ) , "/" ) ; rootTokens . hasMoreTokens ( ) ; ) { if ( ! rootTokens . nextToken ( ) . equals ( pathTokens . nextToken ( ) ) ) { return null ; } } StringBuilder sb = new StringBuilder ( ) ; for ( ; pathTokens . hasMoreTokens ( ) ; ) { sb . append ( pathTokens . nextToken ( ) ) ; if ( pathTokens . hasMoreTokens ( ) ) { sb . append ( Path . SEPARATOR ) ; } } return sb . length ( ) == 0 ? "." : sb . toString ( ) ; } 
public final Object clone ( ) { if ( this instanceof GeneralPath ) { return new GeneralPath ( this ) ; } else { return new Path2D . Float ( this ) ; } } 
public boolean contains ( Object value ) { return containsValue ( value ) ; } 
public Object removeFirst ( ) { Object o ; lock . acquire ( ) ; while ( list . isEmpty ( ) ) listEmpty . sleep ( ) ; o = list . removeFirst ( ) ; lock . release ( ) ; return o ; } 
OneStepIteratorForward ( Compiler compiler , int opPos , int analysis ) throws javax . xml . transform . TransformerException { super ( compiler , opPos , analysis ) ; int firstStepPos = OpMap . getFirstChildPos ( opPos ) ; m_axis = WalkerFactory . getAxisFromStep ( compiler , firstStepPos ) ; } 
public BasicBlock getBasicBlock ( ) { if ( isBbFirst ( ) ) { return Label . getBlock ( this ) . block ; } else if ( isBbLast ( ) ) { return BBend . getBlock ( this ) . block ; } else { Instruction instr = null ; for ( instr = getNext ( ) ; ! instr . isBbLast ( ) ; instr = instr . getNext ( ) ) ; return BBend . getBlock ( instr ) . block ; } } 
public BasicDocument < L > init ( URL textURL ) throws FileNotFoundException , IOException { return init ( textURL , textURL . toExternalForm ( ) , true ) ; } 
static ContextStub getInstance ( String contextPath , InitialContextStub parent ) { if ( ! instances . containsKey ( contextPath ) ) { instances . put ( contextPath , new ContextStub ( contextPath , parent ) ) ; } return instances . get ( contextPath ) ; } 
private void linkSubtreeNodesInPreorder ( TreeNode n ) { if ( n . isLeaf ( ) ) return ; for ( int i = 0 ; i < n . numberChildren ( ) ; i ++ ) { linkSubtreeNodesInPreorder ( n . getChild ( i ) ) ; } n . preorderNext = n . firstChild ( ) ; for ( int i = 0 ; i < n . numberChildren ( ) - 1 ; i ++ ) { n . getChild ( i ) . rightmostLeaf . preorderNext = n . getChild ( i + 1 ) ; } n . rightmostLeaf . preorderNext = null ; } 
public ParameterBlock addSource ( Object source ) { sources . addElement ( source ) ; return this ; } 
public static String rowToString ( JSONArray ja ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append ( ',' ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . toString ( ) ; if ( string . length ( ) > 0 && ( string . indexOf ( ',' ) >= 0 || string . indexOf ( '|n' ) >= 0 || string . indexOf ( '|r' ) >= 0 || string . indexOf ( 0 ) >= 0 || string . charAt ( 0 ) == '"' ) ) { sb . append ( '"' ) ; int length = string . length ( ) ; for ( int j = 0 ; j < length ; j += 1 ) { char c = string . charAt ( j ) ; if ( c >= '-' && c != '"' ) { sb . append ( c ) ; } } sb . append ( '"' ) ; } else { sb . append ( string ) ; } } } sb . append ( '|n' ) ; return sb . toString ( ) ; } 
public Section insertRange ( int index , Range r ) { if ( immutable ) throw new IllegalStateException ( "Cant-modify" ) ; list . add ( index , r ) ; return this ; } 
public OffsetTime withMinute ( int minute ) { return with ( time . withMinute ( minute ) , offset ) ; } 
public boolean hasPrivilegeOnProtectionGroup ( Privilege privilege , String protectionGroupName , CenterWrapper < ? > center ) { if ( center != null && getWorkingCenterIds ( ) . contains ( center . getId ( ) ) ) { ProtectionGroupPrivilege pgv = pgMap . get ( protectionGroupName ) ; if ( pgv == null ) { return false ; } return pgv . getPrivileges ( ) . contains ( privilege ) ; } return false ; } 
int [ ] findTemplate ( String name ) { String text = buff . toString ( ) ; int len = text . length ( ) ; int start = 0 ; while ( start < len ) { int cstart = text . indexOf ( "<!--" , start ) ; if ( cstart == - 1 ) return null ; int cend = text . indexOf ( "-->" , cstart ) ; if ( cend == - 1 ) return null ; cend += "-->" . length ( ) ; int tstart = text . indexOf ( "TEMPLATE-" , cstart ) ; if ( tstart == - 1 ) { start = cend ; continue ; } if ( tstart > cend ) { start = cend ; continue ; } int pstart = tstart + "TEMPLATE-" . length ( ) ; int pend = len ; for ( pend = pstart ; pend < len ; pend ++ ) { char c = text . charAt ( pend ) ; if ( c == '-' || c == '|t' || c == '-' ) break ; } if ( pend >= len ) return null ; String param = text . substring ( pstart , pend ) ; if ( param . equals ( name ) ) return new int [ ] { cstart , cend } ; start = cend ; } return null ; } 
public final void characters ( final String string , SerializationHandler handler ) throws TransletException { if ( string != null ) { try { handler . characters ( string ) ; } catch ( Exception e ) { throw new TransletException ( e ) ; } } } 
public void setDefaultBase ( boolean value ) { field_9_options = defaultBase . setShortBoolean ( field_9_options , value ) ; } 
public static boolean isEqual ( Object a , Object b ) { return a == null ? b == null : a . equals ( b ) ; } 
public static Optional < MailAddress > toMailAddress ( String emailAddress ) { if ( emailAddress != null ) { try { return Optional . of ( new MailAddress ( emailAddress . toLowerCase ( ) ) ) ; } catch ( AddressException ex ) { } } return Optional . empty ( ) ; } 
public StringBuilder delete ( int start , int end ) { delete0 ( start , end ) ; return this ; } 
private void waitForCleanupCallableToRun ( ) { try { executorService . submit ( new Runnable ( ) { @ Override public void run ( ) { } } ) . get ( ) ; } catch ( Exception e ) { throw new AssertionError ( ) ; } } 
public Date getDate ( int columnIdx ) throws SQLException { final Date results = _rs . getDate ( columnIdx ) ; _wasNull = results == null ; return results ; } 
public int getStoreNumber ( ) { return bRow . getIntColumn ( "store_number" ) ; } 
public static TransformerFactory newInstance ( String factoryClassName , ClassLoader classLoader ) throws TransformerFactoryConfigurationError { if ( factoryClassName == null ) { throw new TransformerFactoryConfigurationError ( "factoryClassName-==-null" ) ; } if ( classLoader == null ) { classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; } try { Class < ? > type = classLoader != null ? classLoader . loadClass ( factoryClassName ) : Class . forName ( factoryClassName ) ; return ( TransformerFactory ) type . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new TransformerFactoryConfigurationError ( e ) ; } catch ( InstantiationException e ) { throw new TransformerFactoryConfigurationError ( e ) ; } catch ( IllegalAccessException e ) { throw new TransformerFactoryConfigurationError ( e ) ; } } 
public static < E > LinkedList < E > newLinkedList ( final E ... items ) { return new LinkedList < E > ( Arrays . asList ( items ) ) ; } 
private static String formatDate ( Date date ) { if ( date == null ) { return "" ; } return new SimpleDateFormat ( ISO_8601_DATE_FORMAT ) . format ( date ) ; } 
private void loadList ( int first , int last ) { if ( features . size ( ) < last ) last = features . size ( ) - 1 ; listModel . removeAllElements ( ) ; int index = 0 ; for ( int i = first ; i <= last ; i ++ ) if ( i < features . size ( ) ) { listModel . add ( index , getAllFeatures ( ) [ i ] ) ; index ++ ; } } 
public int getIndexOfElement ( Object elem ) { return fElements . indexOf ( elem ) ; } 
public static QueryExp finalSubString ( AttributeValueExp a , StringValueExp s ) { return new MatchQueryExp ( a , new StringValueExp ( "*" + escapeString ( s . getValue ( ) ) ) ) ; } 
private NumberFormat getCurrencyInstanceUsingParseBigDecimal ( ) { NumberFormat formatter = NumberFormat . getCurrencyInstance ( ) ; if ( formatter instanceof DecimalFormat ) { ( ( DecimalFormat ) formatter ) . setParseBigDecimal ( true ) ; } return formatter ; } 
private void startExecutor ( ) { if ( executor == null || executor . isShutdown ( ) ) { Log . debug ( "Starting-executor-service..." ) ; executor = Executors . newScheduledThreadPool ( 2 ) ; } } 
public static Collection synchronizedCollection ( Collection c ) { return new SynchronizedCollection ( c ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public void removeReportModifier ( ReportModifier mod ) { modifiers . remove ( mod ) ; } 
public double getDouble ( String key ) throws JSONException { Object o = get ( key ) ; if ( o == null ) return 0 ; try { if ( o instanceof Number ) { return ( ( Number ) o ) . doubleValue ( ) ; } else if ( o . toString ( ) . length ( ) > 0 ) { return Double . valueOf ( ( o . toString ( ) ) ) ; } else return 0 ; } catch ( Exception e ) { throw new JSONException ( "JSONObject[" + quote ( key ) + "]-is-not-a-number." ) ; } } 
public synchronized int size ( ) { return pktList . size ( ) ; } 
private void emit_actions ( String tabs ) throws java . io . IOException { int elem ; int size ; int bogus_index ; CAccept accept ; if ( CUtility . DEBUG ) { CUtility . ASSERT ( m_spec . m_accept_vector . size ( ) == m_spec . m_anchor_array . length ) ; } bogus_index = - 2 ; size = m_spec . m_accept_vector . size ( ) ; for ( elem = 0 ; elem < size ; ++ elem ) { accept = ( CAccept ) m_spec . m_accept_vector . elementAt ( elem ) ; if ( null != accept ) { m_outstream . println ( tabs + "case-" + elem + ":" ) ; m_outstream . print ( tabs + "-" ) ; m_outstream . print ( new String ( accept . m_action , 0 , accept . m_action_read ) ) ; m_outstream . println ( ) ; m_outstream . println ( tabs + "case-" + bogus_index + ":" ) ; m_outstream . println ( tabs + "-break;" ) ; -- bogus_index ; } } } 
public boolean hasNext ( ) { if ( nextItem != null ) return true ; noNext ( ) ; return false ; } 
public DecimalFormatSymbols getDecimalFormatSymbols ( ) { return ( DecimalFormatSymbols ) symbols . clone ( ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public static File [ ] filter ( IOFileFilter filter , Iterable < File > files ) { List < File > acceptedFiles = filterList ( filter , files ) ; return acceptedFiles . toArray ( new File [ acceptedFiles . size ( ) ] ) ; } 
public static AutoPublishMode getAutoPublishModeFromCombobox ( JComboBox comboBox ) { String autoPublishModeStr = ( String ) comboBox . getSelectedItem ( ) ; if ( autoPublishModeStr == null || autoPublishModeStr . length ( ) == 0 ) { return AutoPublishMode . FILECHANGE ; } autoPublishModeStr = autoPublishModeStr . replaceAll ( "([A-Z]+)-?.*" , "$1" ) ; return AutoPublishMode . valueOf ( autoPublishModeStr ) ; } 
public MLocation getLocation ( Object key , String trxName ) { if ( key == null ) return null ; int C_Location_ID = 0 ; if ( key instanceof Integer ) C_Location_ID = ( ( Integer ) key ) . intValue ( ) ; else if ( key != null ) C_Location_ID = Integer . parseInt ( key . toString ( ) ) ; return getLocation ( C_Location_ID , trxName ) ; } 
public static void error ( String msg ) { throw new AssertionError ( msg ) ; } 
public float getPreferredSpan ( int axis ) { switch ( axis ) { case View . X_AXIS : return c . getIconWidth ( ) ; case View . Y_AXIS : return c . getIconHeight ( ) ; default : throw new IllegalArgumentException ( "Invalid-axis:-" + axis ) ; } } 
protected boolean isFullDetail ( Boolean fullDetailRequest ) { if ( fullDetailRequest == null ) { return defaultFullDetail ; } return fullDetailRequest . booleanValue ( ) ; } 
public void setAccessVector ( String accessVector ) { if ( ( this . accessVector != null ) && ! ( this . accessVector . isEmpty ( ) ) ) { throw new RuntimeException ( "Attempt-to-set-accessVector-when-it's-already-set.-Old-value:-[" + this . accessVector + "]-New-value:-[" + accessVector + "]" ) ; } this . accessVector = accessVector ; } 
public LocalDateTime withYear ( int year ) { return withLocalMillis ( getChronology ( ) . year ( ) . set ( getLocalMillis ( ) , year ) ) ; } 
boolean isPrefixMappedToUri ( String prefix , String uri ) { if ( prefix == null ) { return false ; } String actual = lookupNamespaceURI ( prefix ) ; return uri . equals ( actual ) ; } 
public byte [ ] getNewBytes ( ) { byte [ ] b = new byte [ count ] ; System . arraycopy ( bytes , start , b , 0 , count ) ; return b ; } 
public XPathExpression xpath ( String expression ) { XPathExpression answer = new XPathExpression ( expression ) ; configure ( answer ) ; return answer ; } 
public void setPixelXYZInt ( int x , int y , int z , int value ) { setPixelInt ( getLinearIndexXYZ__ ( x , y , z ) , value ) ; } 
private static boolean isSwitch ( String arg ) { return ( arg . startsWith ( "-" ) ) ; } 
public State clone ( ) { State clone_state = new State ( this . heap , this . scope , this . resultParent , this . resultValue , this . resultType , this . namedValueLhs , this . arrayVals , this . lhsStk , this . callStk , this . recursionStk , this . isInnerHTML ) ; return clone_state ; } 
public ToStringBuilder append ( float value ) { style . append ( buffer , null , value ) ; return this ; } 
public void triggerAnonymousSpecificEvent ( int event , int to , HashMap < String , String > arguments ) { try { ( ( EventListener ) MainFrame . world . getByID ( to ) ) . onAnonymousEvent ( event , arguments ) ; } catch ( ClassCastException e ) { Const . LOGGER . warning ( "Sent-specific-Event-to-non-listener!" ) ; } } 
public Float evaluate ( float fraction , Number startValue , Number endValue ) { float startFloat = startValue . floatValue ( ) ; return startFloat + fraction * ( endValue . floatValue ( ) - startFloat ) ; } 
public Argument editParent ( String newParent ) { return new Function ( "edit-parent" ) . arg ( "newParent" , newParent ) ; } 
public static int getMaxCharWidth ( Font fnt , char [ ] chars ) { FontMetrics fontmet = getFontMetrics ( fnt ) ; int width = 0 ; for ( int i = 0 ; i < chars . length ; i ++ ) { width = Math . max ( width , fontmet . charWidth ( chars [ i ] ) ) ; } return width ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public boolean before ( Time that ) { return Time . compare ( this , that ) < 0 ; } 
private static BSPTree < Euclidean1D > buildTree ( final double lower , final double upper ) { if ( Double . isInfinite ( lower ) && ( lower < 0 ) ) { if ( Double . isInfinite ( upper ) && ( upper > 0 ) ) { return new BSPTree < Euclidean1D > ( Boolean . TRUE ) ; } final SubHyperplane < Euclidean1D > upperCut = new OrientedPoint ( new Vector1D ( upper ) , true ) . wholeHyperplane ( ) ; return new BSPTree < Euclidean1D > ( upperCut , new BSPTree < Euclidean1D > ( Boolean . FALSE ) , new BSPTree < Euclidean1D > ( Boolean . TRUE ) , null ) ; } final SubHyperplane < Euclidean1D > lowerCut = new OrientedPoint ( new Vector1D ( lower ) , false ) . wholeHyperplane ( ) ; if ( Double . isInfinite ( upper ) && ( upper > 0 ) ) { return new BSPTree < Euclidean1D > ( lowerCut , new BSPTree < Euclidean1D > ( Boolean . FALSE ) , new BSPTree < Euclidean1D > ( Boolean . TRUE ) , null ) ; } final SubHyperplane < Euclidean1D > upperCut = new OrientedPoint ( new Vector1D ( upper ) , true ) . wholeHyperplane ( ) ; return new BSPTree < Euclidean1D > ( lowerCut , new BSPTree < Euclidean1D > ( Boolean . FALSE ) , new BSPTree < Euclidean1D > ( upperCut , new BSPTree < Euclidean1D > ( Boolean . FALSE ) , new BSPTree < Euclidean1D > ( Boolean . TRUE ) , null ) , null ) ; } 
static public String getString ( String key , Long arg1 , Long arg2 ) { Object [ ] messageArguments = { arg1 , arg2 } ; return applyPattern ( key , messageArguments ) ; } 
public static Element findTransitionElementInCache ( Document doc , String from , String to ) throws Exception { NodeList transitions = doc . getElementsByTagName ( "transition" ) ; for ( int i = 0 ; i < transitions . getLength ( ) ; i ++ ) { Element transition = ( Element ) transitions . item ( i ) ; if ( transition . getAttribute ( "from" ) . compareTo ( from ) == 0 && transition . getAttribute ( "to" ) . compareTo ( to ) == 0 ) { return transition ; } } return null ; } 
public void unregisterDisplayTransactionListener ( DisplayTransactionListener listener ) { if ( listener == null ) { throw new IllegalArgumentException ( "listener-must-not-be-null" ) ; } mDisplayTransactionListeners . remove ( listener ) ; } 
private static Runnable asUncheckedRunnable ( Closeable c ) { return ( ) -> { try { c . close ( ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } ; } 
protected void refreshRiskCalculation ( List < RiskProvider > providers ) { for ( int cIndex = 0 ; cIndex < components . size ( ) ; cIndex ++ ) { for ( int aIndex = 0 ; aIndex < attributes . size ( ) ; aIndex ++ ) { int row = cIndex + 1 ; int column = aIndex + 1 ; Attribute attribute = attributes . get ( aIndex ) ; Component component = components . get ( cIndex ) ; Integer key = Capability . getCapabilityIntersectionKey ( component , attribute ) ; CapabilityIntersectionData data = dataMap . get ( key ) ; double risk = 0.0 ; double mitigations = 0.0 ; for ( RiskProvider provider : providers ) { double sourceRisk = provider . calculateRisk ( data ) ; if ( sourceRisk < 0 ) { mitigations += sourceRisk ; } else { risk += sourceRisk ; } } updateCell ( row , column , risk , mitigations ) ; } } } 
public ControllerProperties saveSnapshotAs ( String thePropertiesPath , String theKey ) { Set < ControllerProperty > log = _mySnapshots . get ( theKey ) ; if ( log == null ) { return this ; } thePropertiesPath = controlP5 . checkPropertiesPath ( thePropertiesPath ) ; format . compile ( thePropertiesPath , log ) ; return this ; } 
private IAuthorizationPrincipal [ ] getPrincipalsFromPermissions ( IPermission [ ] permissions ) throws AuthorizationException { Set principals = new HashSet ( ) ; for ( int i = 0 ; i < permissions . length ; i ++ ) { IAuthorizationPrincipal principal = getPrincipal ( permissions [ i ] ) ; principals . add ( principal ) ; } return ( ( IAuthorizationPrincipal [ ] ) principals . toArray ( new IAuthorizationPrincipal [ principals . size ( ) ] ) ) ; } 
protected boolean removeItem ( L2ItemInstance item ) { return _items . remove ( item ) ; } 
public FontMetrics getFontMetrics ( Font font ) { FontMetrics fm ; for ( FontMetrics element : cacheFM ) { fm = element ; if ( fm == null ) { break ; } if ( fm . getFont ( ) . equals ( font ) ) { return fm ; } } fm = new FontMetricsImpl ( font ) ; System . arraycopy ( cacheFM , 0 , cacheFM , 1 , cacheFM . length - 1 ) ; cacheFM [ 0 ] = fm ; return fm ; } 
private static StringBuffer printRestoreHelp ( ) { log . debug ( "Printing-restore-help-screen" ) ; StringBuffer helpMsg = new StringBuffer ( ) ; helpMsg . append ( "-Restores-a-server-from-a-backup-file.-This-will-" + "perform-a-union-of-the-current-contents-of-the-server-with-the-" + "contents-of-the-file" + eol ) ; helpMsg . append ( "" + eol ) ; helpMsg . append ( "For-example:" + eol + eol ) ; helpMsg . append ( "-TQL>-restore-<rmi://localhost/server1>-from-local-" + "<file:/tmp/server1backup>-;" + eol ) ; helpMsg . append ( "-TQL>-restore-<rmi://localhost/server1>-from-remote-" + "<file:/tmp/server1backup>-;" + eol ) ; helpMsg . append ( "" + eol ) ; helpMsg . append ( "'local'-refers-to-the-file-system-on-the-client" + eol ) ; helpMsg . append ( "'remote'-refers-to-the-file-system-on-the-server-[default]" + eol ) ; return helpMsg ; } 
public synchronized void controlFree ( final int num ) { logger . info ( "maxFree-was-=-" + maxFree . get ( ) ) ; maxFree . set ( Math . min ( Math . max ( 1 , maxFree . addAndGet ( num ) ) , totalMaxSimultanFreeDownload . get ( ) ) ) ; logger . info ( "maxFree-now-=-" + maxFree . get ( ) ) ; } 
private boolean start ( ) { InetSocketAddress socketAddr ; try { InetAddress hostAddr = InetAddress . getByName ( HOST ) ; socketAddr = new InetSocketAddress ( hostAddr , mPort ) ; } catch ( UnknownHostException e ) { return false ; } try { mSocketChannel = SocketChannel . open ( socketAddr ) ; } catch ( IOException e1 ) { return false ; } readLines ( ) ; return true ; } 
public void addExecutionListener ( ExecutionListener listener ) { if ( listener == null ) { return ; } if ( _executionListeners == null ) { _executionListeners = new LinkedList ( ) ; } _executionListeners . add ( new WeakReference ( listener ) ) ; } 
public static Double bisection ( Function f , double a , double b , double tol , int nMax ) { double fa = f . getValue ( a ) ; double fb = f . getValue ( b ) ; double fc ; if ( fa * fb >= 0.0 ) { System . out . println ( "Bisection-method-failed---root-is-not-bracketed." ) ; return null ; } double signA = Math . signum ( fa ) ; double c = 0 ; int n = 0 ; while ( ++ n <= nMax ) { c = ( a + b ) / 2 ; fc = f . getValue ( c ) ; System . out . println ( n + ".-c-=-" + c + ",-fc-=-" + fc ) ; if ( ( Math . abs ( fc ) < Constants . EPSILON ) || ( ( b - a ) / 2 < tol ) ) return c ; if ( Math . signum ( fc ) == signA ) a = c ; else b = c ; } System . out . println ( "Bisection-method-failed---max-number-of-iterations." ) ; return c ; } 
private static Map [ ] getConvertedCaches ( String encoding ) { synchronized ( cEncodings ) { Map [ ] caches = ( Map [ ] ) cEncodings . get ( encoding ) ; if ( caches == null ) { caches = new Map [ CACHES_PER_ENCODING ] ; for ( int i = 0 ; i < CACHES_PER_ENCODING ; i ++ ) { caches [ i ] = Collections . synchronizedMap ( new IdentityMap ( ) ) ; } cEncodings . put ( encoding , caches ) ; } return caches ; } } 
public void addPlotter ( final Plotter plotter ) { plotters . add ( plotter ) ; } 
public static String formatSeconds ( Object obj ) { long time = - 1L ; if ( obj instanceof Long ) { time = ( ( Long ) obj ) . longValue ( ) ; } else if ( obj instanceof Integer ) { time = ( ( Integer ) obj ) . intValue ( ) ; } return ( time + "-s" ) ; } 
public String getNum ( ) { return ( Integer . toString ( message . getMessageNumber ( ) ) ) ; } 
private static int getDay ( Calendar cal , int dayOfWeek , int orderNum ) { int day = cal . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; cal . set ( Calendar . DAY_OF_MONTH , day ) ; int lastWeekday = cal . get ( Calendar . DAY_OF_WEEK ) ; int shift = lastWeekday >= dayOfWeek ? ( lastWeekday - dayOfWeek ) : ( lastWeekday + 7 - dayOfWeek ) ; day -= shift ; if ( orderNum < 0 ) return day ; cal . set ( Calendar . DAY_OF_MONTH , day ) ; int lastOrderNum = ( cal . get ( Calendar . DAY_OF_MONTH ) - 1 ) / 7 ; if ( orderNum >= lastOrderNum ) return day ; return day - ( lastOrderNum - orderNum ) * 7 ; } 
public long getDate ( ) { return getHeaderFieldDate ( "date" , 0L ) ; } 
public void update ( byte input ) { engineUpdate ( input ) ; state = IN_PROGRESS ; } 
public void update ( byte [ ] b , int offset , int length ) { digest . update ( b , offset , length ) ; } 
private Map < SensorType , List < DeviceType >> makeSensorTypeToDeviceTypeMap ( List < DeviceType > deviceTypeList ) { Map < SensorType , List < DeviceType >> revMap = new HashMap < SensorType , List < DeviceType >> ( ) ; for ( DeviceType currDeviceType : deviceTypeList ) { List < SensorType > sTypeList = currDeviceType . getSensorTypes ( ) ; for ( SensorType sType : sTypeList ) { List < DeviceType > typeLookup = revMap . get ( sType ) ; if ( typeLookup == null ) { typeLookup = new ArrayList < DeviceType > ( ) ; typeLookup . add ( currDeviceType ) ; } else { typeLookup . add ( currDeviceType ) ; } revMap . put ( sType , typeLookup ) ; } } return revMap ; } 
public boolean isEnum ( ) { return ( this . getModifiers ( ) & ENUM ) != 0 && this . getSuperclass ( ) == java . lang . Enum . class ; } 
public static int getType ( int codePoint ) { return CharacterData . of ( codePoint ) . getType ( codePoint ) ; } 
public static void removeInstance ( Context context ) { instances . remove ( context ) ; } 
public Builder < F > options ( Map < String , String > options ) { this . options = this . dataMapperService . mapDataOnObject ( options , optionsClass ) ; if ( this . options == null ) { this . options = this . defaultOptions ; } return this ; } 
@ SuppressWarnings ( "unchecked" ) private void getDescriptors ( EventContainer event , ArrayList < ? extends OccurrenceDisplayDescriptor > fullList , ArrayList outList ) { for ( OccurrenceDisplayDescriptor descriptor : fullList ) { try { if ( descriptor . eventTag == event . mTag ) { if ( descriptor . filterValueIndex == - 1 || event . testValue ( descriptor . filterValueIndex , descriptor . filterValue , descriptor . filterCompareMethod ) ) { outList . add ( descriptor ) ; } } } catch ( InvalidTypeException ite ) { } catch ( ArrayIndexOutOfBoundsException aioobe ) { Log . e ( "Event-Log" , String . format ( "ArrayIndexOutOfBoundsException-occured-when-checking-%1$d-th-value-of-event-%2$d" , descriptor . filterValueIndex , descriptor . eventTag ) ) ; } } } 
public boolean isEmpty ( ) { if ( size ( ) == 0 ) return true ; return false ; } 
public static DoubleBuf buffer ( double [ ] theArray ) { if ( theArray == null ) { throw new NullPointerException ( "DoubleBuf.buffer():-theArray-is-null" ) ; } int nr = Arrays . length ( theArray ) ; return new DoubleArrayBuf_1 ( theArray , new Range ( 0 , nr - 1 ) ) ; } 
private void writeStartElement ( java . lang . String prefix , java . lang . String namespace , java . lang . String localPart , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String writerPrefix = xmlWriter . getPrefix ( namespace ) ; if ( writerPrefix != null ) { xmlWriter . writeStartElement ( namespace , localPart ) ; } else { if ( namespace . length ( ) == 0 ) { prefix = "" ; } else if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; } xmlWriter . writeStartElement ( prefix , localPart , namespace ) ; xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } } 
public int editDistance ( String s , String t ) throws IllegalArgumentException { int d [ ] [ ] ; int n ; int m ; int i ; int j ; char s_i ; char t_j ; int cost ; if ( s . contains ( "-" ) || t . contains ( "-" ) ) throw new IllegalArgumentException ( "The-Levenshtien-algorithm-should-work-on-words,-not-phrases" ) ; n = s . length ( ) ; m = t . length ( ) ; if ( n == 0 ) { return m ; } if ( m == 0 ) { return n ; } d = new int [ n + 1 ] [ m + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { d [ i ] [ 0 ] = i ; } for ( j = 0 ; j <= m ; j ++ ) { d [ 0 ] [ j ] = j ; } for ( i = 1 ; i <= n ; i ++ ) { s_i = s . charAt ( i - 1 ) ; for ( j = 1 ; j <= m ; j ++ ) { t_j = t . charAt ( j - 1 ) ; if ( s_i == t_j ) { cost = 0 ; } else { cost = 1 ; } d [ i ] [ j ] = Minimum ( d [ i - 1 ] [ j ] + 1 , d [ i ] [ j - 1 ] + 1 , d [ i - 1 ] [ j - 1 ] + cost ) ; } } return d [ n ] [ m ] ; } 
public Token peekNextToken ( ) { return peekNextToken ( SINGLE ) ; } 
protected boolean planContainsOption ( SearchNode lastVisitedNode ) { if ( lastVisitedNode == null ) { return false ; } SearchNode curNode = lastVisitedNode ; while ( curNode . backPointer != null ) { if ( ! curNode . generatingAction . action . isPrimitive ( ) ) { return true ; } curNode = curNode . backPointer ; } return false ; } 
public int getNumberOfDocuments ( ) { return mFiles . size ( ) ; } 
public void removeClickingListener ( OnWheelClickedListener listener ) { clickingListeners . remove ( listener ) ; } 
public static synchronized void setSystem ( ActivationSystem system ) throws ActivationException { SecurityManager security = System . getSecurityManager ( ) ; if ( security != null ) security . checkSetFactory ( ) ; if ( currSystem != null ) throw new ActivationException ( "activation-system-already-set" ) ; currSystem = system ; } 
public static synchronized void refreshSuperUserGroupsConfiguration ( Configuration conf ) { proxyGroups . clear ( ) ; proxyHosts . clear ( ) ; String regex = CONF_HADOOP_PROXYUSER_RE + "[^.]*|" + CONF_GROUPS ; Map < String , String > allMatchKeys = conf . getValByRegex ( regex ) ; for ( Entry < String , String > entry : allMatchKeys . entrySet ( ) ) { proxyGroups . put ( entry . getKey ( ) , StringUtils . getStringCollection ( entry . getValue ( ) ) ) ; } regex = CONF_HADOOP_PROXYUSER_RE + "[^.]*|" + CONF_HOSTS ; allMatchKeys = conf . getValByRegex ( regex ) ; for ( Entry < String , String > entry : allMatchKeys . entrySet ( ) ) { proxyHosts . put ( entry . getKey ( ) , StringUtils . getStringCollection ( entry . getValue ( ) ) ) ; } init = true ; } 
public int getURLCount ( int list ) { int result = 0 ; Map urlMap = ( Map ) this . urls . get ( list ) ; if ( urlMap != null ) { result = urlMap . size ( ) ; } return result ; } 
public Locale getLocale ( ) { AccessibleContext ac = getCurrentAccessibleContext ( ) ; if ( ac != null ) { return ac . getLocale ( ) ; } else { return tree . getLocale ( ) ; } } 
public static char [ ] pad4 ( final char [ ] ca ) { final int PAD = 4 ; final char [ ] result ; int l = ca . length % PAD ; if ( l == 0 ) result = ca ; else { l = PAD - l ; result = new char [ ca . length + l ] ; System . arraycopy ( ca , 0 , result , 0 , ca . length ) ; } return result ; } 
public void addFrame ( String frameText , String wordForm ) { List frameList = ( List ) ( wordFrames . get ( wordForm ) ) ; if ( frameList == null ) { frameList = new ArrayList ( ) ; wordFrames . put ( wordForm , frameList ) ; } frameList . add ( frameText ) ; } 
public void setFont ( Font newFont ) { graphic . setFont ( newFont ) ; } 
@ XmlElementDecl ( namespace = "http://schemas.microsoft.com/2003/10/Serialization/" , name = "int" ) public JAXBElement < Integer > createInt ( Integer value ) { return new JAXBElement < Integer > ( _Int_QNAME , Integer . class , null , value ) ; } 
@ SuppressWarnings ( "unchecked" ) public static void logRequest ( HttpServletRequest request ) { if ( log . isDebugEnabled ( ) ) { log . debug ( request . getMethod ( ) ) ; StringBuffer url = request . getRequestURL ( ) ; String queryString = request . getQueryString ( ) ; if ( queryString != null ) { url . append ( "?" ) ; url . append ( queryString ) ; } log . debug ( url . toString ( ) ) ; for ( Map . Entry < String , String [ ] > param : ( ( Map < String , String [ ] > ) request . getParameterMap ( ) ) . entrySet ( ) ) for ( String val : param . getValue ( ) ) log . debug ( "-" + param . getKey ( ) + "=" + val ) ; Enumeration < String > nameEnu = request . getHeaderNames ( ) ; while ( nameEnu . hasMoreElements ( ) ) { String name = nameEnu . nextElement ( ) ; Enumeration < String > valuesEnu = request . getHeaders ( name ) ; while ( valuesEnu . hasMoreElements ( ) ) { String value = valuesEnu . nextElement ( ) ; log . debug ( "-" + name + ":-" + value ) ; } } } } 
private void releasePlock ( int ps ) { plock = ps ; synchronized ( this ) { notifyAll ( ) ; } } 
public static int getPropertyValueAsInt ( Properties props , String key , int defaultValue ) { return props == null || ! props . containsKey ( key ) ? defaultValue : Integer . parseInt ( props . getProperty ( key ) ) ; } 
public void setComponentOrientation ( ComponentOrientation o ) { ComponentOrientation oldValue = componentOrientation ; componentOrientation = o ; firePropertyChange ( "componentOrientation" , oldValue , o ) ; if ( valid ) { invalidate ( ) ; } } 
protected DualTreeBidiMap ( Map normalMap , Map reverseMap , BidiMap inverseBidiMap ) { super ( normalMap , reverseMap , inverseBidiMap ) ; this . comparator = ( ( SortedMap ) normalMap ) . comparator ( ) ; } 
@ Override protected String renameInternalType ( String type ) { if ( type == null ) { return null ; } if ( type . equals ( mOldName ) ) { return mNewName ; } if ( mOldBase != mOldName && type . equals ( mOldBase ) ) { return mNewBase ; } int pos = type . indexOf ( '$' ) ; if ( pos == mOldBase . length ( ) && type . startsWith ( mOldBase ) ) { return mNewBase + type . substring ( pos ) ; } return type ; } 
public byte [ ] readRawBytes ( int code ) throws IOException { int length = in . readInt ( ) ; byte [ ] bytes = new byte [ 5 + length ] ; bytes [ 0 ] = ( byte ) code ; bytes [ 1 ] = ( byte ) ( 0xff & ( length >> 24 ) ) ; bytes [ 2 ] = ( byte ) ( 0xff & ( length >> 16 ) ) ; bytes [ 3 ] = ( byte ) ( 0xff & ( length >> 8 ) ) ; bytes [ 4 ] = ( byte ) ( 0xff & length ) ; in . readFully ( bytes , 5 , length ) ; return bytes ; } 
private int nullAddressAdjustment ( ) { int selected = jComboBoxAddress1 . getSelectedIndex ( ) ; int nullLocation = jComboBoxAddress1 . getItemCount ( ) - 1 ; if ( ! addressAllFlag ) { return - 1 ; } else if ( selected == nullLocation ) { NULL = true ; jComboBoxCommand1 . setSelectedIndex ( jComboBoxCommand1 . getItemCount ( ) - 1 ) ; return 1 ; } else if ( ( selected != nullLocation ) & NULL ) { NULL = false ; jComboBoxCommand1 . setSelectedIndex ( 0 ) ; return 2 ; } return 0 ; } 
public String get ( int pos ) { if ( pos >= 0 && pos < props . size ( ) / 2 ) { return props . get ( pos * 2 + 1 ) ; } return null ; } 
private URI decodeHarURI ( URI rawURI , Configuration conf ) throws IOException { String tmpAuth = rawURI . getAuthority ( ) ; if ( tmpAuth == null ) { return FileSystem . getDefaultUri ( conf ) ; } String authority = rawURI . getAuthority ( ) ; if ( authority == null ) { throw new IOException ( "URI:-" + rawURI + "-is-an-invalid-Har-URI-since-authority==null." + "-Expecting-har://<scheme>-<host>/<path>." ) ; } int i = authority . indexOf ( '-' ) ; if ( i < 0 ) { throw new IOException ( "URI:-" + rawURI + "-is-an-invalid-Har-URI-since-'-'-not-found." + "-Expecting-har://<scheme>-<host>/<path>." ) ; } if ( rawURI . getQuery ( ) != null ) { throw new IOException ( "query-component-in-Path-not-supported-" + rawURI ) ; } URI tmp ; try { URI baseUri = new URI ( authority . replaceFirst ( "-" , "://" ) ) ; tmp = new URI ( baseUri . getScheme ( ) , baseUri . getAuthority ( ) , rawURI . getPath ( ) , rawURI . getQuery ( ) , rawURI . getFragment ( ) ) ; } catch ( URISyntaxException e ) { throw new IOException ( "URI:-" + rawURI + "-is-an-invalid-Har-URI.-Expecting-har://<scheme>-<host>/<path>." ) ; } return tmp ; } 
private void writeObject ( java . io . ObjectOutputStream out ) throws IOException { ObjectOutputStream . PutField fields = out . putFields ( ) ; fields . put ( "all_allowed" , all != null ) ; out . writeFields ( ) ; } 
protected Board ( int size ) { _size = size ; _boardInfo = new ArrayList < > ( _size ) ; _rows = new ArrayList < > ( _size ) ; _columns = new ArrayList < > ( _size ) ; for ( int i = 0 ; i < _size ; ++ i ) { _boardInfo . add ( i , new ArrayList < > ( size ) ) ; _rows . add ( i , new Row ( _size , i ) ) ; for ( int j = 0 ; j < _size ; ++ j ) { if ( i == 0 ) _columns . add ( j , new Column ( _size , j ) ) ; _boardInfo . get ( i ) . add ( j , new Cell ( _size , _rows . get ( i ) , _columns . get ( j ) ) ) ; _rows . get ( i ) . addCell ( j , _boardInfo . get ( i ) . get ( j ) ) ; _columns . get ( j ) . addCell ( i , _boardInfo . get ( i ) . get ( j ) ) ; } } } 
public void addExternalEntity ( String name , String publicID , String systemID ) { if ( ! this . entities . containsKey ( name ) ) { this . entities . put ( name , new String [ ] { publicID , systemID } ) ; } } 
public boolean accepts ( double value ) { if ( Double . isNaN ( value ) ) { return false ; } if ( value < this . lowerBound ) { return false ; } if ( value > this . upperBound ) { return false ; } if ( value == this . lowerBound ) { return this . includeLowerBound ; } if ( value == this . upperBound ) { return this . includeUpperBound ; } return true ; } 
public static Header [ ] getDefaultParamsAsHeaders ( Header [ ] pHeaders ) throws Exception { JSONObject defaultParams = FH . getDefaultParams ( ) ; ArrayList < Header > headers = new ArrayList < Header > ( defaultParams . length ( ) ) ; for ( Iterator < String > it = defaultParams . keys ( ) ; it . hasNext ( ) ; ) { String key = it . next ( ) ; headers . add ( new BasicHeader ( "X-FH-" + key , defaultParams . getString ( key ) ) ) ; } if ( pHeaders != null ) { headers . ensureCapacity ( pHeaders . length + 1 ) ; Collections . addAll ( headers , pHeaders ) ; } return headers . toArray ( new Header [ headers . size ( ) ] ) ; } 
private void invokePropertyHandler ( String name , List < Value > values ) { try { String [ ] parts = name . toLowerCase ( ) . split ( "-" ) ; StringBuffer methodName = new StringBuffer ( "propertyHandler" ) ; for ( String part : parts ) { if ( part . length ( ) > 0 ) { methodName . append ( Character . toUpperCase ( part . charAt ( 0 ) ) ) ; methodName . append ( part , 1 , part . length ( ) ) ; } } try { Method m = getClass ( ) . getDeclaredMethod ( methodName . toString ( ) , Value . class ) ; assert Value . class . isAssignableFrom ( m . getReturnType ( ) ) ; Value newValue = ( Value ) m . invoke ( this , values . get ( 0 ) ) ; values . set ( 0 , newValue ) ; } catch ( NoSuchMethodException e ) { } try { Method m = getClass ( ) . getDeclaredMethod ( methodName . toString ( ) , List . class ) ; m . invoke ( this , values ) ; } catch ( NoSuchMethodException e ) { } } catch ( SecurityException e ) { throw new CssCompilerException ( "Unable-to-invoke-property-handler-function-for-" + name , e ) ; } catch ( IllegalArgumentException e ) { throw new CssCompilerException ( "Unable-to-invoke-property-handler-function-for-" + name , e ) ; } catch ( IllegalAccessException e ) { throw new CssCompilerException ( "Unable-to-invoke-property-handler-function-for-" + name , e ) ; } catch ( InvocationTargetException e ) { throw new CssCompilerException ( "Unable-to-invoke-property-handler-function-for-" + name , e ) ; } } 
public String toString ( ) { if ( m_ZeroR != null ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( this . getClass ( ) . getName ( ) . replaceAll ( ".*|." , "" ) + "-" ) ; buf . append ( this . getClass ( ) . getName ( ) . replaceAll ( ".*|." , "" ) . replaceAll ( "." , "=" ) + "-" ) ; buf . append ( "Warning:-No-model-could-be-built,-hence-ZeroR-model-is-used:-" ) ; buf . append ( m_ZeroR . toString ( ) ) ; return buf . toString ( ) ; } StringBuffer text = new StringBuffer ( ) ; if ( m_NumGenerated == 0 ) { text . append ( "LogitBoost:-No-model-built-yet." ) ; } else { text . append ( "LogitBoost:-Base-classifiers-and-their-weights:-" ) ; for ( int i = 0 ; i < m_NumGenerated ; i ++ ) { text . append ( "-Iteration-" + ( i + 1 ) ) ; for ( int j = 0 ; j < m_NumClasses ; j ++ ) { text . append ( "-Class-" + ( j + 1 ) + "-(" + m_ClassAttribute . name ( ) + "=" + m_ClassAttribute . value ( j ) + ")-" + m_Classifiers [ j ] [ i ] . toString ( ) + "-" ) ; } } text . append ( "Number-of-performed-iterations:-" + m_NumGenerated + "-" ) ; } return text . toString ( ) ; } 
public boolean domainMatch ( String host , String domain ) { boolean match = host . equals ( domain ) || ( domain . startsWith ( "." ) && host . endsWith ( domain ) ) ; return match ; } 
public List < Date > getDates ( ) { if ( dates == null ) { dates = new ArrayList < Date > ( ) ; } return this . dates ; } 
public boolean isValid ( ) { try { validate ( ) ; } catch ( org . exolab . castor . xml . ValidationException vex ) { return false ; } return true ; } 
public int getModule ( int i ) { return vars . get ( i ) . module ; } 
@ Override public void end ( String namespace , String name ) { if ( bodyTextStack != null && ! bodyTextStack . empty ( ) ) { Object parameters [ ] = ( Object [ ] ) digester . peekParams ( ) ; parameters [ paramIndex ] = bodyTextStack . pop ( ) ; } } 
public List < CustomerRequest > getCustomerRequests ( ) { return new ArrayList < CustomerRequest > ( mCustomerRequests ) ; } 
protected void extractEmailAddressFromMessageBody ( ) { String [ ] parts = messageBody . split ( "(-/)|(-)" , 2 ) ; if ( parts . length < 2 ) return ; emailFrom = parts [ 0 ] ; emailBody = parts [ 1 ] ; isEmail = Telephony . Mms . isEmailAddress ( emailFrom ) ; } 
public int getValueU8AsInt ( ) { try { final Element fsApiResult = ( Element ) xmlDoc . getElementsByTagName ( "fsapiResponse" ) . item ( 0 ) ; final Element valueNode = ( Element ) fsApiResult . getElementsByTagName ( "value" ) . item ( 0 ) ; final Element u8Node = ( Element ) valueNode . getElementsByTagName ( "u8" ) . item ( 0 ) ; final String value = getCharacterDataFromElement ( u8Node ) ; logger . trace ( "value-is:-" + value ) ; return Integer . parseInt ( value ) ; } catch ( Exception e ) { logger . error ( "getting-Value.U8-failed-with-" + e . getClass ( ) . getName ( ) + ":-" + e . getMessage ( ) ) ; return 0 ; } } 
public Boolean isRoomCacheOutOfDate ( ) { Date timeout = new Date ( ) ; timeout . setTime ( timeout . getTime ( ) - roomCacheTimeout ) ; return ( roomCacheLastUpdate == null || roomCacheLastUpdate . before ( timeout ) ) ; } 
public static AWTKeyStroke getAWTKeyStroke ( char keyChar ) { return getCachedStroke ( keyChar , KeyEvent . VK_UNDEFINED , 0 , false ) ; } 
@ XmlElementDecl ( namespace = "" , name = "FileType1" , scope = MMSFileUpload . class ) public JAXBElement < String > createMMSFileUploadFileType1 ( String value ) { return new JAXBElement < String > ( _MMSFileUploadFileType1_QNAME , String . class , MMSFileUpload . class , value ) ; } 
public static String rename ( String desc , Map map ) { if ( map == null ) return desc ; StringBuffer newdesc = new StringBuffer ( ) ; int head = 0 ; int i = 0 ; for ( ; ; ) { int j = desc . indexOf ( 'L' , i ) ; if ( j < 0 ) break ; int k = desc . indexOf ( ';' , j ) ; if ( k < 0 ) break ; i = k + 1 ; String name = desc . substring ( j + 1 , k ) ; String name2 = ( String ) map . get ( name ) ; if ( name2 != null ) { newdesc . append ( desc . substring ( head , j ) ) ; newdesc . append ( 'L' ) ; newdesc . append ( name2 ) ; newdesc . append ( ';' ) ; head = i ; } } if ( head == 0 ) return desc ; else { int len = desc . length ( ) ; if ( head < len ) newdesc . append ( desc . substring ( head , len ) ) ; return newdesc . toString ( ) ; } } 
public int referenceCount ( ) { return references . size ( ) ; } 
public static String capitalize ( String s ) { if ( Character . isLowerCase ( s . charAt ( 0 ) ) ) { return Character . toUpperCase ( s . charAt ( 0 ) ) + s . substring ( 1 ) ; } else { return s ; } } 
public static Collection < String > getValidUrns ( ) { return Collections . unmodifiableCollection ( validUrns ) ; } 
public java . io . OutputStream setAsciiStream ( long pos ) throws SerialException , SQLException { isValid ( ) ; if ( this . clob != null ) { return this . clob . setAsciiStream ( pos ) ; } else { throw new SerialException ( "Unsupported-operation.-SerialClob-cannot-" + "return-a-writable-ascii-stream-unless-instantiated-with-a-Clob-object-" + "that-has-a-setAsciiStream()-implementation" ) ; } } 
public static POILogger getLogger ( final String cat ) { POILogger logger = null ; if ( _loggerClassName == null ) { try { _loggerClassName = System . getProperty ( "org.apache.poi.util.POILogger" ) ; } catch ( Exception e ) { } if ( _loggerClassName == null ) { _loggerClassName = _nullLogger . getClass ( ) . getName ( ) ; } } if ( _loggerClassName . equals ( _nullLogger . getClass ( ) . getName ( ) ) ) { return _nullLogger ; } if ( _loggers . containsKey ( cat ) ) { logger = ( POILogger ) _loggers . get ( cat ) ; } else { try { Class loggerClass = Class . forName ( _loggerClassName ) ; logger = ( POILogger ) loggerClass . newInstance ( ) ; logger . initialize ( cat ) ; } catch ( Exception e ) { logger = _nullLogger ; } _loggers . put ( cat , logger ) ; } return logger ; } 
@ Override public double evaluate ( final double [ ] values , final int start , final int length ) { return evaluate ( values , start , length , quantile ) ; } 
public int getOffset ( long date ) { if ( inDaylightTime ( new Date ( date ) ) ) { return getRawOffset ( ) + getDSTSavings ( ) ; } return getRawOffset ( ) ; } 
public static void disposeImages ( ) { { for ( Image image : m_imageMap . values ( ) ) { image . dispose ( ) ; } m_imageMap . clear ( ) ; } for ( int i = 0 ; i < m_decoratedImageMap . length ; i ++ ) { Map < Image , Map < Image , Image >> cornerDecoratedImageMap = m_decoratedImageMap [ i ] ; if ( cornerDecoratedImageMap != null ) { for ( Map < Image , Image > decoratedMap : cornerDecoratedImageMap . values ( ) ) { for ( Image image : decoratedMap . values ( ) ) { image . dispose ( ) ; } decoratedMap . clear ( ) ; } cornerDecoratedImageMap . clear ( ) ; } } } 
public int codePointAt ( int index ) { if ( index < 0 || index >= count ) { throw indexAndLength ( index ) ; } return Character . codePointAt ( value , index , count ) ; } 
public int getEstimatedInLinesPerTest ( ) throws IOException { if ( estimatedInLinesPerTest != 0 ) return estimatedInLinesPerTest ; LineNumberReader inReader = new LineNumberReader ( new FileReader ( new File ( inputFile ) ) ) ; int numberOfTests = Integer . valueOf ( inReader . readLine ( ) ) ; while ( inReader . skip ( Long . MAX_VALUE ) > 0 ) ; inReader . close ( ) ; int totalInputLines = inReader . getLineNumber ( ) - 1 ; if ( totalInputLines % numberOfTests == 0 ) { return estimatedInLinesPerTest = totalInputLines / numberOfTests ; } return estimatedInLinesPerTest = - 1 ; } 
public final boolean isSpawnRegistered ( AutoSpawnInstance spawnInst ) { return _registeredSpawns . containsValue ( spawnInst ) ; } 
protected static final String addEscapes ( String str ) { StringBuffer retval = new StringBuffer ( ) ; char ch ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { switch ( str . charAt ( i ) ) { case 0 : continue ; case '|b' : retval . append ( "|b" ) ; continue ; case '|t' : retval . append ( "|t" ) ; continue ; case '|n' : retval . append ( "|n" ) ; continue ; case '|f' : retval . append ( "|f" ) ; continue ; case '|r' : retval . append ( "|r" ) ; continue ; case '|"' : retval . append ( "|"" ) ; continue ; case '|'' : retval . append ( "|'" ) ; continue ; case '|' : retval . append ( "||" ) ; continue ; default : if ( ( ch = str . charAt ( i ) ) < 0x20 || ch > 0x7e ) { String s = "0000" + Integer . toString ( ch , 16 ) ; retval . append ( "|u" + s . substring ( s . length ( ) - 4 , s . length ( ) ) ) ; } else { retval . append ( ch ) ; } continue ; } } return retval . toString ( ) ; } 
SubMap ( ConcurrentSkipListMap < K , V > map , K fromKey , boolean fromInclusive , K toKey , boolean toInclusive , boolean isDescending ) { if ( fromKey != null && toKey != null && map . compare ( fromKey , toKey ) > 0 ) throw new IllegalArgumentException ( "inconsistent-range" ) ; this . m = map ; this . lo = fromKey ; this . hi = toKey ; this . loInclusive = fromInclusive ; this . hiInclusive = toInclusive ; this . isDescending = isDescending ; } 
private boolean isBoolean ( String value ) { if ( value . equalsIgnoreCase ( "TRUE" ) || value . equalsIgnoreCase ( "FALSE" ) ) { return true ; } else { return false ; } } 
public static int getExternalNodeCount ( RootedTree tree , Node node ) { final List < Node > children = tree . getChildren ( node ) ; if ( children . size ( ) == 0 ) return 1 ; int externalNodeCount = 0 ; for ( Node child : children ) { externalNodeCount += getExternalNodeCount ( tree , child ) ; } return externalNodeCount ; } 
public void close ( ) throws IOException { TCPTransport . tcpLog . log ( Log . BRIEF , "close-connection" ) ; if ( socket != null ) socket . close ( ) ; else { in . close ( ) ; out . close ( ) ; } } 
static String getUnixUserName ( ) { return System . getProperty ( "user.name" ) ; } 
protected void logSoapMessage ( String logMessage , SoapMessage soapMessage , boolean incoming ) throws TransformerException { Transformer transformer = createIndentingTransformer ( ) ; StringWriter writer = new StringWriter ( ) ; transformer . transform ( soapMessage . getEnvelope ( ) . getSource ( ) , new StreamResult ( writer ) ) ; logMessage ( logMessage , XMLUtils . prettyPrint ( writer . toString ( ) ) , incoming ) ; } 
protected void updateComponent ( Component comp , Graphics g ) { if ( comp != null ) { ComponentPeer peer = comp . getPeer ( ) ; if ( peer != null ) { peer . paint ( g ) ; } super . updateComponent ( comp , g ) ; } } 
public void setTitle ( String title ) { String oldValue = this . title ; this . title = title ; propertyChangeSupport . firePropertyChange ( "title" , oldValue , title ) ; } 
protected Long addLongValue ( Object name , long inc ) { Long val = this . longCounters . get ( name ) ; Long retv = null ; if ( val == null ) { retv = new Long ( inc ) ; } else { retv = new Long ( val . longValue ( ) + inc ) ; } this . longCounters . put ( name , retv ) ; return retv ; } 
public static String classesNotSupported ( Class < ? > mapper ) { return MessageFormat . format ( "Mapper-''{0}''-could-not-be-configured-since-introspection-" + "factory-does-not-support-mapping-abstract-classes.-Use-ASM-factory." , mapper . getName ( ) ) ; } 
public static MediaType parse ( String string ) { Matcher typeSubtype = TYPE_SUBTYPE . matcher ( string ) ; if ( ! typeSubtype . lookingAt ( ) ) return null ; String type = typeSubtype . group ( 1 ) . toLowerCase ( Locale . US ) ; String subtype = typeSubtype . group ( 2 ) . toLowerCase ( Locale . US ) ; String charset = null ; Matcher parameter = PARAMETER . matcher ( string ) ; for ( int s = typeSubtype . end ( ) ; s < string . length ( ) ; s = parameter . end ( ) ) { parameter . region ( s , string . length ( ) ) ; if ( ! parameter . lookingAt ( ) ) return null ; String name = parameter . group ( 1 ) ; if ( name == null || ! name . equalsIgnoreCase ( "charset" ) ) continue ; if ( charset != null ) throw new IllegalArgumentException ( "Multiple-charsets:-" + string ) ; charset = parameter . group ( 2 ) != null ? parameter . group ( 2 ) : parameter . group ( 3 ) ; } return new MediaType ( string , type , subtype , charset ) ; } 
public static String getName ( DERObjectIdentifier oid ) { return names . get ( oid ) ; } 
static byte [ ] altBase64ToByteArray ( String s ) { return base64ToByteArray ( s , true ) ; } 
public final Result get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { return mFuture . get ( timeout , unit ) ; } 
@ Override public void unlock ( ) { if ( DEBUG ) Log . d ( TAG , "unlock()" ) ; mHandler . sendEmptyMessage ( MSG_UNLOCK ) ; } 
private static void usage ( ) { System . err . println ( "Usage:-java-benchmarks.detinfer.pj.edu.ritimage.test.Test02-<height>-<width>-<filename>" ) ; System . err . println ( "<height>-=-Image-height-(pixels)" ) ; System . err . println ( "<width>-=-Image-width-(pixels)" ) ; System . err . println ( "<filename>-=-PJG-image-file-name" ) ; System . exit ( 1 ) ; } 
public int getBooleanCount ( ) { return boolean_ . size ( ) ; } 
static < K , V > Entry < K , V > unmodifiableEntry ( final Entry < K , V > entry ) { checkNotNull ( entry ) ; return new AbstractMapEntry < K , V > ( ) { @ Override public K getKey ( ) { return entry . getKey ( ) ; } @ Override public V getValue ( ) { return entry . getValue ( ) ; } } ; } 
public RealLinearOperator sqrt ( ) { final RealVector sqrtDiag = diag . map ( new Sqrt ( ) ) ; return new RealLinearOperator ( ) { @ Override public RealVector operate ( final RealVector x ) { return new ArrayRealVector ( MathArrays . ebeDivide ( x . toArray ( ) , sqrtDiag . toArray ( ) ) , false ) ; } @ Override public int getRowDimension ( ) { return sqrtDiag . getDimension ( ) ; } @ Override public int getColumnDimension ( ) { return sqrtDiag . getDimension ( ) ; } } ; } 
public static int getType ( int codePoint ) { return CharacterData . of ( codePoint ) . getType ( codePoint ) ; } 
@ Deprecated public Reader ( FileSystem fs , String dirName , WritableComparator comparator , Configuration conf ) throws IOException { this ( new Path ( dirName ) , conf , comparator ( comparator ) ) ; } 
protected void addBooleanAttribute ( String elementName , String attrName , boolean hasDefaultValue , boolean defaultValue ) { List values = new ArrayList ( ) ; values . add ( "TRUE" ) ; values . add ( "FALSE" ) ; String dval = null ; if ( hasDefaultValue ) { dval = defaultValue ? "TRUE" : "FALSE" ; } addAttribute ( elementName , attrName , DATATYPE_BOOLEAN , true , dval , values ) ; } 
public static boolean isMac ( ) { String lcOSName = System . getProperty ( "os.name" ) . toLowerCase ( ) ; return lcOSName . indexOf ( "mac" ) != - 1 ; } 
public Object clone ( ) { if ( tracing ( ) ) { trace ( "ModelMBeanAttributeInfo.clone()" , "Entry" ) ; } return ( new ModelMBeanAttributeInfo ( this ) ) ; } 
public void texture ( Shape shape , Image image , float scaleX , float scaleY ) { texture ( shape , image , scaleX , scaleY , false ) ; } 
private SubMap < K , V > newSubMap ( K fromKey , boolean fromInclusive , K toKey , boolean toInclusive ) { if ( isDescending ) { K tk = fromKey ; fromKey = toKey ; toKey = tk ; boolean ti = fromInclusive ; fromInclusive = toInclusive ; toInclusive = ti ; } if ( lo != null ) { if ( fromKey == null ) { fromKey = lo ; fromInclusive = loInclusive ; } else { int c = m . compare ( fromKey , lo ) ; if ( c < 0 || ( c == 0 && ! loInclusive && fromInclusive ) ) throw new IllegalArgumentException ( "key-out-of-range" ) ; } } if ( hi != null ) { if ( toKey == null ) { toKey = hi ; toInclusive = hiInclusive ; } else { int c = m . compare ( toKey , hi ) ; if ( c > 0 || ( c == 0 && ! hiInclusive && toInclusive ) ) throw new IllegalArgumentException ( "key-out-of-range" ) ; } } return new SubMap < K , V > ( m , fromKey , fromInclusive , toKey , toInclusive , isDescending ) ; } 
public boolean contains ( Object o ) { if ( o == null ) return false ; final E [ ] items = this . items ; final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { int i = takeIndex ; int k = 0 ; while ( k ++ < count ) { if ( o . equals ( items [ i ] ) ) return true ; i = inc ( i ) ; } return false ; } finally { lock . unlock ( ) ; } } 
public Interval toInterval ( ) { return toInterval ( null ) ; } 
public static SnmpEngineId createEngineId ( int port , int iana ) throws UnknownHostException { InetAddress address = null ; address = InetAddress . getLocalHost ( ) ; return createEngineId ( address , port , iana ) ; } 
InputStream asStream ( Context context , DSpaceObject object , boolean emitPasswords ) throws IOException { PipedOutputStream outStream = new PipedOutputStream ( ) ; PipedInputStream inStream = new PipedInputStream ( outStream ) ; Serializer serializer = new Serializer ( context , object , outStream , emitPasswords ) ; new Thread ( serializer ) . start ( ) ; return inStream ; } 
public boolean add ( E e ) { return map . put ( e , PRESENT ) == null ; } 
protected void internalPut ( String key , String value ) { int lengthMask = keyTable . length - 1 ; int index = key . hashCode ( ) & lengthMask ; String currentKey ; while ( ( currentKey = keyTable [ index ] ) != null ) { if ( currentKey . equals ( key ) ) { valueTable [ index ] = value ; return ; } index = ( index + 1 ) & lengthMask ; } keyTable [ index ] = key ; valueTable [ index ] = value ; ++ elementSize ; } 
public static Map < String , Float > parseFieldBoosts ( String [ ] fieldLists ) { if ( null == fieldLists || 0 == fieldLists . length ) { return new HashMap < String , Float > ( ) ; } Map < String , Float > out = new HashMap < String , Float > ( 7 ) ; for ( String in : fieldLists ) { if ( null == in ) { continue ; } in = in . trim ( ) ; if ( in . length ( ) == 0 ) { continue ; } String [ ] bb = whitespacePattern . split ( in ) ; for ( String s : bb ) { String [ ] bbb = caratPattern . split ( s ) ; out . put ( bbb [ 0 ] , 1 == bbb . length ? null : Float . valueOf ( bbb [ 1 ] ) ) ; } } return out ; } 
public boolean unitAt ( ImmutablePoint position ) { return getUnitAt ( position ) != null ; } 
public synchronized void checkTimer ( ) { if ( watchDogTimer == null ) { if ( ! activeWrappers . isEmpty ( ) ) { LOGGER . debug ( "starting-up-" + THREAD_NAME + ",-" + setting_watchdogFrequency + "ms-check-frequency" ) ; watchDogTimer = new Timer ( THREAD_NAME , true ) ; watchDogTimer . schedule ( new WatchdogTask ( ) , setting_watchdogFrequency , setting_watchdogFrequency ) ; } } else { if ( activeWrappers . isEmpty ( ) ) { LOGGER . debug ( "exiting-" + THREAD_NAME + ",-no-connections-requiring-monitoring-are-in-use" ) ; watchDogTimer . cancel ( ) ; watchDogTimer = null ; } } } 
public static String toFullHexString ( long value ) { long currentValue = value ; StringBuilder sb = new StringBuilder ( 16 ) ; for ( int j = 0 ; j < 16 ; j ++ ) { int currentDigit = ( int ) currentValue & 0xf ; sb . append ( HEX_DIGITS [ currentDigit ] ) ; currentValue >>>= 4 ; } return sb . reverse ( ) . toString ( ) ; } 
String getNextReferral ( ) throws ReferralException { if ( debug ) System . out . println ( "LdapReferralException.getNextReferral" ) ; if ( hasMoreReferrals ( ) ) { return ( String ) referrals . elementAt ( referralIndex ++ ) ; } else if ( hasMoreReferralExceptions ( ) ) { throw nextReferralEx ; } else { return null ; } } 
public void setAxisLineStroke ( float stroke ) { this . axisLineStroke = stroke ; fireChangeEvent ( ) ; } 
public void layoutContainer ( Container parent ) { layoutComboBox ( parent , this ) ; } 
public File getPersonFilePath ( ) { Preferences prefs = Preferences . userNodeForPackage ( MainApp . class ) ; String filePath = prefs . get ( "filePath" , null ) ; if ( filePath != null ) { return new File ( filePath ) ; } else { return null ; } } 
protected BooleanControl ( Type type , boolean initialValue ) { this ( type , initialValue , "true" , "false" ) ; } 
protected final Color decodeColor ( Color color1 , Color color2 , float midPoint ) { return new Color ( NimbusLookAndFeel . deriveARGB ( color1 , color2 , midPoint ) ) ; } 
@ XmlElementDecl ( namespace = "http://www.sifassociation.org/au/datamodel/3.4" , name = "Status" , scope = LearningResourceType . class ) @ XmlJavaTypeAdapter ( NormalizedStringAdapter . class ) public JAXBElement < String > createLearningResourceTypeStatus ( String value ) { return new JAXBElement < String > ( _LearningResourceTypeStatus_QNAME , String . class , LearningResourceType . class , value ) ; } 
public final ShortBuffer put ( short [ ] src ) { return put ( src , 0 , src . length ) ; } 
private String normalisedVersion ( String version , String sep , int maxWidth ) { String [ ] split = Pattern . compile ( sep , Pattern . LITERAL ) . split ( version ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String s : split ) sb . append ( String . format ( "%" + maxWidth + 's' , s ) ) ; return sb . toString ( ) ; } 
public Name canonicalize ( ) { boolean canonical = true ; for ( int i = 0 ; i < name . length ; i ++ ) { if ( lowercase [ name [ i ] & 0xFF ] != name [ i ] ) { canonical = false ; break ; } } if ( canonical ) return this ; Name newname = new Name ( ) ; newname . appendSafe ( name , offset ( 0 ) , getlabels ( ) ) ; for ( int i = 0 ; i < newname . name . length ; i ++ ) newname . name [ i ] = lowercase [ newname . name [ i ] & 0xFF ] ; return newname ; } 
private void validateExceptions ( Method method ) throws IDLTypeException { Class [ ] exceptions = method . getExceptionTypes ( ) ; boolean declaresRemoteExceptionOrSuperClass = false ; for ( int eIndex = 0 ; eIndex < exceptions . length ; eIndex ++ ) { Class exception = exceptions [ eIndex ] ; if ( isRemoteExceptionOrSuperClass ( exception ) ) { declaresRemoteExceptionOrSuperClass = true ; break ; } } if ( ! declaresRemoteExceptionOrSuperClass ) { String msg = "Method-'" + method + "'-must-throw-at-least-one-" + "exception-of-type-java.rmi.RemoteException-or-one-of-its-" + "super-classes" ; throw new IDLTypeException ( msg ) ; } for ( int eIndex = 0 ; eIndex < exceptions . length ; eIndex ++ ) { Class exception = exceptions [ eIndex ] ; if ( isCheckedException ( exception ) && ! isValue ( exception ) && ! isRemoteException ( exception ) ) { String msg = "Exception-'" + exception + "'-on-method-'" + method + "'-is-not-a-allowed-RMI/IIOP-exception-type" ; throw new IDLTypeException ( msg ) ; } } return ; } 
private String getFilenameForKey ( String key ) { int firstHalfLength = key . length ( ) / 2 ; String localFilename = String . valueOf ( key . substring ( 0 , firstHalfLength ) . hashCode ( ) ) ; localFilename += String . valueOf ( key . substring ( firstHalfLength ) . hashCode ( ) ) ; return localFilename ; } 
private static SummaryAndText splitToSummaryAndOnymList ( String text ) { String meaning_summary = "" , onym_list = "" ; Matcher m = ptrn_summary_in_sense . matcher ( text ) ; if ( m . find ( ) ) { meaning_summary = m . group ( 1 ) ; onym_list = text . substring ( m . end ( ) ) ; } else { m = ptrn_summary_in_italics . matcher ( text ) ; if ( m . find ( ) ) { meaning_summary = m . group ( 1 ) ; onym_list = text . substring ( m . end ( ) ) ; } } if ( onym_list . length ( ) == 0 ) return null ; SummaryAndText st = new WRelationEn . SummaryAndText ( ) ; st . meaning_summary = meaning_summary ; st . onym_list = onym_list ; return st ; } 
public static void _main ( String [ ] argv ) throws Exception { JavaClass java_class ; String name = argv [ 0 ] ; if ( ( java_class = Repository . lookupClass ( name ) ) == null ) java_class = new ClassParser ( name ) . parse ( ) ; BCELifier bcelifier = new BCELifier ( java_class , System . out ) ; bcelifier . start ( ) ; } 
public void addPropertyChangeListener ( PropertyChangeListener listener ) { support . addPropertyChangeListener ( listener ) ; } 
public static boolean entBox ( Entity entA , Entity entB ) { Rectangle rectA = new Rectangle ( entA . getXOffset ( ) , entA . getYOffset ( ) , entA . width , entA . height ) ; Rectangle rectB = new Rectangle ( entB . getXOffset ( ) , entB . getYOffset ( ) , entB . width , entB . height ) ; if ( rectA . intersects ( rectB ) ) { return true ; } return false ; } 
public XmlEnum createXmlEnum ( ) { return new XmlEnum ( ) ; } 
public void marshal ( java . io . Writer out ) throws org . exolab . castor . xml . MarshalException , org . exolab . castor . xml . ValidationException { Marshaller . marshal ( this , out ) ; } 
public void readState ( DataInputStream stream ) throws IOException { int len = mt . length ; for ( int x = 0 ; x < len ; x ++ ) mt [ x ] = stream . readInt ( ) ; len = mag01 . length ; for ( int x = 0 ; x < len ; x ++ ) mag01 [ x ] = stream . readInt ( ) ; mti = stream . readInt ( ) ; __nextNextGaussian = stream . readDouble ( ) ; __haveNextNextGaussian = stream . readBoolean ( ) ; } 
public static String escapeHTML ( String string ) { if ( string == null ) { return null ; } StringBuffer sb = new StringBuffer ( ) ; boolean lastCharacterWasSpace = false ; char [ ] chars = string . toCharArray ( ) ; for ( char c : chars ) { if ( c == '-' ) { if ( lastCharacterWasSpace ) { lastCharacterWasSpace = false ; sb . append ( "&nbsp;" ) ; } else { lastCharacterWasSpace = true ; sb . append ( "-" ) ; } } else { lastCharacterWasSpace = false ; switch ( c ) { case '<' : sb . append ( "&lt;" ) ; break ; case '>' : sb . append ( "&gt;" ) ; break ; case '&' : sb . append ( "&amp;" ) ; break ; case '"' : sb . append ( "&quot;" ) ; break ; default : sb . append ( c ) ; break ; } } } return sb . toString ( ) ; } 
private String encodeUri ( String uri ) { String newUri = "" ; StringTokenizer st = new StringTokenizer ( uri , "/-" , true ) ; while ( st . hasMoreTokens ( ) ) { String tok = st . nextToken ( ) ; if ( tok . equals ( "/" ) ) newUri += "/" ; else if ( tok . equals ( "-" ) ) newUri += "%20" ; else { newUri += URLEncoder . encode ( tok ) ; } } return newUri ; } 
public boolean contains ( JComponent a , int b , int c ) { boolean returnValue = ( ( ComponentUI ) ( uis . elementAt ( 0 ) ) ) . contains ( a , b , c ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . contains ( a , b , c ) ; } return returnValue ; } 
public sparqles . avro . analytics . Index . Builder setEndpoint ( sparqles . avro . Endpoint value ) { validate ( fields ( ) [ 0 ] , value ) ; this . endpoint = value ; fieldSetFlags ( ) [ 0 ] = true ; return this ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public AbstractTool createFrame ( String name ) throws InstantiationException , IllegalAccessException , ClassNotFoundException , PropertyVetoException { AbstractTool ti = null ; String classname = ( String ) toolmap . get ( name ) ; ti = ( AbstractTool ) Class . forName ( classname ) . newInstance ( ) ; toolarray . add ( ti ) ; JInternalFrame f = ti . getInternalFrame ( ) ; f . setLocation ( locationX , locationY ) ; locationX += 25 ; if ( locationX > this . getWidth ( ) + 50 ) { locationX = 0 ; } locationY += 25 ; if ( locationY > this . getHeight ( ) + 50 ) { locationY = 0 ; } f . setVisible ( true ) ; desktop . add ( f ) ; f . setSelected ( true ) ; return ti ; } 
@ XmlElementDecl ( namespace = "" , name = "OriginalBudgetedCost" , scope = LineItem . class ) public JAXBElement < String > createLineItemOriginalBudgetedCost ( String value ) { return new JAXBElement < String > ( _LineItemOriginalBudgetedCost_QNAME , String . class , LineItem . class , value ) ; } 
public static boolean isInProjection ( String [ ] projection , String column ) { if ( projection == null ) { return true ; } for ( String test : projection ) { if ( column . equals ( test ) ) { return true ; } } return false ; } 
public Connection getConnection ( ) throws Exception { return DriverManager . getConnection ( "jdbc:mysql://localhost:3306/ST_JAVA" , "root" , "root" ) ; } 
public NotificationData fireNotification ( String eventType , String title , String message , Map < String , String > extra , byte [ ] icon , Object tag ) { Notification notification = notifications . get ( eventType ) ; if ( notification == null || ! notification . isActive ( ) ) return null ; NotificationData data = new NotificationData ( eventType , title , message , extra , icon , tag ) ; if ( notificationCache != null ) notificationCache . add ( data ) ; else fireNotification ( data ) ; return data ; } 
public void displayError ( final String title , final String message , final String button , final boolean exit ) { final CordovaActivity me = this ; me . runOnUiThread ( new Runnable ( ) { public void run ( ) { try { AlertDialog . Builder dlg = new AlertDialog . Builder ( me ) ; dlg . setMessage ( message ) ; dlg . setTitle ( title ) ; dlg . setCancelable ( false ) ; dlg . setPositiveButton ( button , new AlertDialog . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; if ( exit ) { finish ( ) ; } } } ) ; dlg . create ( ) ; dlg . show ( ) ; } catch ( Exception e ) { finish ( ) ; } } } ) ; } 
private final void performClearTaskAtIndexLocked ( int taskId , int i ) { while ( i < mHistory . size ( ) ) { ActivityRecord r = mHistory . get ( i ) ; if ( r . task . taskId != taskId ) { return ; } if ( r . finishing ) { i ++ ; continue ; } if ( ! finishActivityLocked ( r , i , Activity . RESULT_CANCELED , null , "clear" ) ) { i ++ ; } } } 
@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) public void blacklistNode ( int nodeId ) { Collection < Node > nodesInCluster = adminClient . getAdminClientCluster ( ) . getNodes ( ) ; if ( blackListedNodes == null ) { blackListedNodes = new ArrayList ( ) ; } blackListedNodes . add ( nodeId ) ; for ( Node node : nodesInCluster ) { if ( node . getId ( ) == nodeId ) { nodesToStream . remove ( node ) ; break ; } } for ( String store : storeNames ) { try { SocketAndStreams sands = nodeIdStoreToSocketAndStreams . get ( new Pair ( store , nodeId ) ) ; close ( sands . getSocket ( ) ) ; SocketDestination destination = nodeIdStoreToSocketRequest . get ( new Pair ( store , nodeId ) ) ; streamingSocketPool . checkin ( destination , sands ) ; } catch ( Exception ioE ) { logger . error ( ioE ) ; } } } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public static int parseInt ( IFXGNode node , String value , int min , int max ) throws NumberFormatException { int i = Integer . parseInt ( value ) ; if ( i >= min && i <= max ) { return i ; } throw new NumberFormatException ( "Integer-is-out-of-bounds" ) ; } 
protected void installListeners ( ) { if ( propertyChangeListener == null ) { propertyChangeListener = createPropertyChangeListener ( ) ; } frame . addPropertyChangeListener ( propertyChangeListener ) ; } 
public static void setResourceListeners ( Resource resource , Map listeners ) throws IntrospectionException , InvocationTargetException , IllegalAccessException , GateException { BeanInfo resBeanInfo = getBeanInfo ( resource . getClass ( ) ) ; EventSetDescriptor [ ] events = resBeanInfo . getEventSetDescriptors ( ) ; if ( events != null ) { EventSetDescriptor event ; for ( int i = 0 ; i < events . length ; i ++ ) { event = events [ i ] ; Object listener = listeners . get ( event . getListenerType ( ) . getName ( ) ) ; if ( listener != null ) { Method addListener = event . getAddListenerMethod ( ) ; Object [ ] args = new Object [ 1 ] ; args [ 0 ] = listener ; addListener . invoke ( resource , args ) ; } } } } 
void writeNonRoot ( DataOutput out ) throws IOException { out . writeInt ( blockKeys . size ( ) ) ; if ( secondaryIndexOffsetMarks . size ( ) != blockKeys . size ( ) ) { throw new IOException ( "Corrupted-block-index-chunk-writer:-" + blockKeys . size ( ) + "-entries-but-" + secondaryIndexOffsetMarks . size ( ) + "-secondary-index-items" ) ; } for ( int currentSecondaryIndex : secondaryIndexOffsetMarks ) out . writeInt ( currentSecondaryIndex ) ; out . writeInt ( curTotalNonRootEntrySize ) ; for ( int i = 0 ; i < blockKeys . size ( ) ; ++ i ) { out . writeLong ( blockOffsets . get ( i ) ) ; out . writeInt ( onDiskDataSizes . get ( i ) ) ; out . write ( blockKeys . get ( i ) ) ; } } 
public boolean isValue ( Object obj ) { if ( ! ( obj instanceof CompositeData ) ) { return false ; } CompositeData value = ( CompositeData ) obj ; CompositeType valueType = value . getCompositeType ( ) ; return this . isAssignableFrom ( valueType ) ; } 
public String [ ] getTypeArgumentBoundSignatures ( String type , int index ) { List < String > all = new ArrayList < String > ( ) ; IType [ ] supertypes = getSupertypes ( type ) ; if ( fUnit != null ) { for ( int i = 0 ; i < supertypes . length ; i ++ ) { try { TypeParameterResolver util = new TypeParameterResolver ( this ) ; String [ ] result = util . computeBinding ( supertypes [ i ] . getFullyQualifiedName ( ) , index ) ; all . addAll ( Arrays . asList ( result ) ) ; } catch ( JavaModelException e ) { } catch ( IndexOutOfBoundsException e ) { } } } if ( all . isEmpty ( ) ) return new String [ ] { Signature . createTypeSignature ( "java.lang.Object" , true ) } ; return all . toArray ( new String [ all . size ( ) ] ) ; } 
private boolean delete ( int i ) { checkInvariants ( ) ; final E [ ] elements = this . elements ; final int mask = elements . length - 1 ; final int h = head ; final int t = tail ; final int front = ( i - h ) & mask ; final int back = ( t - i ) & mask ; if ( front >= ( ( t - h ) & mask ) ) throw new ConcurrentModificationException ( ) ; if ( front < back ) { if ( h <= i ) { System . arraycopy ( elements , h , elements , h + 1 , front ) ; } else { System . arraycopy ( elements , 0 , elements , 1 , i ) ; elements [ 0 ] = elements [ mask ] ; System . arraycopy ( elements , h , elements , h + 1 , mask - h ) ; } elements [ h ] = null ; head = ( h + 1 ) & mask ; return false ; } else { if ( i < t ) { System . arraycopy ( elements , i + 1 , elements , i , back ) ; tail = t - 1 ; } else { System . arraycopy ( elements , i + 1 , elements , i , mask - i ) ; elements [ mask ] = elements [ 0 ] ; System . arraycopy ( elements , 1 , elements , 0 , t ) ; tail = ( t - 1 ) & mask ; } return true ; } } 
public void setComponentStyle ( String id , Style style ) { if ( id == null || id . length ( ) == 0 ) { id = "" ; } else { id = id + "." ; } styles . put ( id , style ) ; } 
public boolean isNodeDescendant ( DefaultMutableTreeNode anotherNode ) { if ( anotherNode == null ) return false ; return anotherNode . isNodeAncestor ( this ) ; } 
public static String getCSSClassByPercentage ( String val ) { if ( NO_DATA . equals ( val ) ) { return CLASS_METRIC_NODATA ; } else { try { float numberValue = Float . parseFloat ( val ) ; if ( numberValue < 50 ) { return CLASS_METRIC_LOW ; } else if ( numberValue < 70 ) { return CLASS_METRIC_AVERAGE ; } else if ( numberValue < 85 ) { return CLASS_METRIC_GOOD ; } else if ( numberValue < 100 ) { return CLASS_METRIC_VERY_GOOD ; } else if ( numberValue == 100 ) { return CLASS_METRIC_PERFECT ; } } catch ( Exception e ) { } } return null ; } 
public static void init ( String databaseName ) throws SQLException { db = DriverManager . getConnection ( "jdbc:sqlite:" + databaseName + ".db" ) ; } 
public URI ( String scheme , String authority , String path , String query , String fragment ) throws URISyntaxException { String s = toString ( scheme , null , authority , null , null , - 1 , path , query , fragment ) ; checkPath ( s , scheme , path ) ; new Parser ( s ) . parse ( false ) ; } 
private static void storeWordInBuffer ( ByteBuffer buffer , int wordSize , int index , int value ) { int wordIndex = index * wordSize ; if ( wordSize == SHORT_NUM_BYTES ) { buffer . putShort ( wordIndex , ( short ) value ) ; } else { buffer . putInt ( wordIndex , value ) ; } } 
public void addConfiguration ( String conf ) { confs . add ( conf ) ; } 
public boolean equals ( Object other ) { if ( this == other ) { return true ; } if ( other instanceof Certificate ) { try { return Arrays . equals ( this . getEncoded ( ) , ( ( Certificate ) other ) . getEncoded ( ) ) ; } catch ( CertificateEncodingException e ) { throw new RuntimeException ( e ) ; } } return false ; } 
public static Value literalValue ( boolean value , EscapeMode mode , boolean partiallyEscaped ) { return getIntValue ( mode , partiallyEscaped , value ? 1 : 0 ) ; } 
public long getLong ( String key ) throws JSONException { Object object = this . get ( key ) ; try { return object instanceof Number ? ( ( Number ) object ) . longValue ( ) : Long . parseLong ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONObject[" + quote ( key ) + "]-is-not-a-long." ) ; } } 
private static int toInt ( final String text ) { return Integer . valueOf ( text ) ; } 
public Iterator < TreeNode > getIterator ( ) { if ( children != null ) return children . iterator ( ) ; else return null ; } 
String PAGERID ( ) { return fileName != null ? fileName . getPath ( ) : null ; } 
public int getC_AcctSchema_ID ( ) { Integer ii = ( Integer ) get_Value ( "C_AcctSchema_ID" ) ; if ( ii == null ) return 0 ; return ii . intValue ( ) ; } 
public boolean handleApplicationWtf ( final IBinder app , final String tag , boolean system , final ApplicationErrorReport . CrashInfo crashInfo ) { final int callingUid = Binder . getCallingUid ( ) ; final int callingPid = Binder . getCallingPid ( ) ; if ( system ) { mHandler . post ( new Runnable ( ) { @ Override public void run ( ) { handleApplicationWtfInner ( callingUid , callingPid , app , tag , crashInfo ) ; } } ) ; return false ; } final ProcessRecord r = handleApplicationWtfInner ( callingUid , callingPid , app , tag , crashInfo ) ; if ( r != null && r . pid != Process . myPid ( ) && Settings . Global . getInt ( mContext . getContentResolver ( ) , Settings . Global . WTF_IS_FATAL , 0 ) != 0 ) { crashApplication ( r , crashInfo ) ; return true ; } else { return false ; } } 
boolean getCreatedDoubleBuffer ( ) { return getFlag ( CREATED_DOUBLE_BUFFER ) ; } 
public String toString ( ) { elapsedTime = System . currentTimeMillis ( ) - START_TIME ; StringBuilder str = new StringBuilder ( NEW_LINE ) ; TimeObject to ; final TreeMap < String , TimeObject > consoldatedTimerMap = otherTimers == null ? timingsMap : getConsolidatedTimings ( ) ; str . append ( "Total-time:-" + ( elapsedTime / 1000 ) + "s-(Overhead:-" + overheadTime + "ms)" ) ; final TreeMap < String , TimeObject > sortedMap = new TreeMap < String , TimeObject > ( ) ; for ( String key : consoldatedTimerMap . keySet ( ) ) { to = consoldatedTimerMap . get ( key ) ; sortedMap . put ( to . lineKey , to ) ; } for ( String key : sortedMap . keySet ( ) ) { to = sortedMap . get ( key ) ; str . append ( NEW_LINE ) . append ( getSpaces ( to . level , to . key . contains ( CAPTURE_SEPARATOR ) ) + to ) ; } return str . toString ( ) ; } 
final public List interfaceMemberDeclaration ( ) throws ParseException { Node node = null ; List list = new LinkedList ( ) ; if ( jj_2_15 ( 2147483647 ) ) { node = classDeclaration ( ) ; } else if ( jj_2_16 ( 2147483647 ) ) { node = interfaceDeclaration ( ) ; } else if ( jj_2_17 ( 2147483647 ) ) { node = methodDeclaration ( ) ; } else { switch ( this . jj_ntk == - 1 ? jj_ntk ( ) : this . jj_ntk ) { case ABSTRACT : case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FINAL : case FLOAT : case INT : case LONG : case NATIVE : case PRIVATE : case PROTECTED : case PUBLIC : case SHORT : case STATIC : case SYNCHRONIZED : case TRANSIENT : case VOLATILE : case IDENTIFIER : list = fieldDeclaration ( ) ; break ; default : this . jj_la1 [ 38 ] = this . jj_gen ; jj_consume_token ( - 1 ) ; throw new ParseException ( ) ; } } if ( node != null ) { list . add ( node ) ; } { if ( true ) { return list ; } } throw new Error ( "Missing-return-statement-in-function" ) ; } 
private Data readTop ( ) { if ( itemStack . size ( ) == 0 ) { return data ; } else { return ( ( Data ) itemStack . getLast ( ) ) ; } } 
public void addMouseListenerToTable ( ) { List < MouseListener > mouseListeners = Arrays . asList ( getTable ( ) . getMouseListeners ( ) ) ; if ( ! mouseListeners . contains ( jTableMouseListener ) ) { getTable ( ) . addMouseListener ( jTableMouseListener ) ; } } 
public com . google . protobuf . ByteString getLongFieldNameIsLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong823Bytes ( ) { java . lang . Object ref = longFieldNameIsLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong823_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; longFieldNameIsLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong823_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public String getComparisonString ( ) { return fieldName . toUpperCase ( ) ; } 
public Map < String , Object > getTuple ( ) { return tuples . get ( index ) ; } 
public static boolean isBetweenDateTime ( Date date , Date startDate , Date endDate ) { return ( date . equals ( startDate ) || date . after ( startDate ) ) && ( date . equals ( endDate ) || date . before ( endDate ) ) ; } 
public int valueForXPosition ( int xPos ) { int value ; final int minValue = slider . getMinimum ( ) ; final int maxValue = slider . getMaximum ( ) ; final int trackLength = trackRect . width ; final int trackLeft = trackRect . x ; final int trackRight = trackRect . x + ( trackRect . width - 1 ) ; if ( xPos <= trackLeft ) { value = drawInverted ( ) ? maxValue : minValue ; } else if ( xPos >= trackRight ) { value = drawInverted ( ) ? minValue : maxValue ; } else { int distanceFromTrackLeft = xPos - trackLeft ; double valueRange = ( double ) maxValue - ( double ) minValue ; double valuePerPixel = valueRange / ( double ) trackLength ; int valueFromTrackLeft = ( int ) Math . round ( distanceFromTrackLeft * valuePerPixel ) ; value = drawInverted ( ) ? maxValue - valueFromTrackLeft : minValue + valueFromTrackLeft ; } return value ; } 
@ JsxSetter public void setDirection ( final String direction ) { setStyleAttribute ( DIRECTION , direction ) ; } 
public static Bitmap decodeFile ( String pathName , Options opts ) { Bitmap bm = null ; InputStream stream = null ; try { stream = new FileInputStream ( pathName ) ; bm = decodeStream ( stream , null , opts ) ; } catch ( Exception e ) { } finally { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { } } } return bm ; } 
public XObject execute ( XPathContext xctxt , int currentNode , DTM dtm , int expType ) throws javax . xml . transform . TransformerException { if ( m_whatToShow == NodeTest . SHOW_BYFUNCTION ) { if ( null != m_relativePathPattern ) { return m_relativePathPattern . execute ( xctxt ) ; } else return NodeTest . SCORE_NONE ; } XObject score ; score = super . execute ( xctxt , currentNode , dtm , expType ) ; if ( score == NodeTest . SCORE_NONE ) return NodeTest . SCORE_NONE ; if ( getPredicateCount ( ) != 0 ) { if ( ! executePredicates ( xctxt , dtm , currentNode ) ) return NodeTest . SCORE_NONE ; } if ( null != m_relativePathPattern ) return m_relativePathPattern . executeRelativePathPattern ( xctxt , dtm , currentNode ) ; return score ; } 
public static < T > void sort ( T [ ] array , int start , int end , Comparator < ? super T > comparator ) { TimSort . sort ( array , start , end , comparator ) ; } 
public boolean containsKey ( Object key ) { Iterator entries = entrySet ( ) . iterator ( ) ; int pos = size ( ) ; while ( -- pos >= 0 ) if ( equals ( key , ( ( Map . Entry ) entries . next ( ) ) . getKey ( ) ) ) return true ; return false ; } 
@ XmlElementDecl ( namespace = "urn:vim25" , name = "InUseFeatureManipulationDisallowedFault" ) public JAXBElement < InUseFeatureManipulationDisallowed > createInUseFeatureManipulationDisallowedFault ( InUseFeatureManipulationDisallowed value ) { return new JAXBElement < InUseFeatureManipulationDisallowed > ( _InUseFeatureManipulationDisallowedFault_QNAME , InUseFeatureManipulationDisallowed . class , null , value ) ; } 
public Object clone ( ) throws CloneNotSupportedException { return ( IntStack ) super . clone ( ) ; } 
public ValueSanitizer getValueSanitizer ( String parameter ) { return mSanitizers . get ( parameter ) ; } 
public static Id fromRef ( String name ) { if ( ! name . startsWith ( REFS_CHANGES ) ) { throw new IllegalArgumentException ( "Not-a-PatchSet.Id:-" + name ) ; } final String [ ] parts = name . substring ( REFS_CHANGES . length ( ) ) . split ( "/" ) ; final int n = parts . length ; if ( n < 2 ) { throw new IllegalArgumentException ( "Not-a-PatchSet.Id:-" + name ) ; } final int changeId = Integer . parseInt ( parts [ n - 2 ] ) ; final int patchSetId = Integer . parseInt ( parts [ n - 1 ] ) ; return new PatchSet . Id ( new Change . Id ( changeId ) , patchSetId ) ; } 
public static String random ( int count , int [ ] chars ) { if ( count == 0 ) { return "" ; } else if ( count < 0 ) { throw new IllegalArgumentException ( "Requested-random-string-length-" + count + "-is-less-than-0." ) ; } if ( chars != null && chars . length == 0 ) { throw new IllegalArgumentException ( "The-chars-array-must-not-be-empty" ) ; } Random randomizer = new Random ( ) ; StringBuilder returnStr = new StringBuilder ( ) ; for ( int iterator = 0 ; iterator < count ; iterator ++ ) { returnStr . append ( Character . toChars ( chars [ randomizer . nextInt ( chars . length ) ] ) ) ; } return returnStr . toString ( ) ; } 
public Version ( String s ) throws java . text . ParseException { String [ ] parts = s . split ( "[.]" ) ; vers = new int [ parts . length ] ; try { for ( int i = 0 ; i < vers . length ; ++ i ) vers [ i ] = Integer . parseInt ( parts [ i ] ) ; } catch ( NumberFormatException e ) { throw new java . text . ParseException ( "Bad-version-number:-" + s , 0 ) ; } } 
public void setCount ( StringList ngram , int count ) { Integer oldCount = ( Integer ) mNGrams . put ( ngram , new Integer ( count ) ) ; if ( oldCount == null ) { mNGrams . remove ( ngram ) ; throw new NoSuchElementException ( ) ; } } 
public final void rotZ ( double angle ) { double sinAngle , cosAngle ; sinAngle = Math . sin ( angle ) ; cosAngle = Math . cos ( angle ) ; this . m00 = cosAngle ; this . m01 = - sinAngle ; this . m02 = 0.0 ; this . m03 = 0.0 ; this . m10 = sinAngle ; this . m11 = cosAngle ; this . m12 = 0.0 ; this . m13 = 0.0 ; this . m20 = 0.0 ; this . m21 = 0.0 ; this . m22 = 1.0 ; this . m23 = 0.0 ; this . m30 = 0.0 ; this . m31 = 0.0 ; this . m32 = 0.0 ; this . m33 = 1.0 ; } 
public void setCertificateValid ( Date certificateValid ) { this . certificateValid = ( certificateValid == null ) ? null : ( Date ) certificateValid . clone ( ) ; } 
public static boolean isLeapYear ( int year ) { return ( new GregorianCalendar ( ) ) . isLeapYear ( year ) ; } 
public byte [ ] getAuthorityKeyIdentifier ( ) { if ( authorityKeyIdentifier == null ) { return null ; } byte [ ] res = new byte [ authorityKeyIdentifier . length ] ; System . arraycopy ( authorityKeyIdentifier , 0 , res , 0 , res . length ) ; return res ; } 
public void setLeftComponent ( Component comp ) { if ( comp == null ) { if ( leftComponent != null ) { remove ( leftComponent ) ; leftComponent = null ; } } else { add ( comp , JSplitPane . LEFT ) ; } } 
public List < Agent > getReturn ( ) { if ( _return == null ) { _return = new ArrayList < Agent > ( ) ; } return this . _return ; } 
public void removeAllReport ( ) { _reportList . removeAllElements ( ) ; } 
public Font deriveFont ( int style , AffineTransform trans ) { AttributeValues newValues = getAttributeValues ( ) . clone ( ) ; int oldStyle = ( this . style != style ) ? this . style : - 1 ; applyStyle ( style , newValues ) ; applyTransform ( trans , newValues ) ; return new Font ( newValues , null , oldStyle , createdFont , font2DHandle ) ; } 
public double [ ] [ ] confusionMatrix ( ) { double [ ] [ ] newMatrix = new double [ m_ConfusionMatrix . length ] [ 0 ] ; for ( int i = 0 ; i < m_ConfusionMatrix . length ; i ++ ) { newMatrix [ i ] = new double [ m_ConfusionMatrix [ i ] . length ] ; System . arraycopy ( m_ConfusionMatrix [ i ] , 0 , newMatrix [ i ] , 0 , m_ConfusionMatrix [ i ] . length ) ; } return newMatrix ; } 
@ Deprecated public static IOFileFilter andFileFilter ( IOFileFilter filter1 , IOFileFilter filter2 ) { return new AndFileFilter ( filter1 , filter2 ) ; } 
public void init ( ) { initialise ( ) ; setLayout ( new GridLayout ( 3 , 2 ) ) ; inputTF = new TextField ( "sin(x^2)" , 50 ) ; outputTF = new TextField ( 50 ) ; outputTF . setEditable ( false ) ; varTF = new TextField ( "x" , 5 ) ; but = new Button ( "Calculate" ) ; but . addActionListener ( this ) ; inputTF . addActionListener ( this ) ; Panel p1 = new Panel ( ) ; p1 . add ( new Label ( "Differentiate:" ) ) ; p1 . add ( inputTF ) ; add ( p1 ) ; Panel p2 = new Panel ( ) ; p2 . add ( new Label ( "with-respect-to:" ) ) ; p2 . add ( varTF ) ; p2 . add ( but ) ; add ( p2 ) ; Panel p3 = new Panel ( ) ; p3 . add ( new Label ( "Result:" ) ) ; p3 . add ( outputTF ) ; add ( p3 ) ; } 
@ Override public synchronized void close ( ) throws IOException { if ( nnProxyInfo == null ) { return ; } if ( nnProxyInfo . proxy instanceof Closeable ) { ( ( Closeable ) nnProxyInfo . proxy ) . close ( ) ; } else { RPC . stopProxy ( nnProxyInfo . proxy ) ; } } 
@ ikvm . internal . HasCallerID public static java . util . Enumeration < Driver > getDrivers ( ) { java . util . Vector < Driver > result = new java . util . Vector < Driver > ( ) ; java . util . Vector drivers = null ; if ( ! initialized ) { initialize ( ) ; } synchronized ( DriverManager . class ) { drivers = readDrivers ; } ClassLoader callerCL = CallerID . getCallerID ( ) . getCallerClassLoader ( ) ; for ( int i = 0 ; i < drivers . size ( ) ; i ++ ) { DriverInfo di = ( DriverInfo ) drivers . elementAt ( i ) ; if ( getCallerClass ( callerCL , di . driverClassName ) != di . driverClass ) { println ( "-skipping:-" + di ) ; continue ; } result . addElement ( di . driver ) ; } return ( result . elements ( ) ) ; } 
public void GenerateReferenceSet ( List < Subset > ReferenceSet , int bestSolutions , int divSolutions ) { ReferenceSet = bubbleSubsetSort ( ReferenceSet ) ; BitSet allBits_RefSet = getAllBits ( ReferenceSet . subList ( 0 , bestSolutions ) ) ; int refSetlength = bestSolutions ; int total = bestSolutions + divSolutions ; while ( refSetlength < total ) { List < Integer > aux = new ArrayList < Integer > ( ) ; for ( int i = refSetlength ; i < ReferenceSet . size ( ) ; i ++ ) { aux . add ( SimetricDiference ( ( ( Subset ) ReferenceSet . get ( i ) ) . clone ( ) , allBits_RefSet ) ) ; } int mostDiv = getIndexofBiggest ( aux ) ; ReferenceSet . set ( refSetlength , ReferenceSet . get ( refSetlength + mostDiv ) ) ; refSetlength ++ ; allBits_RefSet = getAllBits ( ReferenceSet . subList ( 0 , refSetlength ) ) ; } ReferenceSet = filterSubset ( ReferenceSet , refSetlength ) ; } 
public static byte [ ] getBytes ( final Writable ... ws ) throws IOException { List < byte [ ] > bytes = new ArrayList < byte [ ] > ( ) ; int size = 0 ; for ( Writable w : ws ) { byte [ ] b = getBytes ( w ) ; size += b . length ; bytes . add ( b ) ; } byte [ ] result = new byte [ size ] ; int offset = 0 ; for ( byte [ ] b : bytes ) { System . arraycopy ( b , 0 , result , offset , b . length ) ; offset += b . length ; } return result ; } 
@ Override public List < CellInfo > getAllCellInfo ( ) { if ( mCi . getRilVersion ( ) >= 8 ) { return super . getAllCellInfo ( ) ; } else { ArrayList < CellInfo > arrayList = new ArrayList < CellInfo > ( ) ; CellInfo ci ; synchronized ( mCellInfo ) { arrayList . add ( mCellInfoLte ) ; } if ( DBG ) log ( "getAllCellInfo:-arrayList=" + arrayList ) ; return arrayList ; } } 
private ImageIcon createIcon ( final String resourceName , final boolean scale , final boolean large ) { final URL in = ObjectUtilities . getResource ( resourceName , ResourceBundleSupport . class ) ; ; if ( in == null ) { Log . warn ( "Unable-to-find-file-in-the-class-path:-" + resourceName ) ; return new ImageIcon ( createTransparentImage ( 1 , 1 ) ) ; } final Image img = Toolkit . getDefaultToolkit ( ) . createImage ( in ) ; if ( img == null ) { Log . warn ( "Unable-to-instantiate-the-image:-" + resourceName ) ; return new ImageIcon ( createTransparentImage ( 1 , 1 ) ) ; } if ( scale ) { if ( large ) { return new ImageIcon ( img . getScaledInstance ( 24 , 24 , Image . SCALE_SMOOTH ) ) ; } return new ImageIcon ( img . getScaledInstance ( 16 , 16 , Image . SCALE_SMOOTH ) ) ; } return new ImageIcon ( img ) ; } 
public static String removeExtraBlanks ( String string ) { StringBuffer sb = new StringBuffer ( ) ; Vector tokens = tokenize ( string , "-" ) ; for ( int i = 0 ; i < tokens . size ( ) ; i ++ ) { if ( ! tokens . elementAt ( i ) . equals ( "" ) ) { sb . append ( ( String ) tokens . elementAt ( i ) + "-" ) ; } } return sb . toString ( ) . trim ( ) ; } 
public boolean exists ( ) { if ( IS_USE_HASHMAP ) { return _fileMap . get ( _pathname ) != null ; } else { EntityManager em = _entityManager ; Query query = em . createQuery ( "SELECT-FROM-" + DatastoreFile . class + "-WHERE-_pathname-=-:name" ) ; query . setParameter ( "name" , _pathname ) ; List resultList = query . getResultList ( ) ; return resultList . size ( ) > 0 ; } } 
public static < T extends MessageLite > T parseAndClose ( InputStream inputStream , Class < T > messageClass ) throws IOException { try { Method newBuilder = messageClass . getDeclaredMethod ( "parseFrom" , InputStream . class ) ; return messageClass . cast ( newBuilder . invoke ( null , inputStream ) ) ; } catch ( Exception e ) { Throwables . propagateIfPossible ( e , IOException . class ) ; IOException io = new IOException ( "Error-parsing-message-of-type-" + messageClass ) ; io . initCause ( e ) ; throw io ; } finally { inputStream . close ( ) ; } } 
public void setRequestUpdate ( String table , HashMap < String , String > values , String where ) { String tempRequest = "UPDATE-" + table + "-SET-" ; Iterator mIterator = values . keySet ( ) . iterator ( ) ; while ( mIterator . hasNext ( ) ) { String key = ( String ) mIterator . next ( ) ; String value = ( String ) values . get ( key ) ; if ( mIterator . hasNext ( ) ) tempRequest += key + "-=-'" + value + "',-" ; else tempRequest += key + "-=-'" + value + "'" ; } tempRequest += "-WHERE-" + where ; this . request = tempRequest ; } 
public String getToolTipText ( ) { checkWidget ( ) ; return toolTipText ; } 
public boolean equals ( String string1 , String string2 ) { return compare ( string1 , string2 ) == 0 ; } 
public long getMinimumOperationsPerPeriod ( TokenType type , CTSOperation operation ) { if ( ! tokenOperations . containsKey ( type ) ) { return 0L ; } return tokenOperations . get ( type ) . getMinRate ( operation ) ; } 
public void removeListener ( Listener listener ) { if ( listener != null ) { mListeners . remove ( listener ) ; } } 
public Type getReturnType ( ) { return Type . getReturnType ( desc ) ; } 
public int getSeconds ( ) { return getFieldValueAsInt ( DatatypeConstants . SECONDS ) ; } 
public static void supportSASLMechanism ( String name , int index ) { mechanismsPreferences . add ( index , name ) ; } 
public static boolean exists ( String file ) { File f = new File ( file ) ; return f . exists ( ) ; } 
public static void makeAccessible ( Method method ) { if ( ( ! Modifier . isPublic ( method . getModifiers ( ) ) || ! Modifier . isPublic ( method . getDeclaringClass ( ) . getModifiers ( ) ) ) && ! method . isAccessible ( ) ) { method . setAccessible ( true ) ; } } 
public String getAccessibleColumnHeader ( int c ) { if ( validateIfNecessary ( ) ) { TableCellElementInfo cellInfo = getCell ( 0 , c ) ; if ( cellInfo . isHeaderCell ( ) ) { View v = cellInfo . getView ( ) ; if ( v != null && model != null ) { try { return model . getText ( v . getStartOffset ( ) , v . getEndOffset ( ) - v . getStartOffset ( ) ) ; } catch ( BadLocationException e ) { return null ; } } } } return null ; } 
public static byte toByte ( final String s ) { return Byte . parseByte ( s ) ; } 
public boolean hasReceivedWrites ( ) { return ! mBuffer . isEmpty ( ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public void close ( ) throws IOException { this . key . channel ( ) . close ( ) ; } 
@ XmlElementDecl ( namespace = "" , name = "CountryId" ) public JAXBElement < Long > createCountryId ( Long value ) { return new JAXBElement < Long > ( _CountryId_QNAME , Long . class , null , value ) ; } 
@ SuppressWarnings ( "unchecked" ) private void mergeAt ( int i ) { if ( DEBUG ) assert stackSize >= 2 ; if ( DEBUG ) assert i >= 0 ; if ( DEBUG ) assert i == stackSize - 2 || i == stackSize - 3 ; int base1 = runBase [ i ] ; int len1 = runLen [ i ] ; int base2 = runBase [ i + 1 ] ; int len2 = runLen [ i + 1 ] ; if ( DEBUG ) assert len1 > 0 && len2 > 0 ; if ( DEBUG ) assert base1 + len1 == base2 ; runLen [ i ] = len1 + len2 ; if ( i == stackSize - 3 ) { runBase [ i + 1 ] = runBase [ i + 2 ] ; runLen [ i + 1 ] = runLen [ i + 2 ] ; } stackSize -- ; int k = gallopRight ( ( Comparable < Object > ) a [ base2 ] , a , base1 , len1 , 0 ) ; if ( DEBUG ) assert k >= 0 ; base1 += k ; len1 -= k ; if ( len1 == 0 ) return ; len2 = gallopLeft ( ( Comparable < Object > ) a [ base1 + len1 - 1 ] , a , base2 , len2 , len2 - 1 ) ; if ( DEBUG ) assert len2 >= 0 ; if ( len2 == 0 ) return ; if ( len1 <= len2 ) mergeLo ( base1 , len1 , base2 , len2 ) ; else mergeHi ( base1 , len1 , base2 , len2 ) ; } 
public double getLength ( ) { return Math . sqrt ( ( this . x * this . x ) + ( this . y * this . y ) ) ; } 
public PointVectorValuePair [ ] getOptima ( ) { if ( optima == null ) { throw new MathIllegalStateException ( LocalizedFormats . NO_OPTIMUM_COMPUTED_YET ) ; } return optima . clone ( ) ; } 
public synchronized Certificate engineGetCertificate ( String alias ) { token . ensureValid ( ) ; AliasInfo aliasInfo = aliasMap . get ( alias ) ; if ( aliasInfo == null ) { return null ; } return aliasInfo . cert ; } 
void writeComment ( String string ) throws IOException { write ( "<!--" ) ; if ( string != null ) { write ( string ) ; } write ( "-->" ) ; writeLineSeparator ( ) ; indentSmart ( ) ; } 
public static byte [ ] subarray ( byte [ ] array , int startIndexInclusive , int endIndexExclusive ) { if ( array == null ) { return null ; } if ( startIndexInclusive < 0 ) { startIndexInclusive = 0 ; } if ( endIndexExclusive > array . length ) { endIndexExclusive = array . length ; } int newSize = endIndexExclusive - startIndexInclusive ; if ( newSize <= 0 ) { return EMPTY_BYTE_ARRAY ; } byte [ ] subarray = new byte [ newSize ] ; System . arraycopy ( array , startIndexInclusive , subarray , 0 , newSize ) ; return subarray ; } 
public void dump ( DataOutputStream out ) throws IOException { out . writeByte ( opcode ) ; if ( length == 2 ) out . writeByte ( index ) ; else out . writeShort ( index ) ; } 
public Dimension getSize ( ) { return new Dimension ( width , height ) ; } 
public synchronized void disablePlatformNotifications ( ) { if ( HttpLog . LOGV ) HttpLog . v ( "RequestQueue.disablePlatformNotifications()-network" ) ; if ( mProxyChangeReceiver != null ) { mContext . unregisterReceiver ( mProxyChangeReceiver ) ; mProxyChangeReceiver = null ; } } 
public List < List < ObjectInstance >> getAllObjectsByTrueClass ( ) { return new ArrayList < List < ObjectInstance >> ( objectIndexByTrueClass . values ( ) ) ; } 
public void cancelAllAndWait ( ) throws PhoneCommunicationException { synchronized ( this ) { if ( ! executorService . isShutdown ( ) ) { try { executorService . shutdownNow ( ) ; } catch ( SecurityException e ) { if ( DEBUG ) { System . out . println ( "Unexpected-security-exception-while-cancelling-tasks.-Ignoring." ) ; } } } try { if ( DEBUG ) { System . out . println ( "Waiting-for-termination-after-a-cancellation..." ) ; } boolean cleanTermination = executorService . awaitTermination ( 15 , TimeUnit . SECONDS ) ; if ( ! cleanTermination ) { throw new PhoneCommunicationException ( "Not-all-outstanding-tasks-cancelled-(timeout)" ) ; } } catch ( InterruptedException e ) { throw new PhoneCommunicationException ( "Not-all-outstanding-tasks-cancelled:-" + e . getMessage ( ) ) ; } finally { if ( DEBUG ) { System . out . println ( "Starting-a-new-executor-service-after-a-cancellation." ) ; } executorService = Executors . newSingleThreadExecutor ( ) ; } } } 
static public byte [ ] decode ( final String base32 ) { int i , index , lookup , offset , digit ; byte [ ] bytes = new byte [ base32 . length ( ) * 5 / 8 ] ; for ( i = 0 , index = 0 , offset = 0 ; i < base32 . length ( ) ; i ++ ) { lookup = base32 . charAt ( i ) - '0' ; if ( lookup < 0 || lookup >= base32Lookup . length ) { continue ; } digit = base32Lookup [ lookup ] ; if ( digit == 0xFF ) { continue ; } if ( index <= 3 ) { index = ( index + 5 ) % 8 ; if ( index == 0 ) { bytes [ offset ] |= digit ; offset ++ ; if ( offset >= bytes . length ) break ; } else { bytes [ offset ] |= digit << ( 8 - index ) ; } } else { index = ( index + 5 ) % 8 ; bytes [ offset ] |= ( digit >>> index ) ; offset ++ ; if ( offset >= bytes . length ) { break ; } bytes [ offset ] |= digit << ( 8 - index ) ; } } return bytes ; } 
private static boolean isDeprecatedFunction ( Node n ) { if ( n . isFunction ( ) ) { JSType type = n . getJSType ( ) ; if ( type != null ) { return getTypeDeprecationInfo ( type ) != null ; } } return false ; } 
public R visitPackage ( PackageElement e , P p ) { return defaultAction ( e , p ) ; } 
public void addSoundEvent ( State event , int resId ) { mSoundMap . put ( event , resId ) ; } 
public static ParcelUuid parseUuidFrom ( byte [ ] uuidBytes ) { if ( uuidBytes == null ) { throw new IllegalArgumentException ( "uuidBytes-cannot-be-null" ) ; } int length = uuidBytes . length ; if ( length != UUID_BYTES_16_BIT && length != UUID_BYTES_32_BIT && length != UUID_BYTES_128_BIT ) { throw new IllegalArgumentException ( "uuidBytes-length-invalid---" + length ) ; } if ( length == UUID_BYTES_128_BIT ) { ByteBuffer buf = ByteBuffer . wrap ( uuidBytes ) . order ( ByteOrder . LITTLE_ENDIAN ) ; long msb = buf . getLong ( 8 ) ; long lsb = buf . getLong ( 0 ) ; return new ParcelUuid ( new UUID ( msb , lsb ) ) ; } long shortUuid ; if ( length == UUID_BYTES_16_BIT ) { shortUuid = uuidBytes [ 0 ] & 0xFF ; shortUuid += ( uuidBytes [ 1 ] & 0xFF ) << 8 ; } else { shortUuid = uuidBytes [ 0 ] & 0xFF ; shortUuid += ( uuidBytes [ 1 ] & 0xFF ) << 8 ; shortUuid += ( uuidBytes [ 2 ] & 0xFF ) << 16 ; shortUuid += ( uuidBytes [ 3 ] & 0xFF ) << 24 ; } long msb = BASE_UUID . getUuid ( ) . getMostSignificantBits ( ) + ( shortUuid << 32 ) ; long lsb = BASE_UUID . getUuid ( ) . getLeastSignificantBits ( ) ; return new ParcelUuid ( new UUID ( msb , lsb ) ) ; } 
public Relationship createRelationship ( ) { return new Relationship ( ) ; } 
public boolean isDefined ( Object key ) { if ( key instanceof StyleConstants ) { Object cssKey = css . styleConstantsKeyToCSSKey ( ( StyleConstants ) key ) ; if ( cssKey != null ) { key = cssKey ; } } return super . isDefined ( key ) ; } 
public void addFunction ( String name , Object fun ) { if ( _functions == null ) _functions = new HashMap ( ) ; _functions . put ( name , fun ) ; } 
public void addUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { mUpdateListeners = new ArrayList < AnimatorUpdateListener > ( ) ; } mUpdateListeners . add ( listener ) ; } 
public static Request newCustomAudienceThirdPartyIdRequest ( Session session , Context context , Callback callback ) { return newCustomAudienceThirdPartyIdRequest ( session , context , null , callback ) ; } 
public static String shadeDouble ( double d , double max ) { int a = ( int ) Math . floor ( d * 10 / max + 0.5 ) ; if ( a > 10 || a < 0 ) { String x = lnf . format ( d ) ; a = 5 - x . length ( ) ; for ( int i = 0 ; i < a ; i ++ ) { x += "-" ; } return "<" + x + ">" ; } return "[" + shades [ a ] + "]" ; } 
public RenderingTestSuite ( Class < ? > klass ) throws Throwable { super ( klass , Collections . < Runner > emptyList ( ) ) ; try { this . klassInstance = klass . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( "Failed-to-construct-instance-of-[" + klass . getName ( ) + "]" , e ) ; } Scope scopeAnnotation = klass . getAnnotation ( Scope . class ) ; String packagePrefix = "" ; String pattern = DEFAULT_PATTERN ; if ( scopeAnnotation != null ) { packagePrefix = scopeAnnotation . value ( ) ; pattern = scopeAnnotation . pattern ( ) ; } List < Object [ ] > parametersList = ( List < Object [ ] > ) GENERATOR . generateData ( packagePrefix , pattern ) ; for ( int i = 0 ; i < parametersList . size ( ) ; i ++ ) { this . runners . add ( new TestClassRunnerForParameters ( RenderingTest . class , parametersList , i ) ) ; } } 
public int getNumberOfActivePills ( ) { return pills . cardinality ( ) ; } 
public static byte [ ] writeToArray ( NSObject root ) throws IOException { ByteArrayOutputStream bout = new ByteArrayOutputStream ( ) ; write ( bout , root ) ; return bout . toByteArray ( ) ; } 
public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; g . drawImage ( background , 0 , 0 , FRAMEWIDTH , FRAMEHEIGHT , null ) ; } 
public static Integer valueOf ( String s , int radix ) throws NumberFormatException { return new Integer ( parseInt ( s , radix ) ) ; } 
public File getCatalinaHomeDir ( ) { if ( catalinaHomeDir == null ) { String catalinaHome = System . getProperty ( "catalina.home" ) ; if ( catalinaHome != null ) { catalinaHomeDir = new File ( catalinaHome ) ; } } return catalinaHomeDir ; } 
public List < AnyOf > getAnyOf ( ) { if ( anyOf == null ) { anyOf = new ArrayList < AnyOf > ( ) ; } return this . anyOf ; } 
private JLabel getlblSubcontractor ( ) { if ( ivjlblSubcontractor == null ) { try { ivjlblSubcontractor = new JLabel ( ) ; ivjlblSubcontractor . setName ( "lblSubcontractor" ) ; ivjlblSubcontractor . setText ( "001-Education-Credit-Union---Rev" ) ; ivjlblSubcontractor . setMaximumSize ( new java . awt . Dimension ( 159 , 14 ) ) ; ivjlblSubcontractor . setMinimumSize ( new java . awt . Dimension ( 159 , 14 ) ) ; ivjlblSubcontractor . setBounds ( 123 , 7 , 447 , 14 ) ; } catch ( Throwable aeIVJEx ) { handleException ( aeIVJEx ) ; } } return ivjlblSubcontractor ; } 
public static byte [ ] decode ( byte [ ] input , int offset , int len , int flags ) { Decoder decoder = new Decoder ( flags , new byte [ len * 3 / 4 ] ) ; if ( ! decoder . process ( input , offset , len , true ) ) { throw new IllegalArgumentException ( "bad-base-64" ) ; } if ( decoder . op == decoder . output . length ) { return decoder . output ; } byte [ ] temp = new byte [ decoder . op ] ; System . arraycopy ( decoder . output , 0 , temp , 0 , decoder . op ) ; return temp ; } 
public static Object deserialize ( byte [ ] bytes ) { if ( bytes == null ) { return null ; } try { ObjectInputStream ois = new ObjectInputStream ( new ByteArrayInputStream ( bytes ) ) ; return ois . readObject ( ) ; } catch ( IOException ex ) { throw new IllegalArgumentException ( "Failed-to-deserialize-object" , ex ) ; } catch ( ClassNotFoundException ex ) { throw new IllegalStateException ( "Failed-to-deserialize-object-type" , ex ) ; } } 
public int getEntityCount ( ) { return entities . size ( ) ; } 
protected final void fireServiceAdded ( Class serviceClass ) { BeanContextServiceAvailableEvent bcssae = new BeanContextServiceAvailableEvent ( getBeanContextServicesPeer ( ) , serviceClass ) ; fireServiceAdded ( bcssae ) ; } 
public void addPropertyChangeListener ( final PropertyChangeListener listener ) { _listeners . addPropertyChangeListener ( listener ) ; } 
private int getInterval ( String key ) { return _config . getInt ( key . substring ( 0 , key . lastIndexOf ( "." ) ) + ".INTERVAL" , SimpleTrigger . REPEAT_INDEFINITELY ) ; } 
public String receiveMessage ( long timeoutMs ) throws InterruptedException , ExecutionException , TimeoutException { return Executors . newSingleThreadExecutor ( ) . submit ( new Callable < String > ( ) { public String call ( ) throws Exception { int received = 0 ; StringBuilder message = new StringBuilder ( ) ; while ( received < contentLength ) { int avail = inputStream . available ( ) ; if ( avail > 0 ) { byte [ ] buf = new byte [ avail ] ; received += inputStream . read ( buf , 0 , avail ) ; message . append ( new String ( buf ) ) ; } else { Thread . sleep ( 10L ) ; } } return message . toString ( ) ; } } ) . get ( timeoutMs , TimeUnit . MILLISECONDS ) ; } 
private void clearExceptionalCompletion ( ) { int h = System . identityHashCode ( this ) ; final ReentrantLock lock = exceptionTableLock ; lock . lock ( ) ; try { ExceptionNode [ ] t = exceptionTable ; int i = h & ( t . length - 1 ) ; ExceptionNode e = t [ i ] ; ExceptionNode pred = null ; while ( e != null ) { ExceptionNode next = e . next ; if ( e . get ( ) == this ) { if ( pred == null ) t [ i ] = next ; else pred . next = next ; break ; } pred = e ; e = next ; } expungeStaleExceptions ( ) ; status = 0 ; } finally { lock . unlock ( ) ; } } 
public int hashCode ( ) { int h = 0 ; for ( int j = size , i = 0 , t = 0 ; j -- != 0 ; ) { while ( ! used [ i ] ) i ++ ; t = it . unimi . dsi . fastutil . HashCommon . float2int ( key [ i ] ) ; if ( this != value [ i ] ) t ^= ( ( value [ i ] ) == null ? 0 : System . identityHashCode ( value [ i ] ) ) ; h += t ; i ++ ; } return h ; } 
@ JsxFunction public void initPointerEvent ( final String type , final boolean bubbles , final boolean cancelable , final Object view , final int detail , final int screenX , final int screenY , final int clientX , final int clientY , final boolean ctrlKey , final boolean altKey , final boolean shiftKey , final boolean metaKey , final int button , final Object relatedTarget , final int offsetX , final int offsetY , final int width , final int height , final Double pressure , final int rotation , final int tiltX , final int tiltY , final int pointerId , final String pointerType , final int hwTimestamp , final boolean isPrimary ) { super . initMouseEvent ( type , bubbles , cancelable , view , detail , screenX , screenY , clientX , clientY , ctrlKey , altKey , shiftKey , metaKey , button , relatedTarget ) ; width_ = width ; height_ = height ; pressure_ = pressure . doubleValue ( ) ; tiltX_ = tiltX ; tiltY_ = tiltY ; pointerId_ = pointerId ; pointerType_ = pointerType ; isPrimary_ = isPrimary ; } 
public static boolean isWhitespace ( String text ) { for ( int i = text . length ( ) - 1 ; i >= 0 ; i -- ) if ( ! XmlChar . isWhitespace ( text . charAt ( i ) ) ) return false ; return true ; } 
public static void randomPlayer ( ) { double playerOneSnap = Math . random ( ) ; double playerTwoSnap = Math . random ( ) ; if ( playerOneSnap > playerTwoSnap ) { System . out . println ( "Player-1-snap" ) ; playerOneHand . addAll ( deck ) ; } else { System . out . println ( "Player-2-snap" ) ; playerTwoHand . addAll ( deck ) ; } deck . clear ( ) ; } 
public void addEvent ( EventsOfOneEntity eventsOfOneEntity ) { allEvents . add ( eventsOfOneEntity ) ; } 
private static ResourceBundle getResourceBundle ( String enumClassName ) { String bundleName = enumClassName . replace ( '$' , '_' ) ; return ResourceBundle . getBundle ( bundleName ) ; } 
public static String rowToString ( JSONArray ja ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append ( ',' ) ; } Object o = ja . opt ( i ) ; if ( o != null ) { String s = o . toString ( ) ; if ( s . indexOf ( ',' ) >= 0 || s . indexOf ( '|n' ) >= 0 || s . indexOf ( '|r' ) >= 0 || s . indexOf ( 0 ) >= 0 || s . charAt ( 0 ) == '"' ) { sb . append ( '"' ) ; int length = s . length ( ) ; for ( int j = 0 ; j < length ; j += 1 ) { char c = s . charAt ( j ) ; if ( c >= '-' && c != '"' ) { sb . append ( c ) ; } } sb . append ( '"' ) ; } else { sb . append ( s ) ; } } } sb . append ( '|n' ) ; return sb . toString ( ) ; } 
public Enumeration listOptions ( ) { Vector newVector = new Vector ( ) ; newVector . addElement ( new Option ( "-Name-of-file-containing-network-structure-in-BIF-format-" , "B" , 1 , "-B-<BIF-File>" ) ) ; Enumeration en = super . listOptions ( ) ; while ( en . hasMoreElements ( ) ) newVector . addElement ( en . nextElement ( ) ) ; return newVector . elements ( ) ; } 
public int getIndexOf ( Object anObject ) { return objects . indexOf ( anObject ) ; } 
public Properties getOutputProperties ( ) { return _parser . getOutputProperties ( ) ; } 
public static String getAttachmentUrl ( String applicationId , UUID callId , String attachmentName ) { return String . format ( "%s%s/%s/%s" , ATTACHMENT_URL_BASE , applicationId , callId . toString ( ) , attachmentName ) ; } 
public int hashCode ( ) { int hashCode = new Long ( getChecksum ( ) ) . hashCode ( ) ; hashCode += super . hashCode ( ) ; return hashCode ; } 
public PrintWriter ( String fileName ) throws FileNotFoundException { this ( new OutputStreamWriter ( new BufferedOutputStream ( new FileOutputStream ( fileName ) ) ) , false ) ; } 
public static String getReplacementText ( Matcher m , CharSequence template ) { int cursor = 0 ; StringBuffer result = new StringBuffer ( ) ; while ( cursor < template . length ( ) ) { char nextChar = template . charAt ( cursor ) ; if ( nextChar == '|' ) { nextChar = template . charAt ( ++ cursor ) ; switch ( nextChar ) { case 'n' : nextChar = '|n' ; break ; case 't' : nextChar = '|t' ; break ; } result . append ( nextChar ) ; cursor ++ ; } else if ( nextChar == '$' ) { cursor ++ ; int refNum = template . charAt ( cursor ) - '0' ; if ( ( refNum < 0 ) || ( refNum > 9 ) ) { throw new IndexOutOfBoundsException ( "No-group-" + template . charAt ( cursor ) ) ; } cursor ++ ; boolean done = false ; while ( ! done ) { if ( cursor >= template . length ( ) ) { break ; } int nextDigit = template . charAt ( cursor ) - '0' ; if ( ( nextDigit < 0 ) || ( nextDigit > 9 ) ) { break ; } int newRefNum = ( refNum * 10 ) + nextDigit ; if ( m . groupCount ( ) < newRefNum ) { done = true ; } else { refNum = newRefNum ; cursor ++ ; } } if ( m . group ( refNum ) != null ) result . append ( m . group ( refNum ) ) ; } else { result . append ( nextChar ) ; cursor ++ ; } } return result . toString ( ) ; } 
public static void main ( String [ ] argv ) { print ( "SAX-features:" , SAX_FEATURE_PREFIX , fgSAXFeatures ) ; print ( "SAX-properties:" , SAX_PROPERTY_PREFIX , fgSAXProperties ) ; print ( "Xerces-features:" , XERCES_FEATURE_PREFIX , fgXercesFeatures ) ; print ( "Xerces-properties:" , XERCES_PROPERTY_PREFIX , fgXercesProperties ) ; } 
private Result pJavaInCBlock ( final int yyStart ) throws IOException { Result yyResult ; Node yyValue ; ParseError yyError = ParseError . DUMMY ; yyResult = pJavaInC ( yyStart ) ; yyError = yyResult . select ( yyError ) ; if ( yyResult . hasValue ( ) ) { yyResult = pJavaInJavaBlock ( yyResult . index ) ; yyError = yyResult . select ( yyError ) ; if ( yyResult . hasValue ( ) ) { final Node v$g$1 = yyResult . semanticValue ( ) ; yyValue = GNode . create ( "JavaInCBlock" , v$g$1 ) ; yyValue . setLocation ( location ( yyStart ) ) ; return yyResult . createValue ( yyValue , yyError ) ; } } return yyError ; } 
public static X509Certificate GenerateUserCertificate ( KeyPair userKeyPair , String subjectDN , String emailAddress , long duration ) throws CertificateEncodingException , InvalidKeyException , IllegalStateException , NoSuchAlgorithmException , SignatureException { return GenerateUserCertificate ( userKeyPair . getPublic ( ) , subjectDN , emailAddress , duration , userKeyPair . getPrivate ( ) ) ; } 
private static Map < String , String > getOptionsFromSelect ( String select , String responseBodyAsString ) { Map < String , String > toret = new LinkedHashMap < String , String > ( ) ; Pattern valuepattern = Pattern . compile ( "value="(.*)"" ) ; Pattern namepattern = Pattern . compile ( ">([^<]*)<" ) ; String [ ] lines = responseBodyAsString . split ( System . getProperty ( "line.separator" ) ) ; for ( String line : lines ) { if ( line . contains ( "<option" ) ) { Matcher mname = namepattern . matcher ( line ) ; if ( mname . find ( ) ) { String name = mname . group ( 1 ) ; if ( debug ) System . out . println ( "-found-option.-name=" + name + "-->-in-linewether" + line ) ; Matcher mvalue = valuepattern . matcher ( line ) ; if ( mvalue . find ( ) ) { String value = mvalue . group ( 1 ) ; if ( debug ) System . out . println ( "-found-value=" + value + "-->-in-line:-" + line ) ; value = value . replaceAll ( "&#x3a;" , ":" ) ; if ( debug ) System . out . println ( "-replaced-value=" + value ) ; toret . put ( name , value ) ; } } } } return toret ; } 
HTTPResponse ( HTTPClientModule [ ] modules , int timeout , Request orig ) { this . modules = modules ; this . timeout = timeout ; try { int qp = orig . getRequestURI ( ) . indexOf ( '?' ) ; this . OriginalURI = new URI ( orig . getConnection ( ) . getProtocol ( ) , null , orig . getConnection ( ) . getHost ( ) , orig . getConnection ( ) . getPort ( ) , qp < 0 ? orig . getRequestURI ( ) : orig . getRequestURI ( ) . substring ( 0 , qp ) , qp < 0 ? null : orig . getRequestURI ( ) . substring ( qp + 1 ) , null ) ; } catch ( ParseException pe ) { } this . method = orig . getMethod ( ) ; } 
public String getElementName ( ) { return getQualifiedName ( ) ; } 
public synchronized void removeItemListener ( ItemListener l ) { if ( l == null ) { return ; } itemListener = AWTEventMulticaster . remove ( itemListener , l ) ; } 
public void addXMLViewer ( String name , String content ) { JPanel panel = new JPanel ( ) ; panel . setLayout ( new BorderLayout ( ) ) ; final MyEditor codeEditor = new MyEditor ( false , MyEditor . TYPE_XML ) ; panel . add ( codeEditor , BorderLayout . CENTER ) ; panel . doLayout ( ) ; codeEditor . setContent ( content ) ; mapEditor . put ( name , codeEditor ) ; tabbedPane . addTab ( name , null , panel , null ) ; tabbedPane . setSelectedComponent ( panel ) ; } 
public static Condition getCondition ( final Bundle bundle , final ConditionInfo info ) { if ( ! CONDITION_TYPE . equals ( info . getType ( ) ) ) throw new IllegalArgumentException ( "ConditionInfo-must-be-of-type-"" + CONDITION_TYPE + """ ) ; String [ ] args = info . getArgs ( ) ; if ( args . length != 1 && args . length != 2 ) throw new IllegalArgumentException ( "Illegal-number-of-args:-" + args . length ) ; Map signers = bundle . getSignerCertificates ( Bundle . SIGNERS_TRUSTED ) ; boolean match = false ; for ( Iterator iSigners = signers . values ( ) . iterator ( ) ; iSigners . hasNext ( ) ; ) { List signerCerts = ( List ) iSigners . next ( ) ; List dnChain = new ArrayList ( signerCerts . size ( ) ) ; for ( Iterator iCerts = signerCerts . iterator ( ) ; iCerts . hasNext ( ) ; ) { dnChain . add ( ( ( X509Certificate ) iCerts . next ( ) ) . getSubjectDN ( ) . getName ( ) ) ; } if ( FrameworkUtil . matchDistinguishedNameChain ( args [ 0 ] , dnChain ) ) { match = true ; break ; } } boolean negate = ( args . length == 2 ) ? "!" . equals ( args [ 1 ] ) : false ; return negate ^ match ? Condition . TRUE : Condition . FALSE ; } 
public static byte [ ] decode ( byte [ ] source ) throws java . io . IOException { byte [ ] decoded = null ; decoded = decode ( source , 0 , source . length , Base64 . NO_OPTIONS ) ; return decoded ; } 
public static Element getFirstChildElement ( Element root ) { Node child = root . getFirstChild ( ) ; while ( child != null ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { return ( Element ) child ; } child = child . getNextSibling ( ) ; } return null ; } 
public URL getInfoURL ( ) throws MalformedURLException { return new URL ( "http://www.opensha.org/documentation/modelsImplemented/attenRel/CB_2003.html" ) ; } 
public boolean unregister ( ) { final MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; try { mbs . unregisterMBean ( mxbeanName ) ; } catch ( MBeanRegistrationException e ) { e . printStackTrace ( ) ; return false ; } catch ( InstanceNotFoundException e ) { e . printStackTrace ( ) ; return false ; } return true ; } 
public IIOMetadata getImageMetadata ( int imageIndex , String formatName , Set < String > nodeNames ) throws IOException { return getMetadata ( formatName , nodeNames , false , imageIndex ) ; } 
public static Vector3D estimateSpin ( final Rotation start , final Rotation end , final double dt ) { final Rotation evolution = start . applyTo ( end . revert ( ) ) ; return new Vector3D ( evolution . getAngle ( ) / dt , evolution . getAxis ( ) ) ; } 
private void writeObject ( ObjectOutputStream out ) throws IOException { if ( compat ) { ObjectOutputStream . PutField fields = out . putFields ( ) ; fields . put ( "consDescriptor" , consDescriptor ) ; fields . put ( "currClass" , currClass ) ; out . writeFields ( ) ; } else { out . defaultWriteObject ( ) ; } } 
public Object getObject ( ) throws SecurityException { if ( guard != null ) { guard . checkGuard ( object ) ; } return object ; } 
public Set < ConditionKeys > getAllKeys ( ) { return keys . keySet ( ) ; } 
public static < V , E > Graph < V , E > generateMixedRandomGraph ( Factory < Graph < V , E >> graphFactory , Factory < V > vertexFactory , Factory < E > edgeFactory , Map < E , Number > edge_weights , int num_vertices , boolean parallel , Set < V > seedVertices ) { int seed = ( int ) ( Math . random ( ) * 10000 ) ; BarabasiAlbertGenerator < V , E > bag = new BarabasiAlbertGenerator < V , E > ( graphFactory , vertexFactory , edgeFactory , 4 , 3 , seed , seedVertices ) ; bag . evolveGraph ( num_vertices - 4 ) ; Graph < V , E > ug = bag . create ( ) ; Graph < V , E > g = graphFactory . create ( ) ; for ( V v : ug . getVertices ( ) ) { g . addVertex ( v ) ; } for ( E e : ug . getEdges ( ) ) { V v1 = ug . getEndpoints ( e ) . getFirst ( ) ; V v2 = ug . getEndpoints ( e ) . getSecond ( ) ; E me = edgeFactory . create ( ) ; g . addEdge ( me , v1 , v2 , Math . random ( ) < .5 ? EdgeType . DIRECTED : EdgeType . UNDIRECTED ) ; edge_weights . put ( me , Math . random ( ) ) ; } return g ; } 
final boolean acquireQueued ( final Node node , int arg ) { try { boolean interrupted = false ; for ( ; ; ) { final Node p = node . predecessor ( ) ; if ( p == head && tryAcquire ( arg ) ) { setHead ( node ) ; p . next = null ; return interrupted ; } if ( shouldParkAfterFailedAcquire ( p , node ) && parkAndCheckInterrupt ( ) ) interrupted = true ; } } catch ( RuntimeException ex ) { cancelAcquire ( node ) ; throw ex ; } } 
public Elements unwrap ( ) { for ( Element element : contents ) { element . unwrap ( ) ; } return this ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public static JMenu createJMenu ( String name ) { final int idx = name . indexOf ( '&' ) ; char mnemonic = 0 ; if ( idx >= 0 ) { mnemonic = name . charAt ( idx + 1 ) ; name = name . substring ( 0 , idx ) + name . substring ( idx + 1 ) ; } final JMenu menu = new JMenu ( name ) ; if ( mnemonic != 0 ) menu . setMnemonic ( mnemonic ) ; return menu ; } 
public Float ( String string ) throws NumberFormatException { this ( parseFloat ( string ) ) ; } 
protected void paintBackgroundComponent ( Graphics g , Component component , Rectangle clip ) { try { g . setPaintMode ( ) ; Dimension dim = component . getPreferredSize ( ) ; rendererPane . paintComponent ( g , component , graph , 0 , 0 , ( int ) dim . getWidth ( ) , ( int ) dim . getHeight ( ) , true ) ; } catch ( Exception e ) { } catch ( Error e ) { } } 
public StrBuilder insert ( final int index , final int value ) { return insert ( index , String . valueOf ( value ) ) ; } 
public static String listToJson ( List < Group > pGroupSettings ) { String ret = ""groups":{" ; for ( Iterator < Group > iterator = pGroupSettings . iterator ( ) ; iterator . hasNext ( ) ; ) { Group setting = ( Group ) iterator . next ( ) ; String id = ParsingUtil . removeUninterestingParts ( setting . toString ( ) , "{id=" , ";name" , false ) ; ret += """ + id + "":" + setting . toJson ( ) ; if ( iterator . hasNext ( ) ) { ret += "," ; } } ret += "}" ; return ret ; } 
public Collection < NodeSubscription > getSubscriptions ( ) { return node . getSubscriptions ( jid ) ; } 
public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( DEBUG ) System . out . println ( "TransformerHandlerImpl#endElement:-" + qName ) ; if ( m_contentHandler != null ) { m_contentHandler . endElement ( uri , localName , qName ) ; } } 
public ServerSocket createSocket ( int port , int backlog ) throws IOException , KeyStoreException , NoSuchAlgorithmException , CertificateException , UnrecoverableKeyException , KeyManagementException { return ( new ServerSocket ( port , backlog ) ) ; } 
protected void setBody ( Object body , Message message ) throws JMSException , PersistenceException { MapMessage map = ( MapMessage ) message ; if ( body != null ) { if ( ! ( body instanceof Map ) ) { throw new JMSException ( "Expected-Map-body-for-MapMessage-with-JMSMessageID=" + message . getJMSMessageID ( ) + "-but-got-type-" + body . getClass ( ) . getName ( ) ) ; } Map properties = ( Map ) body ; Iterator iterator = properties . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) iterator . next ( ) ; String name = ( String ) entry . getKey ( ) ; Object value = entry . getValue ( ) ; map . setObject ( name , value ) ; } } } 
public void validate ( String content , ValidationContext context ) throws InvalidDatatypeValueException { if ( context . useNamespaces ( ) ) { if ( ! XML11Char . isXML11ValidNCName ( content ) ) { throw new InvalidDatatypeValueException ( "IDREFInvalidWithNamespaces" , new Object [ ] { content } ) ; } } else { if ( ! XML11Char . isXML11ValidName ( content ) ) { throw new InvalidDatatypeValueException ( "IDREFInvalid" , new Object [ ] { content } ) ; } } context . addIdRef ( content ) ; } 
@ Override public void close ( ) throws IOException { synchronized ( lock ) { if ( isClosed ( ) ) { return ; } Throwable thrown = null ; try { flushInternal ( ) ; } catch ( Throwable e ) { thrown = e ; } buf = null ; try { out . close ( ) ; } catch ( Throwable e ) { if ( thrown == null ) { thrown = e ; } } out = null ; if ( thrown != null ) { SneakyThrow . sneakyThrow ( thrown ) ; } } } 
public int addArrayClass ( ArrayType type ) { return addClass_ ( type . getSignature ( ) ) ; } 
@ Deprecated public long getDefaultBlockSize ( ) { return getConf ( ) . getLong ( "fs.local.block.size" , 32 * 1024 * 1024 ) ; } 
@ Override public SnmpInformRequest snmpInformRequest ( SnmpPeer peer , SnmpInformHandler cb , SnmpOid trapOid , SnmpVarBindList varBindList ) throws IllegalStateException , IOException , SnmpStatusException { SnmpParameters p = ( SnmpParameters ) peer . getParams ( ) ; return snmpInformRequest ( peer . getDestAddr ( ) , peer . getDestPort ( ) , p . getInformCommunity ( ) , cb , trapOid , varBindList ) ; } 
public void registerForUpdate ( final UpdateListener listener ) { synchronized ( listenerMutex ) { updateListeners . add ( listener ) ; } } 
private ByteArrayInputStream fetchUrl ( String urlString , Exception [ ] outException ) { URL url ; try { url = new URL ( urlString ) ; InputStream is = null ; int inc = 65536 ; int curr = 0 ; byte [ ] result = new byte [ inc ] ; try { is = url . openStream ( ) ; int n ; while ( ( n = is . read ( result , curr , result . length - curr ) ) != - 1 ) { curr += n ; if ( curr == result . length ) { byte [ ] temp = new byte [ curr + inc ] ; System . arraycopy ( result , 0 , temp , 0 , curr ) ; result = temp ; } } return new ByteArrayInputStream ( result , 0 , curr ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } catch ( Exception e ) { outException [ 0 ] = e ; } return null ; } 
public void setSavedInPageBreakPreview ( boolean p ) { field_1_options = savedInPageBreakPreview . setShortBoolean ( field_1_options , p ) ; } 
private int append ( FileSystem fs , Configuration conf , Path src , PrintWriter writer , int currentRecordNumber ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( fs . open ( src ) ) ) ; try { String line = reader . readLine ( ) ; while ( line != null ) { if ( line . startsWith ( "Recno::-" ) ) { line = "Recno::-" + currentRecordNumber ++ ; } writer . println ( line ) ; line = reader . readLine ( ) ; } return currentRecordNumber ; } finally { reader . close ( ) ; } } 
private int removeEmptyLocalVariables ( LocalVariableInfo [ ] localVariableInfos , int localVariableInfoCount , int maxLocals ) { int newIndex = 0 ; for ( int index = 0 ; index < localVariableInfoCount ; index ++ ) { LocalVariableInfo localVariableInfo = localVariableInfos [ index ] ; if ( localVariableInfo . u2length > 0 && localVariableInfo . u2index < maxLocals ) { localVariableInfos [ newIndex ++ ] = localVariableInfo ; } } Arrays . fill ( localVariableInfos , newIndex , localVariableInfoCount , null ) ; return newIndex ; } 
public boolean isSpecified ( String uri , String localName ) { int index = getIndex ( uri , localName ) ; if ( index < 0 ) throw new IllegalArgumentException ( "No-such-attribute:-local=" + localName + ",-namespace=" + uri ) ; return specified [ index ] ; } 
public void addCountListener ( CountListener listener ) { listenerCount . add ( listener ) ; } 
public void init ( ) { image = fontImage . getSubImage ( x , y , width , height ) ; } 
public Date getCreationDate ( ) { return new Date ( startDate ) ; } 
private void checkExcludedIP ( Set excluded , byte [ ] ip ) throws PKIXNameConstraintValidatorException { if ( excluded . isEmpty ( ) ) { return ; } Iterator it = excluded . iterator ( ) ; while ( it . hasNext ( ) ) { byte [ ] ipWithSubnet = ( byte [ ] ) it . next ( ) ; if ( isIPConstrained ( ip , ipWithSubnet ) ) { throw new PKIXNameConstraintValidatorException ( "IP-is-from-an-excluded-subtree." ) ; } } } 
public com . google . protobuf . ByteString getStorageIDBytes ( ) { java . lang . Object ref = storageID_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; storageID_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
private static BigDecimal zeroScaledBy ( long longScale ) { if ( longScale == ( int ) longScale ) { return valueOf ( 0 , ( int ) longScale ) ; } if ( longScale >= 0 ) { return new BigDecimal ( 0 , Integer . MAX_VALUE ) ; } return new BigDecimal ( 0 , Integer . MIN_VALUE ) ; } 
public void setPopupMenu ( ) { popup . add ( clearMenu ) ; popup . setLightWeightPopupEnabled ( true ) ; clearMenu . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { clearMessage ( ) ; } } ) ; } 
public List < DescriptionType > getDescription ( ) { if ( description == null ) { description = new ArrayList < DescriptionType > ( ) ; } return this . description ; } 
public AcNetId getAcNetId ( String idOnIvy ) { return acNetIdMap . get ( idOnIvy ) ; } 
public Constant equatesWithConstant ( String fldname ) { if ( lhs . isFieldName ( ) && lhs . asFieldName ( ) . equals ( fldname ) && rhs . isConstant ( ) ) return rhs . asConstant ( ) ; else if ( rhs . isFieldName ( ) && rhs . asFieldName ( ) . equals ( fldname ) && lhs . isConstant ( ) ) return lhs . asConstant ( ) ; else return null ; } 
@ XmlElementDecl ( namespace = "http://xmlns.oracle.com/apps/crmCommon/salesParties/salesPartiesService/" , name = "Attribute2" , scope = SalesAccountResource . class ) public JAXBElement < String > createSalesAccountResourceAttribute2 ( String value ) { return new JAXBElement < String > ( _SalesAccountResourceAttribute2_QNAME , String . class , SalesAccountResource . class , value ) ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
private char foldCase ( char ch ) { if ( ch < 128 ) { if ( 'A' <= ch && ch <= 'Z' ) { return ( char ) ( ch + ( 'a' - 'A' ) ) ; } return ch ; } return Character . toLowerCase ( Character . toUpperCase ( ch ) ) ; } 
public int getTextRunCursor ( String text , int contextStart , int contextEnd , int flags , int offset , int cursorOpt ) { if ( ( ( contextStart | contextEnd | offset | ( contextEnd - contextStart ) | ( offset - contextStart ) | ( contextEnd - offset ) | ( text . length ( ) - contextEnd ) | cursorOpt ) < 0 ) || cursorOpt > CURSOR_OPT_MAX_VALUE ) { throw new IndexOutOfBoundsException ( ) ; } return native_getTextRunCursor ( mNativePaint , text , contextStart , contextEnd , flags , offset , cursorOpt ) ; } 
public static < T extends Serializable > T deserializeObject ( DataInput in , Class < T > clazz ) throws IOException { byte [ ] buffer = new byte [ in . readInt ( ) ] ; in . readFully ( buffer ) ; return byteArrayToSerializable ( buffer , clazz , clazz . getClassLoader ( ) ) ; } 
public static String createXml ( Document document ) throws Exception { TransformerFactory transformerFactory = TransformerFactory . newInstance ( ) ; Transformer transformer = transformerFactory . newTransformer ( ) ; StringWriter stringWriter = new StringWriter ( ) ; StreamResult result = new StreamResult ( stringWriter ) ; DOMSource source = new DOMSource ( document ) ; transformer . transform ( source , result ) ; return stringWriter . toString ( ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public static Nucleotide getByCode ( String code ) { if ( code . length ( ) == 1 ) { return one2aa . get ( Character . toUpperCase ( code . charAt ( 0 ) ) ) ; } else if ( code . length ( ) == 2 ) { return two2aa . get ( code . toUpperCase ( ) ) ; } return null ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
protected void setTTester ( ) { m_TTester . setDisplayedResultsets ( null ) ; String name = ( new SimpleDateFormat ( "HH:mm:ss---" ) ) . format ( new Date ( ) ) + Messages . getInstance ( ) . getString ( "ResultsPanel_SetTTester_Name_Text" ) ; StringBuffer outBuff = new StringBuffer ( ) ; outBuff . append ( Messages . getInstance ( ) . getString ( "ResultsPanel_SetTTester_OutBuff_Text_First" ) + m_TTester . resultsetKey ( ) + "-" ) ; m_History . addResult ( name , outBuff ) ; m_History . setSingle ( name ) ; m_TestsModel . removeAllElements ( ) ; for ( int i = 0 ; i < m_TTester . getNumResultsets ( ) ; i ++ ) { String tname = m_TTester . getResultsetName ( i ) ; m_TestsModel . addElement ( tname ) ; } m_DisplayedModel . removeAllElements ( ) ; for ( int i = 0 ; i < m_TestsModel . size ( ) ; i ++ ) m_DisplayedModel . addElement ( m_TestsModel . elementAt ( i ) ) ; m_TestsModel . addElement ( Messages . getInstance ( ) . getString ( "ResultsPanel_SetTTester_TestsModel_Element_Text_First" ) ) ; m_TestsModel . addElement ( Messages . getInstance ( ) . getString ( "ResultsPanel_SetTTester_TestsModel_Element_Text_Second" ) ) ; m_TestsList . setSelectedIndex ( 0 ) ; m_DisplayedList . setSelectionInterval ( 0 , m_DisplayedModel . size ( ) - 1 ) ; m_TestsButton . setEnabled ( true ) ; m_DisplayedButton . setEnabled ( true ) ; m_ShowStdDevs . setEnabled ( true ) ; m_OutputFormatButton . setEnabled ( true ) ; m_PerformBut . setEnabled ( true ) ; } 
protected String dumpRemainingTokenQueue ( ) { int q = m_queueMark ; String returnMsg ; if ( q < m_ops . getTokenQueueSize ( ) ) { String msg = "-Remaining-tokens:-(" ; while ( q < m_ops . getTokenQueueSize ( ) ) { String t = ( String ) m_ops . m_tokenQueue . elementAt ( q ++ ) ; msg += ( "-'" + t + "'" ) ; } returnMsg = msg + ")" ; } else { returnMsg = "" ; } return returnMsg ; } 
protected void unregisterCursor ( Cursor cur ) { for ( Iterator it = _cursors . iterator ( ) ; it . hasNext ( ) ; ) { WeakReference ref = ( WeakReference ) it . next ( ) ; Cursor cursor = ( Cursor ) ref . get ( ) ; if ( cursor == null ) { it . remove ( ) ; } else if ( cursor == cur ) { ref . clear ( ) ; it . remove ( ) ; break ; } } } 
private static final int getShort ( final InputStream is ) throws IOException { return ( is . read ( ) << 8 ) + is . read ( ) ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public com . google . protobuf . ByteString getLongNameBytes ( ) { java . lang . Object ref = longName_ ; if ( ref instanceof java . lang . String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; longName_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public List < PartitionInfo > partitionsForTopic ( String topic ) { return this . partitionsByTopic . get ( topic ) ; } 
public String toString ( ) { try { return new String ( rawBytes , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( Logger . EVENT_FAILURE , "PlainText.toString()-failed:-Can't-find-UTF-8-byte-encoding!" , e ) ; throw new RuntimeException ( "Can't-find-UTF-8-byte-encoding!" , e ) ; } } 
private static boolean isUKSecondPartValid ( String secondPart ) { if ( secondPart . length ( ) == 3 ) { if ( Strings . isNumeric ( new String ( new char [ ] { secondPart . charAt ( 0 ) } ) ) ) { if ( Strings . isAlphabetic ( new String ( new char [ ] { secondPart . charAt ( 1 ) } ) ) ) { if ( Strings . isAlphabetic ( new String ( new char [ ] { secondPart . charAt ( 2 ) } ) ) ) { return true ; } } } } return false ; } 
public int getColumnCount ( ) { int colCount = 0 ; if ( validateIfNecessary ( ) ) { for ( int counter = 0 ; counter < getChildCount ( ) ; counter ++ ) { TableCellElementInfo cell = ( TableCellElementInfo ) getChild ( counter ) ; if ( cell . validateIfNecessary ( ) ) { colCount += cell . getColumnCount ( ) ; } } } return colCount ; } 
public long length ( ) throws SerialException { isValid ( ) ; return len ; } 
public void receiveComplete ( String id ) { Endpoint endpoint = endpointMap . get ( id ) ; events . offer ( new EndpointEvent ( id , endpoint == null ? "null" : endpoint . toString ( ) , EventType . RECEIVE_COMPLETE , System . currentTimeMillis ( ) ) ) ; } 
public StringBuffer append ( float f ) { return append ( String . valueOf ( f ) ) ; } 
public Bitmap toBitmap ( int width , int height , int inset , int color ) { final Bitmap bitmap = Bitmap . createBitmap ( width , height , Bitmap . Config . ARGB_8888 ) ; final Canvas canvas = new Canvas ( bitmap ) ; final Paint paint = new Paint ( ) ; paint . setAntiAlias ( BITMAP_RENDERING_ANTIALIAS ) ; paint . setDither ( BITMAP_RENDERING_DITHER ) ; paint . setColor ( color ) ; paint . setStyle ( Paint . Style . STROKE ) ; paint . setStrokeJoin ( Paint . Join . ROUND ) ; paint . setStrokeCap ( Paint . Cap . ROUND ) ; paint . setStrokeWidth ( BITMAP_RENDERING_WIDTH ) ; final Path path = toPath ( ) ; final RectF bounds = new RectF ( ) ; path . computeBounds ( bounds , true ) ; final float sx = ( width - 2 * inset ) / bounds . width ( ) ; final float sy = ( height - 2 * inset ) / bounds . height ( ) ; final float scale = sx > sy ? sy : sx ; paint . setStrokeWidth ( 2.0f / scale ) ; path . offset ( - bounds . left + ( width - bounds . width ( ) * scale ) / 2.0f , - bounds . top + ( height - bounds . height ( ) * scale ) / 2.0f ) ; canvas . translate ( inset , inset ) ; canvas . scale ( scale , scale ) ; canvas . drawPath ( path , paint ) ; return bitmap ; } 
public int indexOf ( byte b ) { return indexOf ( b , 0 , this . len ) ; } 
public static boolean create ( File destination , boolean isFile ) { if ( destination == null ) { return true ; } if ( isFile && destination . isFile ( ) ) { return true ; } else if ( ! isFile && destination . isDirectory ( ) ) { return true ; } boolean result = false ; if ( isFile ) { File dir = destination . getParentFile ( ) ; if ( ! dir . exists ( ) ) { result = dir . mkdirs ( ) ; if ( ! result ) { if ( enableLogging ) { FileSyncPlugin . log ( "Could-not-create-directory-'" + dir + "'" , null , IStatus . WARNING ) ; } return false ; } } try { result = destination . createNewFile ( ) ; } catch ( IOException e ) { if ( enableLogging ) { FileSyncPlugin . log ( "Could-not-create-file-'" + destination + "'" , e , IStatus . WARNING ) ; } } } else { result = destination . mkdirs ( ) ; if ( ! result && enableLogging ) { FileSyncPlugin . log ( "Could-not-create-directory-'" + destination + "'" , null , IStatus . WARNING ) ; } } return result ; } 
public int getScrollbarsMode ( ) { checkWidget ( ) ; return SWT . NONE ; } 
public float [ ] getBaselineOffsets ( ) { float [ ] offsets = new float [ baselineOffsets . length ] ; System . arraycopy ( baselineOffsets , 0 , offsets , 0 , offsets . length ) ; return offsets ; } 
protected TreeCellRenderer getCellRenderer ( ) { if ( currentCellRenderer != null ) return currentCellRenderer ; return createDefaultCellRenderer ( ) ; } 
public DefaultMutableTreeNode getFirstLeaf ( ) { DefaultMutableTreeNode node = this ; while ( ! node . isLeaf ( ) ) { node = ( DefaultMutableTreeNode ) node . getFirstChild ( ) ; } return node ; } 
public void removeAttribute ( String name ) { attributes . remove ( name ) ; } 
public Instruction getInstruction ( int index ) { try { return instructions . get ( index ) ; } catch ( IndexOutOfBoundsException e ) { return null ; } } 
public final List < ? > filter ( String filterName , Value ... filterArgs ) throws AerospikeException { return ( List < ? > ) client . execute ( policy , key , PackageName , "filter" , binName , userModule , Value . get ( filterName ) , Value . get ( filterArgs ) ) ; } 
public boolean copyValue ( FileAttribute attr ) { if ( attr == null ) { return false ; } attr . setFileSize ( size ) ; attr . setResourceID ( resourceId ) ; attr . setOwnerName ( ownerName ) ; attr . setUpdateTime ( lastUpdateTime ) ; attr . setRegistrationId ( id ) ; attr . setType ( type ) ; attr . setChecksum ( checksum ) ; attr . setCost ( cost ) ; attr . setMasterCopy ( masterCopy ) ; attr . setReadOnly ( readOnly ) ; attr . setName ( name ) ; attr . setCreationTime ( creationTime ) ; return true ; } 
void writeFileHeader ( ) throws IOException { Text . writeString ( out , keyClass . getName ( ) ) ; Text . writeString ( out , valClass . getName ( ) ) ; out . writeBoolean ( this . isCompressed ( ) ) ; out . writeBoolean ( this . isBlockCompressed ( ) ) ; if ( this . isCompressed ( ) ) { Text . writeString ( out , ( codec . getClass ( ) ) . getName ( ) ) ; } this . metadata . write ( out ) ; } 
private PopupMenu buildOptionsMenu ( View invoker ) { final PopupMenu popupMenu = new PopupMenu ( getActivity ( ) , invoker ) { @ Override public void show ( ) { final Menu menu = getMenu ( ) ; final MenuItem sendMessage = menu . findItem ( R . id . menu_send_message ) ; sendMessage . setVisible ( mSmsPackageComponentName != null ) ; boolean enable = ! isDigitsEmpty ( ) ; for ( int i = 0 ; i < menu . size ( ) ; i ++ ) { menu . getItem ( i ) . setEnabled ( enable ) ; } super . show ( ) ; } } ; popupMenu . inflate ( R . menu . dialpad_options ) ; popupMenu . setOnMenuItemClickListener ( this ) ; return popupMenu ; } 
public final void setOwnerActivity ( Activity activity ) { mOwnerActivity = activity ; getWindow ( ) . setVolumeControlStream ( mOwnerActivity . getVolumeControlStream ( ) ) ; } 
public String host ( Properties props ) { return props . getProperty ( HOST_PROPERTY_KEY , "localhost" ) ; } 
public void setSelectionByIds ( List < String > userIds ) { preSelectedFriendIds . addAll ( userIds ) ; } 
public static void executeReport ( long id , Map < String , String > params ) { String parameters = "" ; if ( ! params . isEmpty ( ) ) { for ( String key : params . keySet ( ) ) { parameters += "&" + key + "=" + params . get ( key ) ; } } final Element downloadIframe = RootPanel . get ( "__download" ) . getElement ( ) ; String url = RPCService . ReportServlet + "?" + "id=" + id + parameters ; DOM . setElementAttribute ( downloadIframe , "src" , url ) ; } 
public String getPasswordAttribute ( ) { if ( passwordAttributeMapper != null ) { Iterator < String > iter = passwordAttributeMapper . getLDAPAttributeTypes ( ) . iterator ( ) ; if ( iter . hasNext ( ) ) { return iter . next ( ) ; } } return null ; } 
private static File checkInstance ( Scriptable obj ) { if ( obj == null || ! ( obj instanceof File ) ) { throw Context . reportRuntimeError ( "called-on-incompatible-object" ) ; } return ( File ) obj ; } 
public List < Link > getProtectedLinks ( ) throws LinkNotFoundException { if ( isBackupLsp ( ) && this . getBackup ( ) . getProtectedLinks ( ) != null ) { List protectedLinks = this . getBackup ( ) . getProtectedLinks ( ) . getProtectedLink ( ) ; List < Link > linkList = new ArrayList < Link > ( protectedLinks . size ( ) ) ; for ( int i = 0 ; i < protectedLinks . size ( ) ; i ++ ) { linkList . add ( domain . getLink ( ( String ) protectedLinks . get ( i ) ) ) ; } return linkList ; } return null ; } 
public PCI . Record getRecord ( Connection c ) throws BadServerResponse , XenAPIException , XmlRpcException { String method_call = "PCI.get_record" ; String session = c . getSessionReference ( ) ; Object [ ] method_params = { Marshalling . toXMLRPC ( session ) , Marshalling . toXMLRPC ( this . ref ) } ; Map response = c . dispatch ( method_call , method_params ) ; Object result = response . get ( "Value" ) ; return Types . toPCIRecord ( result ) ; } 
public void clearFields ( ) { passText . setText ( "" ) ; confirmPassText . setText ( "" ) ; } 
public static void closeAll ( Closeable a , Closeable b ) throws IOException { Throwable thrown = null ; try { a . close ( ) ; } catch ( Throwable e ) { thrown = e ; } try { b . close ( ) ; } catch ( Throwable e ) { if ( thrown == null ) thrown = e ; } if ( thrown == null ) return ; if ( thrown instanceof IOException ) throw ( IOException ) thrown ; if ( thrown instanceof RuntimeException ) throw ( RuntimeException ) thrown ; if ( thrown instanceof Error ) throw ( Error ) thrown ; throw new AssertionError ( thrown ) ; } 
public void run ( ) { Command command = null ; try { command = ( Command ) ois . readObject ( ) ; if ( command . isSynchronous ( ) ) { Object result = command . execute ( ) ; oos . writeObject ( result ) ; oos . flush ( ) ; oos . close ( ) ; ois . close ( ) ; client . close ( ) ; } else { oos . close ( ) ; ois . close ( ) ; client . close ( ) ; command . execute ( ) ; } } catch ( Exception e ) { } } 
public static void prepareStructurePieces ( ) { structurePieceList = new ArrayList ( ) ; StructureStrongholdPieceWeight [ ] var0 = pieceWeightArray ; int var1 = var0 . length ; for ( int var2 = 0 ; var2 < var1 ; ++ var2 ) { StructureStrongholdPieceWeight var3 = var0 [ var2 ] ; var3 . instancesSpawned = 0 ; structurePieceList . add ( var3 ) ; } strongComponentType = null ; } 
public StringBuilder encodeBody ( StringBuilder buffer ) { return buffer . append ( contentEncoding ) ; } 
void handleCommand ( ) throws InputMismatchException { String command = scan . next ( ) ; if ( command . equals ( "new" ) ) { newWorld ( ) ; } else if ( command . equals ( "load" ) ) { String filename = scan . next ( ) ; loadWorld ( filename ) ; } else if ( command . equals ( "critters" ) ) { String filename = scan . next ( ) ; int n = scan . nextInt ( ) ; loadCritters ( filename , n ) ; } else if ( command . equals ( "step" ) ) { int n = scan . nextInt ( ) ; advanceTime ( n ) ; } else if ( command . equals ( "info" ) ) { worldInfo ( ) ; } else if ( command . equals ( "hex" ) ) { int c = scan . nextInt ( ) ; int r = scan . nextInt ( ) ; hexInfo ( c , r ) ; } else if ( command . equals ( "help" ) ) { printHelp ( ) ; } else if ( command . equals ( "exit" ) ) { done = true ; } else if ( command . equals ( "#print-all" ) ) { printAll ( ) ; } else if ( command . equals ( "#play" ) ) { play ( ) ; } else if ( command . equals ( "#customload" ) ) { String filename = scan . next ( ) ; int col = scan . nextInt ( ) ; int row = scan . nextInt ( ) ; customload ( filename , col , row ) ; } else System . out . println ( command + "-is-not-a-valid-command." ) ; } 
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || this . getClass ( ) != obj . getClass ( ) ) { return false ; } Subject that = ( Subject ) obj ; if ( principals . equals ( that . principals ) && publicCredentials . equals ( that . publicCredentials ) && privateCredentials . equals ( that . privateCredentials ) ) { return true ; } return false ; } 
public boolean handleWaterMovement ( ) { if ( this . worldObj . handleMaterialAcceleration ( this . getEntityBoundingBox ( ) , Material . water , this ) ) { if ( ! this . inWater && ! this . firstUpdate ) { this . resetHeight ( ) ; } this . inWater = true ; } else { this . inWater = false ; } return this . inWater ; } 
private boolean confirmOverwrite ( File f ) throws CancelledException { String title = s_stringMgr . getString ( "ExportPanel.confirmoverwritetitle" ) ; String message = s_stringMgr . getString ( "ExportPanel.confirmoverwritemsg" , f . getAbsolutePath ( ) ) ; int option = JOptionPane . showConfirmDialog ( SwingUtilities . getRoot ( _panel ) , message , title , JOptionPane . YES_NO_CANCEL_OPTION ) ; if ( option == JOptionPane . OK_OPTION ) { return true ; } if ( option == JOptionPane . CANCEL_OPTION ) { throw new CancelledException ( ) ; } return false ; } 
public void dumpToStdout ( ) { int oldRegCount = interference . size ( ) ; for ( int i = 0 ; i < oldRegCount ; i ++ ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "Reg-" + i + ":" + interference . get ( i ) . toString ( ) ) ; System . out . println ( sb . toString ( ) ) ; } } 
public static Method getGetterMethod ( final Class < ? > beanClass , final String key ) { if ( beanClass == null ) { throw new IllegalArgumentException ( "beanClass-is-null." ) ; } if ( key == null ) { throw new IllegalArgumentException ( "key-is-null." ) ; } if ( key . length ( ) == 0 ) { throw new IllegalArgumentException ( "key-is-empty." ) ; } String keyUpdated = Character . toUpperCase ( key . charAt ( 0 ) ) + key . substring ( 1 ) ; Method getterMethod = null ; try { getterMethod = beanClass . getMethod ( GET_PREFIX + keyUpdated ) ; } catch ( NoSuchMethodException exception ) { } if ( getterMethod == null ) { try { getterMethod = beanClass . getMethod ( IS_PREFIX + keyUpdated ) ; } catch ( NoSuchMethodException exception ) { } } return getterMethod ; } 
public void paint ( Graphics g , JComponent c ) { Iterator iterator = uis . iterator ( ) ; while ( iterator . hasNext ( ) ) { ComponentUI ui = ( ComponentUI ) iterator . next ( ) ; ui . paint ( g , c ) ; } } 
public void setParent ( XMLReader parent ) { super . setParent ( parent ) ; if ( null != parent . getContentHandler ( ) ) this . setContentHandler ( parent . getContentHandler ( ) ) ; setupParse ( ) ; } 
public String getButtonLabel ( ) { if ( hasBinding ( BND_BUTTON_LABEL ) ) return ( String ) valueForBinding ( BND_BUTTON_LABEL ) ; return DFL_BUTTON_LABEL ; } 
@ Override public String toString ( ) { return String . format ( "<%.3f,-%.3f,-%.3f,-%.3f>" , Double . valueOf ( this . w ) , Double . valueOf ( this . x ) , Double . valueOf ( this . y ) , Double . valueOf ( this . z ) ) ; } 
public String getElementContentModel ( String name ) { Object [ ] element = ( Object [ ] ) elementInfo . get ( name ) ; if ( element == null ) { return null ; } else { return ( String ) element [ 1 ] ; } } 
public final int countDataTypes ( ) { return mDataTypes != null ? mDataTypes . size ( ) : 0 ; } 
public String getConstantString ( int index , byte tag ) throws ClassFormatException { Constant c ; int i ; c = getConstant ( index , tag ) ; switch ( tag ) { case Constants . CONSTANT_Class : i = ( ( ConstantClass ) c ) . getNameIndex ( ) ; break ; case Constants . CONSTANT_String : i = ( ( ConstantString ) c ) . getStringIndex ( ) ; break ; default : throw new RuntimeException ( "getConstantString-called-with-illegal-tag-" + tag ) ; } c = getConstant ( i , Constants . CONSTANT_Utf8 ) ; return ( ( ConstantUtf8 ) c ) . getBytes ( ) ; } 
public String getInfinity ( ) { return m_dfs . getInfinity ( ) ; } 
public void setUsage ( AtomicInteger usage ) { this . usage = new AtomicInteger ( usage . get ( ) ) ; } 
private boolean correctSymbols ( char [ ] symbols ) { Set < Character > legalCharacters = chars . keySet ( ) ; for ( Character c : symbols ) { if ( ! legalCharacters . contains ( c ) ) { return false ; } } return true ; } 
public static LinearGradientPaint getProgressPaint ( final JComponent element , final int h ) { boolean pressed = false ; if ( element instanceof AbstractButton ) { final ButtonModel bm = ( ( AbstractButton ) element ) . getModel ( ) ; pressed = bm . isPressed ( ) || bm . isSelected ( ) ; } return new LinearGradientPaint ( 0 , 0 , 0 , h , progressFractions , pressed ? selectedProgressFillColors : progressFillColors ) ; } 
public Package getPackage ( ) { return Package . getPackage ( this ) ; } 
public int size ( ) { return authors . size ( ) ; } 
@ Override synchronized public final boolean isRegistered ( ) { return ! keyList . isEmpty ( ) ; } 
public void write ( String str , int st , int end ) throws IOException { out . write ( str , st , end ) ; } 
public void writeTo ( OutputStream out ) throws IOException , MessagingException { BufferedWriter writer = new BufferedWriter ( new OutputStreamWriter ( out ) , 1024 ) ; mHeader . writeTo ( out ) ; writer . write ( "-" ) ; writer . flush ( ) ; if ( mBody != null ) { mBody . writeTo ( out ) ; } } 
synchronized void removeLease ( Lease lease , String src ) { sortedLeasesByPath . remove ( src ) ; if ( ! lease . removePath ( src ) ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( src + "-not-found-in-lease.paths-(=" + lease . paths + ")" ) ; } } if ( ! lease . hasPath ( ) ) { leases . remove ( lease . holder ) ; if ( ! sortedLeases . remove ( lease ) ) { LOG . error ( lease + "-not-found-in-sortedLeases" ) ; } } } 
public List < Object > getContent ( ) { if ( content == null ) { content = new ArrayList < Object > ( ) ; } return this . content ; } 
public static int toChars ( int codePoint , char [ ] dst , int dstIndex ) { if ( ! isValidCodePoint ( codePoint ) ) { throw new IllegalArgumentException ( ) ; } if ( dst == null ) { throw new NullPointerException ( ) ; } if ( dstIndex < 0 || dstIndex >= dst . length ) { throw new IndexOutOfBoundsException ( ) ; } if ( isSupplementaryCodePoint ( codePoint ) ) { if ( dstIndex == dst . length - 1 ) { throw new IndexOutOfBoundsException ( ) ; } int cpPrime = codePoint - 0x10000 ; int high = 0xD800 | ( ( cpPrime >> 10 ) & 0x3FF ) ; int low = 0xDC00 | ( cpPrime & 0x3FF ) ; dst [ dstIndex ] = ( char ) high ; dst [ dstIndex + 1 ] = ( char ) low ; return 2 ; } dst [ dstIndex ] = ( char ) codePoint ; return 1 ; } 
private static void drawHArrow ( Path path , float cx , float cy , float width , float height ) { path . moveTo ( cx , cy - height / 2.0f ) ; path . lineTo ( cx + width , cy ) ; path . lineTo ( cx , cy + height / 2.0f ) ; path . close ( ) ; } 
public static long getTimeInMillis ( ) { return new GregorianCalendar ( ) . getTimeInMillis ( ) ; } 
public static int getMenuIdentifier ( Class cls , String identifier ) { int id = - 1 ; try { Integer field = ( Integer ) cls . getDeclaredField ( identifier ) . get ( cls ) ; id = field . intValue ( ) ; } catch ( NoSuchFieldException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } return id ; } 
@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) private boolean hasExit ( ASTBlockStatement block ) { List exitBlocks = block . findDescendantsOfType ( ASTReturnStatement . class ) ; exitBlocks . addAll ( block . findDescendantsOfType ( ASTThrowStatement . class ) ) ; if ( exitBlocks . isEmpty ( ) ) return false ; for ( int i = 0 ; i < exitBlocks . size ( ) ; i ++ ) { Node exitNode = ( Node ) exitBlocks . get ( i ) ; if ( hasAsParentBetween ( exitNode , ASTMethodDeclaration . class , block ) ) continue ; return true ; } return false ; } 
public static Node getParentOfNode ( Node node ) throws RuntimeException { Node parent ; short nodeType = node . getNodeType ( ) ; if ( Node . ATTRIBUTE_NODE == nodeType ) { Document doc = node . getOwnerDocument ( ) ; DOMImplementation impl = doc . getImplementation ( ) ; if ( impl != null && impl . hasFeature ( "Core" , "2.0" ) ) { parent = ( ( Attr ) node ) . getOwnerElement ( ) ; return parent ; } Element rootElem = doc . getDocumentElement ( ) ; if ( null == rootElem ) { throw new RuntimeException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT , null ) ) ; } parent = locateAttrParent ( rootElem , node ) ; } else { parent = node . getParentNode ( ) ; } return parent ; } 
public static void updateCSSPropertyFontSize ( CSS2FontProperties font , CSSValue value ) { if ( value . getCssValueType ( ) == CSSValue . CSS_PRIMITIVE_VALUE ) { font . setSize ( ( CSSPrimitiveValue ) value ) ; } } 
protected static String exceptionToRaw ( final Exception exception ) { String result = null ; if ( exception != null ) { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; final PrintWriter os = new PrintWriter ( bos ) ; exception . printStackTrace ( os ) ; os . flush ( ) ; result = bos . toString ( ) ; } return result ; } 
public final void cancelOperation ( int token ) { mWorkerThreadHandler . removeMessages ( token ) ; } 
public Long getMemoryDynamicMax ( Connection c ) throws BadServerResponse , XenAPIException , XmlRpcException { String method_call = "VM.get_memory_dynamic_max" ; String session = c . getSessionReference ( ) ; Object [ ] method_params = { Marshalling . toXMLRPC ( session ) , Marshalling . toXMLRPC ( this . ref ) } ; Map response = c . dispatch ( method_call , method_params ) ; Object result = response . get ( "Value" ) ; return Types . toLong ( result ) ; } 
@ Override public Value key ( ) { if ( _current != null ) return _current . getKey ( ) ; else return NullValue . NULL ; } 
public String toString ( ) { return getClass ( ) + "-[Source:-" + getSource ( ) + ",-TreePath:-" + getTreePath ( ) + ",-Child-Indicies:-" + getChildIndices ( ) + ",-Children:-" + getChildren ( ) + ",-Path:-" + getPath ( ) + "]" ; } 
public SocketAddress getRemoteSocketAddress ( ) { if ( ! isConnected ( ) ) { return null ; } return new InetSocketAddress ( getInetAddress ( ) , getPort ( ) ) ; } 
public static Webcam getDefault ( long timeout , TimeUnit tunit ) throws TimeoutException , WebcamException { if ( timeout < 0 ) { throw new IllegalArgumentException ( String . format ( "Timeout-cannot-be-negative-(%d)" , timeout ) ) ; } if ( tunit == null ) { throw new IllegalArgumentException ( "Time-unit-cannot-be-null!" ) ; } List < Webcam > webcams = getWebcams ( timeout , tunit ) ; assert webcams != null ; if ( ! webcams . isEmpty ( ) ) { return webcams . get ( 0 ) ; } LOG . warn ( "No-webcam-has-been-detected!" ) ; return null ; } 
public static int getDepth ( @ NonNull Node node ) { int depth = - 1 ; while ( node != null ) { depth ++ ; node = node . getParentNode ( ) ; } return depth ; } 
public LocalDate minus ( ReadablePeriod period ) { return withPeriodAdded ( period , - 1 ) ; } 
public void setClip ( Rectangle rect ) { if ( rect == null ) { clearClip ( ) ; return ; } setClip ( ( int ) rect . getX ( ) , ( int ) rect . getY ( ) , ( int ) rect . getWidth ( ) , ( int ) rect . getHeight ( ) ) ; } 
public Boolean hasExpired ( long par1 ) { return Boolean . valueOf ( this . timestamp < par1 ) ; } 
public void onUserActivity ( int event , int uid ) { if ( DEBUG ) { Slog . d ( TAG , "onUserActivity:-event=" + event + ",-uid=" + uid ) ; } try { mBatteryStats . noteUserActivity ( uid , event ) ; } catch ( RemoteException ex ) { } synchronized ( mLock ) { if ( ! mUserActivityPending ) { mUserActivityPending = true ; Message msg = mHandler . obtainMessage ( MSG_USER_ACTIVITY ) ; msg . setAsynchronous ( true ) ; mHandler . sendMessage ( msg ) ; } } } 
private static long getMemUsed ( ) { return memMXbean . getHeapMemoryUsage ( ) . getUsed ( ) ; } 
public static boolean interfaceExists ( String hostname ) { try { Class < ? > networkInterfaceClass = Class . forName ( "java.net.NetworkInterface" ) ; return networkInterfaceClass . getMethod ( "getByName" , ( Class [ ] ) null ) . invoke ( networkInterfaceClass , new Object [ ] { hostname } ) != null ; } catch ( Throwable t ) { return false ; } } 
public static String trimHostName ( String hostname ) { if ( hostname == null ) { return null ; } int start = 0 ; if ( hostname . regionMatches ( true , 0 , "www." , 0 , 4 ) ) { start = 4 ; } int end = hostname . lastIndexOf ( '.' ) ; if ( end <= start ) { return hostname ; } return hostname . substring ( start , end ) ; } 
private void parseExposedMethodAndAttributes ( Class < ? > clazz , Method [ ] methods , Map < String , AccessibleField > exposedAttributes , List < Method > exposedMethods , boolean includeNonPrimitive ) { for ( int mth = 0 ; mth < methods . length ; mth ++ ) { Method method = methods [ mth ] ; if ( DEBUG ) { LOG . debug ( "Method-:-" + method . getName ( ) + ",-return=" + method . getReturnType ( ) . getName ( ) + "-(exposable=" + isExposableType ( method . getReturnType ( ) , includeNonPrimitive ) + ")" + ",-args=" + method . getParameterTypes ( ) . length + ",-declaringClass=" + method . getDeclaringClass ( ) . getName ( ) ) ; } if ( isIgnoredMethod ( method ) ) { continue ; } parseExposedMethod ( clazz , exposedAttributes , exposedMethods , includeNonPrimitive , method ) ; } } 
double arg ( ) { double a = Math . atan ( fy / fx ) ; if ( fx < 0 ) { a += Math . PI ; } else if ( fy < 0 ) { a += 2 * Math . PI ; } return a ; } 
public static List < Bitmap > findCachedBitmapsForImageUri ( String imageUri , MemoryCache memoryCache ) { List < Bitmap > values = new ArrayList < Bitmap > ( ) ; for ( String key : memoryCache . keys ( ) ) { if ( key . startsWith ( imageUri ) ) { values . add ( memoryCache . get ( key ) ) ; } } return values ; } 
public long getLong ( String key ) throws JSONException { Object object = this . get ( key ) ; try { return object instanceof Number ? ( ( Number ) object ) . longValue ( ) : Long . parseLong ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONObject[" + quote ( key ) + "]-is-not-a-long." ) ; } } 
public int getWidth ( ) { return nativeGetWidth ( mNativeBox ) ; } 
void endBody ( ) { Arrays . fill ( this . firstCellOnPage , false ) ; } 
public boolean cancel ( ) { return request . cancel ( ) ; } 
public int size ( ) { return st . size ( ) ; } 
public static < F , T > Collection < T > transform ( Collection < F > fromCollection , Function < ? super F , T > function ) { return new TransformedCollection < F , T > ( fromCollection , function ) ; } 
public String toDebugString ( ) { String s = "" ; if ( nodes == null ) return "" ; for ( int i = 0 ; i < nodes . toArray ( ) . length ; i ++ ) { if ( nodes . get ( i ) != null ) s += nodes . get ( i ) . getId ( ) + "---" + nodes . get ( i ) . getValue ( ) + ( ( i < nodes . toArray ( ) . length - 1 ) ? "-" : "" ) ; } return s ; } 
protected short unwrapValue ( Object value ) { return ( ( Short ) value ) . shortValue ( ) ; } 
String [ ] getImplementations ( BEASTObject plugin ) { String sName = plugin . getClass ( ) . getName ( ) ; List < String > sImplementations = new ArrayList < String > ( ) ; for ( String sPlugin : m_sPluginNames ) { try { if ( ! sPlugin . equals ( sName ) && plugin . getClass ( ) . isAssignableFrom ( Class . forName ( sPlugin ) ) ) { sImplementations . add ( sPlugin ) ; } } catch ( ClassNotFoundException e ) { } } return sImplementations . toArray ( new String [ 0 ] ) ; } 
public void addAction ( Action action ) { actionMap . put ( action . getClass ( ) , action ) ; } 
public void setResolveParent ( AttributeSet parent ) { checkForIllegalCast ( ) ; AttributeContext context = getAttributeContext ( ) ; if ( parent != null ) { attributes = context . addAttribute ( attributes , StyleConstants . ResolveAttribute , parent ) ; } else { attributes = context . removeAttribute ( attributes , StyleConstants . ResolveAttribute ) ; } } 
public void removeFromParent ( ) { MutableTreeNode parent = ( MutableTreeNode ) getParent ( ) ; if ( parent != null ) { parent . remove ( this ) ; } } 
private String findPerClause ( Class < ? > aspectClass ) { String str = aspectClass . getAnnotation ( Aspect . class ) . value ( ) ; str = str . substring ( str . indexOf ( "(" ) + 1 ) ; str = str . substring ( 0 , str . length ( ) - 1 ) ; return str ; } 
public static void putln ( Object x , int minChars ) { put ( x , minChars ) ; out . println ( ) ; out . flush ( ) ; if ( out . checkError ( ) ) outputError ( "Error-while-writing-output." ) ; } 
public int getFieldSize ( ) { return p . bitLength ( ) ; } 
public void enter ( Symbol sym , Scope s , Scope origin ) { Assert . check ( shared == 0 ) ; if ( nelems * 3 >= hashMask * 2 ) dble ( ) ; int hash = getIndex ( sym . name ) ; Entry old = table [ hash ] ; if ( old == null ) { old = sentinel ; nelems ++ ; } Entry e = makeEntry ( sym , old , elems , s , origin ) ; table [ hash ] = e ; elems = e ; for ( List < ScopeListener > l = listeners ; l . nonEmpty ( ) ; l = l . tail ) { l . head . symbolAdded ( sym , this ) ; } } 
public Socket ( String host , int port , NXTConnection nxtc ) throws IOException { this . host = host ; this . port = port ; this . nxtc = nxtc ; inFromProxy = new DataInputStream ( nxtc . openInputStream ( ) ) ; outToProxy = new DataOutputStream ( nxtc . openOutputStream ( ) ) ; negotiateConnection ( ) ; outToProxy . close ( ) ; inFromProxy . close ( ) ; } 
public boolean add ( AccessibleState state ) { return states . contains ( state ) ? false : states . add ( state ) ; } 
public Collection < User > getUsers ( int startIndex , int numResults ) { String [ ] usernamesAll = getUsernames ( ) . toArray ( new String [ 0 ] ) ; Collection < String > usernames = new ArrayList < String > ( ) ; for ( int i = startIndex ; ( i < startIndex + numResults ) && ( i < usernamesAll . length ) ; i ++ ) { usernames . add ( usernamesAll [ i ] ) ; } return new UserCollection ( usernames . toArray ( new String [ usernames . size ( ) ] ) ) ; } 
public static byte [ ] serialize ( Object object ) { if ( object == null ) { return null ; } ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { ObjectOutputStream oos = new ObjectOutputStream ( baos ) ; oos . writeObject ( object ) ; oos . flush ( ) ; } catch ( IOException ex ) { throw new IllegalArgumentException ( "Failed-to-serialize-object-of-type:-" + object . getClass ( ) , ex ) ; } return baos . toByteArray ( ) ; } 
public Map < String , String > getOtherConfig ( Connection c ) throws BadServerResponse , XenAPIException , XmlRpcException { String method_call = "PIF_metrics.get_other_config" ; String session = c . getSessionReference ( ) ; Object [ ] method_params = { Marshalling . toXMLRPC ( session ) , Marshalling . toXMLRPC ( this . ref ) } ; Map response = c . dispatch ( method_call , method_params ) ; Object result = response . get ( "Value" ) ; return Types . toMapOfStringString ( result ) ; } 
public RadioAction getRadioAction ( ActionId id ) { return radios . get ( id ) ; } 
public int size ( ) { return map . size ( ) ; } 
private List filterAvailableModelQueryActions ( List modelQueryActions ) { List filtered = new ArrayList ( modelQueryActions . size ( ) ) ; Iterator iterator = modelQueryActions . iterator ( ) ; while ( iterator . hasNext ( ) ) { ModelQueryAction action = ( ModelQueryAction ) iterator . next ( ) ; if ( validModelQueryNode ( action . getCMNode ( ) ) ) { filtered . add ( action ) ; } } return filtered ; } 
public static String renderEmptyElement ( Element element , boolean includeNamespaceAttribute ) { StringBuilder result = new StringBuilder ( ) ; result . append ( MARKER_START ) ; String name = element . getLocalName ( ) ; if ( name == null ) { name = element . getNodeName ( ) ; } result . append ( name ) ; if ( includeNamespaceAttribute ) { result . append ( SPACE_XMLNS_EQUALS_QUOTE + element . getNamespaceURI ( ) + QUOTE_MARK ) ; } result . append ( renderAttributes ( element . getAttributes ( ) ) ) ; result . append ( EMPTY_ELEMENT_TAG_END ) ; return result . toString ( ) ; } 
@ Override public boolean containsKey ( Object key ) { if ( isValidKeyType ( key ) ) { int keyOrdinal = ( ( Enum ) key ) . ordinal ( ) ; return hasMapping [ keyOrdinal ] ; } return false ; } 
private static String getCurrentTimeStamp ( ) { DateFormat dateFormat = new SimpleDateFormat ( "yyyy-MM-dd-HH-mm-ss" ) ; Date date = new Date ( ) ; return dateFormat . format ( date ) ; } 
public int hashCode ( ) { return url . hashCode ( ) ; } 
public void generateStoreLocal ( Method m , short varIndex ) { Compiler . internalError ( ) ; } 
public static ActivatableServerRef getActivatableRef ( ActivationID id ) throws ActivationException { ActivatableServerRef ref = ( ActivatableServerRef ) actIds . get ( id ) ; if ( ref == null ) throw new ActivationException ( id + "-was-not-registered-with-this-server" ) ; return ref ; } 
private void moveItems ( final JList srcList , final HashSet < Integer > srcHash , final JList dstList , final HashSet < Integer > dstHash ) { int inx = srcList . getSelectedIndex ( ) ; if ( inx > - 1 ) { DefaultListModel srcModel = ( DefaultListModel ) srcList . getModel ( ) ; DefaultListModel dstModel = ( DefaultListModel ) dstList . getModel ( ) ; int [ ] indexes = srcList . getSelectedIndices ( ) ; ArrayList < LatLonPoint > llpList = new ArrayList < LatLonPoint > ( indexes . length ) ; for ( int selInx : indexes ) { LatLonPoint llp = ( LatLonPoint ) srcModel . get ( selInx ) ; llpList . add ( llp ) ; if ( ! dstHash . contains ( llp . getLocId ( ) ) ) { dstModel . addElement ( llp ) ; dstHash . add ( llp . getLocId ( ) ) ; } } for ( LatLonPoint llp : llpList ) { srcModel . removeElement ( llp ) ; srcHash . remove ( llp . getLocId ( ) ) ; } } } 
private void paintForegroundPressed ( Graphics2D g , int width , int height ) { Shape s = decodeArrowPath ( width , height ) ; g . setPaint ( pressedColor ) ; g . fill ( s ) ; } 
public static < K , E > boolean isEmpty ( Map < K , E > m ) { return ( m == null ) || m . isEmpty ( ) ; } 
public Object clone ( ) { try { StrokeImpl clone = ( StrokeImpl ) super . clone ( ) ; if ( dashArray != null ) { clone . dashArray = new float [ dashArray . length ] ; System . arraycopy ( dashArray , 0 , clone . dashArray , 0 , dashArray . length ) ; } if ( fillGraphic != null && fillGraphic instanceof Cloneable ) { clone . fillGraphic = ( GraphicImpl ) ( ( Cloneable ) fillGraphic ) . clone ( ) ; } if ( strokeGraphic != null && fillGraphic instanceof Cloneable ) { clone . strokeGraphic = ( GraphicImpl ) ( ( Cloneable ) strokeGraphic ) . clone ( ) ; } return clone ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( "Failed-to-clone-StrokeImpl" ) ; } } 
public void setGlassPane ( Component glassPane ) { getRootPane ( ) . setGlassPane ( glassPane ) ; } 
public boolean matches ( String base , String test ) { return test . endsWith ( base . substring ( 1 ) ) ; } 
public T getRow ( int row ) { return modelData . get ( row ) ; } 
public static Object invokeStaticMethod ( Class cls , String methodName , Object [ ] args , Class [ ] parameterTypes ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { if ( parameterTypes == null ) { parameterTypes = ArrayUtils . EMPTY_CLASS_ARRAY ; } if ( args == null ) { args = ArrayUtils . EMPTY_OBJECT_ARRAY ; } Method method = getMatchingAccessibleMethod ( cls , methodName , parameterTypes ) ; if ( method == null ) { throw new NoSuchMethodException ( "No-such-accessible-method:-" + methodName + "()-on-class:-" + cls . getName ( ) ) ; } return method . invoke ( null , args ) ; } 
public static int copyCodePointsAndReturnCodePointCount ( @ Nonnull final int [ ] destination , @ Nonnull final CharSequence charSequence , final int startIndex , final int endIndex , final boolean downCase ) { int destIndex = 0 ; for ( int index = startIndex ; index < endIndex ; index = Character . offsetByCodePoints ( charSequence , index , 1 ) ) { final int codePoint = Character . codePointAt ( charSequence , index ) ; destination [ destIndex ] = downCase ? Character . toLowerCase ( codePoint ) : codePoint ; destIndex ++ ; } return destIndex ; } 
@ Override public boolean containsValue ( Object value ) { if ( value == null ) { for ( int i = 0 ; i < enumSize ; i ++ ) { if ( hasMapping [ i ] && values [ i ] == null ) { return true ; } } } else { for ( int i = 0 ; i < enumSize ; i ++ ) { if ( hasMapping [ i ] && value . equals ( values [ i ] ) ) { return true ; } } } return false ; } 
private static Set getPartnerSourceID ( String certOrIP ) { Map partnerMap = ( Map ) SAMLServiceManager . getAttribute ( SAMLConstants . PARTNER_URLS ) ; if ( partnerMap != null ) { Set sidSet = new HashSet ( ) ; Set partnerSet = partnerMap . entrySet ( ) ; Iterator it = partnerSet . iterator ( ) ; Set hostSet = null ; while ( it . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; SAMLServiceManager . SOAPEntry partnerEntry = ( SAMLServiceManager . SOAPEntry ) entry . getValue ( ) ; hostSet = partnerEntry . getHostSet ( ) ; if ( ( hostSet != null ) && ( hostSet . contains ( certOrIP ) ) ) { sidSet . add ( ( String ) entry . getKey ( ) ) ; if ( SAMLUtils . debug . messageEnabled ( ) ) { SAMLUtils . debug . message ( "getPartnerSourceID:-found-" + "a-matching-sid=" + Base64 . encode ( SAMLUtils . stringToByteArray ( ( String ) entry . getKey ( ) ) ) ) ; } } } return sidSet ; } return ( null ) ; } 
@ Override public boolean equals ( Object object ) { if ( this == object ) { return true ; } if ( object instanceof Set ) { Set < ? > s = ( Set < ? > ) object ; try { return size ( ) == s . size ( ) && containsAll ( s ) ; } catch ( NullPointerException ignored ) { return false ; } catch ( ClassCastException ignored ) { return false ; } } return false ; } 
@ Deprecated public void clearPluginObjects ( ) { pluginMap . clear ( ) ; } 
public static List < String > captureOutAndError ( List < String > setup , List < String > cmd , File stdoutFilename , File stderrFilename , long tailLength , boolean useSetsid ) throws IOException { List < String > result = new ArrayList < String > ( 3 ) ; result . add ( bashCommand ) ; result . add ( "-c" ) ; String mergedCmd = buildCommandLine ( setup , cmd , stdoutFilename , stderrFilename , tailLength , useSetsid ) ; result . add ( mergedCmd ) ; return result ; } 
public static int nextGaussian ( final int min , final int max , final int sd ) { return nextGaussian ( min , max , min + ( max - min ) / 2 , sd ) ; } 
public static String toIsoString ( byte [ ] bytes ) { try { return new String ( bytes , CharacterSets . MIMENAME_ISO_8859_1 ) ; } catch ( UnsupportedEncodingException e ) { Log . e ( TAG , "ISO_8859_1-must-be-supported!" , e ) ; return "" ; } } 
public void removeMessageEventRequestListener ( MessageEventRequestListener messageEventRequestListener ) { synchronized ( messageEventRequestListeners ) { messageEventRequestListeners . remove ( messageEventRequestListener ) ; } } 
public void clearSounds ( ) { mSoundMap . clear ( ) ; } 
public List < CmsPageTypeDTO > getCMSPageType ( ) { if ( cmsPageType == null ) { cmsPageType = new ArrayList < CmsPageTypeDTO > ( ) ; } return this . cmsPageType ; } 
public static String chop ( String str ) { if ( str == null ) { return null ; } int strLen = str . length ( ) ; if ( strLen < 2 ) { return EMPTY ; } int lastIdx = strLen - 1 ; String ret = str . substring ( 0 , lastIdx ) ; char last = str . charAt ( lastIdx ) ; if ( last == '|n' ) { if ( ret . charAt ( lastIdx - 1 ) == '|r' ) { return ret . substring ( 0 , lastIdx - 1 ) ; } } return ret ; } 
private int getObscuredState ( int compIndex , int x , int y , int width , int height ) { int retValue = NOT_OBSCURED ; Rectangle tmpRect = fetchRectangle ( ) ; for ( int i = compIndex - 1 ; i >= 0 ; i -- ) { Component sibling = getComponent ( i ) ; if ( ! sibling . isVisible ( ) ) { continue ; } Rectangle siblingRect ; boolean opaque ; if ( sibling instanceof JComponent ) { opaque = ( ( JComponent ) sibling ) . isOpaque ( ) ; if ( ! opaque ) { if ( retValue == PARTIALLY_OBSCURED ) { continue ; } } } else { opaque = true ; } siblingRect = sibling . getBounds ( tmpRect ) ; if ( opaque && x >= siblingRect . x && ( x + width ) <= ( siblingRect . x + siblingRect . width ) && y >= siblingRect . y && ( y + height ) <= ( siblingRect . y + siblingRect . height ) ) { recycleRectangle ( tmpRect ) ; return COMPLETELY_OBSCURED ; } else if ( retValue == NOT_OBSCURED && ! ( ( x + width <= siblingRect . x ) || ( y + height <= siblingRect . y ) || ( x >= siblingRect . x + siblingRect . width ) || ( y >= siblingRect . y + siblingRect . height ) ) ) { retValue = PARTIALLY_OBSCURED ; } } recycleRectangle ( tmpRect ) ; return retValue ; } 
public String toString ( ) { if ( toString == null ) { toString = new StringBuffer ( 32 ) . append ( getNumerator ( ) ) . append ( '/' ) . append ( getDenominator ( ) ) . toString ( ) ; } return toString ; } 
public Product createProduct ( ) { return new Product ( ) ; } 
protected synchronized PreparedStatement roles ( Connection dbConnection , String username ) throws SQLException { if ( preparedRoles == null ) { StringBuffer sb = new StringBuffer ( "SELECT-" ) ; sb . append ( roleNameCol ) ; sb . append ( "-FROM-" ) ; sb . append ( userRoleTable ) ; sb . append ( "-WHERE-" ) ; sb . append ( userNameCol ) ; sb . append ( "-=-?" ) ; preparedRoles = dbConnection . prepareStatement ( sb . toString ( ) ) ; } preparedRoles . setString ( 1 , username ) ; return ( preparedRoles ) ; } 
@ Override public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; fUpdateStrategy . draw ( g , this ) ; } 
public int stringWidth ( String str ) { int len = str . length ( ) ; char data [ ] = new char [ len ] ; str . getChars ( 0 , len , data , 0 ) ; return charsWidth ( data , 0 , len ) ; } 
public static void installLookAndFeel ( String name , String className ) { installLookAndFeel ( new LookAndFeelInfo ( name , className ) ) ; } 
protected RMIConnection makeClient ( String connectionId , Subject subject ) throws IOException { if ( connectionId == null ) throw new NullPointerException ( "Null-connectionId" ) ; RMIConnection client = new RMIConnectionImpl ( this , connectionId , getDefaultClassLoader ( ) , subject , env ) ; export ( client ) ; return client ; } 
public synchronized final Map < K , V > snapshot ( ) { return new LinkedHashMap < K , V > ( map ) ; } 
private static void registerCommonClasses ( Class < ? > ... commonClasses ) { for ( Class < ? > clazz : commonClasses ) { commonClassCache . put ( clazz . getName ( ) , clazz ) ; } } 
private boolean hasMatches ( String prefix ) { for ( int i = 0 ; i < mClockCities . size ( ) ; i ++ ) { City city = mClockCities . get ( i ) ; if ( nameMatches ( city , prefix ) ) { return true ; } } return false ; } 
public static boolean isValidName ( String name ) { if ( name . length ( ) == 0 ) return false ; char ch = name . charAt ( 0 ) ; if ( isNameStart ( ch ) == false ) return false ; for ( int i = 1 ; i < name . length ( ) ; i ++ ) { ch = name . charAt ( i ) ; if ( isName ( ch ) == false ) { return false ; } } return true ; } 
private Method [ ] getDeclaredPublicMethods ( ) { if ( declaredPublicMethods == null ) { declaredPublicMethods = Class . getDeclaredMethods ( clazz , true ) ; } return declaredPublicMethods ; } 
public boolean hasFixedCondition ( ) { return _fixedCondition != null && _fixedCondition . trim ( ) . length ( ) > 0 ; } 
public void printStackTrace ( PrintStream s ) { if ( ! isJDK14OrAbove && causeOnJDK13OrBelow != null ) { printStackTrace0 ( new PrintWriter ( s ) ) ; } else { super . printStackTrace ( s ) ; } } 
private File getDummyBat ( ) { int number = 0 ; while ( true ) { if ( number == 100 ) { RouterPlugin . LOG . severe ( "Cannot-create-dummy-Bat-file,-please-delete-all-recon_*.bat-files-in-tmp-folder!" ) ; return null ; } final File tmp = JDUtilities . getResourceFile ( "tmp/recon_" + number + ".bat" , true ) ; if ( tmp . exists ( ) ) { if ( tmp . delete ( ) ) { return tmp ; } tmp . deleteOnExit ( ) ; } else { return tmp ; } number ++ ; } } 
public static void parseCacheControl ( String value , CacheControlHandler handler ) { int pos = 0 ; while ( pos < value . length ( ) ) { int tokenStart = pos ; pos = skipUntil ( value , pos , "=,;" ) ; String directive = value . substring ( tokenStart , pos ) . trim ( ) ; if ( pos == value . length ( ) || value . charAt ( pos ) == ',' || value . charAt ( pos ) == ';' ) { pos ++ ; handler . handle ( directive , null ) ; continue ; } pos ++ ; pos = skipWhitespace ( value , pos ) ; String parameter ; if ( pos < value . length ( ) && value . charAt ( pos ) == '|"' ) { pos ++ ; int parameterStart = pos ; pos = skipUntil ( value , pos , """ ) ; parameter = value . substring ( parameterStart , pos ) ; pos ++ ; } else { int parameterStart = pos ; pos = skipUntil ( value , pos , ",;" ) ; parameter = value . substring ( parameterStart , pos ) . trim ( ) ; } handler . handle ( directive , parameter ) ; } } 
private Object doInvoke ( ) throws Exception { try { return invoke ( ) ; } catch ( InvocationTargetException ex ) { if ( ex . getTargetException ( ) instanceof Exception ) { throw ( Exception ) ex . getTargetException ( ) ; } if ( ex . getTargetException ( ) instanceof Error ) { throw ( Error ) ex . getTargetException ( ) ; } throw ex ; } } 
public static Document getOwnerDocument ( Set < Node > xpathNodeSet ) { NullPointerException npe = null ; for ( Node node : xpathNodeSet ) { int nodeType = node . getNodeType ( ) ; if ( nodeType == Node . DOCUMENT_NODE ) { return ( Document ) node ; } try { if ( nodeType == Node . ATTRIBUTE_NODE ) { return ( ( Attr ) node ) . getOwnerElement ( ) . getOwnerDocument ( ) ; } return node . getOwnerDocument ( ) ; } catch ( NullPointerException e ) { npe = e ; } } throw new NullPointerException ( I18n . translate ( "endorsed.jdk1.4.0" ) + "-Original-message-was-"" + ( npe == null ? "" : npe . getMessage ( ) ) + """ ) ; } 
public void setCompressionType ( String compressionType ) { checkWriteCompressed ( ) ; checkCompressionMode ( ) ; if ( compressionType == null ) { this . compressionType = null ; } else { String [ ] compressionTypes = getCompressionTypes ( ) ; if ( compressionTypes == null ) { throw new UnsupportedOperationException ( "No-settable-compression-types" ) ; } for ( int i = 0 ; i < compressionTypes . length ; i ++ ) { if ( compressionTypes [ i ] . equals ( compressionType ) ) { this . compressionType = compressionType ; return ; } } throw new IllegalArgumentException ( "Unknown-compression-type!" ) ; } } 
private void setIndexTreeList ( ) { indexTreeList = new ArrayList ( ) ; while ( indexTreeEnum . hasMoreElements ( ) ) { indexTreeList . add ( indexTreeEnum . nextElement ( ) ) ; } } 
protected HttpTunnel newHttpTunnel ( HttpRequest request , HttpResponse response , InetAddress iaddr , int port , int timeoutMS ) throws IOException { try { Socket socket = new Socket ( iaddr , port ) ; socket . setSoTimeout ( timeoutMS ) ; socket . setTcpNoDelay ( true ) ; return new HttpTunnel ( socket , null , null ) ; } catch ( IOException e ) { log . log ( Level . FINE , "Exception-thrown" , e ) ; response . sendError ( HttpResponse . __400_Bad_Request ) ; return null ; } } 
public StringBuilder append ( double d ) { append0 ( Double . toString ( d ) ) ; return this ; } 
public void clearSounds ( ) { mSoundMap . clear ( ) ; } 
private Result pDeclarators$1 ( final int yyStart ) throws IOException { Result yyResult ; Node yyValue ; ParseError yyError = ParseError . DUMMY ; yyResult = pDeclarator ( yyStart ) ; yyError = yyResult . select ( yyError ) ; if ( yyResult . hasValue ( ) ) { final Node v$g$1 = yyResult . semanticValue ( ) ; yyResult = pDeclarators$$Star1 ( yyResult . index ) ; yyError = yyResult . select ( yyError ) ; if ( yyResult . hasValue ( ) ) { final Pair < Node > v$g$2 = yyResult . semanticValue ( ) ; yyValue = GNode . createFromPair ( "Declarators" , v$g$1 , v$g$2 ) ; yyValue . setLocation ( location ( yyStart ) ) ; return yyResult . createValue ( yyValue , yyError ) ; } } return yyError ; } 
public boolean equals ( Object o ) { if ( ! ( o instanceof Field ) ) return false ; Field that = ( Field ) o ; if ( declaringClass != that . getDeclaringClass ( ) ) return false ; if ( ! name . equals ( that . getName ( ) ) ) return false ; if ( getType ( ) != that . getType ( ) ) return false ; return true ; } 
public void addHeader ( Header header ) { if ( header == null ) { return ; } headers . add ( header ) ; } 
protected void processAnyRemoteFieldsHolder ( View view , Object model , Container container ) { List < Component > processedItems = new ArrayList < Component > ( ) ; for ( Component item : container . getItems ( ) ) { if ( item instanceof RemoteFieldsHolder ) { List < InputField > translatedFields = ( ( RemoteFieldsHolder ) item ) . fetchAndTranslateRemoteFields ( view , model , container ) ; processedItems . addAll ( translatedFields ) ; } else { processedItems . add ( item ) ; } } container . setItems ( processedItems ) ; } 
public static ComponentUI createUI ( JComponent x ) { return new SynthTreeUI ( ) ; } 
public Iterator getSignatures ( ) { if ( subSigs == null ) { List sigs = new ArrayList ( ) ; sigs . addAll ( keySigs ) ; for ( int i = 0 ; i != idSigs . size ( ) ; i ++ ) { sigs . addAll ( ( Collection ) idSigs . get ( i ) ) ; } return sigs . iterator ( ) ; } else { return subSigs . iterator ( ) ; } } 
private Set < String > getReadablePropertyNamesByAnnotationType ( Class < ? extends Annotation > annotationType ) { Set < String > propertyNames = readablePropertyNamesByAnnotationType . get ( annotationType ) ; if ( propertyNames != null ) { return propertyNames ; } propertyNames = new LinkedHashSet < String > ( ) ; for ( Entry < String , Method > readMethodEntry : readMethods . entrySet ( ) ) { Method readMethod = readMethodEntry . getValue ( ) ; if ( readMethod != null && readMethod . isAnnotationPresent ( annotationType ) ) { propertyNames . add ( readMethodEntry . getKey ( ) ) ; } } propertyNames = Collections . unmodifiableSet ( propertyNames ) ; readablePropertyNamesByPropertyType . put ( annotationType , propertyNames ) ; return propertyNames ; } 
private String getType ( XMLResourceIdentifier resourceIdentifier ) { if ( resourceIdentifier instanceof XMLGrammarDescription ) { XMLGrammarDescription desc = ( XMLGrammarDescription ) resourceIdentifier ; if ( XMLGrammarDescription . XML_SCHEMA . equals ( desc . getGrammarType ( ) ) ) { return XSD_TYPE ; } } return XML_TYPE ; } 
public JLabel getJLabel ( ) { if ( image == null ) { return null ; } ImageIcon icon = new ImageIcon ( image ) ; return new JLabel ( icon ) ; } 
String getString ( final String columnName ) { String value = null ; if ( useColumn ( columnName ) ) { try { value = results . getString ( columnName ) ; if ( results . wasNull ( ) ) { value = null ; } if ( value != null ) { value = value . trim ( ) ; } } catch ( final SQLException e ) { LOGGER . log ( Level . WARNING , "Could-not-read-string-value-for-column-" + columnName , e ) ; } } return value ; } 
protected final void firePropertyChange ( String propertyName , Object oldValue , Object newValue ) { pcs . firePropertyChange ( propertyName , oldValue , newValue ) ; } 
private static int numberOfAllowedFailedLoginAttempts ( ) { String maxAttemptsStr = System . getProperty ( "authentication.maxFailedLoginAttempts" ) ; int maxAttempts = 5 ; if ( maxAttemptsStr == null ) { System . setProperty ( "authentication.maxFailedLoginAttempts" , "5" ) ; return maxAttempts ; } try { maxAttempts = Integer . valueOf ( maxAttemptsStr ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "authentication.maxFailedLoginAttempts-must-be-an-integer" ) ; } return maxAttempts ; } 
public static byte [ ] reverseDwordBytes ( byte [ ] bytes , int trimLength ) { checkArgument ( bytes . length % 4 == 0 ) ; checkArgument ( trimLength < 0 || trimLength % 4 == 0 ) ; byte [ ] rev = new byte [ trimLength >= 0 && bytes . length > trimLength ? trimLength : bytes . length ] ; for ( int i = 0 ; i < rev . length ; i += 4 ) { System . arraycopy ( bytes , i , rev , i , 4 ) ; for ( int j = 0 ; j < 4 ; j ++ ) { rev [ i + j ] = bytes [ i + 3 - j ] ; } } return rev ; } 
private double screenToNormalized ( float screenCoord ) { int width = getWidth ( ) ; if ( width <= 2 * padding ) { return 0d ; } else { double result = ( screenCoord - padding ) / ( width - 2 * padding ) ; return Math . min ( 1d , Math . max ( 0d , result ) ) ; } } 
void pendingReplicationCheck ( ) { synchronized ( pendingReplications ) { Iterator iter = pendingReplications . entrySet ( ) . iterator ( ) ; long now = FSNamesystem . now ( ) ; FSNamesystem . LOG . debug ( "PendingReplicationMonitor-checking-Q" ) ; while ( iter . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; PendingBlockInfo pendingBlock = ( PendingBlockInfo ) entry . getValue ( ) ; if ( now > pendingBlock . getTimeStamp ( ) + timeout ) { Block block = ( Block ) entry . getKey ( ) ; synchronized ( timedOutItems ) { timedOutItems . add ( block ) ; } FSNamesystem . LOG . warn ( "PendingReplicationMonitor-timed-out-block-" + block ) ; iter . remove ( ) ; } } } } 
public short getShort ( Object key ) { Number n = get ( key ) ; if ( n == null ) { return ( short ) 0 ; } return n . shortValue ( ) ; } 
public String getGraphCommandFor ( String fromDateFormatted , String toDateFormatted , GPlotSeries plotSeries ) { return String . format ( COMMAND_TEMPLATE , name , fromDateFormatted , toDateFormatted , plotSeries . getLogDef ( ) ) ; } 
public static boolean isDartFile ( File file ) { return file . getName ( ) . endsWith ( DOT_DART ) ; } 
private Proxy nextProxy ( ) { if ( userSpecifiedProxy != null ) { hasNextProxy = false ; return userSpecifiedProxy ; } if ( proxySelectorProxies != null ) { while ( proxySelectorProxies . hasNext ( ) ) { Proxy candidate = proxySelectorProxies . next ( ) ; if ( candidate . type ( ) != Proxy . Type . DIRECT ) { return candidate ; } } } hasNextProxy = false ; return Proxy . NO_PROXY ; } 
public List < AdCustomizerFeed > getEntries ( ) { if ( entries == null ) { entries = new ArrayList < AdCustomizerFeed > ( ) ; } return this . entries ; } 
public ExitListener [ ] getExitListeners ( ) { int size = exitListeners . size ( ) ; return exitListeners . toArray ( new ExitListener [ size ] ) ; } 
private long getSectors ( int offset , int size ) throws IOException { String hex = "" ; readBytes ( ) ; if ( bytes == null ) { return - 1 ; } for ( int i = size ; i > 0 ; i -- ) { hex += String . format ( "%02x" , bytes [ offset + i - 1 ] & 0xFF ) ; } return Long . valueOf ( hex , 16 ) ; } 
public PipedReader ( PipedWriter out , int pipeSize ) throws IOException { this ( pipeSize ) ; connect ( out ) ; } 
public void addMetadata ( com . amazon . s3 . MetadataEntry param ) { if ( localMetadata == null ) { localMetadata = new com . amazon . s3 . MetadataEntry [ ] { } ; } localMetadataTracker = true ; java . util . List list = org . apache . axis2 . databinding . utils . ConverterUtil . toList ( localMetadata ) ; list . add ( param ) ; this . localMetadata = ( com . amazon . s3 . MetadataEntry [ ] ) list . toArray ( new com . amazon . s3 . MetadataEntry [ list . size ( ) ] ) ; } 
private void saveGameActionPerformed ( java . awt . event . ActionEvent evt ) { savegame_dialog . setSize ( 500 , 140 ) ; savegame_dialog . setVisible ( true ) ; } 
public static byte [ ] getSeed ( int numBytes ) { if ( internalSecureRandom == null ) { internalSecureRandom = new SecureRandom ( ) ; } return internalSecureRandom . generateSeed ( numBytes ) ; } 
private static String dropTrailingZeros ( int number ) { if ( number <= 0 ) return null ; while ( ( number % 10 ) == 0 ) { number = number / 10 ; } return Integer . toString ( number ) ; } 
public static boolean sameDocumentURI ( String uri ) { return ( uri != null && ( uri . length ( ) == 0 || uri . charAt ( 0 ) == '#' ) ) ; } 
@ Override public String getLocalAddr ( ) { if ( localAddr == null ) { coyoteRequest . action ( ActionCode . REQ_LOCAL_ADDR_ATTRIBUTE , coyoteRequest ) ; localAddr = coyoteRequest . localAddr ( ) . toString ( ) ; } return localAddr ; } 
public static String extractNetworkPortionAlt ( String phoneNumber ) { if ( phoneNumber == null ) { return null ; } int len = phoneNumber . length ( ) ; StringBuilder ret = new StringBuilder ( len ) ; boolean haveSeenPlus = false ; for ( int i = 0 ; i < len ; i ++ ) { char c = phoneNumber . charAt ( i ) ; if ( c == '+' ) { if ( haveSeenPlus ) { continue ; } haveSeenPlus = true ; } if ( isDialable ( c ) ) { ret . append ( c ) ; } else if ( isStartsPostDial ( c ) ) { break ; } } return ret . toString ( ) ; } 
public void fill ( Graphics2D g , Shape s ) { Rectangle bounds = s . getBounds ( ) ; int width = bounds . width ; int height = bounds . height ; BufferedImage bimage = Effect . createBufferedImage ( width , height , true ) ; Graphics2D gbi = bimage . createGraphics ( ) ; gbi . setColor ( Color . BLACK ) ; gbi . fill ( s ) ; g . drawImage ( applyEffect ( bimage , null , width , height ) , 0 , 0 , null ) ; } 
public void recycle ( ) { synchronized ( sPool ) { if ( sPool . size ( ) < MAX_POOL_SIZE ) { sPool . add ( this ) ; } } } 
public void initialize ( String name , LRSpec aspec ) throws ImplementationException { super . initialize ( name , aspec ) ; List < String > readers = aspec . getReaders ( ) . getReader ( ) ; for ( String reader : readers ) { LOG . debug ( String . format ( "retrieving-reader-part-%s" , reader ) ) ; LogicalReader logicalReader = logicalReaderManager . getLogicalReader ( reader ) ; logicalReader . addObserver ( this ) ; logicalReaders . put ( logicalReader . getName ( ) , logicalReader ) ; } } 
public void println ( long l ) { println ( String . valueOf ( l ) ) ; } 
private void checkAxisIndices ( List indices ) { if ( indices == null ) { return ; } int count = indices . size ( ) ; if ( count == 0 ) { throw new IllegalArgumentException ( "Empty-list-not-permitted." ) ; } HashSet set = new HashSet ( ) ; for ( int i = 0 ; i < count ; i ++ ) { Object item = indices . get ( i ) ; if ( ! ( item instanceof Integer ) ) { throw new IllegalArgumentException ( "Indices-must-be-Integer-instances." ) ; } if ( set . contains ( item ) ) { throw new IllegalArgumentException ( "Indices-must-be-unique." ) ; } set . add ( item ) ; } } 
public void getString ( StringBuffer buf ) { ParseItem [ ] operands = getOperands ( ) ; operands [ 1 ] . getString ( buf ) ; buf . append ( getSymbol ( ) ) ; operands [ 0 ] . getString ( buf ) ; } 
public Map < SpringConfig , String > getAllSpringConfig ( ) { return Collections . unmodifiableMap ( mSpringConfigMap ) ; } 
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; } 
public static String getOwningProcessGuidFromPath ( String path ) { if ( path == null ) { return null ; } int index = path . indexOf ( "," ) ; String guid ; if ( index < 0 ) { guid = path ; } else { guid = path . substring ( 0 , index ) ; } return guid ; } 
public synchronized Set < UGen > getConnectedInputs ( ) { Set < UGen > connectedInputs = new HashSet < UGen > ( ) ; for ( int i = 0 ; i < ins ; i ++ ) { for ( BufferPointer bp : inputsAtChannel [ i ] ) { connectedInputs . add ( bp . ugen ) ; } } return connectedInputs ; } 
public Builder setProtocol ( String protocol ) throws IllegalArgumentException { if ( protocol == null ) { throw new NullPointerException ( "protocol-cannot-be-null" ) ; } protocol = protocol . toUpperCase ( ) ; if ( ! protocol . equals ( UDP ) && ! protocol . equals ( TCP ) ) { throw new IllegalArgumentException ( "unsupported-protocol:-" + protocol ) ; } mProfile . mProtocol = protocol ; return this ; } 
public BigDecimal BigDecimalValue ( MathContext mc ) { BigDecimal n = new BigDecimal ( a ) ; BigDecimal d = new BigDecimal ( b ) ; return BigDecimalMath . scalePrec ( n . divide ( d , mc ) , mc ) ; } 
public void testFlipBitZero ( ) { byte aBytes [ ] = { 0 } ; int aSign = 0 ; int number = 0 ; byte rBytes [ ] = { 1 } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . flipBit ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = 0 ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( "incorrect-sign" , 1 , result . signum ( ) ) ; } 
@ Override public Value remove ( Value key ) { if ( _isDirty ) copyOnWrite ( ) ; key = key . toKey ( ) ; Entry [ ] entries = _entries ; Entry entry ; int hash = key . hashCode ( ) & _hashMask ; if ( entries != null ) { entry = entries [ hash ] ; } else entry = _head ; Entry prevHash = null ; for ( ; entry != null ; entry = entry . getNextHash ( ) ) { Value entryKey = entry . getKey ( ) ; if ( key == entryKey || key . equals ( entryKey ) ) { if ( prevHash != null ) prevHash . setNextHash ( entry . getNextHash ( ) ) ; else if ( entries != null ) entries [ hash ] = entry . getNextHash ( ) ; else _head = entry . getNextHash ( ) ; return removeEntry ( key , entry ) ; } prevHash = entry ; } return UnsetValue . UNSET ; } 
public SimpleMatrix getWordVectorOf ( String word ) { word = word . toLowerCase ( ) ; if ( this . wordCache . containsKey ( word ) ) { return this . wordCache . get ( word ) ; } else if ( this . words . containsKey ( word ) ) { this . wordCache . put ( word , this . constructVector ( this . words . getJsonArray ( word ) ) ) ; return this . wordCache . get ( word ) ; } else { return this . wordCache . get ( Parameters . UNKNOWN ) ; } } 
private javax . swing . JLabel getJLabel1 ( ) { if ( ivjJLabel1 == null ) { try { ivjJLabel1 = new javax . swing . JLabel ( ) ; ivjJLabel1 . setName ( "JLabel1" ) ; ivjJLabel1 . setPreferredSize ( new java . awt . Dimension ( 551 , 20 ) ) ; ivjJLabel1 . setText ( "-Please-note:-Subset-restrictions-are-only-taken-into-account-if-TWO-STAGE-estimation-is-selected-(current:-JOHANSEN)." ) ; } catch ( Throwable ivjExc ) { handleException ( ivjExc ) ; } } return ivjJLabel1 ; } 
protected String getSelector ( Control control ) { String selector = AjaxUtils . getSelector ( control ) ; if ( selector == null ) { throw new IllegalArgumentException ( "No-selector-could-be-found-for" + "-the-control:-" + control . getClass ( ) . getName ( ) + "#" + control . getName ( ) ) ; } return selector ; } 
public void damageRange ( JTextComponent t , int p0 , int p1 , Position . Bias p0Bias , Position . Bias p1Bias ) { if ( painted ) { Rectangle alloc = getVisibleEditorRect ( ) ; if ( alloc != null ) { Document doc = t . getDocument ( ) ; if ( doc instanceof AbstractDocument ) { ( ( AbstractDocument ) doc ) . readLock ( ) ; } try { rootView . setSize ( alloc . width , alloc . height ) ; Shape toDamage = rootView . modelToView ( p0 , p0Bias , p1 , p1Bias , alloc ) ; Rectangle rect = ( toDamage instanceof Rectangle ) ? ( Rectangle ) toDamage : toDamage . getBounds ( ) ; editor . repaint ( rect . x , rect . y , rect . width , rect . height ) ; } catch ( BadLocationException e ) { } finally { if ( doc instanceof AbstractDocument ) { ( ( AbstractDocument ) doc ) . readUnlock ( ) ; } } } } } 
public final byte [ ] getNameConstraints ( ) { if ( nameConstraints == null ) { return null ; } byte [ ] ret = new byte [ nameConstraints . length ] ; System . arraycopy ( nameConstraints , 0 , ret , 0 , nameConstraints . length ) ; return ret ; } 
public byte [ ] toBytes ( ) throws UnsupportedEncodingException { StringBuilder result = new StringBuilder ( 256 ) ; result . append ( requestLine ) . append ( "-" ) ; for ( int i = 0 ; i < namesAndValues . size ( ) ; i += 2 ) { result . append ( namesAndValues . get ( i ) ) . append ( ":-" ) . append ( namesAndValues . get ( i + 1 ) ) . append ( "-" ) ; } result . append ( "-" ) ; return result . toString ( ) . getBytes ( "ISO-8859-1" ) ; } 
public Object getChild ( Object parent , int index ) { return ( ( TreeNode ) parent ) . getChildAt ( index ) ; } 
public boolean hasPurchase ( String sku ) { return mPurchaseMap . containsKey ( sku ) ; } 
@ SuppressWarnings ( { "unchecked" , "cast" } ) public List < VariableDecl > getVariableDeclList ( ) { List < VariableDecl > list = ( List < VariableDecl > ) getChild ( 2 ) ; list . getNumChild ( ) ; return list ; } 
public void testDrawWithNullInfo ( ) { boolean success = false ; try { BufferedImage image = new BufferedImage ( 200 , 100 , BufferedImage . TYPE_INT_RGB ) ; Graphics2D g2 = image . createGraphics ( ) ; this . chart . draw ( g2 , new Rectangle2D . Double ( 0 , 0 , 200 , 100 ) , null , null ) ; g2 . dispose ( ) ; success = true ; } catch ( Exception e ) { success = false ; } assertTrue ( success ) ; } 
public boolean insert ( T element ) { if ( size < maxSize ) { put ( element ) ; return true ; } else if ( size > 0 && ! lessThan ( element , top ( ) ) ) { heap [ 1 ] = element ; adjustTop ( ) ; return true ; } else return false ; } 
@ Deprecated @ Override public String readLine ( ) throws IOException { return primitiveTypes . readLine ( ) ; } 
@ Override public void setSkipButtonPosition ( RelativeLayout . LayoutParams layoutParams ) { mSkipButton . setLayoutParams ( layoutParams ) ; } 
public static String getFolderSegment ( int version ) { if ( version != DEFAULT_VERSION ) { return String . format ( "v%1$d" , version ) ; } return "" ; } 
private boolean col_equiv ( int col1 , int col2 ) { int n ; int i ; CDTrans dtrans ; n = m_spec . m_dtrans_vector . size ( ) ; for ( i = 0 ; i < n ; ++ i ) { dtrans = ( CDTrans ) m_spec . m_dtrans_vector . elementAt ( i ) ; if ( dtrans . m_dtrans [ col1 ] != dtrans . m_dtrans [ col2 ] ) { return false ; } } return true ; } 
private static String decodeBase900toBase10 ( int [ ] codewords , int count ) throws FormatException { BigInteger result = BigInteger . ZERO ; for ( int i = 0 ; i < count ; i ++ ) { result = result . add ( EXP900 [ count - i - 1 ] . multiply ( BigInteger . valueOf ( codewords [ i ] ) ) ) ; } String resultString = result . toString ( ) ; if ( resultString . charAt ( 0 ) != '1' ) { throw FormatException . getFormatInstance ( ) ; } return resultString . substring ( 1 ) ; } 
public com . google . protobuf . ByteString getJavaPackageBytes ( ) { java . lang . Object ref = javaPackage_ ; if ( ref instanceof java . lang . String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; javaPackage_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
private String formatDate ( String date ) { int UTCloc = date . indexOf ( "UTC" ) ; String part1 = date . substring ( 0 , UTCloc + 3 ) ; Log . i ( TAG , "Old-date:-" + date + "-New-Date:-" + part1 ) ; return part1 ; } 
public void addFile ( String filename ) { synchronized ( files ) { if ( ! files . contains ( filename ) ) { files . add ( filename ) ; } } } 
public int popInt ( ) { mbuf . len = INTSIZE ; popReadOnly ( mbuf ) ; int ch1 = mbuf . data [ mbuf . off + 0 ] & 0xFF ; int ch2 = mbuf . data [ mbuf . off + 1 ] & 0xFF ; int ch3 = mbuf . data [ mbuf . off + 2 ] & 0xFF ; int ch4 = mbuf . data [ mbuf . off + 3 ] & 0xFF ; if ( ( ch1 | ch2 | ch3 | ch4 ) < 0 ) throw new MessageException ( "Error-reading-integer-from-message." , new EOFException ( ) ) ; return ( ( ch1 << 24 ) + ( ch2 << 16 ) + ( ch3 << 8 ) + ( ch4 << 0 ) ) ; } 
private String getFilename ( int year , int month , int day ) { Calendar cal = blog . getCalendar ( ) ; cal . set ( Calendar . YEAR , year ) ; cal . set ( Calendar . MONTH , month - 1 ) ; cal . set ( Calendar . DAY_OF_MONTH , day ) ; return filenameFormat . format ( cal . getTime ( ) ) ; } 
private int selectorToCID ( String selector ) { if ( ! selector . startsWith ( "|" ) ) { throw new IllegalArgumentException ( "Invalid-selector" ) ; } return Integer . parseInt ( selector . substring ( 1 ) ) ; } 
public static final char [ ] append ( char [ ] target , int index , char [ ] array , int start , int end ) { int targetLength = target . length ; int subLength = end - start ; int newTargetLength = subLength + index ; if ( newTargetLength > targetLength ) { System . arraycopy ( target , 0 , target = new char [ newTargetLength * 2 ] , 0 , index ) ; } System . arraycopy ( array , start , target , index , subLength ) ; return target ; } 
@ JsonCreator public ColumnMapperBigInteger ( @ JsonProperty ( "digits" ) Integer digits ) { super ( new AbstractType < ? > [ ] { AsciiType . instance , UTF8Type . instance , Int32Type . instance , LongType . instance , IntegerType . instance } , new AbstractType [ ] { } ) ; if ( digits != null && digits <= 0 ) { throw new IllegalArgumentException ( "Positive-digits-required" ) ; } this . digits = digits == null ? DEFAULT_DIGITS : digits ; complement = BigInteger . valueOf ( 10 ) . pow ( this . digits ) . subtract ( BigInteger . valueOf ( 1 ) ) ; BigInteger maxValue = complement . multiply ( BigInteger . valueOf ( 2 ) ) ; hexDigits = encode ( maxValue ) . length ( ) ; } 
private Frame getFrame ( ) { Window window = getWindow ( ) ; if ( window instanceof Frame ) { return ( Frame ) window ; } return null ; } 
public void setExtraFields ( Collection < String > fields ) { extraFields = new HashSet < String > ( ) ; if ( fields != null ) { extraFields . addAll ( fields ) ; } } 
public String getISO3Country ( ) { if ( countryCode . length ( ) == 0 ) { return countryCode ; } return ICU . getISO3CountryNative ( toString ( ) ) ; } 
protected boolean ensureDirectoryExists ( File directory ) { if ( ! directory . exists ( ) ) { if ( ! queryYesNoQuestion ( "Target-directory-does-not-exist.-Would-you-like-to-create-it?" ) ) { return false ; } if ( ! directory . mkdirs ( ) ) { displayErrorDialog ( "Target-directory-could-not-be-created." ) ; exportFolderPathField . setFocus ( ) ; return false ; } } return true ; } 
@ Override public CharArrayWriter append ( char c ) { write ( c ) ; return this ; } 
public Cell < Double > getAgentLocation ( Agent anAgent ) { return agentLocations . get ( anAgent ) . getCell ( ) ; } 
public static IntBuffer wrap ( int [ ] array ) { return wrap ( array , 0 , array . length ) ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; javax . xml . namespace . NamespaceContext nsContext = xmlWriter . getNamespaceContext ( ) ; while ( true ) { java . lang . String uri = nsContext . getNamespaceURI ( prefix ) ; if ( uri == null || uri . length ( ) == 0 ) { break ; } prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
protected String decodeUTF8 ( DataInputStream input ) throws MqttException { int encodedLength ; try { encodedLength = input . readUnsignedShort ( ) ; byte [ ] encodedString = new byte [ encodedLength ] ; input . readFully ( encodedString ) ; return new String ( encodedString , "UTF-8" ) ; } catch ( IOException ex ) { throw new MqttException ( ex ) ; } } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public String showPlayers ( ) { int count = 0 ; List < String > players = new ArrayList < > ( ) ; for ( Map . Entry < String , Player > entry : this . playersByNickname . entrySet ( ) ) { if ( entry . getValue ( ) . getOnline ( ) ) { players . add ( entry . getValue ( ) . getNickname ( ) ) ; count ++ ; } } if ( players . isEmpty ( ) ) players . add ( Strings . FORMAT_NONE ) ; return String . format ( Strings . FORMAT_LIST_PLAYERS , count , Strings . join ( players , ",-" ) ) ; } 
Collection < DatanodeDescriptor > getNodes ( Block blk ) { return corruptReplicasMap . get ( blk ) ; } 
protected void reducePermits ( int reduction ) { if ( reduction < 0 ) throw new IllegalArgumentException ( ) ; sync . reducePermits ( reduction ) ; } 
public static boolean setOwnerPerm ( File f , boolean r , boolean w , boolean x ) { boolean success = true ; try { String [ ] methods = { "setReadable" , "setWritable" , "setExecutable" } ; boolean [ ] perms = { r , w , x } ; for ( int i = 0 ; i < methods . length ; ++ i ) { Method m = File . class . getDeclaredMethod ( methods [ i ] , boolean . class , boolean . class ) ; if ( m != null ) { success &= ( Boolean ) m . invoke ( f , false , false ) ; success &= ( Boolean ) m . invoke ( f , perms [ i ] , true ) ; } } } catch ( NoSuchMethodException e ) { success = false ; } catch ( java . lang . reflect . InvocationTargetException e ) { success = false ; } catch ( IllegalAccessException e ) { success = false ; } catch ( ExceptionInInitializerError e ) { success = false ; } catch ( RuntimeException e ) { success = false ; } return success ; } 
public int size ( ) { return entrySet ( ) . size ( ) ; } 
public static void write ( OutputStream ostream , String value ) { ostream . write_string ( value ) ; } 
private void magnitudeFFT ( double [ ] re ) { double [ ] im = new double [ re . length ] ; for ( int i = 0 ; i < re . length ; i ++ ) re [ i ] = Math . sqrt ( re [ i ] * re [ i ] + im [ i ] * im [ i ] ) ; } 
static final void outputPItoWriter ( ProcessingInstruction currentPI , OutputStream writer ) throws IOException { final int position = getPositionRelativeToDocumentElement ( currentPI ) ; if ( position == NODE_AFTER_DOCUMENT_ELEMENT ) { writer . write ( '|n' ) ; } writer . write ( _BEGIN_PI ) ; final String target = currentPI . getTarget ( ) ; int length = target . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { char c = target . charAt ( i ) ; if ( c == 0x0D ) { writer . write ( __XD_ ) ; } else { writeCharToUtf8 ( c , writer ) ; } } final String data = currentPI . getData ( ) ; length = data . length ( ) ; if ( length > 0 ) { writer . write ( '-' ) ; for ( int i = 0 ; i < length ; i ++ ) { char c = data . charAt ( i ) ; if ( c == 0x0D ) { writer . write ( __XD_ ) ; } else { writeCharToUtf8 ( c , writer ) ; } } } writer . write ( _END_PI ) ; if ( position == NODE_BEFORE_DOCUMENT_ELEMENT ) { writer . write ( '|n' ) ; } } 
@ Override public int hashCode ( ) { return path != null ? path . hashCode ( ) : 0 ; } 
public static void setFont ( Graphics g , String name , int style , int size ) { Font myFont = new Font ( name , style , size ) ; g . setFont ( myFont ) ; } 
private static void writeParameters ( ObjectOutputStream out , Class [ ] parms ) throws IOException { out . writeShort ( parms . length ) ; outer : for ( int i = 0 ; i < parms . length ; i ++ ) { Class parm = parms [ i ] ; boolean primitive = parm . isPrimitive ( ) ; out . writeBoolean ( primitive ) ; if ( ! primitive ) { out . writeObject ( parm ) ; continue ; } for ( int j = 0 ; j < primitives . length ; j ++ ) { if ( parm . equals ( primitives [ j ] ) ) { out . writeByte ( j ) ; continue outer ; } } throw new IllegalArgumentException ( "Primitive-" + parm + "-not-found" ) ; } } 
public static Encoder getKeysStringEncoder ( Hashtable < String , String > _param , byte type ) { if ( _param == null ) { return Encoder . getNullEncoder ( ) ; } Encoder enc = new Encoder ( ) . initSequence ( ) ; String [ ] param = convertHashtableToArray ( _param ) ; for ( int k = 0 ; k < param . length ; k ++ ) { if ( param [ k ] != null ) enc . addToSequence ( new Encoder ( param [ k ] , type ) ) ; else enc . addToSequence ( Encoder . getNullEncoder ( ) ) ; } return enc ; } 
public double getSkewness ( ) { return apply ( skewnessImpl ) ; } 
public void complete ( ) { latch . countDown ( ) ; state = CommandState . COMPLETE ; } 
public Map < String , List < String >> toMultimap ( boolean response ) { Map < String , List < String >> result = new TreeMap < String , List < String >> ( FIELD_NAME_COMPARATOR ) ; for ( int i = 0 ; i < namesAndValues . size ( ) ; i += 2 ) { String fieldName = namesAndValues . get ( i ) ; String value = namesAndValues . get ( i + 1 ) ; List < String > allValues = new ArrayList < String > ( ) ; List < String > otherValues = result . get ( fieldName ) ; if ( otherValues != null ) { allValues . addAll ( otherValues ) ; } allValues . add ( value ) ; result . put ( fieldName , Collections . unmodifiableList ( allValues ) ) ; } if ( response && statusLine != null ) { result . put ( null , Collections . unmodifiableList ( Collections . singletonList ( statusLine ) ) ) ; } else if ( requestLine != null ) { result . put ( null , Collections . unmodifiableList ( Collections . singletonList ( requestLine ) ) ) ; } return Collections . unmodifiableMap ( result ) ; } 
public void copyFrom ( PolicyInfo other ) { if ( other . conf != null ) { this . conf = other . conf ; } if ( other . policyName != null && other . policyName . length ( ) > 0 ) { this . policyName = other . policyName ; } if ( other . description != null && other . description . length ( ) > 0 ) { this . description = other . description ; } if ( other . codecId != null ) { this . codecId = other . codecId ; } if ( other . srcPath != null ) { this . srcPath = other . srcPath ; } if ( other . fileListPath != null ) { this . fileListPath = other . fileListPath ; } for ( Object key : other . properties . keySet ( ) ) { String skey = ( String ) key ; this . properties . setProperty ( skey , other . properties . getProperty ( skey ) ) ; } LOG . info ( this . policyName + ".codecId-" + codecId ) ; LOG . info ( this . policyName + ".fileListPath-" + fileListPath ) ; LOG . info ( this . policyName + ".srcpath-" + srcPath ) ; } 
public void addPoint ( int x , int y ) { if ( npoints >= xpoints . length || npoints >= ypoints . length ) { int newLength = npoints * 2 ; if ( newLength < MIN_LENGTH ) { newLength = MIN_LENGTH ; } else if ( ( newLength & ( newLength - 1 ) ) != 0 ) { newLength = Integer . highestOneBit ( newLength ) ; } xpoints = CollectionUtils . copyOf ( xpoints , newLength ) ; ypoints = CollectionUtils . copyOf ( ypoints , newLength ) ; } xpoints [ npoints ] = x ; ypoints [ npoints ] = y ; npoints ++ ; if ( bounds != null ) { updateBounds ( x , y ) ; } } 
@ Deprecated public void setTTL ( byte ttl ) throws IOException { if ( isClosed ( ) ) throw new SocketException ( "Socket-is-closed" ) ; getImpl ( ) . setTTL ( ttl ) ; } 
public boolean isVoid ( ) { return permissions == null || permissions . size ( ) == 0 ; } 
public StrBuilder appendFixedWidthPadLeft ( int value , int width , char padChar ) { return appendFixedWidthPadLeft ( String . valueOf ( value ) , width , padChar ) ; } 
void updateStartStopText ( int row ) { if ( proc == null ) return ; if ( row < 0 ) { startStopButton . setText ( "*" ) ; startStopButton . setEnabled ( false ) ; return ; } int row2 = proctable . convertRowIndexToModel ( row ) ; int procid = processes . get ( row2 ) . procid ; if ( proc . getRunStatus ( procid ) ) startStopButton . setText ( "Stop" ) ; else startStopButton . setText ( "Start" ) ; startStopButton . setEnabled ( true ) ; } 
private void setTimestampInternal ( int parameterIndex , Timestamp x , Calendar targetCalendar , TimeZone tz , boolean rollForward ) throws SQLException { if ( x == null ) { setNull ( parameterIndex , java . sql . Types . TIMESTAMP ) ; } else { checkClosed ( ) ; if ( ! this . useLegacyDatetimeCode ) { newSetTimestampInternal ( parameterIndex , x , targetCalendar ) ; } else { String timestampString = null ; Calendar sessionCalendar = this . connection . getUseJDBCCompliantTimezoneShift ( ) ? this . connection . getUtcCalendar ( ) : getCalendarInstanceForSessionOrNew ( ) ; synchronized ( sessionCalendar ) { x = TimeUtil . changeTimezone ( this . connection , sessionCalendar , targetCalendar , x , tz , this . connection . getServerTimezoneTZ ( ) , rollForward ) ; } if ( this . connection . getUseSSPSCompatibleTimezoneShift ( ) ) { doSSPSCompatibleTimezoneShift ( parameterIndex , x , sessionCalendar ) ; } else { synchronized ( this ) { if ( this . tsdf == null ) { this . tsdf = new SimpleDateFormat ( "''yyyy-MM-dd-HH:mm:ss''" , Locale . US ) ; } timestampString = this . tsdf . format ( x ) ; if ( false ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( timestampString ) ; int nanos = x . getNanos ( ) ; if ( nanos != 0 ) { buf . append ( '.' ) ; buf . append ( formatNanos ( nanos ) ) ; } buf . append ( '|'' ) ; } setInternal ( parameterIndex , timestampString ) ; } } } this . parameterTypes [ parameterIndex - 1 + getParameterIndexOffset ( ) ] = Types . TIMESTAMP ; } } 
public void addSpace ( int nbVertSpace ) { add ( Box . createRigidArea ( new Dimension ( 0 , nbVertSpace ) ) ) ; } 
public ListBoxItem getItem ( String theItemName ) { for ( int i = items . size ( ) - 1 ; i >= 0 ; i -- ) { if ( ( items . get ( i ) ) . name . equals ( theItemName ) ) { return items . get ( i ) ; } } return null ; } 
public Builder addKernel ( Script . KernelID k ) { if ( mLines . size ( ) != 0 ) { throw new RSInvalidStateException ( "Kernels-may-not-be-added-once-connections-exist." ) ; } if ( findNode ( k ) != null ) { return this ; } mKernelCount ++ ; Node n = findNode ( k . mScript ) ; if ( n == null ) { n = new Node ( k . mScript ) ; mNodes . add ( n ) ; } n . mKernels . add ( k ) ; return this ; } 
public final boolean supports ( String feature , String version ) { return implementation . hasFeature ( feature , version ) ; } 
public static String dirname ( String path ) { int lastSlash = path . lastIndexOf ( "/" ) ; if ( "/" . equals ( path ) || lastSlash == 0 ) { return "/" ; } else if ( lastSlash == - 1 ) { return "." ; } else { return path . substring ( 0 , lastSlash ) ; } } 
private void loadTemplate ( ) throws SchemaCompilationException { Class < ? > clazz = this . getClass ( ) ; String templateName = javaBeanTemplateName ; if ( templateName != null ) { try { URL xsl = clazz . getResource ( templateName ) ; templateCache = TransformerFactory . newInstance ( ) . newTemplates ( new StreamSource ( xsl . toExternalForm ( ) ) ) ; templateLoaded = true ; } catch ( TransformerConfigurationException e ) { throw new SchemaCompilationException ( SchemaCompilerMessages . getMessage ( "schema.templateLoadException" ) , e ) ; } } else { throw new SchemaCompilationException ( SchemaCompilerMessages . getMessage ( "schema.templateNotFoundException" ) ) ; } } 
public int getCdmaSubscriptionSource ( ) { return mCdmaSubscriptionSource . get ( ) ; } 
public Stroke getLastStroke ( boolean enabled ) { Stroke stroke = null ; for ( int i = m_stkList . size ( ) - 1 ; i >= 0 ; i -- ) { stroke = ( Stroke ) m_stkList . get ( i ) ; if ( stroke . isEnabled ( ) == enabled ) break ; stroke = null ; } return stroke ; } 
private void scan ( File f , Map scanInfoMap ) { try { if ( ! f . exists ( ) ) { return ; } if ( f . isFile ( ) ) { String name = f . getCanonicalPath ( ) ; long lastModified = f . lastModified ( ) ; scanInfoMap . put ( name , new Long ( lastModified ) ) ; } else if ( f . isDirectory ( ) ) { File [ ] files = f . listFiles ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) scan ( files [ i ] , scanInfoMap ) ; } else PluginLog . getLog ( ) . error ( "Skipping-file-of-unacceptable-type:-" + f . getName ( ) ) ; } catch ( IOException e ) { PluginLog . getLog ( ) . error ( "Error-scanning-watched-files" , e ) ; } } 
public static String slurpReader ( Reader reader ) { BufferedReader r = new BufferedReader ( reader ) ; StringBuilder buff = new StringBuilder ( ) ; try { char [ ] chars = new char [ SLURPBUFFSIZE ] ; while ( true ) { int amountRead = r . read ( chars , 0 , SLURPBUFFSIZE ) ; if ( amountRead < 0 ) { break ; } buff . append ( chars , 0 , amountRead ) ; } r . close ( ) ; } catch ( Exception e ) { throw new RuntimeIOException ( "slurpReader-IO-problem" , e ) ; } return buff . toString ( ) ; } 
protected void RelativePathPattern ( ) throws javax . xml . transform . TransformerException { boolean trailingSlashConsumed = StepPattern ( false ) ; while ( tokenIs ( '/' ) ) { nextToken ( ) ; trailingSlashConsumed = StepPattern ( ! trailingSlashConsumed ) ; } } 
private String escapeTabs ( String string ) { StringBuffer buffer = new StringBuffer ( ) ; int begin = 0 ; int end = string . indexOf ( '|t' , begin ) ; while ( end >= 0 ) { buffer . append ( string . substring ( begin , end ) ) ; buffer . append ( TAB ) ; begin = end + 1 ; end = string . indexOf ( '|t' , begin ) ; } buffer . append ( string . substring ( begin ) ) ; return buffer . toString ( ) ; } 
public final PrivateKey generatePrivate ( KeySpec keySpec ) throws InvalidKeySpecException { if ( serviceIterator == null ) { return spi . engineGeneratePrivate ( keySpec ) ; } Exception failure = null ; KeyFactorySpi mySpi = spi ; do { try { return mySpi . engineGeneratePrivate ( keySpec ) ; } catch ( Exception e ) { if ( failure == null ) { failure = e ; } mySpi = nextSpi ( mySpi ) ; } } while ( mySpi != null ) ; if ( failure instanceof RuntimeException ) { throw ( RuntimeException ) failure ; } if ( failure instanceof InvalidKeySpecException ) { throw ( InvalidKeySpecException ) failure ; } throw new InvalidKeySpecException ( "Could-not-generate-private-key" , failure ) ; } 
public ContextService findService ( String name ) { synchronized ( services ) { return services . get ( name ) ; } } 
protected HashAttributeSet ( Attribute attribute , Class < ? > interfaceName ) { this ( interfaceName ) ; if ( attribute == null ) throw new NullPointerException ( ) ; addInternal ( attribute , interfaceName ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
void doReps ( ObjectOutputStream oout , ObjectInputStream oin , StreamBuffer sbuf , ObjectStreamClass [ ] descs , int ncycles ) throws Exception { int ndescs = descs . length ; for ( int i = 0 ; i < ncycles ; i ++ ) { sbuf . reset ( ) ; oout . reset ( ) ; for ( int j = 0 ; j < ndescs ; j ++ ) { oout . writeObject ( descs [ j ] ) ; } oout . flush ( ) ; for ( int j = 0 ; j < ndescs ; j ++ ) { oin . readObject ( ) ; } } } 
public static void setProperty ( Object object , String namePrefix , String name , String value ) { String prefixed = namePrefix + name . substring ( 0 , 1 ) . toUpperCase ( ) + name . substring ( 1 , name . length ( ) ) ; setProperty ( object , prefixed , value ) ; } 
private byte [ ] getMessage ( int zone , byte category , byte channel , int value ) { ArrayList < Integer > zoneArray = new ArrayList < Integer > ( ) ; zoneArray . add ( zone ) ; return this . getMessage ( zoneArray , category , channel , value ) ; } 
private View findFocusableViewInBounds ( boolean leftFocus , int left , int right ) { List < View > focusables = getFocusables ( View . FOCUS_FORWARD ) ; View focusCandidate = null ; boolean foundFullyContainedFocusable = false ; int count = focusables . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { View view = focusables . get ( i ) ; int viewLeft = view . getLeft ( ) ; int viewRight = view . getRight ( ) ; if ( left < viewRight && viewLeft < right ) { final boolean viewIsFullyContained = ( left < viewLeft ) && ( viewRight < right ) ; if ( focusCandidate == null ) { focusCandidate = view ; foundFullyContainedFocusable = viewIsFullyContained ; } else { final boolean viewIsCloserToBoundary = ( leftFocus && viewLeft < focusCandidate . getLeft ( ) ) || ( ! leftFocus && viewRight > focusCandidate . getRight ( ) ) ; if ( foundFullyContainedFocusable ) { if ( viewIsFullyContained && viewIsCloserToBoundary ) { focusCandidate = view ; } } else { if ( viewIsFullyContained ) { focusCandidate = view ; foundFullyContainedFocusable = true ; } else if ( viewIsCloserToBoundary ) { focusCandidate = view ; } } } } } return focusCandidate ; } 
public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { if ( contentHandler != null ) { contentHandler . ignorableWhitespace ( ch , start , length ) ; } } 
public void setFeature ( String featureId , boolean state ) throws XMLConfigurationException { if ( featureId . startsWith ( Constants . XERCES_FEATURE_PREFIX ) ) { final int suffixLength = featureId . length ( ) - Constants . XERCES_FEATURE_PREFIX . length ( ) ; if ( suffixLength == Constants . ALLOW_JAVA_ENCODINGS_FEATURE . length ( ) && featureId . endsWith ( Constants . ALLOW_JAVA_ENCODINGS_FEATURE ) ) { fAllowJavaEncodings = state ; } if ( suffixLength == Constants . LOAD_EXTERNAL_DTD_FEATURE . length ( ) && featureId . endsWith ( Constants . LOAD_EXTERNAL_DTD_FEATURE ) ) { fLoadExternalDTD = state ; return ; } } } 
@ XmlElementDecl ( namespace = "http://docs.oasis-open.org/legaldocml/ns/akn/3.0/CSD09" , name = "intro" ) public JAXBElement < Blocksreq > createIntro ( Blocksreq value ) { return new JAXBElement < Blocksreq > ( _Intro_QNAME , Blocksreq . class , null , value ) ; } 
public SearchResult getParentINForChildIN ( IN child , boolean useTargetLevel , boolean doFetch , CacheMode cacheMode ) throws DatabaseException { return getParentINForChildIN ( child , useTargetLevel , doFetch , cacheMode , null ) ; } 
public int getTile ( int x , int y ) { if ( ! isValidLocation ( x , y ) ) { throw new IndexOutOfBoundsException ( "Tile-with-coordinates-(" + x + ",-" + y + ")-is-out-of-the-map-bounds." ) ; } return map [ x ] [ y ] ; } 
public static baconhep . TPhoton . Builder newBuilder ( ) { return new baconhep . TPhoton . Builder ( ) ; } 
@ Override public void removePropertyChangeListener ( PropertyChangeListener listener ) { support . removePropertyChangeListener ( listener ) ; } 
public void configure ( MediaFormat format , Surface surface , MediaCrypto crypto , int flags ) { Map < String , Object > formatMap = format . getMap ( ) ; String [ ] keys = null ; Object [ ] values = null ; if ( format != null ) { keys = new String [ formatMap . size ( ) ] ; values = new Object [ formatMap . size ( ) ] ; int i = 0 ; for ( Map . Entry < String , Object > entry : formatMap . entrySet ( ) ) { keys [ i ] = entry . getKey ( ) ; values [ i ] = entry . getValue ( ) ; ++ i ; } } native_configure ( keys , values , surface , crypto , flags ) ; } 
@ Override public int size ( ) { return backingMap . size ( ) ; } 
public void add ( EventType eventType , FilterHandleSetNode rootNode ) { eventTypesRWLock . writeLock ( ) . lock ( ) ; try { if ( eventTypes . containsKey ( eventType ) ) { throw new IllegalStateException ( "Event-type-already-in-index,-add-not-performed,-type=" + eventType ) ; } eventTypes . put ( eventType , rootNode ) ; } finally { eventTypesRWLock . writeLock ( ) . unlock ( ) ; } } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
void merge ( int min , int max ) { for ( int i = 0 ; i < num ; i ++ ) { if ( min >= minRange [ i ] && max <= maxRange [ i ] ) { return ; } else if ( min <= minRange [ i ] && max >= maxRange [ i ] ) { delete ( i ) ; merge ( min , max ) ; return ; } else if ( min >= minRange [ i ] && min <= maxRange [ i ] ) { delete ( i ) ; min = minRange [ i ] ; merge ( min , max ) ; return ; } else if ( max >= minRange [ i ] && max <= maxRange [ i ] ) { delete ( i ) ; max = maxRange [ i ] ; merge ( min , max ) ; return ; } } if ( num >= size ) { size *= 2 ; int [ ] newMin = new int [ size ] ; int [ ] newMax = new int [ size ] ; System . arraycopy ( minRange , 0 , newMin , 0 , num ) ; System . arraycopy ( maxRange , 0 , newMax , 0 , num ) ; minRange = newMin ; maxRange = newMax ; } minRange [ num ] = min ; maxRange [ num ] = max ; num ++ ; } 
public Component getTableCellRendererComponent ( JTable table , Object value , boolean isSelected , boolean hasFocus , int row , int column ) { if ( column == 0 ) { FileView v = getFileView ( getFileChooser ( ) ) ; ListModel lm = fileList . getModel ( ) ; if ( row < lm . getSize ( ) ) setIcon ( v . getIcon ( ( File ) lm . getElementAt ( row ) ) ) ; } else setIcon ( null ) ; setText ( value . toString ( ) ) ; setOpaque ( true ) ; setEnabled ( table . isEnabled ( ) ) ; setFont ( fileList . getFont ( ) ) ; if ( startEditing && column == 0 || ! isSelected ) { setBackground ( table . getBackground ( ) ) ; setForeground ( table . getForeground ( ) ) ; } else { setBackground ( table . getSelectionBackground ( ) ) ; setForeground ( table . getSelectionForeground ( ) ) ; } if ( hasFocus ) setBorder ( UIManager . getBorder ( "Table.focusCellHighlightBorder" ) ) ; else setBorder ( noFocusBorder ) ; return this ; } 
public CloseableListIterator < T > listIterator ( ) { return listLazyUncached ( ) . listIteratorAutoClose ( ) ; } 
public void startTimedRefresh ( int time ) { t = new Timer ( time , new ActionListener ( ) { public void actionPerformed ( ActionEvent arg0 ) { scheduleRefresh ( ) ; } } ) ; t . start ( ) ; } 
public static Cursor getCursor ( int id ) { Integer key = Integer . valueOf ( id ) ; Cursor cursor = m_idToCursorMap . get ( key ) ; if ( cursor == null ) { cursor = new Cursor ( Display . getDefault ( ) , id ) ; m_idToCursorMap . put ( key , cursor ) ; } return cursor ; } 
public static void init ( String propFile ) throws SettingsError { String outFile ; try { if ( new File ( DEF_SETTINGS_FILE ) . exists ( ) ) { Properties defProperties = new Properties ( ) ; defProperties . load ( new FileInputStream ( DEF_SETTINGS_FILE ) ) ; props = new Properties ( defProperties ) ; } else { props = new Properties ( ) ; } if ( propFile != null ) { props . load ( new FileInputStream ( propFile ) ) ; } } catch ( IOException e ) { throw new SettingsError ( e ) ; } outFile = props . getProperty ( SETTING_OUTPUT_S ) ; if ( outFile != null ) { if ( outFile . trim ( ) . length ( ) == 0 ) { out = System . out ; } else { try { out = new PrintStream ( new File ( outFile ) ) ; } catch ( FileNotFoundException e ) { throw new SettingsError ( "Can't-open-Settings-output-file:" + e ) ; } } } } 
private static IFrameElement createIFrame ( String src , String name ) { if ( name == null || ! isValidName ( name . trim ( ) ) ) { throw new IllegalArgumentException ( "expecting-one-or-more-non-whitespace-chars-with-no-'<',-'>',-or-'&'" ) ; } Element div = DOM . createDiv ( ) ; div . setInnerSafeHtml ( IFrameTemplate . INSTANCE . get ( src , name ) ) ; return div . getFirstChild ( ) . cast ( ) ; } 
public void initialize ( InputStream propertiesStream ) throws SchedulerException { if ( cfg != null ) { return ; } if ( initException != null ) { throw initException ; } Properties props = new Properties ( ) ; if ( propertiesStream != null ) { try { props . load ( propertiesStream ) ; propSrc = "an-externally-opened-InputStream." ; } catch ( IOException e ) { initException = new SchedulerException ( "Error-loading-property-data-from-InputStream" , e ) ; throw initException ; } } else { initException = new SchedulerException ( "Error-loading-property-data-from-InputStream---InputStream-is-null." ) ; throw initException ; } initialize ( props ) ; } 
public final int arrayCopyInto ( double [ ] array , int startingArrayLocation ) { System . arraycopy ( values , 0 , array , startingArrayLocation , values . length ) ; return startingArrayLocation + values . length ; } 
private byte [ ] loadAudioData ( final String soundFile ) { if ( soundFile == null ) { return null ; } byte [ ] buffer = AccessController . doPrivileged ( new PrivilegedAction < byte [ ] > ( ) { public byte [ ] run ( ) { try { InputStream resource = BasicLookAndFeel . this . getClass ( ) . getResourceAsStream ( soundFile ) ; if ( resource == null ) { return null ; } BufferedInputStream in = new BufferedInputStream ( resource ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( 1024 ) ; byte [ ] buffer = new byte [ 1024 ] ; int n ; while ( ( n = in . read ( buffer ) ) > 0 ) { out . write ( buffer , 0 , n ) ; } in . close ( ) ; out . flush ( ) ; buffer = out . toByteArray ( ) ; return buffer ; } catch ( IOException ioe ) { System . err . println ( ioe . toString ( ) ) ; return null ; } } } ) ; if ( buffer == null ) { System . err . println ( getClass ( ) . getName ( ) + "/" + soundFile + "-not-found." ) ; return null ; } if ( buffer . length == 0 ) { System . err . println ( "warning:-" + soundFile + "-is-zero-length" ) ; return null ; } return buffer ; } 
@ XmlElementDecl ( namespace = "" , name = "webMaster" , scope = TRssChannel . class ) public JAXBElement < String > createTRssChannelWebMaster ( String value ) { return new JAXBElement < String > ( _TRssChannelWebMaster_QNAME , String . class , TRssChannel . class , value ) ; } 
public void setProgress ( int percent ) { percent = Math . min ( 100 , Math . max ( percent , 0 ) ) ; mProgressAngleDegrees = ( int ) ( ( 360f / 100 ) * percent ) ; if ( percent < 100 ) { mVisible = true ; mTimeToHide = System . currentTimeMillis ( ) + SHOW_PROGRESS_X_ADDITIONAL_MS ; } } 
public int getAccessibleChildrenCount ( JComponent a ) { int returnValue = ( ( ComponentUI ) ( uis . elementAt ( 0 ) ) ) . getAccessibleChildrenCount ( a ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . getAccessibleChildrenCount ( a ) ; } return returnValue ; } 
public static Hashtable < ElementType , Integer > getElemRules ( ) { Hashtable < ElementType , Integer > elemRules = new Hashtable < ElementType , Integer > ( ) ; elemRules . put ( ElementType . AIRCRAFT , 1 ) ; return elemRules ; } 
private HTMLElement getOffsetParent ( ) { final Object offsetParent = getOffsetParent_js ( ) ; if ( offsetParent instanceof HTMLElement ) { return ( HTMLElement ) offsetParent ; } return null ; } 
public static void removeClass ( JavaClass clazz ) { _repository . removeClass ( clazz ) ; } 
public void copyFrom ( PointerCoords other ) { final long bits = other . mPackedAxisBits ; mPackedAxisBits = bits ; if ( bits != 0 ) { final float [ ] otherValues = other . mPackedAxisValues ; final int count = Long . bitCount ( bits ) ; float [ ] values = mPackedAxisValues ; if ( values == null || count > values . length ) { values = new float [ otherValues . length ] ; mPackedAxisValues = values ; } System . arraycopy ( otherValues , 0 , values , 0 , count ) ; } x = other . x ; y = other . y ; pressure = other . pressure ; size = other . size ; touchMajor = other . touchMajor ; touchMinor = other . touchMinor ; toolMajor = other . toolMajor ; toolMinor = other . toolMinor ; orientation = other . orientation ; } 
@ Override public void dump ( FileDescriptor fd , PrintWriter writer , String [ ] args ) { Context context = getContext ( ) ; try { writer . print ( "Last-sync-attempted:-" ) ; writer . println ( new java . util . Date ( SettingsUtils . getLastSyncAttemptedTime ( context ) ) ) ; writer . print ( "Last-sync-successful:-" ) ; writer . println ( new java . util . Date ( SettingsUtils . getLastSyncSucceededTime ( context ) ) ) ; writer . print ( "Current-sync-interval:-" ) ; writer . println ( SettingsUtils . getCurSyncInterval ( context ) ) ; writer . print ( "Is-an-account-active:-" ) ; writer . println ( AccountUtils . hasActiveAccount ( context ) ) ; boolean canGetAuthToken = ! TextUtils . isEmpty ( AccountUtils . getAuthToken ( context ) ) ; writer . print ( "Can-an-auth-token-be-retrieved:-" ) ; writer . println ( canGetAuthToken ) ; } catch ( Exception exception ) { writer . append ( "Exception-while-dumping-state:-" ) ; exception . printStackTrace ( writer ) ; } } 
public Boolean run ( ) { return Boolean . getBoolean ( theProp ) ; } 
public boolean isDeclaredEntity ( String entityName ) { Entity entity = ( Entity ) fEntities . get ( entityName ) ; return entity != null ; } 
protected long getFlags ( ) { return sym . flags ( ) ; } 
public float getBlockPathWeight ( int par1 , int par2 , int par3 ) { return this . worldObj . getLightBrightness ( par1 , par2 , par3 ) - 0.5F ; } 
public static File loadFile ( String filePath , String fileName , boolean validate , String propertyName ) throws IllegalArgumentException { File path = new File ( filePath ) ; if ( validate && ( path == null || ! path . exists ( ) ) ) { throw new IllegalArgumentException ( ( propertyName != null ? "Property-'" + propertyName + "':-d" : "D" ) + "irectory-'" + filePath + "'-does-not-exist." ) ; } if ( validate && ! path . isDirectory ( ) ) throw new IllegalArgumentException ( ( propertyName != null ? "Property-'" + propertyName + "':-f" : "F" ) + "ile:-'" + filePath + "'-is-not-a-directory." ) ; File file = new File ( path , fileName ) ; if ( validate && ( file == null || ! file . exists ( ) ) ) { throw new IllegalArgumentException ( ( propertyName != null ? "Property-'" + propertyName + "':-f" : "F" ) + "ile:-'" + filePath + "/" + fileName + "'-does-not-exist." ) ; } return file ; } 
private void podaRegla ( Vector regla , Atributo clase ) { float confidenciaSubRegla ; float confidenciaOriginal ; int mejor ; int vueltas = 0 ; int tamanio = regla . size ( ) ; boolean parada = false ; Vector original ; Vector subReglas ; Vector subregla ; Vector hormiga ; Condicion vacia ; int numAtributosReglas = regla . size ( ) ; original = new Vector ( regla ) ; while ( ! parada && vueltas < numAtributosReglas ) { subReglas = new Vector ( ) ; for ( int i = 0 ; i < numAtributosReglas ; i ++ ) { subregla = new Vector ( original ) ; vacia = ( Condicion ) listaCondicionesVacias . get ( i ) ; subregla . set ( i , vacia ) ; subReglas . addElement ( subregla ) ; } confidenciaOriginal = calculaConfidencia ( regla , clase ) ; mejor = - 1 ; for ( int i = 0 ; i < numAtributosReglas ; i ++ ) { subregla = ( Vector ) subReglas . get ( i ) ; confidenciaSubRegla = calculaConfidencia ( subregla , clase ) ; if ( confidenciaSubRegla >= confidenciaOriginal ) { mejor = i ; } } if ( mejor == - 1 ) { parada = true ; } else { subregla = ( Vector ) subReglas . get ( mejor ) ; original = new Vector ( subregla ) ; } vueltas ++ ; } regla = new Vector ( original ) ; } 
public void output ( float [ ] afSamples ) { m_outputPort . output ( afSamples ) ; } 
public static void _main ( String argv [ ] ) { System . out . println ( getVersion ( ) ) ; } 
protected static Uri buildFileUri ( final String authority , final String extension ) { final long fileId = Math . abs ( RANDOM_ID . nextLong ( ) ) ; final Uri . Builder builder = ( new Uri . Builder ( ) ) . authority ( authority ) . scheme ( ContentResolver . SCHEME_CONTENT ) ; builder . appendPath ( String . valueOf ( fileId ) ) ; if ( ! TextUtils . isEmpty ( extension ) ) { builder . appendQueryParameter ( FILE_EXTENSION_PARAM_KEY , extension ) ; } return builder . build ( ) ; } 
public void flush ( ) throws java . io . IOException { m_os . flush ( ) ; } 
public static String getCallers ( final int start , int depth ) { final StackTraceElement [ ] callStack = Thread . currentThread ( ) . getStackTrace ( ) ; StringBuffer sb = new StringBuffer ( ) ; depth += start ; for ( int i = start ; i < depth ; i ++ ) { sb . append ( getCaller ( callStack , i ) ) . append ( "-" ) ; } return sb . toString ( ) ; } 
public static final String encode ( final byte [ ] bytes , final int start , final int length ) { final byte [ ] encoded = new byte [ calculateLengthOfEncodingIncludingLinereturn ( length ) ] ; int index = 0 , line = 0 ; byte remaining = 0x00 , triplet = 1 ; for ( int i = start ; i < start + length ; i ++ ) { switch ( triplet <<= 1 ) { case 2 : encoded [ index ++ ] = charSet [ firstSix ( bytes [ i ] ) ] ; remaining = lastTwo ( bytes [ i ] ) ; break ; case 4 : encoded [ index ++ ] = charSet [ plusFour ( remaining , bytes [ i ] ) ] ; remaining = lastFour ( bytes [ i ] ) ; break ; case 8 : encoded [ index ++ ] = charSet [ plusTwo ( remaining , bytes [ i ] ) ] ; encoded [ index ++ ] = charSet [ lastSix ( bytes [ i ] ) ] ; triplet = 1 ; if ( ++ line == maxlinelength ) { encoded [ index ++ ] = linebreakChar ; line = 0 ; } break ; } } if ( triplet > 1 ) encoded [ index ++ ] = charSet [ remaining ] ; while ( index < encoded . length ) encoded [ index ++ ] = '=' ; return new String ( encoded ) ; } 
@ CliCommand ( value = "hi" , help = "just-returns-hi-with-current-date" ) public String hi ( ) { DateFormat df = new SimpleDateFormat ( "yyy,-dd,-MMM" ) ; return "hi:-" + df . format ( Calendar . getInstance ( ) ) ; } 
@ Deprecated public synchronized void setObservedObject ( ObjectName object ) throws IllegalArgumentException { if ( object == null ) throw new IllegalArgumentException ( "Null-observed-object" ) ; if ( observedObjects . size ( ) == 1 && containsObservedObject ( object ) ) return ; observedObjects . clear ( ) ; addObservedObject ( object ) ; } 
public StyledDocument getStyledDocument ( ) { return ( StyledDocument ) getDocument ( ) ; } 
public TreePath lastButOne ( ) { return this . subPath ( 0 , this . size ( ) - 1 ) ; } 
public final Scheme get ( String name ) { if ( name == null ) throw new IllegalArgumentException ( "Name-must-not-be-null." ) ; Scheme found = registeredSchemes . get ( name ) ; return found ; } 
public Object [ ] toArray ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = 0 ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } } 
public List < PostalAddressType > getPostalAddress ( ) { if ( postalAddress == null ) { postalAddress = new ArrayList < PostalAddressType > ( ) ; } return this . postalAddress ; } 
public void removeExpressionListener ( ExpressionChangeListener listener ) { listeners . remove ( listener ) ; } 
public String getIdText ( ) { return Integer . toString ( id ) ; } 
private void waitForCleanupCallableToRun ( ) { try { executorService . submit ( new Runnable ( ) { @ Override public void run ( ) { } } ) . get ( ) ; } catch ( Exception e ) { throw new AssertionError ( ) ; } } 
public View create ( javax . swing . text . Element elem ) { AttributeSet attr = elem . getAttributes ( ) ; Object name = attr . getAttribute ( StyleConstants . NameAttribute ) ; if ( ( name == HTML . Tag . P ) || ( name == HTML . Tag . IMPLIED ) ) { return new WordSplittingParagraphView ( elem ) ; } return parent . create ( elem ) ; } 
public List < Row > getRows ( ) throws IllegalArgumentException { return Collections . unmodifiableList ( resultSet ) ; } 
public byte [ ] getData ( ) { byte [ ] returnedArray = new byte [ length - 1 ] ; System . arraycopy ( data , 1 , returnedArray , 0 , ( length - 1 ) ) ; return returnedArray ; } 
public JSeparator getJSeparatorMtREV24 ( ) { if ( jSeparatorMtREV24 == null ) { jSeparatorMtREV24 = new JSeparator ( ) ; jSeparatorMtREV24 . setLocation ( new Point ( 602 , 250 ) ) ; jSeparatorMtREV24 . setOrientation ( SwingConstants . VERTICAL ) ; jSeparatorMtREV24 . setSize ( new Dimension ( 10 , 40 ) ) ; } return jSeparatorMtREV24 ; } 
public Date getDate ( int columnIndex ) throws SQLException { Object t = getColumnInType ( columnIndex , Type . SQL_DATE ) ; if ( t == null ) { return null ; } return ( Date ) Type . SQL_DATE . convertSQLToJava ( session , t ) ; } 
public void close ( ) throws IOException { if ( type != null ) { encode ( out , buf , bufPtr ) ; for ( int i = 0 ; i != nl . length ( ) ; i ++ ) { out . write ( nl . charAt ( i ) ) ; } out . write ( '=' ) ; int crcV = crc . getValue ( ) ; buf [ 0 ] = ( ( crcV >> 16 ) & 0xff ) ; buf [ 1 ] = ( ( crcV >> 8 ) & 0xff ) ; buf [ 2 ] = ( crcV & 0xff ) ; encode ( out , buf , 3 ) ; for ( int i = 0 ; i != nl . length ( ) ; i ++ ) { out . write ( nl . charAt ( i ) ) ; } for ( int i = 0 ; i != footerStart . length ( ) ; i ++ ) { out . write ( footerStart . charAt ( i ) ) ; } for ( int i = 0 ; i != type . length ( ) ; i ++ ) { out . write ( type . charAt ( i ) ) ; } for ( int i = 0 ; i != footerTail . length ( ) ; i ++ ) { out . write ( footerTail . charAt ( i ) ) ; } for ( int i = 0 ; i != nl . length ( ) ; i ++ ) { out . write ( nl . charAt ( i ) ) ; } out . flush ( ) ; type = null ; start = true ; } } 
public void draw ( ) { draw ( 0 , 0 ) ; } 
public int find ( Object key ) { Object o = this . map . get ( key ) ; return o instanceof Integer ? ( ( Integer ) o ) . intValue ( ) : none ; } 
public void add ( final Permission permission ) { if ( ! ( permission instanceof ServicePermission ) ) { throw new IllegalArgumentException ( "invalid-permission:-" + permission ) ; } if ( isReadOnly ( ) ) { throw new SecurityException ( "attempt-to-add-a-Permission-to-a-" + "readonly-PermissionCollection" ) ; } final ServicePermission sp = ( ServicePermission ) permission ; if ( sp . service != null ) { throw new IllegalArgumentException ( "cannot-add-to-collection:-" + sp ) ; } final String name = sp . getName ( ) ; final Filter f = sp . filter ; synchronized ( this ) { Map pc ; if ( f != null ) { pc = filterPermissions ; if ( pc == null ) { filterPermissions = pc = new HashMap ( ) ; } } else { pc = permissions ; } final ServicePermission existing = ( ServicePermission ) pc . get ( name ) ; if ( existing != null ) { final int oldMask = existing . action_mask ; final int newMask = sp . action_mask ; if ( oldMask != newMask ) { pc . put ( name , new ServicePermission ( name , oldMask | newMask ) ) ; } } else { pc . put ( name , sp ) ; } if ( ! all_allowed ) { if ( name . equals ( "*" ) ) { all_allowed = true ; } } } } 
public static WifiP2pUpnpServiceRequest newInstance ( String st ) { if ( st == null ) { throw new IllegalArgumentException ( "search-target-cannot-be-null" ) ; } StringBuffer sb = new StringBuffer ( ) ; sb . append ( String . format ( Locale . US , "%02x" , WifiP2pUpnpServiceInfo . VERSION_1_0 ) ) ; sb . append ( WifiP2pServiceInfo . bin2HexStr ( st . getBytes ( ) ) ) ; return new WifiP2pUpnpServiceRequest ( sb . toString ( ) ) ; } 
public static String stripFileProtocol ( String uriString ) { if ( uriString . startsWith ( "file://" ) ) { uriString = uriString . substring ( 7 ) ; } return uriString ; } 
public void displayError ( final String title , final String message , final String button , final boolean exit ) { final CordovaActivity me = this ; me . runOnUiThread ( new Runnable ( ) { public void run ( ) { try { AlertDialog . Builder dlg = new AlertDialog . Builder ( me ) ; dlg . setMessage ( message ) ; dlg . setTitle ( title ) ; dlg . setCancelable ( false ) ; dlg . setPositiveButton ( button , new AlertDialog . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; if ( exit ) { me . endActivity ( ) ; } } } ) ; dlg . create ( ) ; dlg . show ( ) ; } catch ( Exception e ) { finish ( ) ; } } } ) ; } 
public void generate ( Queue < Pair < Env < AttrContext > , JCClassDecl >> queue ) { generate ( queue , null ) ; } 
public final Object execute ( final String method , final String collection , final HashMap < String , String > searchTerms ) throws ServiceException , IOException { return this . execute ( method , collection , searchTerms , false ) ; } 
public MatchResult exec ( String input ) { int searchStartIndex = ( globalFlag ) ? lastIndex : 0 ; Matcher matcher ; if ( input == null || searchStartIndex < 0 || searchStartIndex > input . length ( ) ) { matcher = null ; } else { matcher = pattern . matcher ( input ) ; if ( ! matcher . find ( searchStartIndex ) ) { matcher = null ; } } if ( matcher != null ) { int groupCount = matcher . groupCount ( ) ; List < String > groups = new ArrayList < String > ( 1 + groupCount ) ; for ( int group = 0 ; group <= groupCount ; group ++ ) { groups . add ( matcher . group ( group ) ) ; } if ( globalFlag ) { lastIndex = matcher . end ( ) ; } return new MatchResult ( matcher . start ( ) , input , groups ) ; } else { if ( globalFlag ) { lastIndex = 0 ; } return null ; } } 
public Vector getBandwidths ( boolean create ) { if ( bandwidthList == null ) { if ( create ) bandwidthList = new Vector ( ) ; } return bandwidthList ; } 
public void add ( int index , E element ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] elements = getArray ( ) ; int len = elements . length ; if ( index > len || index < 0 ) throw new IndexOutOfBoundsException ( "Index:-" + index + ",-Size:-" + len ) ; Object [ ] newElements ; int numMoved = len - index ; if ( numMoved == 0 ) newElements = Arrays . copyOf ( elements , len + 1 ) ; else { newElements = new Object [ len + 1 ] ; System . arraycopy ( elements , 0 , newElements , 0 , index ) ; System . arraycopy ( elements , index , newElements , index + 1 , numMoved ) ; } newElements [ index ] = element ; setArray ( newElements ) ; } finally { lock . unlock ( ) ; } } 
protected void sendStart ( OutputStream out ) throws IOException { out . write ( EXTRA_BYTES ) ; out . write ( getPartBoundary ( ) ) ; out . write ( CRLF_BYTES ) ; } 
@ Deprecated public ObjectInputStream deserialize ( String className , ObjectName loaderName , byte [ ] data ) throws InstanceNotFoundException , OperationsException , ReflectionException { loaderName = cloneObjectName ( loaderName ) ; try { getClassLoader ( loaderName ) ; } catch ( SecurityException e ) { throw e ; } catch ( Exception e ) { } ClassLoader myLoader = outerShell . getClass ( ) . getClassLoader ( ) ; return instantiator . deserialize ( className , loaderName , data , myLoader ) ; } 
private JPanel getContents ( ) { if ( contents == null ) { name = new JLabel ( ) ; name . setText ( "Goal-name" ) ; name . setMinimumSize ( new java . awt . Dimension ( 50 , 24 ) ) ; name . setMaximumSize ( new java . awt . Dimension ( 50 , 24 ) ) ; name . setPreferredSize ( new java . awt . Dimension ( 50 , 24 ) ) ; name . setBorder ( javax . swing . BorderFactory . createEmptyBorder ( 5 , 15 , 5 , 15 ) ) ; contents = new JPanel ( ) ; contents . setLayout ( new BorderLayout ( ) ) ; contents . setPreferredSize ( new java . awt . Dimension ( 150 , 50 ) ) ; contents . setBackground ( java . awt . Color . white ) ; contents . setMinimumSize ( new java . awt . Dimension ( 100 , 50 ) ) ; contents . add ( name , java . awt . BorderLayout . CENTER ) ; } return contents ; } 
public void writeVectorHeader ( int length ) throws IOException { out . write ( Type . VECTOR . code ) ; out . writeInt ( length ) ; } 
public int getLength ( ) { return nodes . size ( ) ; } 
public static ColorUIResource getPrimaryControlDarkShadow ( ) { return getCurrentTheme ( ) . getPrimaryControlDarkShadow ( ) ; } 
List < Annotation > getAnnotations ( ) { List < Annotation > toReturn = new ArrayList < Annotation > ( registrations . size ( ) ) ; for ( ObserverRegistration registration : registrations ) { toReturn . add ( registration . annotation ) ; } return toReturn ; } 
public boolean isDataFlavorSupported ( DataFlavor df ) { if ( isDrop ) { if ( source instanceof DropTargetDragEvent ) { return ( ( DropTargetDragEvent ) source ) . isDataFlavorSupported ( df ) ; } else { return ( ( DropTargetDropEvent ) source ) . isDataFlavorSupported ( df ) ; } } return ( ( Transferable ) source ) . isDataFlavorSupported ( df ) ; } 
@ Override public void putAll ( Map < ? extends K , ? extends V > map ) { putAllImpl ( map ) ; } 
public JarEntry getJarEntry ( ) throws IOException { return getJarFile ( ) . getJarEntry ( entryName ) ; } 
public String getMessage ( ) { return m_exception . getMessage ( ) ; } 
public static void showToast ( final Context context , final String message ) { getMainThreadHandler ( ) . post ( new Runnable ( ) { @ Override public void run ( ) { Toast . makeText ( context , message , Toast . LENGTH_LONG ) . show ( ) ; } } ) ; } 
private static void printUsage ( ) { final String lineSeparator = System . getProperty ( "line.separator" ) ; final StringBuffer msg = new StringBuffer ( ) ; msg . append ( Console . class . getCanonicalName ( ) + "-[options]" + lineSeparator ) ; msg . append ( lineSeparator ) ; msg . append ( "Options:-" + lineSeparator ) ; msg . append ( "--d-or--double-use-Double-evaluation-mode" + lineSeparator ) ; msg . append ( "--c-or--complex-use-Complex-evaluation-mode" + lineSeparator ) ; msg . append ( "--h-or--help-print-this-message" + lineSeparator ) ; msg . append ( "--f-or--file-<filename>-use-given-file-as-input" + lineSeparator ) ; msg . append ( "To-stop-the-program-type:-" + lineSeparator ) ; msg . append ( "exit<RETURN-KEY>" + lineSeparator ) ; msg . append ( "To-switch-between-the-evaluation-modes-type:-" + lineSeparator ) ; msg . append ( "complex<RETURN-KEY>-or" + lineSeparator ) ; msg . append ( "double<RETURN-KEY>" + lineSeparator ) ; msg . append ( "To-continue-an-input-line-type-'|'-at-the-end-of-the-line." + lineSeparator ) ; msg . append ( "****+****+****+****+****+****+****+****+****+****+****+****+" ) ; System . out . println ( msg . toString ( ) ) ; } 
public void start ( ) throws IOException { _process = _processBuilder . start ( ) ; _out = new InputReader ( new BufferedInputStream ( _process . getInputStream ( ) ) ) ; _err = new InputReader ( new BufferedInputStream ( _process . getErrorStream ( ) ) ) ; _out . start ( ) ; _err . start ( ) ; } 
public List < Warning > getWarning ( ) { if ( warning == null ) { warning = new ArrayList < Warning > ( ) ; } return this . warning ; } 
public double getDouble ( final String key ) throws PropertyParseException { String value = props . getProperty ( key ) ; if ( value == null ) throw new PropertyParseException ( "Missing-property" , key ) ; try { return Double . parseDouble ( value ) ; } catch ( NumberFormatException e ) { throw new PropertyParseException ( "Invalid-double-property" , key , value ) ; } } 
public Event idAttr ( final IDSimpleType idAttr ) { setIdAttr ( idAttr ) ; return this ; } 
public boolean isReverseAxes ( ) { return m_iterator . isReverse ( ) ; } 
private void resetNextProxy ( URI uri , Proxy proxy ) { this . hasNextProxy = true ; if ( proxy != null ) { this . userSpecifiedProxy = proxy ; } else { List < Proxy > proxyList = proxySelector . select ( uri ) ; if ( proxyList != null ) { this . proxySelectorProxies = proxyList . iterator ( ) ; } } } 
public synchronized boolean hasTrashFolder ( ) { return ! K9 . FOLDER_NONE . equalsIgnoreCase ( mTrashFolderName ) ; } 
public List < AudioSourceConfiguration > getConfigurations ( ) { if ( configurations == null ) { configurations = new ArrayList < AudioSourceConfiguration > ( ) ; } return this . configurations ; } 
@ Override public synchronized void removeInstanceListener ( InstanceListener tsl ) { m_instanceListeners . removeElement ( tsl ) ; } 
public static RequestAsyncTask executeBatchAsync ( Request ... requests ) { Validate . notNull ( requests , "requests" ) ; return executeBatchAsync ( Arrays . asList ( requests ) ) ; } 
private int nextRandomizationTime ( int index ) { int randomTime = mRetryArray . get ( index ) . mRandomizationTime ; if ( randomTime == 0 ) { return 0 ; } else { return mRng . nextInt ( randomTime ) ; } } 
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = false ; } 
private int deleteAllAffectedFiles ( ) { int count = 0 ; for ( Enumeration e = outOfDateClasses . elements ( ) ; e . hasMoreElements ( ) ; ) { String className = ( String ) e . nextElement ( ) ; count += deleteAffectedFiles ( className ) ; ClassFileInfo classInfo = ( ClassFileInfo ) classFileInfoMap . get ( className ) ; if ( classInfo != null && classInfo . absoluteFile . exists ( ) ) { classInfo . absoluteFile . delete ( ) ; count ++ ; } } return count ; } 
protected Range parseContentRange ( HttpServletRequest request , HttpServletResponse response ) throws IOException { String rangeHeader = request . getHeader ( "Content-Range" ) ; if ( rangeHeader == null ) return null ; if ( ! rangeHeader . startsWith ( "bytes" ) ) { response . sendError ( HttpServletResponse . SC_BAD_REQUEST ) ; return null ; } rangeHeader = rangeHeader . substring ( 6 ) . trim ( ) ; int dashPos = rangeHeader . indexOf ( '-' ) ; int slashPos = rangeHeader . indexOf ( '/' ) ; if ( dashPos == - 1 ) { response . sendError ( HttpServletResponse . SC_BAD_REQUEST ) ; return null ; } if ( slashPos == - 1 ) { response . sendError ( HttpServletResponse . SC_BAD_REQUEST ) ; return null ; } Range range = new Range ( ) ; try { range . start = Long . parseLong ( rangeHeader . substring ( 0 , dashPos ) ) ; range . end = Long . parseLong ( rangeHeader . substring ( dashPos + 1 , slashPos ) ) ; range . length = Long . parseLong ( rangeHeader . substring ( slashPos + 1 , rangeHeader . length ( ) ) ) ; } catch ( NumberFormatException e ) { response . sendError ( HttpServletResponse . SC_BAD_REQUEST ) ; return null ; } if ( ! range . validate ( ) ) { response . sendError ( HttpServletResponse . SC_BAD_REQUEST ) ; return null ; } return range ; } 
DeferredCommentImpl ( DeferredDocumentImpl ownerDocument , int nodeIndex ) { super ( ownerDocument , null ) ; fNodeIndex = nodeIndex ; needsSyncData ( true ) ; } 
public void printDebts ( ) { Log . printLine ( "*****PowerDatacenter:-" + this . getName ( ) + "*****" ) ; Log . printLine ( "User-id-Debt" ) ; Set < Integer > keys = getDebts ( ) . keySet ( ) ; Iterator < Integer > iter = keys . iterator ( ) ; DecimalFormat df = new DecimalFormat ( "#.##" ) ; while ( iter . hasNext ( ) ) { int key = iter . next ( ) ; double value = getDebts ( ) . get ( key ) ; Log . printLine ( key + "-" + df . format ( value ) ) ; } Log . printLine ( "**********************************" ) ; } 
public void markNewCallsAsOld ( ) { StringBuilder where = new StringBuilder ( ) ; where . append ( Calls . NEW ) ; where . append ( "-=-1" ) ; ContentValues values = new ContentValues ( 1 ) ; values . put ( Calls . NEW , "0" ) ; startUpdate ( UPDATE_MARK_AS_OLD_TOKEN , null , Calls . CONTENT_URI_WITH_VOICEMAIL , values , where . toString ( ) , null ) ; } 
public void deleteFileOrFolder ( File fileOrFolder ) { if ( fileOrFolder != null ) { if ( isDirectory ( fileOrFolder ) ) { File [ ] files = fileOrFolder . listFiles ( ) ; if ( files != null ) { for ( File item : files ) { deleteFileOrFolder ( item ) ; } } } if ( SdkConstants . CURRENT_PLATFORM == SdkConstants . PLATFORM_WINDOWS ) { for ( int i = 0 ; i < 5 ; i ++ ) { if ( fileOrFolder . delete ( ) ) { return ; } try { Thread . sleep ( 100 ) ; } catch ( InterruptedException e ) { } } fileOrFolder . deleteOnExit ( ) ; } else { if ( ! fileOrFolder . delete ( ) ) { fileOrFolder . deleteOnExit ( ) ; } } } } 
private void checkCorrectThread ( Handler h ) { if ( h . getLooper ( ) != mLooper ) { throw new RuntimeException ( "com.android.internal.telephony.Phone-must-be-used-from-within-one-thread" ) ; } } 
@ Override public String toString ( ) { return String . format ( "%d,%2d,%4d,%3d" , this . majorVersion , this . minorVersion , this . majorBuildNumber , this . minorBuildNumber ) ; } 
public static boolean interfaceExists ( String hostname ) { try { Class < ? > networkInterfaceClass = Class . forName ( "java.net.NetworkInterface" ) ; return networkInterfaceClass . getMethod ( "getByName" , ( Class [ ] ) null ) . invoke ( networkInterfaceClass , new Object [ ] { hostname } ) != null ; } catch ( Throwable t ) { return false ; } } 
public synchronized void write ( byte [ ] b , int off , int len ) throws IOException { ensureOpen ( ) ; if ( off < 0 || len < 0 || off > b . length - len ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len == 0 ) { return ; } if ( entry == null ) { throw new ZipException ( "no-current-ZIP-entry" ) ; } switch ( entry . method ) { case DEFLATED : super . write ( b , off , len ) ; break ; case STORED : written += len ; if ( written - locoff > entry . size ) { throw new ZipException ( "attempt-to-write-past-end-of-STORED-entry" ) ; } out . write ( b , off , len ) ; break ; default : throw new InternalError ( "invalid-compression-method" ) ; } crc . update ( b , off , len ) ; } 
public Any extract_any ( ) { checkExtractBadOperation ( TCKind . _tk_any ) ; return ( Any ) object ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
private static boolean isBoolean ( Method method ) { return method . getReturnType ( ) == boolean . class ; } 
public final void clearWidth ( ) { clearProperty ( STYLE_WIDTH ) ; } 
public static long getFreeDiskSpace ( boolean checkInternal ) { String status = Environment . getExternalStorageState ( ) ; long freeSpace = 0 ; if ( status . equals ( Environment . MEDIA_MOUNTED ) ) { freeSpace = freeSpaceCalculation ( Environment . getExternalStorageDirectory ( ) . getPath ( ) ) ; } else if ( checkInternal ) { freeSpace = freeSpaceCalculation ( "/" ) ; } else { return - 1 ; } return freeSpace ; } 
protected Map dataStoreParams ( Element dataStoreElement ) throws Exception { Element paramsElement = ReaderUtils . getChildElement ( dataStoreElement , "connectionParameters" , true ) ; NodeList paramList = paramsElement . getElementsByTagName ( "parameter" ) ; Map params = new HashMap ( ) ; for ( int i = 0 ; i < paramList . getLength ( ) ; i ++ ) { Element paramElement = ( Element ) paramList . item ( i ) ; String key = ReaderUtils . getAttribute ( paramElement , "name" , true ) ; String value = ReaderUtils . getAttribute ( paramElement , "value" , true ) ; params . put ( key , value ) ; } return params ; } 
public static StringBuffer toHexString ( byte b [ ] , int ofs , int len , StringBuffer sb ) { if ( sb == null ) { sb = new StringBuffer ( ) ; } if ( b != null ) { int bstrt = ( ofs < 0 ) ? 0 : ofs ; int bstop = ( len < 0 ) ? b . length : Math . min ( b . length , ( ofs + len ) ) ; for ( int i = bstrt ; i < bstop ; i ++ ) { StringTools . toHexString ( b [ i ] , sb ) ; } } return sb ; } 
public static void println ( boolean x ) { out . println ( x ) ; } 
public void submit ( ) { if ( myTextline . length ( ) > 0 ) { myTextList . add ( myTextline . toString ( ) ) ; update ( ) ; checkClear ( ) ; } } 
public void setOptions ( String [ ] options ) throws Exception { String tmpStr ; tmpStr = Utils . getOption ( 'E' , options ) ; if ( tmpStr . length ( ) != 0 ) setExponent ( Double . parseDouble ( tmpStr ) ) ; else setExponent ( 1.0 ) ; setUseLowerOrder ( Utils . getFlag ( 'L' , options ) ) ; super . setOptions ( options ) ; } 
public void stopAutoScroll ( ) { isAutoScroll = false ; handler . removeMessages ( SCROLL_WHAT ) ; } 
public void addLine ( String name ) { lines . addElement ( new DataLine ( this , name , Color . black ) ) ; } 
@ Override public boolean equals ( Object obj ) { if ( obj != null && obj instanceof Index ) { return name . equals ( ( ( Index ) obj ) . getName ( ) ) ; } return false ; } 
protected void doFormatValue ( final CharArrayBuffer buffer , final String value , boolean quote ) { if ( ! quote ) { for ( int i = 0 ; ( i < value . length ( ) ) && ! quote ; i ++ ) { quote = isSeparator ( value . charAt ( i ) ) ; } } if ( quote ) { buffer . append ( '"' ) ; } for ( int i = 0 ; i < value . length ( ) ; i ++ ) { char ch = value . charAt ( i ) ; if ( isUnsafe ( ch ) ) { buffer . append ( '|' ) ; } buffer . append ( ch ) ; } if ( quote ) { buffer . append ( '"' ) ; } } 
protected void setEncodedStringValues ( EncodedStringValue [ ] value , int field ) { if ( null == value ) { throw new NullPointerException ( ) ; } switch ( field ) { case BCC : case CC : case TO : break ; default : throw new RuntimeException ( "Invalid-header-field!" ) ; } ArrayList < EncodedStringValue > list = new ArrayList < EncodedStringValue > ( ) ; for ( int i = 0 ; i < value . length ; i ++ ) { list . add ( value [ i ] ) ; } mHeaderMap . put ( field , list ) ; } 
public Iligml10Writer ( java . io . File buffer , TransferDescription td ) throws IoxException { this . td = td ; String encoding = "UTF-8" ; try { init ( new java . io . OutputStreamWriter ( new java . io . FileOutputStream ( buffer ) , encoding ) ) ; } catch ( UnsupportedEncodingException ex ) { throw new IoxException ( ex ) ; } catch ( FileNotFoundException ex ) { throw new IoxException ( ex ) ; } } 
public static SnmpEngineId createEngineId ( int port ) throws UnknownHostException { int suniana = 42 ; InetAddress address = null ; address = InetAddress . getLocalHost ( ) ; return createEngineId ( address , port , suniana ) ; } 
private void writeHex ( int i ) throws IOException { int cursor = 8 ; do { hex [ -- cursor ] = HEX_DIGITS [ i & 0xf ] ; } while ( ( i >>>= 4 ) != 0 ) ; socketOut . write ( hex , cursor , hex . length - cursor ) ; } 
static int setLowercaseIndexOf ( CharArrayBuffer buffer , final int ch ) { int beginIndex = 0 ; int endIndex = buffer . length ( ) ; char [ ] chars = buffer . buffer ( ) ; for ( int i = beginIndex ; i < endIndex ; i ++ ) { char current = chars [ i ] ; if ( current == ch ) { return i ; } else if ( current >= 'A' && current <= 'Z' ) { current += uppercaseAddon ; chars [ i ] = current ; } } return - 1 ; } 
private static String getSingleMessageUID ( int msgNum ) { final String UID_HEAD = "ABCDEF-" ; final String UID_TAIL = "" ; return UID_HEAD + Integer . toString ( msgNum ) + UID_TAIL ; } 
public synchronized void cancel ( ) { cancelled = true ; tasks . reset ( ) ; this . notify ( ) ; } 
public boolean isSetRemarks ( ) { return ( ( this . remarks != null ) && ( ! this . remarks . isEmpty ( ) ) ) ; } 
protected String getFilterString ( ) { return filterText != null ? filterText . getText ( ) : null ; } 
private void setupDeleteButton ( ) { if ( mIsDeletable ) { mDeleteContainer . setVisibility ( View . VISIBLE ) ; mDelete . setEnabled ( ! mReadOnly && isEnabled ( ) ) ; } else { mDeleteContainer . setVisibility ( View . GONE ) ; } } 
public void addPCData ( final Reader reader , final String systemID , final int lineNr ) { int bufSize = 2048 ; int sizeRead = 0 ; final StringBuilder str = new StringBuilder ( bufSize ) ; final char [ ] buf = new char [ bufSize ] ; for ( ; ; ) { if ( sizeRead >= bufSize ) { bufSize *= 2 ; str . ensureCapacity ( bufSize ) ; } int size ; try { size = reader . read ( buf ) ; } catch ( final IOException e ) { break ; } if ( size < 0 ) { break ; } str . append ( buf , 0 , size ) ; sizeRead += size ; } final XMLElement elt = prototype . createElement ( null , systemID , lineNr ) ; elt . setContent ( str . toString ( ) ) ; if ( ! stack . empty ( ) ) { final XMLElement top = ( XMLElement ) stack . peek ( ) ; top . addChild ( elt ) ; } } 
IntRange ( int startId , int endId , String client ) { this . startId = startId ; this . endId = endId ; clients = new ArrayList < ClientRange > ( INITIAL_CLIENTS_ARRAY_SIZE ) ; clients . add ( new ClientRange ( startId , endId , client ) ) ; } 
public ShortBuffer put ( short [ ] src , int srcOffset , int shortCount ) { Arrays . checkOffsetAndCount ( src . length , srcOffset , shortCount ) ; if ( shortCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + shortCount ; ++ i ) { put ( src [ i ] ) ; } return this ; } 
@ Deprecated public static int getCurrentInc ( ) { return _nextInc . get ( ) ; } 
public boolean isAdd ( ) { boolean result = true ; if ( add != null ) { if ( add . trim ( ) . equalsIgnoreCase ( "false" ) ) { result = false ; } } return result ; } 
public double getCollectionFrequency ( HashMap < String , ArrayList < Integer >> termStats ) { double collectionFrequency = 0 ; for ( String docId : termStats . keySet ( ) ) { collectionFrequency = collectionFrequency + ( termStats . get ( docId ) ) . size ( ) ; } return collectionFrequency ; } 
public Pair < RequestHolder , Long > jpegProduced ( ) { final ReentrantLock lock = this . mLock ; lock . lock ( ) ; try { CaptureHolder h = mJpegProduceQueue . poll ( ) ; if ( h == null ) { Log . w ( TAG , "jpegProduced-called-with-no-jpeg-request-on-queue!" ) ; return null ; } h . setJpegProduced ( ) ; return new Pair < > ( h . mRequest , h . mTimestamp ) ; } finally { lock . unlock ( ) ; } } 
public int getJspReloadCount ( ) { return jspReloadCount . intValue ( ) ; } 
private static String getFileName ( String url ) { try { URL url2 = new URL ( url ) ; String path = url2 . getPath ( ) ; int i = path . indexOf ( ".nsf" ) ; if ( i > - 1 ) { path = path . substring ( i + 4 ) ; } if ( path . length ( ) > 0 && path . charAt ( 0 ) == '/' ) { path = path . substring ( 1 ) ; } String name = path ; if ( url2 . getQuery ( ) != null ) { name += '_' + url2 . getQuery ( ) ; } name = name . replace ( '/' , '_' ) . replace ( '?' , '_' ) . replace ( '&' , '_' ) ; System . out . println ( "writing-" + name ) ; return name ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } return url ; } 
int getIntFromStringPath ( int nrOfWord , String line ) { int a = 0 ; String [ ] tab = line . split ( "-" ) ; a = Integer . parseInt ( tab [ nrOfWord - 1 ] ) ; return a ; } 
public synchronized void connected ( Route route ) { failedRoutes . remove ( route ) ; } 
public static Type getReturnType ( final String methodDescriptor ) { char [ ] buf = methodDescriptor . toCharArray ( ) ; return getType ( buf , methodDescriptor . indexOf ( ')' ) + 1 ) ; } 
private String getProviderKey ( String elementName , String namespace ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( "<" ) . append ( elementName ) . append ( "/><" ) . append ( namespace ) . append ( "/>" ) ; return buf . toString ( ) ; } 
private void encLinkListener ( ) { Activator . getDefault ( ) . setIsFromEncLink ( true ) ; Activator . getDefault ( ) . setPubUname ( txtUserName . getText ( ) . trim ( ) ) ; Activator . getDefault ( ) . setPubPwd ( txtPassword . getText ( ) . trim ( ) ) ; Activator . getDefault ( ) . setPubCnfPwd ( txtConfirmPassword . getText ( ) . trim ( ) ) ; Object remoteAccess = new WARemoteAccessPropertyPage ( ) ; int btnId = PluginUtil . openPropertyPageDialog ( com . persistent . util . Messages . cmhIdRmtAces , com . persistent . util . Messages . cmhLblRmtAces , remoteAccess ) ; if ( btnId == Window . OK ) { loadDefaultRDPValues ( ) ; isPwdChanged = false ; } } 
FailedElements ( ) { failedRules = new HashSet < Integer > ( ) ; failedRulesInCompounds = new HashMap < String , Set < Integer >> ( ) ; } 
public double ptSegDistSq ( double px , double py ) { return ptSegDistSq ( getX1 ( ) , getY1 ( ) , getX2 ( ) , getY2 ( ) , px , py ) ; } 
public String describeAttributes ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "[" ) ; boolean first = true ; for ( Object key : attributes . keySet ( ) ) { if ( first ) { first = false ; } else { sb . append ( ",-" ) ; } sb . append ( key ) ; sb . append ( "==" ) ; sb . append ( attributes . get ( key ) ) ; } sb . append ( "]" ) ; return sb . toString ( ) ; } 
private void logEventNow ( final String eventName , final double valueToSum , final Bundle parameters ) { Settings . getExecutor ( ) . execute ( new Runnable ( ) { @ Override public void run ( ) { final String eventJSON = buildJSONForEvent ( eventName , valueToSum , parameters ) ; if ( eventJSON == null ) { return ; } GraphObject publishParams = GraphObject . Factory . create ( ) ; publishParams . setProperty ( "event" , "CUSTOM_APP_EVENTS" ) ; publishParams . setProperty ( "custom_events" , eventJSON ) ; if ( Utility . queryAppAttributionSupportAndWait ( applicationId ) ) { String attributionId = Settings . getAttributionId ( context . getContentResolver ( ) ) ; if ( attributionId != null ) { publishParams . setProperty ( "attribution" , attributionId ) ; } } String publishUrl = String . format ( "%s/activities" , applicationId ) ; try { Request postRequest = Request . newPostRequest ( sessionToLogTo ( ) , publishUrl , publishParams , null ) ; Response response = postRequest . executeAndWait ( ) ; final int NO_CONNECTIVITY_ERROR_CODE = - 1 ; if ( response . getError ( ) != null && response . getError ( ) . getErrorCode ( ) != NO_CONNECTIVITY_ERROR_CODE ) { notifyDeveloperError ( String . format ( "Error-publishing-Insights-event-'%s'-Response:-%s-Error:-%s" , eventJSON , response . toString ( ) , response . getError ( ) . toString ( ) ) ) ; } } catch ( Exception e ) { Utility . logd ( "Insights-exception:-" , e ) ; } } } ) ; } 
public void updateWidth ( String val , FontMetrics metrics , boolean force ) { int newWidth = metrics . stringWidth ( val ) ; if ( newWidth > width || force ) { width = newWidth ; } } 
private boolean isParentIcon ( ) { if ( rootParent instanceof JFrame ) { return ( ( ( JFrame ) rootParent ) . getExtendedState ( ) & Frame . ICONIFIED ) != 0 ; } else { return false ; } } 
int skipItems ( int num , ByteBuffer buffer ) { int n = Math . min ( num , buffer . remaining ( ) / 8 ) ; buffer . position ( buffer . position ( ) + 8 * n ) ; return n ; } 
public GroupObject ( Element element ) throws SlickException { name = element . getAttribute ( "name" ) ; type = element . getAttribute ( "type" ) ; x = Integer . parseInt ( element . getAttribute ( "x" ) ) ; y = Integer . parseInt ( element . getAttribute ( "y" ) ) ; width = Integer . parseInt ( element . getAttribute ( "width" ) ) ; height = Integer . parseInt ( element . getAttribute ( "height" ) ) ; Element imageElement = ( Element ) element . getElementsByTagName ( "image" ) . item ( 0 ) ; if ( imageElement != null ) { image = imageElement . getAttribute ( "source" ) ; } Element propsElement = ( Element ) element . getElementsByTagName ( "properties" ) . item ( 0 ) ; if ( propsElement != null ) { NodeList properties = propsElement . getElementsByTagName ( "property" ) ; if ( properties != null ) { props = new Properties ( ) ; for ( int p = 0 ; p < properties . getLength ( ) ; p ++ ) { Element propElement = ( Element ) properties . item ( p ) ; String name = propElement . getAttribute ( "name" ) ; String value = propElement . getAttribute ( "value" ) ; props . setProperty ( name , value ) ; } } } } 
public void uninstallUI ( JComponent c ) { Iterator iterator = uis . iterator ( ) ; while ( iterator . hasNext ( ) ) { ComponentUI ui = ( ComponentUI ) iterator . next ( ) ; ui . uninstallUI ( c ) ; } } 
void errorForDOM3 ( String msg , Object [ ] args ) throws TransformerException { String fmsg = XSLMessages . createXPATHMessage ( msg , args ) ; ErrorListener ehandler = this . getErrorListener ( ) ; TransformerException te = new XPathStylesheetDOM3Exception ( fmsg , m_sourceLocator ) ; if ( null != ehandler ) { ehandler . fatalError ( te ) ; } else { throw te ; } } 
public static void doQuit ( ) { synchronized ( isQuittingLock ) { if ( isQuitting ) return ; else isQuitting = true ; Object [ ] entries = allControllers . entrySet ( ) . toArray ( ) ; for ( int x = 0 ; x < entries . length ; x ++ ) if ( entries [ x ] != null && entries [ x ] instanceof Console ) ( ( Console ) ( ( ( Map . Entry ) ( entries [ x ] ) ) . getKey ( ) ) ) . doClose ( ) ; else if ( entries [ x ] != null && entries [ x ] instanceof SimpleController ) ( ( SimpleController ) ( ( ( Map . Entry ) ( entries [ x ] ) ) . getKey ( ) ) ) . doClose ( ) ; if ( ! ( SimApplet . isApplet ) ) try { System . exit ( 0 ) ; } catch ( Exception e ) { } isQuitting = false ; } } 
public void setValues ( PropertyValuesHolder ... values ) { int numValues = values . length ; mValues = values ; mValuesMap = new HashMap < String , PropertyValuesHolder > ( numValues ) ; for ( int i = 0 ; i < numValues ; ++ i ) { PropertyValuesHolder valuesHolder = values [ i ] ; mValuesMap . put ( valuesHolder . getPropertyName ( ) , valuesHolder ) ; } mInitialized = false ; } 
public final void setOrientationWithConstraint ( Rotation orientation ) { if ( referenceFrame ( ) != null ) { if ( is3D ( ) ) orientation = Quat . compose ( referenceFrame ( ) . orientation ( ) . inverse ( ) , orientation ) ; else orientation = Rot . compose ( referenceFrame ( ) . orientation ( ) . inverse ( ) , orientation ) ; } setRotationWithConstraint ( orientation ) ; } 
public int maxDifference ( ) { int max = seaLevels [ 0 ] ; int min = seaLevels [ 0 ] ; for ( int i = 1 ; i < seaLevels . length ; i ++ ) { if ( seaLevels [ i ] > max ) { max = seaLevels [ i ] ; } else if ( seaLevels [ i ] < min ) { min = seaLevels [ i ] ; } } int difference = Math . abs ( max - min ) ; return difference ; } 
public void add ( int index , E element ) { rangeCheckForAdd ( index ) ; ensureCapacityInternal ( size + 1 ) ; System . arraycopy ( elementData , index , elementData , index + 1 , size - index ) ; elementData [ index ] = element ; size ++ ; } 
public Object getAttribute ( Object key ) { if ( key instanceof StyleConstants ) { Object cssKey = css . styleConstantsKeyToCSSKey ( ( StyleConstants ) key ) ; if ( cssKey != null ) { Object value = super . getAttribute ( cssKey ) ; if ( value != null ) { return css . cssValueToStyleConstantsValue ( ( StyleConstants ) key , value ) ; } } } return super . getAttribute ( key ) ; } 
public static Variable unary ( String name ) { return new Variable ( name ) ; } 
synchronized long getFsEditTime ( ) { Iterator < StorageDirectory > it = fsimage . dirIterator ( NameNodeDirType . EDITS ) ; if ( it . hasNext ( ) ) return getEditFile ( it . next ( ) ) . lastModified ( ) ; return 0 ; } 
public String platformName ( ) { return System . getProperty ( "java.specification.vendor" ) ; } 
public Form getLoginFormCredentialsForItem ( UserContext userContext , long itemId ) { try { return itemManagement . getLoginFormCredentialsForItem ( userContext , new Long ( itemId ) ) ; } catch ( Exception e ) { throw new RuntimeException ( "Error-fetching-login-form-credentials-for-this-ItemId" ) ; } } 
public synchronized void add ( ServerName sn ) { processing = true ; if ( ! deadServers . containsKey ( sn ) ) { deadServers . put ( sn , EnvironmentEdgeManager . currentTime ( ) ) ; } } 
public String getIsValid ( ) { return isValid != null ? isValid . trim ( ) : "" ; } 
private JLabel getJLabel1 ( ) { if ( ivjJLabel1 == null ) { try { ivjJLabel1 = new JLabel ( ) ; ivjJLabel1 . setName ( "JLabel1" ) ; ivjJLabel1 . setText ( SystemControlBatchConstant . TXT_CLASS_TYPE ) ; } catch ( Throwable aeIVJExc ) { handleException ( aeIVJExc ) ; } } return ivjJLabel1 ; } 
@ SuppressWarnings ( "unchecked" ) @ Override public boolean equals ( Object o ) { if ( o == this ) return true ; if ( ! ( o instanceof Pair ) ) return false ; final Pair < F , S > other ; try { other = ( Pair < F , S > ) o ; } catch ( ClassCastException e ) { return false ; } return first . equals ( other . first ) && second . equals ( other . second ) ; } 
private Parser ensureParser ( HTMLDocument doc ) throws IOException { Parser p = doc . getParser ( ) ; if ( p == null ) { p = getParser ( ) ; } if ( p == null ) { throw new IOException ( "Can't-load-parser" ) ; } return p ; } 
public static String getEmailAccount ( Context context ) { return getStringFromPreference ( context , PREFS_KEY_EMAIL ) ; } 
public void setErrorHandler ( ErrorHandler handler ) { xmlReader . setErrorHandler ( handler ) ; } 
public void setPreviousVisible ( boolean previousVisible ) { if ( this . previousVisible != previousVisible ) { boolean old = this . previousVisible ; this . previousVisible = previousVisible ; pcs . firePropertyChange ( "previousVisible" , old , previousVisible ) ; } } 
public void elementStarted ( String name , String systemId , int lineNr ) { Properties attribs = ( Properties ) this . attributeDefaultValues . get ( name ) ; if ( attribs == null ) { attribs = new Properties ( ) ; } else { attribs = ( Properties ) attribs . clone ( ) ; } this . currentElements . push ( attribs ) ; } 
public void updateMessageDigest ( MessageDigest messageDigest , int len ) { if ( currentBuffer == null ) { return ; } else if ( len == 0 ) { return ; } else if ( len < 0 ) { throw new IllegalArgumentException ( "len-must-be-0-or-greater:-" + len ) ; } else { if ( nextIndexInCurrentBuffer < currentBufferLength ) { int bytesToCopy = Math . min ( len , currentBufferLength - nextIndexInCurrentBuffer ) ; nextIndexInCurrentBuffer += bytesToCopy ; messageDigest . update ( currentBuffer , nextIndexInCurrentBuffer , bytesToCopy ) ; updateMessageDigest ( messageDigest , len - bytesToCopy ) ; } else { if ( buffersIterator . hasNext ( ) ) { currentBuffer = buffersIterator . next ( ) ; if ( currentBuffer == fastByteArrayOutputStream . buffers . getLast ( ) ) { currentBufferLength = fastByteArrayOutputStream . index ; } else { currentBufferLength = currentBuffer . length ; } nextIndexInCurrentBuffer = 0 ; } else { currentBuffer = null ; } updateMessageDigest ( messageDigest , len ) ; } } } 
public Map < Object , AttributeMap > toJAttrMap ( ) { Map < Object , AttributeMap > result = new HashMap < Object , AttributeMap > ( ) ; for ( Map . Entry < Node , JVertexLayout > layoutEntry : nodeMap ( ) . entrySet ( ) ) { JCellLayout layout = layoutEntry . getValue ( ) ; result . put ( layoutEntry . getKey ( ) , layout . toJAttr ( ) ) ; } for ( Map . Entry < Edge , JEdgeLayout > layoutEntry : edgeMap ( ) . entrySet ( ) ) { JCellLayout layout = layoutEntry . getValue ( ) ; result . put ( layoutEntry . getKey ( ) , layout . toJAttr ( ) ) ; } return result ; } 
public static boolean isAvailable ( ) { try { String osName = System . getProperty ( "os.name" ) ; if ( ! osName . startsWith ( "Linux" ) ) { LOG . info ( "ProcfsBasedProcessTree-currently-is-supported-only-on-" + "Linux." ) ; return false ; } } catch ( SecurityException se ) { LOG . warn ( "Failed-to-get-Operating-System-name.-" + se ) ; return false ; } return true ; } 
private byte [ ] getNonRootIndexedKey ( ByteBuffer nonRootIndex , int i ) { int numEntries = nonRootIndex . getInt ( 0 ) ; if ( i < 0 || i >= numEntries ) { return null ; } int entriesOffset = Bytes . SIZEOF_INT * ( numEntries + 2 ) ; int targetKeyRelOffset = nonRootIndex . getInt ( Bytes . SIZEOF_INT * ( i + 1 ) ) ; int targetKeyOffset = entriesOffset + targetKeyRelOffset + SECONDARY_INDEX_ENTRY_OVERHEAD ; int targetKeyLength = nonRootIndex . getInt ( Bytes . SIZEOF_INT * ( i + 2 ) ) - targetKeyRelOffset - SECONDARY_INDEX_ENTRY_OVERHEAD ; int from = nonRootIndex . arrayOffset ( ) + targetKeyOffset ; int to = from + targetKeyLength ; return Arrays . copyOfRange ( nonRootIndex . array ( ) , from , to ) ; } 
public boolean addDnsServer ( InetAddress dnsServer ) { if ( dnsServer != null && ! mDnses . contains ( dnsServer ) ) { mDnses . add ( dnsServer ) ; return true ; } return false ; } 
public void iterateChain ( ) { iterations = 0 ; if ( this . numOfSamples > 0 ) iterations = this . numOfSamples * this . numOfChannels ; returned = 0 ; int i ; while ( ! finished ) { finished = true ; buffer = null ; if ( iterations > bufsize || iterations <= 0 ) { buffer = new float [ bufsize ] ; } else { buffer = new float [ iterations ] ; } try { if ( restNote ) { returned = buffer . length ; } else { returned = finalAO . nextWork ( buffer ) ; } } catch ( AOException aoe ) { System . out . println ( aoe ) ; System . exit ( 1 ) ; } iterations -= returned ; if ( iterations > 0 ) { finished = false ; } samplesProcessed += returned ; for ( i = 0 ; i < returned ; i ++ ) { rtBuffer [ index ++ ] = buffer [ i ] ; if ( index == bufsize ) { index = 0 ; Enumeration enum1 = listeners . elements ( ) ; while ( enum1 . hasMoreElements ( ) ) { AudioChainListener acl = ( AudioChainListener ) enum1 . nextElement ( ) ; acl . controlChange ( rtBuffer , returned , finished ) ; } this . block ( ) ; } } } } 
public SelectionBuilder append ( String selection , Object ... selectionArgs ) { if ( TextUtils . isEmpty ( selection ) ) { if ( selectionArgs != null && selectionArgs . length > 0 ) { throw new IllegalArgumentException ( "Valid-selection-required-when-including-arguments" ) ; } return this ; } if ( mSelection . length ( ) > 0 ) { mSelection . append ( "-AND-" ) ; } mSelection . append ( "(" ) . append ( selection ) . append ( ")" ) ; if ( selectionArgs != null ) { for ( Object arg : selectionArgs ) { mSelectionArgs . add ( String . valueOf ( arg ) ) ; } } return this ; } 
public Query appendIf ( final String name , final GitlabAccessLevel value ) throws UnsupportedEncodingException { if ( value != null ) { append ( name , Integer . toString ( value . accessValue ) ) ; } return this ; } 
public boolean contains ( JComponent c , int x , int y ) { boolean result = false ; Iterator iterator = uis . iterator ( ) ; if ( iterator . hasNext ( ) ) { ComponentUI ui = ( ComponentUI ) iterator . next ( ) ; result = ui . contains ( c , x , y ) ; } while ( iterator . hasNext ( ) ) { ComponentUI ui = ( ComponentUI ) iterator . next ( ) ; ui . contains ( c , x , y ) ; } return result ; } 
public boolean wbsDescendentOf ( Task potentialParentTask ) { if ( this == potentialParentTask ) return true ; Task parentTask = getWbsParentTask ( ) ; if ( parentTask == null ) return false ; return parentTask . wbsDescendentOf ( potentialParentTask ) ; } 
public List < QName > getUnrecognizedPolicy ( ) { if ( unrecognizedPolicy == null ) { unrecognizedPolicy = new ArrayList < QName > ( ) ; } return this . unrecognizedPolicy ; } 
private void step4 ( StringBuffer sb ) { if ( sb . length ( ) < 4 ) return ; String end = sb . substring ( sb . length ( ) - 4 , sb . length ( ) ) ; char c = end . charAt ( 0 ) ; char v1 = end . charAt ( 1 ) ; char v2 = end . charAt ( 2 ) ; char d = end . charAt ( 3 ) ; if ( v1 == v2 && d != 'I' && v1 != 'i' && isVowel ( v1 ) && ! isVowel ( d ) && ! isVowel ( c ) ) { sb . delete ( sb . length ( ) - 2 , sb . length ( ) - 1 ) ; } } 
static Process runClient ( List < String > command , Map < String , String > env ) throws IOException { ProcessBuilder builder = new ProcessBuilder ( command ) ; if ( env != null ) { builder . environment ( ) . putAll ( env ) ; } Process result = builder . start ( ) ; return result ; } 
public Point getPoint ( ) { return mouseEvent . getPoint ( ) ; } 
private SqlFile ( Reader reader , String inputStreamLabel , File baseDir ) { logger . privlog ( Level . FINER , "<init>ting-SqlFile-instance" , null , 2 , FrameworkLogger . class ) ; if ( reader == null ) throw new IllegalArgumentException ( "'reader'-may-not-be-null" ) ; if ( inputStreamLabel == null ) throw new IllegalArgumentException ( "'inputStreamLabel'-may-not-be-null" ) ; this . reader = reader ; this . inputStreamLabel = inputStreamLabel ; this . baseDir = ( baseDir == null ) ? new File ( "." ) : baseDir ; } 
@ SuppressWarnings ( "unchecked" ) private Entry readTree ( final java . io . ObjectInputStream s , final int n , final Entry pred , final Entry succ ) throws java . io . IOException , ClassNotFoundException { if ( n == 1 ) { final Entry top = new Entry ( s . readChar ( ) ) ; top . pred ( pred ) ; top . succ ( succ ) ; top . black ( true ) ; return top ; } if ( n == 2 ) { final Entry top = new Entry ( s . readChar ( ) ) ; top . black ( true ) ; top . right ( new Entry ( s . readChar ( ) ) ) ; top . right . pred ( top ) ; top . pred ( pred ) ; top . right . succ ( succ ) ; return top ; } final int rightN = n / 2 , leftN = n - rightN - 1 ; final Entry top = new Entry ( ) ; top . left ( readTree ( s , leftN , pred , top ) ) ; top . key = s . readChar ( ) ; top . black ( true ) ; top . right ( readTree ( s , rightN , top , succ ) ) ; if ( n + 2 == ( ( n + 2 ) & - ( n + 2 ) ) ) top . right . black ( false ) ; return top ; } 
public final Certificate [ ] getCertificateChain ( String alias ) throws KeyStoreException { if ( ! initialized ) { throw new KeyStoreException ( "Uninitialized-keystore" ) ; } return keyStoreSpi . engineGetCertificateChain ( alias ) ; } 
public static void sendTempFile ( File file , HttpServletResponse response ) throws IOException { String mimeType = null ; String filename = file . getName ( ) ; if ( filename . length ( ) > 5 ) { if ( filename . substring ( filename . length ( ) - 5 , filename . length ( ) ) . equals ( ".jpeg" ) ) { mimeType = "image/jpeg" ; } else if ( filename . substring ( filename . length ( ) - 4 , filename . length ( ) ) . equals ( ".png" ) ) { mimeType = "image/png" ; } } ServletUtilities . sendTempFile ( file , response , mimeType ) ; } 
public Object parse ( InstanceComponent instance , Object value ) throws Exception { Number number = ( Number ) value ; if ( number . longValue ( ) == 0 ) { throw new IllegalArgumentException ( "negativeInteger-value-'" + number + "'-required-to-be-negative" ) ; } return number ; } 
public void startElement ( QName element , XMLAttributes attributes , Augmentations augs ) { if ( ! fNamespaceDeclarations && fNamespaceAware ) { int len = attributes . getLength ( ) ; for ( int i = len - 1 ; i >= 0 ; -- i ) { if ( XMLSymbols . PREFIX_XMLNS == attributes . getPrefix ( i ) || XMLSymbols . PREFIX_XMLNS == attributes . getQName ( i ) ) { attributes . removeAttributeAt ( i ) ; } } } super . startElement ( element , attributes , augs ) ; } 
@ Override public int read ( ) throws IOException { checkReadPrimitiveTypes ( ) ; return primitiveData . read ( ) ; } 
public static String inputStreamToString ( InputStream is ) throws Exception { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; StringBuilder sb = new StringBuilder ( ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { sb . append ( line ) ; } is . close ( ) ; return sb . toString ( ) ; } 
public void setLib ( Properties conf , String pathStr ) { conf . setProperty ( LIBPATH , pathStr ) ; } 
public void installUI ( JComponent c ) { super . installUI ( c ) ; root = ( JRootPane ) c ; if ( PlatformUtils . isMac ( ) ) { if ( root . isValid ( ) ) { throw new IllegalArgumentException ( "This-method-only-works-if-the-given-JRootPane-has-not-yet-been-realized." ) ; } root . putClientProperty ( "apple.awt.brushMetalLook" , Boolean . TRUE ) ; } int style = root . getWindowDecorationStyle ( ) ; Container parent = root . getParent ( ) ; if ( parent != null && ( parent instanceof JFrame || parent instanceof JDialog ) && style != JRootPane . NONE ) { installClientDecorations ( root ) ; } LookAndFeel . installProperty ( ( JComponent ) root . getContentPane ( ) , "opaque" , Boolean . FALSE ) ; } 
public Builder setFullScreenIntent ( PendingIntent intent , boolean highPriority ) { mFullScreenIntent = intent ; setFlag ( FLAG_HIGH_PRIORITY , highPriority ) ; return this ; } 
public boolean free ( T obj ) { int top = _top . get ( ) ; if ( top < _freeStack . length ( ) ) { boolean isFree = _freeStack . compareAndSet ( top , null , obj ) ; _top . compareAndSet ( top , top + 1 ) ; return isFree ; } else return false ; } 
public int get ( DateTimeFieldType fieldType ) { if ( fieldType == null ) { throw new IllegalArgumentException ( "The-DateTimeFieldType-must-not-be-null" ) ; } if ( isSupported ( fieldType ) == false ) { throw new IllegalArgumentException ( "Field-'" + fieldType + "'-is-not-supported" ) ; } return fieldType . getField ( getChronology ( ) ) . get ( getLocalMillis ( ) ) ; } 
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; StringBuffer sb = new StringBuffer ( ) ; int length = s . length ( ) ; for ( int i = 0 ; i < length ; i += 1 ) { c = s . charAt ( i ) ; if ( c < '-' || c == '+' || c == '%' || c == '=' || c == ';' ) { sb . append ( '%' ) ; sb . append ( Character . forDigit ( ( char ) ( ( c >>> 4 ) & 0x0f ) , 16 ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & 0x0f ) , 16 ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; } 
private static Locale strip ( Locale locale ) { String language = locale . getLanguage ( ) ; String country = locale . getCountry ( ) ; String variant = locale . getVariant ( ) ; if ( ! variant . isEmpty ( ) ) { variant = "" ; } else if ( ! country . isEmpty ( ) ) { country = "" ; } else if ( ! language . isEmpty ( ) ) { language = "" ; } else { return null ; } return new Locale ( language , country , variant ) ; } 
public ScheduledFuture < ? > scheduleGeneral ( Runnable task , long delay ) { return scheduleGeneral ( task , delay , TimeUnit . MILLISECONDS ) ; } 
public void removeLayoutComponent ( Component comp ) { synchronized ( comp . getTreeLock ( ) ) { if ( comp == center ) { center = null ; } else if ( comp == north ) { north = null ; } else if ( comp == south ) { south = null ; } else if ( comp == east ) { east = null ; } else if ( comp == west ) { west = null ; } if ( comp == firstLine ) { firstLine = null ; } else if ( comp == lastLine ) { lastLine = null ; } else if ( comp == firstItem ) { firstItem = null ; } else if ( comp == lastItem ) { lastItem = null ; } } } 
@ XmlElementDecl ( namespace = "http://service.web.rapidanalytics.de/" , name = "deleteEntryResponse" ) public JAXBElement < DeleteEntryResponse > createDeleteEntryResponse ( DeleteEntryResponse value ) { return new JAXBElement < DeleteEntryResponse > ( _DeleteEntryResponse_QNAME , DeleteEntryResponse . class , null , value ) ; } 
@ Override public String getCurrentName ( ) throws IOException , JsonParseException { return _inputContext . getCurrentName ( ) ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; javax . xml . namespace . NamespaceContext nsContext = xmlWriter . getNamespaceContext ( ) ; while ( true ) { java . lang . String uri = nsContext . getNamespaceURI ( prefix ) ; if ( uri == null || uri . length ( ) == 0 ) { break ; } prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public boolean hasPurchase ( String sku ) { return mPurchaseMap . containsKey ( sku ) ; } 
public FontUIResource getSubTextFont ( ) { return getFont ( SUB_TEXT_FONT ) ; } 
public static CharSequence take ( CharSequence self , int num ) { if ( num < 0 ) { return self . subSequence ( 0 , 0 ) ; } if ( self . length ( ) <= num ) { return self ; } return self . subSequence ( 0 , num ) ; } 
public void getTextPath ( char [ ] text , int index , int count , float x , float y , Path path ) { if ( ( index | count ) < 0 || index + count > text . length ) { throw new ArrayIndexOutOfBoundsException ( ) ; } native_getTextPath ( mNativePaint , mBidiFlags , text , index , count , x , y , path . ni ( ) ) ; } 
public void clear ( ) { if ( size != 0 ) { modCount ++ ; Arrays . fill ( table , null ) ; size = 0 ; } } 
public Changes get ( ) { javax . ws . rs . client . Invocation . Builder resourceBuilder = Utils . getBuilder ( _uriBuilder , _client , _templateAndMatrixParameterValues , "application/json" ) ; Response response = resourceBuilder . build ( Utils . METHOD_GET ) . invoke ( ) ; Utils . throwExceptionIfWrongStatus ( response ) ; return response . readEntity ( Changes . class ) ; } 
public boolean isOlder ( Object o ) { return ( compareTo ( o ) == - 1 ) ; } 
private void grow ( int minCapacity ) { int oldCapacity = queue . length ; int newCapacity = oldCapacity + ( ( oldCapacity < 64 ) ? ( oldCapacity + 2 ) : ( oldCapacity >> 1 ) ) ; if ( newCapacity - MAX_ARRAY_SIZE > 0 ) newCapacity = hugeCapacity ( minCapacity ) ; queue = Arrays . copyOf ( queue , newCapacity ) ; } 
public Node cloneNode ( boolean deep ) { ElementImpl newnode = ( ElementImpl ) super . cloneNode ( deep ) ; if ( attributes != null ) { newnode . attributes = ( AttributeMap ) attributes . cloneMap ( newnode ) ; } return newnode ; } 
public String readLine ( ) { String line ; try { line = scanner . nextLine ( ) ; } catch ( Exception e ) { line = null ; } return line ; } 
public static void printStatsToFile ( Statistics s , String filename ) { try { File file = new File ( filename ) ; if ( ! file . exists ( ) ) { file . createNewFile ( ) ; } FileWriter fw = new FileWriter ( file . getAbsoluteFile ( ) , true ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; bw . write ( s . toString ( ) ) ; bw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } 
public void onPull ( float deltaDistance ) { final long now = AnimationTime . get ( ) ; if ( mState == STATE_PULL_DECAY && now - mStartTime < mDuration ) { return ; } if ( mState != STATE_PULL ) { mGlowScaleY = PULL_GLOW_BEGIN ; } mState = STATE_PULL ; mStartTime = now ; mDuration = PULL_TIME ; mPullDistance += deltaDistance ; float distance = Math . abs ( mPullDistance ) ; mEdgeAlpha = mEdgeAlphaStart = Math . max ( PULL_EDGE_BEGIN , Math . min ( distance , MAX_ALPHA ) ) ; mEdgeScaleY = mEdgeScaleYStart = Math . max ( HELD_EDGE_SCALE_Y , Math . min ( distance * PULL_DISTANCE_EDGE_FACTOR , 1.f ) ) ; mGlowAlpha = mGlowAlphaStart = Math . min ( MAX_ALPHA , mGlowAlpha + ( Math . abs ( deltaDistance ) * PULL_DISTANCE_ALPHA_GLOW_FACTOR ) ) ; float glowChange = Math . abs ( deltaDistance ) ; if ( deltaDistance > 0 && mPullDistance < 0 ) { glowChange = - glowChange ; } if ( mPullDistance == 0 ) { mGlowScaleY = 0 ; } mGlowScaleY = mGlowScaleYStart = Math . min ( MAX_GLOW_HEIGHT , Math . max ( 0 , mGlowScaleY + glowChange * PULL_DISTANCE_GLOW_FACTOR ) ) ; mEdgeAlphaFinish = mEdgeAlpha ; mEdgeScaleYFinish = mEdgeScaleY ; mGlowAlphaFinish = mGlowAlpha ; mGlowScaleYFinish = mGlowScaleY ; } 
public void actionPerformed ( ActionEvent e ) { FileDialog chooser = new FileDialog ( frame , "Use-a-.png-or-.jpg-extension" , FileDialog . SAVE ) ; chooser . setVisible ( true ) ; if ( chooser . getFile ( ) != null ) { save ( chooser . getDirectory ( ) + File . separator + chooser . getFile ( ) ) ; } } 
public static void i ( String tag , String s , Object ... args ) { if ( LOG . INFO >= LOGLEVEL ) Log . i ( tag , String . format ( s , args ) ) ; } 
protected boolean test ( final double [ ] values , final int begin , final int length ) throws MathIllegalArgumentException { return test ( values , begin , length , false ) ; } 
public void setDate ( int parameterIndex , java . sql . Date x , Calendar cal ) throws SQLException { if ( x == null ) { setNull ( parameterIndex , java . sql . Types . DATE ) ; } else { checkClosed ( ) ; if ( ! this . useLegacyDatetimeCode ) { newSetDateInternal ( parameterIndex , x , cal ) ; } else { SimpleDateFormat dateFormatter = new SimpleDateFormat ( "''yyyy-MM-dd''" , Locale . US ) ; setInternal ( parameterIndex , dateFormatter . format ( x ) ) ; this . parameterTypes [ parameterIndex - 1 + getParameterIndexOffset ( ) ] = Types . DATE ; } } } 
public void add ( TrayIcon trayIcon ) throws AWTException { if ( trayIcon == null ) { throw new NullPointerException ( "adding-null-TrayIcon" ) ; } TrayIcon [ ] oldArray = null , newArray = null ; Vector < TrayIcon > icons = null ; synchronized ( this ) { oldArray = systemTray . getTrayIcons ( ) ; icons = ( Vector < TrayIcon > ) AppContext . getAppContext ( ) . get ( TrayIcon . class ) ; if ( icons == null ) { icons = new Vector < TrayIcon > ( 3 ) ; AppContext . getAppContext ( ) . put ( TrayIcon . class , icons ) ; } else if ( icons . contains ( trayIcon ) ) { throw new IllegalArgumentException ( "adding-TrayIcon-that-is-already-added" ) ; } icons . add ( trayIcon ) ; newArray = systemTray . getTrayIcons ( ) ; trayIcon . setID ( ++ currentIconID ) ; } try { trayIcon . addNotify ( ) ; } catch ( AWTException e ) { icons . remove ( trayIcon ) ; throw e ; } firePropertyChange ( "trayIcons" , oldArray , newArray ) ; } 
public boolean isCompatibleWith ( Extension required ) { if ( extensionName == null ) return false ; if ( ! extensionName . equals ( required . getExtensionName ( ) ) ) return false ; if ( required . getSpecificationVersion ( ) != null ) { if ( ! isNewer ( specificationVersion , required . getSpecificationVersion ( ) ) ) return false ; } if ( required . getImplementationVendorId ( ) != null ) { if ( implementationVendorId == null ) return false ; if ( ! implementationVendorId . equals ( required . getImplementationVendorId ( ) ) ) return false ; } if ( required . getImplementationVersion ( ) != null ) { if ( ! isNewer ( implementationVersion , required . getImplementationVersion ( ) ) ) return false ; } return true ; } 
public void setIdentifier ( String identifier ) { assertNotNull ( identifier ) ; this . identifier = identifier ; setLength ( identifier . length ( ) ) ; } 
private void cleanUp ( File toDelete ) { org . simonme . tracer . logger . Tracer . traceMethodInvoke ( toDelete ) ; if ( ! toDelete . delete ( ) ) return ; if ( toDelete . getName ( ) . equals ( INDEXES_DIR_NAME ) ) return ; cleanUp ( toDelete . getParentFile ( ) ) ; } 
public void failWrite ( FileOutputStream str ) { if ( str != null ) { sync ( str ) ; try { str . close ( ) ; mBaseName . delete ( ) ; mBackupName . renameTo ( mBaseName ) ; } catch ( IOException e ) { Log . w ( "AtomicFile" , "failWrite:-Got-exception:" , e ) ; } } } 
private static double round ( double value , int nb ) { if ( nb <= 0 ) { return Math . floor ( value + 0.5d ) ; } double p = Math . pow ( 10 , nb ) ; double tempval = Math . floor ( value * p + 0.5d ) ; return tempval / p ; } 
public void setToolTip ( String tooltip ) { this . tooltip = tooltip ; TrayIconPeer peer = this . peer ; if ( peer != null ) { peer . setToolTip ( tooltip ) ; } } 
public Iterator getUnknownModuleClassIDs ( ) { if ( unknownModuleClassIDs != null ) { return unknownModuleClassIDs . iterator ( ) ; } else { return new LinkedList ( ) . iterator ( ) ; } } 
public Byte getTypeCode ( String tenant , String type ) throws ApplicationFault , SystemFault { if ( StringUtils . isEmpty ( type ) ) return null ; Map < String , Byte > cachedCodes = null ; if ( tenantTypeCodes . containsKey ( tenant ) ) { cachedCodes = tenantTypeCodes . get ( tenant ) ; if ( cachedCodes . containsKey ( type ) ) return cachedCodes . get ( type ) ; } cachedCodes = load ( tenant ) ; if ( null == cachedCodes ) { cachedCodes = getDefaultCodes ( ) ; if ( null == cachedCodes ) cachedCodes = new HashMap < String , Byte > ( ) ; } tenantTypeCodes . put ( tenant , cachedCodes ) ; if ( cachedCodes . containsKey ( type ) ) { return cachedCodes . get ( type ) ; } autoInsert ( cachedCodes , type ) ; persist ( tenant , cachedCodes ) ; return cachedCodes . get ( type ) ; } 
public static int activeCount ( ) { return currentThread ( ) . group . activeCount ( ) ; } 
public String getNetid ( ) { return myRow . getStringColumn ( "netid" ) ; } 
public void writeAnnotations ( String filename ) throws IOException { PrintWriter out = new PrintWriter ( filename ) ; ArrayList < Annotation > annos = this . getAnnotations ( ) ; for ( int j = 0 ; j < annos . size ( ) ; j ++ ) { out . println ( annos . get ( j ) ) ; } out . flush ( ) ; out . close ( ) ; } 
public static ContentSummary toContentSummary ( final Map < ? , ? > json ) { if ( json == null ) { return null ; } final Map < ? , ? > m = ( Map < ? , ? > ) json . get ( ContentSummary . class . getSimpleName ( ) ) ; final long length = ( Long ) m . get ( "length" ) ; final long fileCount = ( Long ) m . get ( "fileCount" ) ; final long directoryCount = ( Long ) m . get ( "directoryCount" ) ; final long quota = ( Long ) m . get ( "quota" ) ; final long spaceConsumed = ( Long ) m . get ( "spaceConsumed" ) ; final long spaceQuota = ( Long ) m . get ( "spaceQuota" ) ; return new ContentSummary ( length , fileCount , directoryCount , quota , spaceConsumed , spaceQuota ) ; } 
public synchronized Connection get ( Address address ) { Connection foundConnection = null ; for ( ListIterator < Connection > i = connections . listIterator ( connections . size ( ) ) ; i . hasPrevious ( ) ; ) { Connection connection = i . previous ( ) ; if ( ! connection . getRoute ( ) . getAddress ( ) . equals ( address ) || ! connection . isAlive ( ) || System . nanoTime ( ) - connection . getIdleStartTimeNs ( ) >= keepAliveDurationNs ) { continue ; } i . remove ( ) ; if ( ! connection . isSpdy ( ) ) { try { Platform . get ( ) . tagSocket ( connection . getSocket ( ) ) ; } catch ( SocketException e ) { Util . closeQuietly ( connection ) ; Platform . get ( ) . logW ( "Unable-to-tagSocket():-" + e ) ; continue ; } } foundConnection = connection ; break ; } if ( foundConnection != null && foundConnection . isSpdy ( ) ) { connections . addFirst ( foundConnection ) ; } executorService . submit ( connectionsCleanupCallable ) ; return foundConnection ; } 
public void setLocation ( Point p ) { setLocation ( p . x , p . y ) ; } 
public static int getMarkerFlag ( Object value ) { if ( value instanceof Byte ) return MemcachedClient . MARKER_BYTE ; if ( value instanceof Boolean ) return MemcachedClient . MARKER_BOOLEAN ; if ( value instanceof Integer ) return MemcachedClient . MARKER_INTEGER ; if ( value instanceof Long ) return MemcachedClient . MARKER_LONG ; if ( value instanceof Character ) return MemcachedClient . MARKER_CHARACTER ; if ( value instanceof String ) return MemcachedClient . MARKER_STRING ; if ( value instanceof StringBuffer ) return MemcachedClient . MARKER_STRINGBUFFER ; if ( value instanceof Float ) return MemcachedClient . MARKER_FLOAT ; if ( value instanceof Short ) return MemcachedClient . MARKER_SHORT ; if ( value instanceof Double ) return MemcachedClient . MARKER_DOUBLE ; if ( value instanceof Date ) return MemcachedClient . MARKER_DATE ; if ( value instanceof StringBuilder ) return MemcachedClient . MARKER_STRINGBUILDER ; if ( value instanceof byte [ ] ) return MemcachedClient . MARKER_BYTEARR ; return - 1 ; } 
public boolean validaEmail ( String email ) { Pattern patron = Pattern . compile ( PATRON_EMAIL ) ; Matcher match = patron . matcher ( email ) ; return match . matches ( ) ; } 
private void init ( ImageCacheParams cacheParams ) { mCacheParams = cacheParams ; if ( mCacheParams . memoryCacheEnabled ) { if ( BuildConfig . DEBUG ) { Log . d ( TAG , "Memory-cache-created-(size-=-" + mCacheParams . memCacheSize + ")" ) ; } if ( Utils . hasHoneycomb ( ) ) { mReusableBitmaps = Collections . synchronizedSet ( new HashSet < SoftReference < Bitmap >> ( ) ) ; } mMemoryCache = new LruCache < String , BitmapDrawable > ( mCacheParams . memCacheSize ) { @ Override protected void entryRemoved ( boolean evicted , String key , BitmapDrawable oldValue , BitmapDrawable newValue ) { if ( RecyclingBitmapDrawable . class . isInstance ( oldValue ) ) { ( ( RecyclingBitmapDrawable ) oldValue ) . setIsCached ( false ) ; } else { if ( Utils . hasHoneycomb ( ) ) { mReusableBitmaps . add ( new SoftReference < Bitmap > ( oldValue . getBitmap ( ) ) ) ; } } } @ Override protected int sizeOf ( String key , BitmapDrawable value ) { final int bitmapSize = getBitmapSize ( value ) / 1024 ; return bitmapSize == 0 ? 1 : bitmapSize ; } } ; } if ( cacheParams . initDiskCacheOnCreate ) { initDiskCache ( ) ; } } 
public static Calendar toCalendar ( String dateString , String format ) throws ParseException { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( toDate ( dateString , format ) ) ; return calendar ; } 
public void setAffinityLvlCd ( JAXBElement < String > value ) { this . affinityLvlCd = ( ( JAXBElement < String > ) value ) ; } 
public void setScalar ( final double scalar ) { if ( ! __valueValidator . isValid ( scalar ) ) throw new IllegalArgumentException ( __valueValidator . message ( scalar , "Scalar" ) ) ; this . _scalar = scalar ; } 
protected InvocationTargetException ( ) { super ( ( Throwable ) null ) ; } 
public static BufferedImage loadImage ( String ref ) throws IOException { URL url = TextureLoader . class . getClassLoader ( ) . getResource ( ref ) ; if ( url == null ) { throw new IOException ( "Cannot-find:-" + ref ) ; } Image img = new ImageIcon ( url ) . getImage ( ) ; BufferedImage bufferedImage = new BufferedImage ( img . getWidth ( null ) , img . getHeight ( null ) , BufferedImage . TYPE_INT_ARGB ) ; Graphics g = bufferedImage . getGraphics ( ) ; g . drawImage ( img , 0 , 0 , null ) ; g . dispose ( ) ; return bufferedImage ; } 
public static String encodeBytes ( byte [ ] source , int options ) throws java . io . IOException { return encodeBytes ( source , 0 , source . length , options ) ; } 
public com . google . protobuf . ByteString getYoutubeChannelUrlBytes ( ) { java . lang . Object ref = youtubeChannelUrl_ ; if ( ref instanceof java . lang . String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; youtubeChannelUrl_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public static ExecutorService newFixedThreadPool ( int nThreads ) { return new ThreadPoolExecutor ( nThreads , nThreads , 0L , TimeUnit . MILLISECONDS , new LinkedBlockingQueue < Runnable > ( ) ) ; } 
public static Credential basic ( String userName , String password ) { try { String usernameAndPassword = userName + ":" + password ; byte [ ] bytes = usernameAndPassword . getBytes ( "ISO-8859-1" ) ; String encoded = Base64 . encode ( bytes ) ; return new Credential ( "Basic-" + encoded ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( ) ; } } 
private static String percentEncodeRfc3986 ( final String string ) { try { return URLEncoder . encode ( string , "UTF-8" ) . replace ( "+" , "%20" ) . replace ( "*" , "%2A" ) . replace ( "%7E" , "~" ) ; } catch ( UnsupportedEncodingException e ) { return string ; } } 
public void setVisible ( boolean b ) { if ( DEBUG ) { System . out . println ( "JPopupMenu.setVisible-" + b ) ; } if ( b == isVisible ( ) ) return ; if ( b == false ) { Boolean doCanceled = ( Boolean ) getClientProperty ( "JPopupMenu.firePopupMenuCanceled" ) ; if ( doCanceled != null && doCanceled == Boolean . TRUE ) { putClientProperty ( "JPopupMenu.firePopupMenuCanceled" , Boolean . FALSE ) ; firePopupMenuCanceled ( ) ; } getSelectionModel ( ) . clearSelection ( ) ; } else { if ( isPopupMenu ( ) ) { MenuElement me [ ] = new MenuElement [ 1 ] ; me [ 0 ] = ( MenuElement ) this ; MenuSelectionManager . defaultManager ( ) . setSelectedPath ( me ) ; } } if ( b ) { firePopupMenuWillBecomeVisible ( ) ; popup = getPopup ( ) ; firePropertyChange ( "visible" , Boolean . FALSE , Boolean . TRUE ) ; } else if ( popup != null ) { firePopupMenuWillBecomeInvisible ( ) ; popup . hide ( ) ; popup = null ; firePropertyChange ( "visible" , Boolean . TRUE , Boolean . FALSE ) ; if ( isPopupMenu ( ) ) { MenuSelectionManager . defaultManager ( ) . clearSelectedPath ( ) ; } } } 
public static void updateCSSPropertyFontWeight ( CSS2FontProperties font , CSSValue value ) { if ( value . getCssValueType ( ) == CSSValue . CSS_PRIMITIVE_VALUE ) { font . setWeight ( ( CSSPrimitiveValue ) value ) ; } } 
public static byte [ ] loadBinary ( File binFile ) throws IOException { byte [ ] xferBuffer = new byte [ 10240 ] ; byte [ ] outBytes = null ; ByteArrayOutputStream baos ; int i ; FileInputStream fis = new FileInputStream ( binFile ) ; try { baos = new ByteArrayOutputStream ( ) ; while ( ( i = fis . read ( xferBuffer ) ) > 0 ) baos . write ( xferBuffer , 0 , i ) ; outBytes = baos . toByteArray ( ) ; } finally { try { fis . close ( ) ; } catch ( IOException ioe ) { } finally { fis = null ; baos = null ; } } return outBytes ; } 
public static String UPLOADIMG ( String url , Bitmap bitmapOrg ) { ByteArrayOutputStream bao = new ByteArrayOutputStream ( ) ; bitmapOrg . compress ( Bitmap . CompressFormat . JPEG , 90 , bao ) ; byte [ ] ba = bao . toByteArray ( ) ; String ba1 = Base64 . encodeToString ( ba , 0 ) ; ArrayList < NameValuePair > nameValuePairs = new ArrayList < NameValuePair > ( ) ; nameValuePairs . add ( new BasicNameValuePair ( "image" , ba1 ) ) ; return POST ( url , nameValuePairs ) ; } 
public void familyComboBoxUpdate ( HashMap < String , Family > values ) { mainPanel . addPanel . familyNameCB . removeAllItems ( ) ; Iterator < String > key = values . keySet ( ) . iterator ( ) ; while ( key . hasNext ( ) ) { String i = key . next ( ) ; mainPanel . addPanel . familyNameCB . addItem ( values . get ( i ) . getFamilyName ( ) ) ; } mainPanel . addPanel . familyNameCB . insertItemAt ( "" , 0 ) ; } 
public void addSlice ( String name ) { if ( name == null ) throw new IllegalArgumentException ( "'name'-is-null!" ) ; nSlices ++ ; if ( nSlices == names . length ) { String [ ] tmp = new String [ nSlices * 2 ] ; System . arraycopy ( names , 0 , tmp , 0 , nSlices ) ; names = tmp ; tmp = new String [ nSlices * 2 ] ; System . arraycopy ( labels , 0 , tmp , 0 , nSlices ) ; labels = tmp ; } names [ nSlices - 1 ] = name ; } 
public boolean onKeyUp ( int keyCode , KeyEvent event ) { boolean result = false ; switch ( keyCode ) { case KeyEvent . KEYCODE_DPAD_CENTER : case KeyEvent . KEYCODE_ENTER : { if ( ( mViewFlags & ENABLED_MASK ) == DISABLED ) { return true ; } if ( ( mViewFlags & CLICKABLE ) == CLICKABLE && isPressed ( ) ) { setPressed ( false ) ; if ( ! mHasPerformedLongPress ) { removeLongPressCallback ( ) ; result = performClick ( ) ; } } break ; } } return result ; } 
public List getWords ( String code ) { Vector mainDictResult = ( Vector ) mainDictionary . get ( code ) ; if ( mainDictResult == null ) return new Vector ( ) ; return mainDictResult ; } 
private static int channelRead ( ReadableByteChannel channel , ByteBuffer buffer ) throws IOException { return ( buffer . remaining ( ) <= NIO_BUFFER_LIMIT ) ? channel . read ( buffer ) : channelIO ( channel , null , buffer ) ; } 
public synchronized Connection getConnection ( long timeout ) { long startTime = new Date ( ) . getTime ( ) ; Connection con ; while ( ( con = getConnection ( ) ) == null ) { try { wait ( timeout ) ; } catch ( InterruptedException e ) { } if ( ( new Date ( ) . getTime ( ) - startTime ) >= timeout ) { return null ; } } return con ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
protected void uninstallListeners ( ) { menuBar . removeContainerListener ( containerListener ) ; menuBar . removePropertyChangeListener ( propertyChangeListener ) ; for ( int i = 0 ; i < menuBar . getMenuCount ( ) ; i ++ ) { JMenu menu = menuBar . getMenu ( i ) ; if ( menu != null ) menu . getModel ( ) . removeChangeListener ( changeListener ) ; } containerListener = null ; changeListener = null ; propertyChangeListener = null ; } 
static JavaMethodSet discoverConstructors ( Class < ? > cls ) { List < JavaConstructor > javaConstructors = new ArrayList < > ( ) ; for ( Constructor < ? > constructor : cls . getDeclaredConstructors ( ) ) { if ( Modifier . isPublic ( constructor . getModifiers ( ) ) ) { javaConstructors . add ( new JavaConstructor ( constructor ) ) ; } } return new JavaMethodSet ( cls . getCanonicalName ( ) , javaConstructors ) ; } 
public void applyConditionToRequest ( final HttpURLConnection request ) { applyLeaseConditionToRequest ( request ) ; if ( this . ifModifiedSinceDate != null ) { request . setRequestProperty ( Constants . HeaderConstants . IF_MODIFIED_SINCE , Utility . getGMTTime ( this . ifModifiedSinceDate ) ) ; } if ( this . ifUnmodifiedSinceDate != null ) { request . setRequestProperty ( Constants . HeaderConstants . IF_UNMODIFIED_SINCE , Utility . getGMTTime ( this . ifUnmodifiedSinceDate ) ) ; } if ( ! Utility . isNullOrEmpty ( this . ifMatchETag ) ) { request . setRequestProperty ( Constants . HeaderConstants . IF_MATCH , this . ifMatchETag ) ; } if ( ! Utility . isNullOrEmpty ( this . ifNoneMatchETag ) ) { request . setRequestProperty ( Constants . HeaderConstants . IF_NONE_MATCH , this . ifNoneMatchETag ) ; } } 
public void setAutoDdl ( String value ) { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "setAutoDdl(String-" + value + ")" ) ; } m_autoDdl = Boolean . valueOf ( value ) . booleanValue ( ) ; } 
public static < K , V > Map < K , V > map ( Map < K , V > input ) { Map < K , V > ret = new HashMap < K , V > ( ) ; for ( Entry < K , V > tmp : input . entrySet ( ) ) { ret . put ( tmp . getKey ( ) , tmp . getValue ( ) ) ; } return ret ; } 
public void generateInstrNew ( String internalName ) { generateInstrShort ( INSTR_new , classFile . constantpool . newConstantClass ( internalName ) , + 1 ) ; } 
@ XmlElementDecl ( namespace = "http://www.omg.org/spec/BPMN/20100524/MODEL" , name = "scriptTask" , substitutionHeadNamespace = "http://www.omg.org/spec/BPMN/20100524/MODEL" , substitutionHeadName = "flowElement" ) public JAXBElement < TScriptTask > createScriptTask ( TScriptTask value ) { return new JAXBElement < TScriptTask > ( _ScriptTask_QNAME , TScriptTask . class , null , value ) ; } 
public double getFitGoodness ( ) { double sumY = 0.0 ; for ( int i = 0 ; i < numPoints ; i ++ ) sumY += yData [ i ] ; double mean = sumY / numPoints ; double sumMeanDiffSqr = 0.0 ; int degreesOfFreedom = numPoints - getNumParams ( ) ; double fitGoodness = 0.0 ; for ( int i = 0 ; i < numPoints ; i ++ ) { sumMeanDiffSqr += sqr ( yData [ i ] - mean ) ; } if ( sumMeanDiffSqr > 0.0 && degreesOfFreedom != 0 ) fitGoodness = 1.0 - ( getSumResidualsSqr ( ) / degreesOfFreedom ) * ( ( numPoints ) / sumMeanDiffSqr ) ; return fitGoodness ; } 
protected void clearViews ( ) { mViews . clear ( ) ; } 
public void write ( byte [ ] buffer ) { try { mmOutStream . write ( buffer ) ; } catch ( IOException e ) { Log . e ( TAG , "Exception-during-write" , e ) ; } } 
public static Filter findInTree ( final Filter f ) { return new Filter ( ) { public Object filter ( Object value ) { Object res = f . filter ( value ) ; if ( res != null ) { return res ; } if ( value instanceof Element ) { return ( ( Element ) value ) . find ( this ) ; } return null ; } @ Override public String toString ( ) { return opToString ( "<FindInTree>" , new Object [ ] { f } , "</FindInTree>" ) ; } } ; } 
private static String massageURI ( String uri ) { uri = uri . trim ( ) ; int protocolEnd = uri . indexOf ( ':' ) ; if ( protocolEnd < 0 ) { uri = "http://" + uri ; } else if ( isColonFollowedByPortNumber ( uri , protocolEnd ) ) { uri = "http://" + uri ; } else { uri = uri . substring ( 0 , protocolEnd ) . toLowerCase ( ) + uri . substring ( protocolEnd ) ; } return uri ; } 
public synchronized void setLocale ( Locale newLocale ) throws PropertyVetoException { if ( ( locale != null && ! locale . equals ( newLocale ) ) && newLocale != null ) { Locale old = locale ; fireVetoableChange ( "locale" , old , newLocale ) ; locale = newLocale ; firePropertyChange ( "locale" , old , newLocale ) ; } } 
@ Override public boolean isEmpty ( ) { return backingMap . isEmpty ( ) ; } 
public static Image sync ( Image image ) { synchronized ( tracker ) { try { tracker . addImage ( image , 0 ) ; tracker . waitForID ( 0 , 0 ) ; tracker . removeImage ( image , 0 ) ; } catch ( InterruptedException e ) { throw new IllegalStateException ( e . toString ( ) ) ; } } return image ; } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
public void write ( long [ ] source , int srcOff , int numEls ) throws BufferException { writeCheckArgs ( source . length , srcOff , numEls ) ; if ( currentSectionType == Type . LONG ) { int newSize = size + 8 * numEls ; if ( newSize > staticBuffer . getCapacity ( ) ) throw new BufferOverflowException ( "Buffer-capacity-" + "too-small-for-attempted-write." ) ; staticBuffer . write ( source , srcOff , numEls , size + bufoffset ) ; sectionSize += numEls ; size = newSize ; } else if ( currentSectionType == Type . LONG_DYNAMIC ) { try { if ( out == null ) { byteOut = new ByteArrayOutputStream ( ) ; out = new ObjectOutputStream ( byteOut ) ; } for ( int i = 0 ; i < numEls ; i ++ ) { out . writeLong ( source [ srcOff + i ] ) ; sectionSize ++ ; } } catch ( IOException e ) { throw new DynamicBufferException ( "Problem-writing-" + "dynamic-buffer" , e ) ; } } else { throw new TypeMismatchException ( "Wrong-type-for-current-" + "section." ) ; } } 
public static String getURL ( String docid , String extraParams ) { if ( extraParams == null ) { extraParams = "" ; } else if ( extraParams . length ( ) > 0 ) { extraParams += "&" ; } return "http://video.google.com/videoplay?" + extraParams + "docid=" + docid ; } 
public TaskStackBuilder addNextIntent ( Intent nextIntent ) { mIntents . add ( nextIntent ) ; return this ; } 
public void addMethodInfo ( CodeLocation param ) { if ( localMethodInfo == null ) { localMethodInfo = new CodeLocation [ ] { } ; } localMethodInfoTracker = true ; java . util . List list = org . apache . axis2 . databinding . utils . ConverterUtil . toList ( localMethodInfo ) ; list . add ( param ) ; this . localMethodInfo = ( CodeLocation [ ] ) list . toArray ( new CodeLocation [ list . size ( ) ] ) ; } 
private void writeObject ( ObjectOutputStream out ) throws IOException { getUnscaledValue ( ) ; out . defaultWriteObject ( ) ; } 
public byte [ ] getData ( ) { return buffer . getData ( ) ; } 
public static ShortcutIconResource fromContext ( Context context , int resourceId ) { ShortcutIconResource icon = new ShortcutIconResource ( ) ; icon . packageName = context . getPackageName ( ) ; icon . resourceName = context . getResources ( ) . getResourceName ( resourceId ) ; return icon ; } 
public Object remove ( int posn ) throws InvalidNameException { return impl . remove ( posn ) ; } 
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; } 
public ShortBuffer get ( short [ ] dst ) { return get ( dst , 0 , dst . length ) ; } 
public void randBomb ( ) { int x ; int y ; do { x = rand . nextInt ( boardSizeX ) ; y = rand . nextInt ( boardSizeY ) ; } while ( board . isBombed ( x , y ) ) ; game . placeBomb ( x , y ) ; } 
@ Nonnull public static JsonArray < Pair < Integer , String >> buildModes ( @ Nullable String initialMode , @ Nonnull JsonArray < Token > tokens ) { JsonArray < Pair < Integer , String >> modes = JsonCollections . createArray ( ) ; String currentMode = initialMode ; int currentColumn = 0 ; for ( Token token : tokens . asIterable ( ) ) { if ( token . getType ( ) == TokenType . NEWLINE ) { break ; } String mode = token . getMode ( ) ; if ( ! mode . equals ( currentMode ) ) { modes . add ( new Pair < Integer , String > ( currentColumn , mode ) ) ; currentMode = mode ; } currentColumn += token . getValue ( ) . length ( ) ; } return modes ; } 
public static void main ( String [ ] args ) throws Exception { if ( args . length > 1 ) { BufferedImage firstImage = ImageIO . read ( new File ( args [ 0 ] ) ) ; ImageOutputStream output = new FileImageOutputStream ( new File ( args [ args . length - 1 ] ) ) ; GifSequenceWriter writer = new GifSequenceWriter ( output , firstImage . getType ( ) , 1 , false ) ; writer . writeToSequence ( firstImage ) ; for ( int i = 1 ; i < args . length - 1 ; i ++ ) { BufferedImage nextImage = ImageIO . read ( new File ( args [ i ] ) ) ; writer . writeToSequence ( nextImage ) ; } writer . close ( ) ; output . close ( ) ; } else { System . out . println ( "Usage:-java-GifSequenceWriter-[list-of-gif-files]-[output-file]" ) ; } } 
private void resetNextInetSocketAddress ( Proxy proxy ) throws UnknownHostException { socketAddresses = null ; String socketHost ; if ( proxy . type ( ) == Proxy . Type . DIRECT ) { socketHost = uri . getHost ( ) ; socketPort = getEffectivePort ( uri ) ; } else { SocketAddress proxyAddress = proxy . address ( ) ; if ( ! ( proxyAddress instanceof InetSocketAddress ) ) { throw new IllegalArgumentException ( "Proxy.address()-is-not-an-" + "InetSocketAddress:-" + proxyAddress . getClass ( ) ) ; } InetSocketAddress proxySocketAddress = ( InetSocketAddress ) proxyAddress ; socketHost = proxySocketAddress . getHostName ( ) ; socketPort = proxySocketAddress . getPort ( ) ; } socketAddresses = dns . getAllByName ( socketHost ) ; nextSocketAddressIndex = 0 ; } 
public boolean activateController ( ) { if ( ! hasController ( ) ) { throw new IllegalStateException ( "hasController()-==-false!" ) ; } return getController ( ) . activate ( this ) ; } 
public void dragEnter ( DropTargetDragEvent dropEvent ) { for ( int i = 0 ; i < _dropTarget . getAdditionalListeners ( ) . size ( ) ; i ++ ) { DropTargetListener listener = _dropTarget . getAdditionalListeners ( ) . elementAt ( i ) ; listener . dragEnter ( dropEvent ) ; } if ( dropEvent . isDataFlavorSupported ( PtolemyTransferable . namedObjFlavor ) ) { dropEvent . acceptDrag ( DnDConstants . ACTION_COPY_OR_MOVE ) ; } else { dropEvent . rejectDrag ( ) ; } } 
public synchronized void deleteObserver ( Observer observer ) { observers . remove ( observer ) ; } 
public List < Property > getProperties ( ) { return new ArrayList < Property > ( properties ) ; } 
public PrintWriter append ( char c ) { write ( c ) ; return this ; } 
public DelayEntry getDelayEntryByMessageId ( String id ) { return delayTable . get ( id ) ; } 
public ComponentUI [ ] getUIs ( ) { return MultiLookAndFeel . uisToArray ( uis ) ; } 
public static BufferedImage getBufferedImage ( String imageFile , Component c ) { Image image = c . getToolkit ( ) . getImage ( imageFile ) ; waitForImage ( image , c ) ; BufferedImage bufferedImage = new BufferedImage ( image . getWidth ( c ) , image . getHeight ( c ) , BufferedImage . TYPE_INT_RGB ) ; Graphics2D g2d = bufferedImage . createGraphics ( ) ; g2d . drawImage ( image , 0 , 0 , c ) ; return ( bufferedImage ) ; } 
public boolean containsAll ( Collection < ? > c ) { return al . containsAll ( c ) ; } 
public static Element getFirstChildElement ( Element root ) { Node child = root . getFirstChild ( ) ; while ( child != null ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { return ( Element ) child ; } child = child . getNextSibling ( ) ; } return null ; } 
public void updateWorldTransform ( ) { Array < Bone > bones = this . bones ; for ( int i = 0 , nn = bones . size ; i < nn ; i ++ ) { Bone bone = bones . get ( i ) ; bone . rotationIK = bone . rotation ; } Array < Array < Bone >> boneCache = this . boneCache ; Array < IkConstraint > ikConstraints = this . ikConstraints ; int i = 0 , last = ikConstraints . size ; while ( true ) { Array < Bone > updateBones = boneCache . get ( i ) ; for ( int ii = 0 , nn = updateBones . size ; ii < nn ; ii ++ ) updateBones . get ( ii ) . updateWorldTransform ( ) ; if ( i == last ) break ; ikConstraints . get ( i ) . apply ( ) ; i ++ ; } } 
@ VisibleForTesting static Collection < Rectangle > subtractRectangles ( Rectangle rectangle , Collection < Rectangle > holes ) { List < Rectangle > result = new ArrayList < Rectangle > ( ) ; result . add ( rectangle ) ; for ( Rectangle hole : holes ) { List < Rectangle > tempResult = new ArrayList < Rectangle > ( ) ; for ( Rectangle r : result ) { if ( hole . intersects ( r ) ) { Rectangle h = hole . intersection ( r ) ; if ( h . y > r . y ) { tempResult . add ( new Rectangle ( r . x , r . y , r . width , h . y - r . y ) ) ; } if ( h . x > r . x ) { tempResult . add ( new Rectangle ( r . x , h . y , h . x - r . x , h . height ) ) ; } int hx2 = h . x + h . width ; int hy2 = h . y + h . height ; int rx2 = r . x + r . width ; int ry2 = r . y + r . height ; if ( hy2 < ry2 ) { tempResult . add ( new Rectangle ( r . x , hy2 , r . width , ry2 - hy2 ) ) ; } if ( hx2 < rx2 ) { tempResult . add ( new Rectangle ( hx2 , h . y , rx2 - hx2 , h . height ) ) ; } } else { tempResult . add ( r ) ; } } result = tempResult ; } return result ; } 
private final int appendNode ( int w0 , int w1 , int w2 , int w3 ) { int slotnumber = nodes . appendSlot ( w0 , w1 , w2 , w3 ) ; if ( DEBUG ) System . out . println ( slotnumber + ":-" + w0 + "-" + w1 + "-" + w2 + "-" + w3 ) ; if ( previousSiblingWasParent ) nodes . writeEntry ( previousSibling , 2 , slotnumber ) ; previousSiblingWasParent = false ; return slotnumber ; } 
public void testAwaitFullGc ( ) { final CountDownLatch finalizerRan = new CountDownLatch ( 1 ) ; final WeakReference < Object > ref = new WeakReference < Object > ( new Object ( ) { @ Override protected void finalize ( ) { finalizerRan . countDown ( ) ; } } ) ; GcFinalization . awaitFullGc ( ) ; assertEquals ( 0 , finalizerRan . getCount ( ) ) ; assertNull ( ref . get ( ) ) ; } 
public static void saveConfiguredSystem ( OutputStream out , ParticleSystem system ) throws IOException { try { DocumentBuilder builder = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; Document document = builder . newDocument ( ) ; Element root = document . createElement ( "system" ) ; root . setAttribute ( "additive" , "" + ( system . getBlendingMode ( ) == ParticleSystem . BLEND_ADDITIVE ) ) ; root . setAttribute ( "points" , "" + ( system . usePoints ( ) ) ) ; document . appendChild ( root ) ; for ( int i = 0 ; i < system . getEmitterCount ( ) ; i ++ ) { ParticleEmitter current = system . getEmitter ( i ) ; if ( current instanceof ConfigurableEmitter ) { Element element = emitterToElement ( document , ( ConfigurableEmitter ) current ) ; root . appendChild ( element ) ; } else { throw new RuntimeException ( "Only-ConfigurableEmitter-instances-can-be-stored" ) ; } } Result result = new StreamResult ( new OutputStreamWriter ( out , "utf-8" ) ) ; DOMSource source = new DOMSource ( document ) ; TransformerFactory factory = TransformerFactory . newInstance ( ) ; Transformer xformer = factory . newTransformer ( ) ; xformer . setOutputProperty ( OutputKeys . INDENT , "yes" ) ; xformer . transform ( source , result ) ; } catch ( Exception e ) { Log . error ( e ) ; throw new IOException ( "Unable-to-save-configured-particle-system" ) ; } } 
public boolean restorePicture ( Bundle b , File src ) { if ( src == null || b == null ) { return false ; } if ( ! src . exists ( ) ) { return false ; } try { final FileInputStream in = new FileInputStream ( src ) ; final Bundle copy = new Bundle ( b ) ; new Thread ( new Runnable ( ) { public void run ( ) { final Picture p = Picture . createFromStream ( in ) ; if ( p != null ) { mPrivateHandler . post ( new Runnable ( ) { public void run ( ) { restoreHistoryPictureFields ( p , copy ) ; } } ) ; } try { in . close ( ) ; } catch ( Exception e ) { } } } ) . start ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } return true ; } 
public void paintToolBarBorder ( SynthContext context , Graphics g , int x , int y , int w , int h , int orientation ) { paintToolBarBorder ( context , g , x , y , w , h ) ; } 
public XMLReaderAdapter ( ) throws SAXException { setup ( XMLReaderFactory . createXMLReader ( ) ) ; } 
public void put ( String key , Object value ) { mAttributes . put ( key , value ) ; } 
public boolean hasVaryAll ( ) { return varyFields . contains ( "*" ) ; } 
@ Override public String getHeader ( String name ) { return headers . get ( name . toLowerCase ( ) ) ; } 
public static byte [ ] decode ( String str , int flags ) { return decode ( str . getBytes ( ) , flags ) ; } 
public Name addAll ( int posn , Name suffix ) throws InvalidNameException { unparsed = null ; if ( suffix instanceof LdapName ) { LdapName s = ( LdapName ) suffix ; rdns . addAll ( posn , s . rdns ) ; } else { Enumeration comps = suffix . getAll ( ) ; while ( comps . hasMoreElements ( ) ) { rdns . add ( posn ++ , ( new Rfc2253Parser ( ( String ) comps . nextElement ( ) ) . parseRdn ( ) ) ) ; } } return this ; } 
private void exercise5 ( ) { List < Integer > list = Arrays . asList ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ) ; } 
public V get ( K key ) { return cache . get ( key ) ; } 
public long roundTripTime ( ) throws InterruptedException { latch . await ( ) ; return received - sent ; } 
public void breakpointHit ( String event ) { String [ ] datum = event . split ( DebugMessageIds . MESSAGE_DELIMITER ) ; String fileName = datum [ 1 ] ; int lineNumber = Integer . parseInt ( datum [ 2 ] ) ; IBreakpoint [ ] breakpoints = DebugPlugin . getDefault ( ) . getBreakpointManager ( ) . getBreakpoints ( IAntDebugConstants . ID_ANT_DEBUG_MODEL ) ; boolean found = false ; for ( int i = 0 ; i < breakpoints . length ; i ++ ) { ILineBreakpoint lineBreakpoint = ( ILineBreakpoint ) breakpoints [ i ] ; if ( setThreadBreakpoint ( lineBreakpoint , lineNumber , fileName ) ) { found = true ; break ; } } if ( ! found && fRunToLineBreakpoints != null ) { Iterator < IBreakpoint > iter = fRunToLineBreakpoints . iterator ( ) ; while ( iter . hasNext ( ) ) { ILineBreakpoint lineBreakpoint = ( ILineBreakpoint ) iter . next ( ) ; if ( setThreadBreakpoint ( lineBreakpoint , lineNumber , fileName ) ) { break ; } } } suspended ( DebugEvent . BREAKPOINT ) ; } 
public String getNaN ( ) { return m_dfs . getNaN ( ) ; } 
protected static NumberFormat getDefaultNumberFormat ( final Locale locale ) { final NumberFormat nf = NumberFormat . getInstance ( locale ) ; nf . setMaximumFractionDigits ( 2 ) ; return nf ; } 
public String getParameter ( String name ) { return parameters . get ( name ) ; } 
public static void clearBundle ( final String bundleName ) { bundlesMap . remove ( bundleName ) ; } 
public boolean isPhoneDisabled ( int phoneId ) { boolean ret = false ; try { if ( disabledForwardingIds != null ) { for ( int i = 0 ; i < disabledForwardingIds . size ( ) ; i ++ ) { if ( disabledForwardingIds . get ( i ) . getId ( ) . equals ( phoneId + "" ) ) { ret = true ; } } } else { ret = false ; } } catch ( NullPointerException e ) { ret = false ; } return ret ; } 
public int createDeferredElement ( String elementURI , String elementName ) { int elementNodeIndex = createNode ( Node . ELEMENT_NODE ) ; int elementChunk = elementNodeIndex >> CHUNK_SHIFT ; int elementIndex = elementNodeIndex & CHUNK_MASK ; setChunkValue ( fNodeName , elementName , elementChunk , elementIndex ) ; setChunkValue ( fNodeURI , elementURI , elementChunk , elementIndex ) ; return elementNodeIndex ; } 
public void printAnswer ( ) { if ( Global . getExtra ( ) . get ( C . X_LETTERS ) == false ) { for ( Enumeration < Row > e = this . answer . getRows ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) System . out . println ( e . nextElement ( ) ) ; } else { Row_answer row ; for ( Enumeration < Row > e = this . answer . getRows ( ) . elements ( ) ; e . hasMoreElements ( ) ; ) { row = ( Row_answer ) e . nextElement ( ) ; System . out . println ( row . toStringName ( ) ) ; } } } 
private void writeStartElement ( java . lang . String prefix , java . lang . String namespace , java . lang . String localPart , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String writerPrefix = xmlWriter . getPrefix ( namespace ) ; if ( writerPrefix != null ) { xmlWriter . writeStartElement ( namespace , localPart ) ; } else { if ( namespace . length ( ) == 0 ) { prefix = "" ; } else if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; } xmlWriter . writeStartElement ( prefix , localPart , namespace ) ; xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } } 
public String dotFormat ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "digraph-G-{-" ) ; Collection < Edge < E >> edges = getAllEdges ( ) ; for ( Edge < E > e : edges ) { sb . append ( "-"" + e . getSource ( ) + ""-->-"" + e . getTarget ( ) + "";-" ) ; } sb . append ( "}" ) ; return sb . toString ( ) ; } 
public void addPauseListener ( AnimatorPauseListener listener ) { if ( mPauseListeners == null ) { mPauseListeners = new ArrayList < AnimatorPauseListener > ( ) ; } mPauseListeners . add ( listener ) ; } 
public static String format ( Date value ) { return STANDARD_DATE_FORMAT . get ( ) . format ( value ) ; } 
@ Override public String toString ( ) { if ( this == ZERO ) { return "PT0S" ; } long hours = seconds / SECONDS_PER_HOUR ; int minutes = ( int ) ( ( seconds % SECONDS_PER_HOUR ) / SECONDS_PER_MINUTE ) ; int secs = ( int ) ( seconds % SECONDS_PER_MINUTE ) ; StringBuilder buf = new StringBuilder ( 24 ) ; buf . append ( "PT" ) ; if ( hours != 0 ) { buf . append ( hours ) . append ( 'H' ) ; } if ( minutes != 0 ) { buf . append ( minutes ) . append ( 'M' ) ; } if ( secs == 0 && nanos == 0 && buf . length ( ) > 2 ) { return buf . toString ( ) ; } if ( secs < 0 && nanos > 0 ) { if ( secs == - 1 ) { buf . append ( "-0" ) ; } else { buf . append ( secs + 1 ) ; } } else { buf . append ( secs ) ; } if ( nanos > 0 ) { int pos = buf . length ( ) ; if ( secs < 0 ) { buf . append ( 2 * NANOS_PER_SECOND - nanos ) ; } else { buf . append ( nanos + NANOS_PER_SECOND ) ; } while ( buf . charAt ( buf . length ( ) - 1 ) == '0' ) { buf . setLength ( buf . length ( ) - 1 ) ; } buf . setCharAt ( pos , '.' ) ; } buf . append ( 'S' ) ; return buf . toString ( ) ; } 
public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , Class clazz ) { final String className = clazz . getName ( ) ; final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; if ( className . equals ( "org.w3c.dom.Node" ) ) { translateTo ( classGen , methodGen , Type . NodeSet ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE , MAKE_NODE_SIG2 ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "org.w3c.dom.NodeList" ) ) { translateTo ( classGen , methodGen , Type . NodeSet ) ; int index = cpg . addInterfaceMethodref ( DOM_INTF , MAKE_NODE_LIST , MAKE_NODE_LIST_SIG2 ) ; il . append ( new INVOKEINTERFACE ( index , 2 ) ) ; } else if ( className . equals ( "java.lang.Object" ) ) { il . append ( NOP ) ; } else if ( className . equals ( "java.lang.String" ) ) { translateTo ( classGen , methodGen , Type . String ) ; } else { ErrorMsg err = new ErrorMsg ( ErrorMsg . DATA_CONVERSION_ERR , toString ( ) , className ) ; classGen . getParser ( ) . reportError ( Constants . FATAL , err ) ; } } 
private void unlockAllTables ( ) { Iterator < SqlJetBtreeLock > ppIter = pBt . pLock . iterator ( ) ; assert ( holdsMutex ( ) ) ; assert ( sharable || ! ppIter . hasNext ( ) ) ; while ( ppIter . hasNext ( ) ) { SqlJetBtreeLock pLock = ppIter . next ( ) ; assert ( pBt . pExclusive == null || pBt . pExclusive == pLock . pBtree ) ; if ( pLock . pBtree == this ) { ppIter . remove ( ) ; } } if ( pBt . pExclusive == this ) { pBt . pExclusive = null ; } } 
private String makeSchemeSpecificPart ( ) { StringBuilder builder = new StringBuilder ( ) ; appendSspTo ( builder ) ; return builder . toString ( ) ; } 
public void writeTo ( OutputStream out ) throws IOException { buffer . writeTo ( out ) ; } 
public boolean equal ( Duration duration ) { boolean result = false ; if ( duration == null ) return result ; result = ( _year == duration . getYear ( ) ) ; result = result && ( _month == duration . getMonth ( ) ) ; result = result && ( _day == duration . getDay ( ) ) ; result = result && ( _hour == duration . getHour ( ) ) ; result = result && ( _minute == duration . getMinute ( ) ) ; result = result && ( _second == duration . getSeconds ( ) ) ; result = result && ( _millisecond == duration . getMilli ( ) ) ; result = result && ( this . isNegative ( ) == duration . isNegative ( ) ) ; return result ; } 
public static boolean isFuzzyColumn ( Connector c , String schemaName , String tableName , String columnName ) throws SQLException { if ( null == fuzzyColumns ) { fuzzyColumns = new HashMap < String , LinkedHashSet < String >> ( ) ; } if ( ! fuzzyColumns . containsKey ( schemaName + "." + tableName ) ) { ResultSet rs = c . executeRawQuery ( "SELECT-table_name,-column_name-" + "FROM-information_schema_fuzzy.columns-" + "WHERE-table_schema-=-'" + schemaName + "'" ) ; while ( rs . next ( ) ) { String tab = rs . getString ( "table_name" ) ; LinkedHashSet < String > cols = fuzzyColumns . get ( schemaName + "." + tab ) ; if ( null == cols ) { cols = new LinkedHashSet < String > ( ) ; } cols . add ( rs . getString ( "column_name" ) ) ; fuzzyColumns . put ( schemaName + "." + tab , cols ) ; } } HashSet < String > cols = fuzzyColumns . get ( schemaName + "." + tableName ) ; return null != cols && cols . contains ( columnName ) ; } 
public void draw ( Graphics2D g2 , DialPlot plot , Rectangle2D frame , Rectangle2D view ) { Paint p = this . paint ; if ( p instanceof GradientPaint ) { p = this . gradientPaintTransformer . transform ( ( GradientPaint ) p , view ) ; } g2 . setPaint ( p ) ; g2 . fill ( view ) ; } 
public void buildClassSummary ( ) { ClassDoc [ ] classes = packageDoc . isIncluded ( ) ? packageDoc . ordinaryClasses ( ) : configuration . classDocCatalog . ordinaryClasses ( Util . getPackageName ( packageDoc ) ) ; if ( classes . length > 0 ) { packageWriter . writeClassesSummary ( classes , configuration . getText ( "doclet.Class_Summary" ) ) ; } } 
@ XmlElementDecl ( namespace = "http://www.wfmc.org/2002/XPDL1.0" , name = "ValidTo" ) public JAXBElement < String > createValidTo ( String value ) { return new JAXBElement < String > ( _ValidTo_QNAME , String . class , null , value ) ; } 
public void addChoice ( String label , String [ ] items , String defaultItem ) { String label2 = label ; if ( label2 . indexOf ( '_' ) != - 1 ) label2 = label2 . replace ( '_' , '-' ) ; Label theLabel = makeLabel ( label2 ) ; c . gridx = 0 ; c . gridy = y ; c . anchor = GridBagConstraints . EAST ; c . gridwidth = 1 ; if ( choice == null ) { choice = new Vector ( 4 ) ; c . insets = getInsets ( 5 , 0 , 5 , 0 ) ; } else c . insets = getInsets ( 0 , 0 , 5 , 0 ) ; grid . setConstraints ( theLabel , c ) ; add ( theLabel ) ; Choice thisChoice = new Choice ( ) ; thisChoice . addKeyListener ( this ) ; thisChoice . addItemListener ( this ) ; for ( int i = 0 ; i < items . length ; i ++ ) thisChoice . addItem ( items [ i ] ) ; thisChoice . select ( defaultItem ) ; c . gridx = 1 ; c . gridy = y ; c . anchor = GridBagConstraints . WEST ; grid . setConstraints ( thisChoice , c ) ; add ( thisChoice ) ; choice . addElement ( thisChoice ) ; if ( Recorder . record || macro ) saveLabel ( thisChoice , label ) ; y ++ ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
static public XObject create ( Object val , XPathContext xctxt ) { return XObjectFactory . create ( val , xctxt ) ; } 
public Fraction plus ( long n ) { long an = numerator ( ) ; long ad = denominator ( ) ; long bn = n ; long bd = 1 ; return new Fraction ( an * bd + bn * ad , ad * bd ) ; } 
public boolean isDirectSubClass ( String subClass , String superClass ) throws EngineException { return Types . edgeExist ( superClass , subClass ) ; } 
private void incrementCursors ( ) { if ( mCompareResultIsValid ) { switch ( mCompareResult ) { case LEFT : mCursorLeft . moveToNext ( ) ; break ; case RIGHT : mCursorRight . moveToNext ( ) ; break ; case BOTH : mCursorLeft . moveToNext ( ) ; mCursorRight . moveToNext ( ) ; break ; } mCompareResultIsValid = false ; } } 
private void closeDownThreadpoolQuietly ( ThreadPoolExecutor executor ) { if ( executor == null ) { return ; } if ( ! executor . isShutdown ( ) ) { executor . shutdownNow ( ) ; } } 
static byte [ ] calculateOriginKey ( String classKey ) { byte [ ] classKeyBytes = null ; int len = 0 ; try { classKeyBytes = classKey . getBytes ( "UTF-8" ) ; len = classKeyBytes . length ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } byte [ ] keyData = new byte [ len + 1 ] ; System . arraycopy ( classKeyBytes , 0 , keyData , 0 , len ) ; keyData [ len ] = 0 ; return keyData ; } 
public synchronized HttpCacheEntry getEntry ( String url ) throws IOException { return entries . get ( url ) ; } 
public final boolean isShortcutDown ( ) { switch ( Toolkit . getToolkit ( ) . getPlatformShortcutKey ( ) ) { case SHIFT : return shiftDown ; case CONTROL : return controlDown ; case ALT : return altDown ; case META : return metaDown ; default : return false ; } } 
public void removeVerifyListener ( VerifyListener listener ) { checkWidget ( ) ; if ( listener == null ) error ( SWT . ERROR_NULL_ARGUMENT ) ; if ( eventTable == null ) return ; eventTable . unhook ( SWT . Verify , listener ) ; } 
public int getPagesRequired ( ) { return super . getPagesRequired ( ) + immixSpace . requiredPages ( ) ; } 
public Point2D getPosition ( ) { return new Point ( ( int ) this . getX ( ) , ( int ) this . getY ( ) ) ; } 
private void rebindWapPushManager ( ) { if ( mWapPushMan != null ) return ; final ServiceConnection wapPushConnection = this ; new Thread ( ) { public void run ( ) { while ( mWapPushMan == null ) { mOwner . bindService ( new Intent ( IWapPushManager . class . getName ( ) ) , wapPushConnection , Context . BIND_AUTO_CREATE ) ; try { Thread . sleep ( BIND_RETRY_INTERVAL ) ; } catch ( InterruptedException e ) { if ( false ) Log . v ( LOG_TAG , "sleep-interrupted." ) ; } } } } . start ( ) ; } 
public Shape createProgressBarIndeterminatePattern ( int x , int y , int w , int h ) { final double wHalf = w / 2.0 ; final double xOffset = wHalf / 4.0 ; path . reset ( ) ; path . moveTo ( xOffset , 0 ) ; path . lineTo ( wHalf + xOffset , 0 ) ; path . lineTo ( w , h ) ; path . lineTo ( wHalf , h ) ; path . closePath ( ) ; return path ; } 
public void savePlayer ( ) { try { ObjectOutputStream oos = new ObjectOutputStream ( new FileOutputStream ( new File ( "player.dat" ) ) ) ; oos . writeObject ( players ) ; oos . flush ( ) ; oos . close ( ) ; } catch ( Exception ioe ) { JOptionPane . showMessageDialog ( null , ioe . toString ( ) , "Error-Message" , JOptionPane . ERROR_MESSAGE ) ; } } 
protected boolean isClosed ( ) { return closed . get ( ) ; } 
protected void onTouchDownWindow ( Vector2 point , IMotionEvent event ) { WindowEvent windowEvent = new WindowEvent ( this , WindowEventType . TOUCH_DOWN ) ; windowEvent . setParam ( "POINT" , point ) ; windowEvent . setParam ( "MOTIONEVENT" , event ) ; fireEvent ( windowEvent ) ; } 
public void recordVariable ( String typeDesc , String varName , int varNo , SymbolTable tbl ) throws CompileError { char c ; int dim = 0 ; while ( ( c = typeDesc . charAt ( dim ) ) == '[' ) ++ dim ; int type = MemberResolver . descToType ( c ) ; String cname = null ; if ( type == CLASS ) { if ( dim == 0 ) cname = typeDesc . substring ( 1 , typeDesc . length ( ) - 1 ) ; else cname = typeDesc . substring ( dim + 1 , typeDesc . length ( ) - 1 ) ; } Declarator decl = new Declarator ( type , cname , dim , varNo , new Symbol ( varName ) ) ; tbl . append ( varName , decl ) ; } 
public com . google . protobuf . ByteString getDistanceBytes ( ) { java . lang . Object ref = distance_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; distance_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public synchronized void setTCPNoDelay ( boolean enable ) throws IOException { tcpNoDelay = enable ; if ( tm != null ) tm . setTcpNoDelay ( enable ) ; } 
public double getOptDouble ( final String name , final double defaultValue ) throws JSONRPC2Error { Number number = ( Number ) getOpt ( name , Double . class , defaultValue ) ; return number . doubleValue ( ) ; } 
public static void exit ( int code ) { Runtime . getRuntime ( ) . exit ( code ) ; } 
public void addProperty ( Property p ) { properties . addElement ( p ) ; } 
void dispose ( ) { mSmsStamp . clear ( ) ; } 
public static double [ ] extend ( double [ ] a , int additional ) { double [ ] ret = new double [ a . length + additional ] ; System . arraycopy ( a , 0 , ret , 0 , a . length ) ; return ret ; } 
private Element getAvatarCreateParams ( long userID ) throws Exception { Element avatarCreateParams = DocumentHelper . createDocument ( ) . addElement ( "createAvatar" ) ; Element avatarResponse = getAvatar ( userID ) ; Element avatar = avatarResponse . element ( "return" ) ; if ( avatar != null ) { avatarCreateParams . addElement ( "ownerID" ) . setText ( avatar . elementText ( "owner" ) ) ; Element attachment = avatar . element ( "attachment" ) ; if ( attachment != null ) { avatarCreateParams . addElement ( "name" ) . setText ( attachment . elementText ( "name" ) ) ; avatarCreateParams . addElement ( "contentType" ) . setText ( attachment . elementText ( "contentType" ) ) ; avatarCreateParams . addElement ( "data" ) . setText ( attachment . elementText ( "data" ) ) ; } } return avatarCreateParams ; } 
private static void extractDeadServersFromZNodeString ( String deadServerListStr , List < String > result ) { if ( deadServerListStr == null || result == null || deadServerListStr . isEmpty ( ) ) return ; int seenCommaCnt = 0 ; int startIndex = 0 ; int len = deadServerListStr . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { switch ( deadServerListStr . charAt ( i ) ) { case ',' : seenCommaCnt += 1 ; break ; case '-' : if ( seenCommaCnt >= 2 ) { if ( i > startIndex ) { result . add ( deadServerListStr . substring ( startIndex , i ) ) ; startIndex = i + 1 ; } seenCommaCnt = 0 ; } break ; default : break ; } } if ( startIndex < len - 1 ) { result . add ( deadServerListStr . substring ( startIndex , len ) ) ; } LOG . debug ( "Found-dead-servers:" + result ) ; } 
public Iterator iterator ( ) { return _entries . values ( ) . iterator ( ) ; } 
public static void setPenColor ( Color color ) { penColor = color ; offscreen . setColor ( penColor ) ; } 
public boolean hasCompatibleArchive ( ) { return mMainPkg . hasCompatibleArchive ( ) ; } 
public void startSeriesPass ( XYDataset dataset , int series , int firstItem , int lastItem , int pass , int passCount ) { this . seriesPath . reset ( ) ; this . lastPointGood = false ; super . startSeriesPass ( dataset , series , firstItem , lastItem , pass , passCount ) ; } 
public static ShortBuffer wrap ( short [ ] array ) { return wrap ( array , 0 , array . length ) ; } 
public void maybeShare ( Connection connection ) { executorService . submit ( connectionsCleanupCallable ) ; if ( ! connection . isSpdy ( ) ) { return ; } if ( connection . isAlive ( ) ) { synchronized ( this ) { connections . addFirst ( connection ) ; } } } 
public void distributeAdena ( L2PcInstance player , long adena , L2Character target ) { final List < L2PcInstance > toReward = new LinkedList < > ( ) ; for ( L2PcInstance member : getMembers ( ) ) { if ( Util . checkIfInRange ( Config . ALT_PARTY_RANGE2 , target , member , true ) ) { toReward . add ( member ) ; } } if ( ! toReward . isEmpty ( ) ) { long count = adena / toReward . size ( ) ; for ( L2PcInstance member : toReward ) { member . addAdena ( "Party" , count , player , true ) ; } } } 
public DTM getDTM ( int nodeHandle ) { return m_execContext . getDTM ( nodeHandle ) ; } 
@ Inline protected static float unboxAsFloat ( Object obj ) { if ( ( obj == null ) || ! ( obj instanceof Float ) ) { throwIllegalArgumentException ( ) ; } return ( ( Float ) obj ) . floatValue ( ) ; } 
public int getImageDepth ( int pSceneNr ) throws InfoException { String [ ] depth = iAttribList . get ( pSceneNr ) . get ( "Depth" ) . split ( "-|/" , 2 ) ; try { return Integer . parseInt ( depth [ 0 ] ) ; } catch ( NumberFormatException ex ) { throw new InfoException ( ex ) ; } } 
public void println ( long l ) { println ( String . valueOf ( l ) ) ; } 
public void startElement ( String uri , String localName , String qName ) throws SAXException { if ( m_state != null ) { m_state . resetState ( getTransformer ( ) ) ; } if ( m_tracer != null ) super . fireStartElem ( qName ) ; } 
public void endGeneralEntity ( String name , Augmentations augs ) throws XNIException { fCurrentNode = fCurrentNode . getParentNode ( ) ; } 
public String nextElement ( ) { return nextToken ( ) ; } 
private static void makeRed ( Node node , int index ) { if ( node != null ) { node . setRed ( index ) ; } } 
public String getLocationAsString ( ) { if ( null != locator ) { StringBuilder sbuffer = new StringBuilder ( ) ; String systemID = locator . getSystemId ( ) ; int line = locator . getLineNumber ( ) ; int column = locator . getColumnNumber ( ) ; if ( null != systemID ) { sbuffer . append ( ";-SystemID:-" ) ; sbuffer . append ( systemID ) ; } if ( 0 != line ) { sbuffer . append ( ";-Line#:-" ) ; sbuffer . append ( line ) ; } if ( 0 != column ) { sbuffer . append ( ";-Column#:-" ) ; sbuffer . append ( column ) ; } return sbuffer . toString ( ) ; } else { return null ; } } 
public int getResponseCode ( ) throws IOException { getInputStream ( ) ; String response = getHeaderField ( 0 ) ; if ( response == null ) { return - 1 ; } response = response . trim ( ) ; int mark = response . indexOf ( "-" ) + 1 ; if ( mark == 0 ) { return - 1 ; } int last = mark + 3 ; if ( last > response . length ( ) ) { last = response . length ( ) ; } responseCode = Integer . parseInt ( response . substring ( mark , last ) ) ; if ( last + 1 <= response . length ( ) ) { responseMessage = response . substring ( last + 1 ) ; } return responseCode ; } 
public int readIntFromXML ( Element node ) throws Exception { if ( DEBUG ) trace ( new Throwable ( ) , node . getAttribute ( ATT_NAME ) ) ; m_CurrentNode = node ; return ( ( Integer ) getPrimitive ( node ) ) . intValue ( ) ; } 
private static Command fromCommandChars ( String string , int start , int end ) { final int s = Math . max ( 0 , start ) ; final int e = Math . min ( string . length ( ) , end ) ; if ( s < e ) { for ( final Command command : Command . values ( ) ) { for ( int i = s ; i < e ; i ++ ) { if ( string . charAt ( i ) == command . commandChar ) { return command ; } } } } return null ; } 
public GMOps transform ( ) { String oper ; StringBuffer buf = new StringBuffer ( ) ; iCmdArgs . add ( "-transform" ) ; if ( buf . length ( ) > 0 ) { iCmdArgs . add ( buf . toString ( ) ) ; } return this ; } 
public String getMessage ( ) { if ( ! specialConstructor ) { return super . getMessage ( ) ; } StringBuffer expected = new StringBuffer ( ) ; int maxSize = 0 ; for ( int i = 0 ; i < expectedTokenSequences . length ; i ++ ) { if ( maxSize < expectedTokenSequences [ i ] . length ) { maxSize = expectedTokenSequences [ i ] . length ; } for ( int j = 0 ; j < expectedTokenSequences [ i ] . length ; j ++ ) { expected . append ( tokenImage [ expectedTokenSequences [ i ] [ j ] ] ) . append ( "-" ) ; } if ( expectedTokenSequences [ i ] [ expectedTokenSequences [ i ] . length - 1 ] != 0 ) { expected . append ( "..." ) ; } expected . append ( eol ) . append ( "-" ) ; } String retval = "Encountered-"" ; Token tok = currentToken . next ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i != 0 ) retval += "-" ; if ( tok . kind == 0 ) { retval += tokenImage [ 0 ] ; break ; } retval += add_escapes ( tok . image ) ; tok = tok . next ; } retval += ""-at-line-" + currentToken . next . beginLine + ",-column-" + currentToken . next . beginColumn ; retval += "." + eol ; if ( expectedTokenSequences . length == 1 ) { retval += "Was-expecting:" + eol + "-" ; } else { retval += "Was-expecting-one-of:" + eol + "-" ; } retval += expected . toString ( ) ; return retval ; } 
public Buffer readFrom ( InputStream in ) throws IOException { readFrom ( in , Long . MAX_VALUE , true ) ; return this ; } 
public static File createTempFile ( String prefix , String suffix , File directory ) throws IOException { if ( prefix . length ( ) < 3 ) throw new IllegalArgumentException ( "Prefix-string-too-short" ) ; if ( suffix == null ) suffix = ".tmp" ; File tmpdir = ( directory != null ) ? directory : TempDirectory . location ( ) ; File f ; try { do { f = TempDirectory . generateFile ( prefix , suffix , tmpdir ) ; } while ( f . exists ( ) ) ; if ( ! f . createNewFile ( ) ) throw new IOException ( "Unable-to-create-temporary-file" ) ; } catch ( SecurityException se ) { if ( directory == null ) throw new SecurityException ( "Unable-to-create-temporary-file" ) ; throw se ; } return f ; } 
private void getNextPosition ( ) { if ( left ) { dx -= moveSpeed ; if ( dx < - maxSpeed ) { dx = - maxSpeed ; } } else if ( right ) { dx += moveSpeed ; if ( dx > maxSpeed ) { dx = maxSpeed ; } } else { if ( dx > 0 ) { dx -= stopSpeed ; if ( dx < 0 ) { dx = 0 ; } } else if ( dx < 0 ) { dx += stopSpeed ; if ( dx > 0 ) { dx = 0 ; } } } if ( jumping && ! falling ) { sounds . get ( "jump" ) . play ( ) ; dy = jumpStart ; falling = true ; } if ( falling ) { if ( dy > 0 ) { dy += fallSpeed ; } else { dy += fallSpeed ; } if ( dy > 0 ) { jumping = false ; } if ( dy < 0 && ! jumping ) { dy += stopJumpSpeed ; } if ( dy > maxFallSpeed ) { dy = maxFallSpeed ; } } } 
protected final void detachDuplicate ( Element elem ) throws JDOMException { final String singularName = elem . getName ( ) . substring ( 0 , elem . getName ( ) . length ( ) - 1 ) ; final List thisNames = getXPath ( "./text:" + singularName + "s/text:" + singularName + "/@text:name" ) . selectNodes ( getChild ( "body" ) ) ; org . apache . commons . collections . CollectionUtils . transform ( thisNames , new Transformer ( ) { public Object transform ( Object obj ) { return ( ( Attribute ) obj ) . getValue ( ) ; } } ) ; final Iterator iter = elem . getChildren ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { final Element decl = ( Element ) iter . next ( ) ; if ( thisNames . contains ( decl . getAttributeValue ( "name" , getVersion ( ) . getTEXT ( ) ) ) ) { iter . remove ( ) ; } } } 
public static void setPreferedHeight ( JComponent component , int height ) { int preferedWidth = component . getPreferredSize ( ) . width ; component . setPreferredSize ( new Dimension ( preferedWidth , height ) ) ; } 
@ Override public void setCharacterStream ( int parameterIndex , Reader reader ) throws SQLException { realCallableStatement . setCharacterStream ( parameterIndex , reader ) ; } 
TimeInterval computeLastDur ( final TimeInterval ti ) { Time simpleDur = computeSimpleDuration ( ti . end ) ; if ( simpleDur != null ) { Time iad = calculateIntermediateActiveDuration ( simpleDur ) ; if ( iad . isResolved ( ) ) { ti . lastDur = new Time ( ti . begin . value + iad . value ) ; if ( ti . lastDur . greaterThan ( ti . end ) ) { ti . lastDur = ti . end ; } } else { ti . lastDur = ti . end ; } } else { ti . lastDur = ti . end ; } return ti ; } 
void removeFromInvalidates ( String storageID ) { Collection < Block > blocks = recentInvalidateSets . remove ( storageID ) ; if ( blocks != null ) { pendingDeletionBlocksCount -= blocks . size ( ) ; } } 
public static String trimmedBothOrBlank ( String string ) { return trimBoth ( string == null ? "" : string . trim ( ) ) ; } 
public void getElements ( Vector < Element > elemVec ) { switch ( type ) { case '*' : case '?' : case '+' : ( ( ContentModel ) content ) . getElements ( elemVec ) ; break ; case ',' : case '|' : case '&' : for ( ContentModel m = ( ContentModel ) content ; m != null ; m = m . next ) { m . getElements ( elemVec ) ; } break ; default : elemVec . addElement ( ( Element ) content ) ; } } 
public void setValue ( String par1Str ) { this . valueString = par1Str ; this . valueBoolean = Boolean . parseBoolean ( par1Str ) ; try { this . valueInteger = Integer . parseInt ( par1Str ) ; } catch ( NumberFormatException var4 ) { ; } try { this . valueDouble = Double . parseDouble ( par1Str ) ; } catch ( NumberFormatException var3 ) { ; } } 
public int getMinimumDividerLocation ( JSplitPane a ) { int returnValue = ( ( SplitPaneUI ) ( uis . elementAt ( 0 ) ) ) . getMinimumDividerLocation ( a ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( SplitPaneUI ) ( uis . elementAt ( i ) ) ) . getMinimumDividerLocation ( a ) ; } return returnValue ; } 
public void selectConvertTextTab ( ) { try { SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { mainTab . setSelectedComponent ( converterPanel ) ; } } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } 
@ XmlElementDecl ( namespace = "" , name = "callingPartyNationalStripDigits" , scope = UpdateH323TrunkReq . class ) public JAXBElement < String > createUpdateH323TrunkReqCallingPartyNationalStripDigits ( String value ) { return new JAXBElement < String > ( new QName ( "" , "callingPartyNationalStripDigits" ) , String . class , UpdateH323TrunkReq . class , value ) ; } 
public StringBuilder deleteCharAt ( int index ) { deleteCharAt0 ( index ) ; return this ; } 
public void clear ( ) { FrequentAtomsTrie . removeAll ( ) ; abstractionCreator = null ; } 
public static void encodeToFile ( byte [ ] dataToEncode , String filename ) throws java . io . IOException { if ( dataToEncode == null ) { throw new NullPointerException ( "Data-to-encode-was-null." ) ; } Base64 . OutputStream bos = null ; try { bos = new Base64 . OutputStream ( new java . io . FileOutputStream ( filename ) , Base64 . ENCODE ) ; bos . write ( dataToEncode ) ; } catch ( java . io . IOException e ) { throw e ; } finally { try { bos . close ( ) ; } catch ( Exception e ) { } } } 
protected void fireChange ( ) { Object [ ] listeners = listenerList . getListenerList ( ) ; ChangeEvent event = new ChangeEvent ( this ) ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == ChangeListener . class ) { ( ( ChangeListener ) listeners [ i + 1 ] ) . stateChanged ( event ) ; } } } 
protected static String buildMessage ( String msg ) { StackTraceElement caller = new Throwable ( ) . fillInStackTrace ( ) . getStackTrace ( ) [ 2 ] ; return new StringBuilder ( ) . append ( caller . getClassName ( ) ) . append ( "." ) . append ( caller . getMethodName ( ) ) . append ( "():-" ) . append ( msg ) . toString ( ) ; } 
public static boolean isMailTo ( String url ) { if ( url != null && url . startsWith ( MAILTO_SCHEME ) ) { return true ; } return false ; } 
public void showAlert ( String message ) { ( new AlertDialog . Builder ( getContext ( ) ) ) . setMessage ( message ) . setNeutralButton ( android . R . string . ok , null ) . create ( ) . show ( ) ; } 
public void setDescriptor ( Descriptor inDescriptor ) { if ( inDescriptor == null ) { if ( MODELMBEAN_LOGGER . isLoggable ( Level . FINER ) ) { MODELMBEAN_LOGGER . logp ( Level . FINER , ModelMBeanAttributeInfo . class . getName ( ) , "setDescriptor(Descriptor)" , "Received-null-for-new-descriptor-value,-" + "setting-descriptor-to-default-values" ) ; } attrDescriptor = createDefaultDescriptor ( ) ; } else { if ( MODELMBEAN_LOGGER . isLoggable ( Level . FINER ) ) { MODELMBEAN_LOGGER . logp ( Level . FINER , ModelMBeanAttributeInfo . class . getName ( ) , "setDescriptor(Descriptor)" , "Executed-for-" + inDescriptor . toString ( ) ) ; } if ( isValid ( inDescriptor ) ) { attrDescriptor = ( Descriptor ) inDescriptor . clone ( ) ; } else { throw new RuntimeOperationsException ( new IllegalArgumentException ( "Invalid-descriptor-passed-in-parameter" ) , ( "Exception-occurred-in-ModelMBeanAttributeInfo-setDescriptor" ) ) ; } } } 
public double nextDouble ( double mean , double gamma , double cut ) { double val , rval , displ ; if ( gamma == 0.0 ) return mean ; if ( cut == Double . NEGATIVE_INFINITY ) { rval = 2.0 * randomGenerator . nextDouble ( ) - 1.0 ; displ = 0.5 * gamma * Math . tan ( rval * ( Math . PI / 2.0 ) ) ; return mean + displ ; } else { val = Math . atan ( 2.0 * cut / gamma ) ; rval = 2.0 * randomGenerator . nextDouble ( ) - 1.0 ; displ = 0.5 * gamma * Math . tan ( rval * val ) ; return mean + displ ; } } 
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof NetworkInterface ) ) { return false ; } NetworkInterface rhs = ( NetworkInterface ) obj ; return interfaceIndex == rhs . interfaceIndex && name . equals ( rhs . name ) && addresses . equals ( rhs . addresses ) ; } 
private void completeRequest ( final Intent intent , final VideoEditor videoEditor , final Exception exception , final Object result , final Object extraResult , final boolean finalize ) { mHandler . post ( new Runnable ( ) { @ Override public void run ( ) { onIntentProcessed ( intent , videoEditor , result , extraResult , exception , finalize ) ; } } ) ; } 
@ XmlElementDecl ( namespace = "http://www.xbrl.org/tw/fr/gaap/tw-gaap-basi-2010-03-31-cr" , name = "LossesEquityInvestmentsTheEquityMethod-LossesEquityInvestmentsTheEquityMethod" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < MonetaryItemType > createLossesEquityInvestmentsTheEquityMethodLossesEquityInvestmentsTheEquityMethod ( MonetaryItemType value ) { return new JAXBElement < MonetaryItemType > ( _LossesEquityInvestmentsTheEquityMethodLossesEquityInvestmentsTheEquityMethod_QNAME , MonetaryItemType . class , null , value ) ; } 
private Partition initPartition ( Template template , List < Record < Location >> locRecords ) { Partition result = new Partition ( template ) ; Map < LocationKey , Cell > cellMap = new LinkedHashMap < LocationKey , Cell > ( ) ; for ( Location loc : template . getLocations ( ) ) { for ( int i = locRecords . size ( ) ; i <= loc . getNumber ( ) ; i ++ ) { locRecords . add ( null ) ; } locRecords . set ( loc . getNumber ( ) , computeRecord ( loc ) ) ; LocationKey key = new LocationKey ( loc ) ; Cell cell = cellMap . get ( key ) ; if ( cell == null ) { cellMap . put ( key , cell = new Cell ( ) ) ; } cell . add ( loc ) ; } result . addAll ( cellMap . values ( ) ) ; return result ; } 
private Boolean isParenthesis ( final Element element , final String propertyName ) { assert element != null && propertyName != null && isProperty ( propertyName ) ; if ( ! element . getName ( ) . equals ( OPERATOR ) ) { return false ; } return getPropertySet ( propertyName ) . contains ( element . getTextNormalize ( ) ) ; } 
public List getSeries ( ) { return Collections . unmodifiableList ( this . data ) ; } 
public void setPasswordAuthentication ( URLName url , PasswordAuthentication pw ) { if ( pw == null ) authTable . remove ( url ) ; else authTable . put ( url , pw ) ; } 
public static String getMissingTail ( String text , String tail ) { for ( int i = 1 ; i < tail . length ( ) ; i ++ ) { int endIndex = text . length ( ) ; int end = Math . max ( 0 , endIndex ) ; int start = Math . max ( 0 , end - i ) ; String contentTail = text . substring ( start , end ) ; String proposalHead = tail . substring ( 0 , i ) ; if ( contentTail . equals ( proposalHead ) ) { return tail . substring ( i ) ; } } return tail ; } 
public final void clearSelection ( ) { grid . clearSelection ( ) ; } 
public static void CloseFile ( PrintWriter theFile ) { theFile . flush ( ) ; theFile . close ( ) ; } 
@ XmlElementDecl ( namespace = "" , name = "short-description" ) public JAXBElement < String > createShortDescription ( String value ) { return new JAXBElement < String > ( _ShortDescription_QNAME , String . class , null , value ) ; } 
public boolean isAvailable ( ) { if ( isConnected ( ) ) { try { if ( _socket_ . getInetAddress ( ) == null ) return false ; if ( _socket_ . getPort ( ) == 0 ) return false ; if ( _socket_ . getRemoteSocketAddress ( ) == null ) return false ; if ( _socket_ . isClosed ( ) ) return false ; if ( _socket_ . isInputShutdown ( ) ) return false ; if ( _socket_ . isOutputShutdown ( ) ) return false ; _socket_ . getInputStream ( ) ; _socket_ . getOutputStream ( ) ; } catch ( IOException ioex ) { return false ; } return true ; } else { return false ; } } 
public void addFireStation ( int location ) { fsLocations . add ( location ) ; } 
public String toString ( ) { return ( attributeValue . toString ( ) ) ; } 
public synchronized void saveCommitPoint ( Long indexCommitVersion ) { AtomicInteger reserveCount = savedCommits . get ( indexCommitVersion ) ; if ( reserveCount == null ) reserveCount = new AtomicInteger ( ) ; reserveCount . incrementAndGet ( ) ; savedCommits . put ( indexCommitVersion , reserveCount ) ; } 
public static Collection < Artist > getSimilar ( String artist , int limit , String apiKey ) { Result result = Caller . getInstance ( ) . call ( "artist.getSimilar" , apiKey , "artist" , artist , "limit" , String . valueOf ( limit ) ) ; if ( ! result . isSuccessful ( ) ) return Collections . emptyList ( ) ; DomElement element = result . getContentElement ( ) ; List < Artist > artists = new ArrayList < Artist > ( ) ; for ( DomElement e : element . getChildren ( "artist" ) ) { artists . add ( artistFromElement ( e ) ) ; } return artists ; } 
public double getDoubleMetadata ( String key ) throws noMetadataException { return ( ( Double ) this . getMetadata ( key ) ) . doubleValue ( ) ; } 
public Enumeration listOptions ( ) { Vector result = new Vector ( ) ; Enumeration en = super . listOptions ( ) ; while ( en . hasMoreElements ( ) ) result . addElement ( en . nextElement ( ) ) ; result . addElement ( new Option ( "-Full-name-and-options-of-the-evaluator-analyzed.-" + "-eg:-weka.attributeSelection.CfsSubsetEval" , "eval" , 1 , "-eval-name-[options]" ) ) ; result . addElement ( new Option ( "-Full-name-and-options-of-the-search-method-analyzed.-" + "-eg:-weka.attributeSelection.Ranker" , "search" , 1 , "-search-name-[options]" ) ) ; result . addElement ( new Option ( "-The-scheme-to-test,-either-the-evaluator-or-the-search-method.-" + "-(Default:-eval)" , "test" , 1 , "-test-<eval|search>" ) ) ; if ( ( m_Evaluator != null ) && ( m_Evaluator instanceof OptionHandler ) ) { result . addElement ( new Option ( "" , "" , 0 , "-Options-specific-to-evaluator-" + m_Evaluator . getClass ( ) . getName ( ) + ":" ) ) ; Enumeration enm = ( ( OptionHandler ) m_Evaluator ) . listOptions ( ) ; while ( enm . hasMoreElements ( ) ) result . addElement ( enm . nextElement ( ) ) ; } if ( ( m_Search != null ) && ( m_Search instanceof OptionHandler ) ) { result . addElement ( new Option ( "" , "" , 0 , "-Options-specific-to-search-method-" + m_Search . getClass ( ) . getName ( ) + ":" ) ) ; Enumeration enm = ( ( OptionHandler ) m_Search ) . listOptions ( ) ; while ( enm . hasMoreElements ( ) ) result . addElement ( enm . nextElement ( ) ) ; } return result . elements ( ) ; } 
public static String abbreviate ( String text , int size ) { if ( text == null ) { return null ; } if ( text . length ( ) > size ) { return text . substring ( 0 , size ) . trim ( ) + "..." ; } return text ; } 
public int getSequenceNumber ( ) { return mSequenceGenerator . incrementAndGet ( ) ; } 
public static void initSynchronization ( ) throws IllegalStateException { if ( isSynchronizationActive ( ) ) { throw new IllegalStateException ( "Cannot-activate-transaction-synchronization---already-active" ) ; } logger . trace ( "Initializing-transaction-synchronization" ) ; synchronizations . set ( new LinkedHashSet < TransactionSynchronization > ( ) ) ; } 
public void init ( StanzaHandler handler , String initString ) throws IOException { this . handler = handler ; init_str = initString ; if ( init_str . endsWith ( File . separator ) ) { file_mask = "" ; directory = init_str ; } else { int idx = init_str . lastIndexOf ( File . separator ) ; directory = init_str . substring ( 0 , idx ) ; file_mask = init_str . substring ( idx + 1 , init_str . length ( ) ) ; } log . config ( "file_mask='" + file_mask + "',-directory='" + directory + "'" ) ; } 
public final void close ( LsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) return ; log . info ( "sending-packet:-" + closePacket + "-and-closing-connection-after-that." ) ; pendingClose = true ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } } 
public static synchronized int getDecodedDataLength ( byte [ ] base64Data ) { if ( base64Data == null ) { return - 1 ; } if ( base64Data . length == 0 ) { return 0 ; } byte [ ] decodedData = null ; if ( ( decodedData = decode ( base64Data ) ) == null ) { return - 1 ; } return decodedData . length ; } 
private static void mergeSort ( int [ ] a , int [ ] tmpArray , int left , int right ) { if ( left < right ) { int center = ( left + right ) / 2 ; mergeSort ( a , tmpArray , left , center ) ; mergeSort ( a , tmpArray , center + 1 , right ) ; merge ( a , tmpArray , left , center + 1 , right ) ; } } 
public void setDate ( int parameterIndex , java . sql . Date x ) throws java . sql . SQLException { setDate ( parameterIndex , x , null ) ; } 
public static void setCurrent ( ArrayList < Object > sel , MyIdentitiesTree tree , IdentityBranch ib ) { MyIdentitiesModel model = ( MyIdentitiesModel ) tree . getModel ( ) ; Identity newID = new Identity ( ) ; newID . globalOrgID = Util . getString ( sel . get ( 0 ) ) ; newID . globalID = Util . getString ( sel . get ( 1 ) ) ; newID . identity_id = Util . getString ( sel . get ( 2 ) ) ; newID . authorship_lang = Util . getString ( sel . get ( 3 ) ) ; newID . authorship_charset = Util . getString ( sel . get ( 4 ) ) ; if ( Identity . current_id_branch == ib ) return ; if ( Identity . current_id_branch != null ) { IdentityBranch oib = ( IdentityBranch ) Identity . current_id_branch ; Identity . current_id_branch = null ; model . fireTreeNodesChanged ( new TreeModelEvent ( tree , new Object [ ] { model . root } , new int [ ] { model . root . getIndexOfChild ( oib ) } , new Object [ ] { oib } ) ) ; } Identity . current_id_branch = ib ; Orgs ao = GUI_Swing . orgs ; if ( ( newID . identity_id != null ) && ( ao != null ) ) { try { long id = new Integer ( newID . identity_id ) . longValue ( ) ; ao . setCurrent ( id ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } Identity . setCurrentIdentity ( newID ) ; } 
public void setQName ( int index , String qName ) { if ( index >= 0 && index < length ) { data [ index * 5 + 2 ] = qName ; } else { badIndex ( index ) ; } } 
public String namespace ( String name , boolean attribute ) { int colon = name . indexOf ( ':' ) ; if ( colon == - 1 ) { return attribute ? "" : theSchema . getURI ( ) ; } String prefix = name . substring ( 0 , colon ) ; if ( prefix . equals ( "xml" ) ) { return "http://www.w3.org/XML/1998/namespace" ; } else { return ( "urn:x-prefix:" + prefix ) . intern ( ) ; } } 
private String getPath ( File base , File file ) { String absoluteBasePath = base . getAbsolutePath ( ) ; int beginIndex = absoluteBasePath . length ( ) ; if ( ! absoluteBasePath . endsWith ( File . separator ) ) { beginIndex ++ ; } return file . getAbsolutePath ( ) . substring ( beginIndex ) ; } 
public void setRequestURI ( final String requestURI ) { this . requestURI = requestURI ; hashCodeValue = requestURI . toLowerCase ( Locale . US ) . hashCode ( ) ; } 
protected void removeMapping ( HashEntry entry , int hashIndex , HashEntry previous ) { modCount ++ ; removeEntry ( entry , hashIndex , previous ) ; size -- ; destroyEntry ( entry ) ; } 
@ Override public int hashCode ( ) { int hash = 0 ; if ( name != null ) { hash += name . hashCode ( ) ; } if ( scope != null ) { hash += scope . hashCode ( ) ; } return hash ; } 
public static List < X509Certificate > getSigners ( URL odfUrl ) throws IOException , ParserConfigurationException , SAXException , MarshalException , XMLSignatureException { List < X509Certificate > signers = new LinkedList < X509Certificate > ( ) ; if ( null == odfUrl ) { throw new IllegalArgumentException ( "odfUrl-is-null" ) ; } ZipInputStream odfZipInputStream = new ZipInputStream ( odfUrl . openStream ( ) ) ; ZipEntry zipEntry ; while ( null != ( zipEntry = odfZipInputStream . getNextEntry ( ) ) ) { if ( ODFUtil . isSignatureFile ( zipEntry ) ) { Document documentSignatures = ODFUtil . loadDocument ( odfZipInputStream ) ; NodeList signatureNodeList = documentSignatures . getElementsByTagNameNS ( XMLSignature . XMLNS , "Signature" ) ; for ( int idx = 0 ; idx < signatureNodeList . getLength ( ) ; idx ++ ) { Node signatureNode = signatureNodeList . item ( idx ) ; X509Certificate signer = getVerifiedSignatureSigner ( odfUrl , signatureNode ) ; if ( null == signer ) { LOG . debug ( "JSR105-says-invalid-signature" ) ; } else { signers . add ( signer ) ; } } return signers ; } } LOG . debug ( "no-signature-file-present" ) ; return signers ; } 
public static byte [ ] getBytes ( String s ) { if ( s == null ) return null ; else { try { return s . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException ueex ) { throw new UndeclaredThrowableException ( ueex ) ; } } } 
public static mr . reviews . fsstruct . avro . model . ReviewKeyAvro . Builder newBuilder ( mr . reviews . fsstruct . avro . model . ReviewKeyAvro other ) { return new mr . reviews . fsstruct . avro . model . ReviewKeyAvro . Builder ( other ) ; } 
static private String format ( ResourceBundle rb , String key , Object [ ] objects ) { String msg = "" ; if ( key != null ) { msg = key ; if ( rb != null ) { try { msg = rb . getString ( key ) ; return MessageFormat . format ( msg , objects ) ; } catch ( Exception e ) { } } } for ( Object obj : objects ) { msg += ",-" + obj . toString ( ) ; } return msg ; } 
@ XmlElementDecl ( namespace = "http://www.xbrl.org/tw/fr/gaap/tw-gaap-ci-2010-03-31" , name = "InstallmentAccountsReceivable" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < MonetaryItemType > createInstallmentAccountsReceivable ( MonetaryItemType value ) { return new JAXBElement < MonetaryItemType > ( _InstallmentAccountsReceivable_QNAME , MonetaryItemType . class , null , value ) ; } 
public static Option filesNotMatching ( ) { return new Option ( OptionTypes . STANDARD_GREP_OPTION , "-L" ) ; } 
public static void setExecutable ( JobConf conf , String executable ) { conf . set ( "hadoop.pipes.executable" , executable ) ; } 
protected Map < String , Collection < String >> reverseAttributeMap ( Map < String , String > toReverse ) { Map < String , Collection < String >> reversed = new HashMap < String , Collection < String >> ( ) ; for ( Map . Entry < String , String > entry : toReverse . entrySet ( ) ) { Collection < String > logicalAttrNames = reversed . get ( entry . getValue ( ) ) ; String logicalAttrName = entry . getKey ( ) ; String physicalAttrName = entry . getValue ( ) ; if ( logicalAttrNames == null ) { logicalAttrNames = new ArrayList < String > ( 1 ) ; logicalAttrNames . add ( logicalAttrName ) ; reversed . put ( physicalAttrName , logicalAttrNames ) ; } else { logicalAttrNames . add ( logicalAttrName ) ; } } return reversed ; } 
public void setOptions ( String [ ] options ) throws Exception { String seed = Utils . getOption ( 'S' , options ) ; if ( seed . length ( ) != 0 ) { setSeed ( Integer . parseInt ( seed ) ) ; } else { setSeed ( 1 ) ; } super . setOptions ( options ) ; } 
private void writeStartElement ( java . lang . String prefix , java . lang . String namespace , java . lang . String localPart , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String writerPrefix = xmlWriter . getPrefix ( namespace ) ; if ( writerPrefix != null ) { xmlWriter . writeStartElement ( namespace , localPart ) ; } else { if ( namespace . length ( ) == 0 ) { prefix = "" ; } else if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; } xmlWriter . writeStartElement ( prefix , localPart , namespace ) ; xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } } 
public void removeTreeModelListener ( TreeModelListener l ) { listenerList . remove ( TreeModelListener . class , l ) ; } 
public void log ( String string ) { Calendar time = Calendar . getInstance ( ) ; try { log . write ( "[" + df . format ( time . getTime ( ) ) + "]-" + string + "-" ) ; log . flush ( ) ; } catch ( IOException e ) { System . err . println ( "Error-while-writing-to-log-file." ) ; e . printStackTrace ( ) ; } } 
public static final java . text . DateFormat getTimeFormat ( Context context ) { boolean b24 = is24HourFormat ( context ) ; int res ; if ( b24 ) { res = R . string . twenty_four_hour_time_format ; } else { res = R . string . twelve_hour_time_format ; } return new java . text . SimpleDateFormat ( context . getString ( res ) ) ; } 
public File chooseForRead ( ) { File result ; if ( mReal . exists ( ) ) { result = mReal ; if ( mTemp . exists ( ) ) { mTemp . delete ( ) ; } } else if ( mTemp . exists ( ) ) { result = mTemp ; mTemp . renameTo ( mReal ) ; } else { return mReal ; } return result ; } 
public Image getImage ( int index ) { Frame frame = ( Frame ) frames . get ( index ) ; return frame . image ; } 
public static void main ( String [ ] aaarArgs ) { FlashDriveRefreshHelper laFDRH = new FlashDriveRefreshHelper ( new Vector ( ) , null ) ; Thread laThread = new Thread ( laFDRH , THREAD_NAME ) ; laThread . start ( ) ; } 
@ Deprecated public int getMinutes ( ) { return new GregorianCalendar ( milliseconds ) . get ( Calendar . MINUTE ) ; } 
public Object getColumn ( String rowName ) { return theCols . get ( rowName ) ; } 
protected int weight ( Node n ) { return n . isConcrete ( ) ? 0 : n . equals ( Node . ANY ) ? 5 : bound . contains ( n ) ? 1 : 4 ; } 
public int quantityDropped ( Random p_149745_1_ ) { return this == Blocks . lapis_ore ? 4 + p_149745_1_ . nextInt ( 5 ) : 1 ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public void setDaemon ( boolean daemon ) { checkRunning ( false ) ; printWithThread ( "setDaemon(" + daemon + ")" ) ; serverProperties . setProperty ( ServerProperties . sc_key_daemon , daemon ) ; } 
protected int getAmountFull ( Insets b , int width , int height ) { int amountFull = 0 ; BoundedRangeModel model = progressBar . getModel ( ) ; if ( ( model . getMaximum ( ) - model . getMinimum ( ) ) != 0 ) { if ( progressBar . getOrientation ( ) == JProgressBar . HORIZONTAL ) { amountFull = ( int ) Math . round ( width * progressBar . getPercentComplete ( ) ) ; } else { amountFull = ( int ) Math . round ( height * progressBar . getPercentComplete ( ) ) ; } } return amountFull ; } 
public String toStringUtf8 ( ) { try { return new String ( bytes , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( "UTF-8-not-supported?" , e ) ; } } 
public void addWorker ( IWorker worker ) throws DataAccessException { PreparedStatement prep = null ; Connection connection = null ; try { connection = getConnection ( ) ; prep = connection . prepareStatement ( OracleDataAccessorConst . ADD_WORKER ) ; prep . setString ( 1 , worker . getFirstName ( ) ) ; prep . setString ( 2 , worker . getLastName ( ) ) ; if ( worker . getManagerID ( ) != null ) { prep . setBigDecimal ( 3 , new BigDecimal ( worker . getManagerID ( ) ) ) ; } else { prep . setNull ( 3 , Types . NUMERIC ) ; } prep . setBigDecimal ( 4 , new BigDecimal ( worker . getDepartmentID ( ) ) ) ; prep . setBigDecimal ( 5 , new BigDecimal ( worker . getJobID ( ) ) ) ; prep . setBigDecimal ( 6 , new BigDecimal ( worker . getOfficeID ( ) ) ) ; prep . setDouble ( 7 , worker . getSalegrade ( ) ) ; prep . executeUpdate ( ) ; connection . commit ( ) ; } catch ( SQLException e ) { log . error ( "addWorker-sql-error" , e ) ; try { connection . rollback ( ) ; } catch ( SQLException e1 ) { log . error ( "addWorker-sql-error" , e ) ; } throw new DataAccessException ( "addWorker-Dept-sql-error" , e ) ; } finally { resClean ( connection , prep , null ) ; } } 
private static int blendColors ( int color1 , int color2 , float ratio ) { final float inverseRation = 1f - ratio ; float r = ( Color . red ( color1 ) * ratio ) + ( Color . red ( color2 ) * inverseRation ) ; float g = ( Color . green ( color1 ) * ratio ) + ( Color . green ( color2 ) * inverseRation ) ; float b = ( Color . blue ( color1 ) * ratio ) + ( Color . blue ( color2 ) * inverseRation ) ; return Color . rgb ( ( int ) r , ( int ) g , ( int ) b ) ; } 
public void getStatistics ( PrintWriter out ) { out . println ( "<h2>DOM-cache-statistics</h2><center><table-border="2">" + "<tr><td><b>Document-URI</b></td>" + "<td><center><b>Build-time</b></center></td>" + "<td><center><b>Access-count</b></center></td>" + "<td><center><b>Last-accessed</b></center></td>" + "<td><center><b>Last-modified</b></center></td></tr>" ) ; for ( int i = 0 ; i < _count ; i ++ ) { CachedDocument doc = ( CachedDocument ) _references . get ( _URIs [ i ] ) ; out . print ( "<tr><td><a-href="" + _URIs [ i ] + "">" + "<font-size=-1>" + _URIs [ i ] + "</font></a></td>" ) ; out . print ( "<td><center>" + doc . getLatency ( ) + "ms</center></td>" ) ; out . print ( "<td><center>" + doc . getAccessCount ( ) + "</center></td>" ) ; out . print ( "<td><center>" + ( new Date ( doc . getLastReferenced ( ) ) ) + "</center></td>" ) ; out . print ( "<td><center>" + ( new Date ( doc . getLastModified ( ) ) ) + "</center></td>" ) ; out . println ( "</tr>" ) ; } out . println ( "</table></center>" ) ; } 
public void testCharAt ( ) { assertEquals ( new StringBuffer ( "abc" ) . charAt ( 1 ) , 'b' ) ; } 
public static String marshallJAXBObject ( String namespace , Object o ) throws JAXBException { return marshallJAXBObject ( namespace , o , true ) ; } 
public void addTable ( String tagString , ByteBuffer data ) { tables . put ( tagString , data ) ; } 
@ Override public boolean onOptionsItemSelected ( final MenuItem item ) { int id = item . getItemId ( ) ; if ( id == R . id . action_settings ) { return true ; } return super . onOptionsItemSelected ( item ) ; } 
protected void checkSwallowInput ( ) { Context context = getContext ( ) ; if ( context != null && ! context . getSwallowAbortedUploads ( ) ) { coyoteRequest . action ( ActionCode . DISABLE_SWALLOW_INPUT , null ) ; } } 
@ Override public long skip ( long charCount ) throws IOException { if ( charCount < 0 ) { throw new IllegalArgumentException ( "charCount-<-0:-" + charCount ) ; } synchronized ( lock ) { checkNotClosed ( ) ; if ( end - pos >= charCount ) { pos += charCount ; return charCount ; } long read = end - pos ; pos = end ; while ( read < charCount ) { if ( fillBuf ( ) == - 1 ) { return read ; } if ( end - pos >= charCount - read ) { pos += charCount - read ; return charCount ; } read += ( end - pos ) ; pos = end ; } return charCount ; } } 
public Cluster createCluster ( ) { return new Cluster ( ) ; } 
public static boolean areTwoBinaryFilesEqual ( File fileA , File fileB ) throws IOException { if ( fileA . length ( ) != fileB . length ( ) ) return false ; InputStream inputStream1 = new FileInputStream ( fileA ) ; InputStream inputStream2 = new FileInputStream ( fileB ) ; int nextByteFromInput1 , nextByteFromInput2 ; do { nextByteFromInput1 = inputStream1 . read ( ) ; nextByteFromInput2 = inputStream2 . read ( ) ; } while ( nextByteFromInput1 == nextByteFromInput2 && nextByteFromInput1 != - 1 ) ; inputStream1 . close ( ) ; inputStream2 . close ( ) ; return nextByteFromInput1 == - 1 ; } 
static public Value booleanValue ( String name , final boolean currentValue , final String description ) { return new DefaultValue ( name , String . valueOf ( currentValue ) ) { public void showDialog ( ) { JCheckBox checkBox = new JCheckBox ( ) ; checkBox . setSelected ( currentValue ) ; if ( showValueDialog ( checkBox , description ) ) value = String . valueOf ( checkBox . isSelected ( ) ) ; } public Object getObject ( ) { return Boolean . valueOf ( value ) ; } } ; } 
private String formatUnits ( Number value ) { return ( value == null ? null : m_formats . getUnitsDecimalFormat ( ) . format ( value . doubleValue ( ) / 100 ) ) ; } 
public Vector times ( double factor ) { Vector c = new Vector ( N ) ; for ( int i = 0 ; i < N ; i ++ ) c . data [ i ] = factor * data [ i ] ; return c ; } 
public boolean validate ( ValuesProcessingClient values ) { boolean result = false ; try { if ( validator == null ) { validator = factory . create ( className , Validator . class ) ; } values . setParameters ( parameters ) ; result = validator . validate ( values ) ; if ( logger . isLoggable ( Level . FINE ) ) { logger . log ( Level . FINE , "Validation-" + ( result ? "OK" : "FAILED" ) + "-using-" + validator . getClass ( ) . getSimpleName ( ) ) ; } } catch ( Throwable exception ) { logger . log ( Level . WARNING , "Validation-using-" + className + "-failed:-" + exception . getMessage ( ) , exception ) ; } return result ; } 
protected void printViewItens ( ArrayList < Node > listCurrentNodes ) { int size = listCurrentNodes . size ( ) ; Log . d ( LT , "---------------------List-State------------------------------" ) ; if ( size > 0 ) for ( int i = 0 ; i < size ; i ++ ) { Log . d ( LT , listCurrentNodes . get ( i ) . toString ( ) ) ; } } 
public static int copy ( InputStream input , OutputStream output ) throws IOException { byte [ ] buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; int count = 0 ; int n = 0 ; while ( - 1 != ( n = input . read ( buffer ) ) ) { output . write ( buffer , 0 , n ) ; count += n ; } return count ; } 
public void add ( MutableTreeNode newChild ) { if ( newChild != null && newChild . getParent ( ) == this ) insert ( newChild , getChildCount ( ) - 1 ) ; else insert ( newChild , getChildCount ( ) ) ; } 
private boolean hasTag ( String version ) { for ( final String string : Updater . NO_UPDATE_TAG ) { if ( version . contains ( string ) ) { return true ; } } return false ; } 
@ XmlElementDecl ( namespace = "http://www.nltaxonomie.nl/8.0/basis/bd/items/bd-bedrijven" , name = "EnvironmentalBusinessAssetsResidualValueFiscal" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < MonetaryNoDecimalsItemType > createEnvironmentalBusinessAssetsResidualValueFiscal ( MonetaryNoDecimalsItemType value ) { return new JAXBElement < MonetaryNoDecimalsItemType > ( _EnvironmentalBusinessAssetsResidualValueFiscal_QNAME , MonetaryNoDecimalsItemType . class , null , value ) ; } 
public void setSamples ( int x , int y , int w , int h , int b , int iArray [ ] , DataBuffer data ) { if ( ( x < 0 ) || ( y < 0 ) || ( x + w > width ) || ( y + h > height ) ) { throw new ArrayIndexOutOfBoundsException ( "Coordinate-out-of-bounds!" ) ; } int lineOffset = y * scanlineStride + x + bandOffsets [ b ] ; int srcOffset = 0 ; int bank = bankIndices [ b ] ; for ( int i = 0 ; i < h ; i ++ ) { int sampleOffset = lineOffset ; for ( int j = 0 ; j < w ; j ++ ) { data . setElem ( bank , sampleOffset ++ , iArray [ srcOffset ++ ] ) ; } lineOffset += scanlineStride ; } } 
@ SuppressWarnings ( "unchecked" ) public E poll ( long time , TimeUnit unit ) throws InterruptedException { E e = null ; long nanos = unit . toNanos ( time ) ; _headLock . lockInterruptibly ( ) ; try { try { while ( _size . get ( ) == 0 ) { if ( nanos <= 0 ) return null ; nanos = _notEmpty . awaitNanos ( nanos ) ; } } catch ( InterruptedException ie ) { _notEmpty . signal ( ) ; throw ie ; } e = ( E ) _elements [ _head ] ; _elements [ _head ] = null ; _head = ( _head + 1 ) % _capacity ; if ( _size . decrementAndGet ( ) > 0 ) _notEmpty . signal ( ) ; } finally { _headLock . unlock ( ) ; } return e ; } 
private void startDelayedFinish ( ) { mHandler . sendEmptyMessageDelayed ( EVENT_DELAYED_FINISH , DELAYED_FINISH_TIME ) ; } 
@ Deprecated public static String encode ( String s ) { StringBuilder buf = new StringBuilder ( s . length ( ) + 16 ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; if ( ( ch >= 'a' && ch <= 'z' ) || ( ch >= 'A' && ch <= 'Z' ) || ( ch >= '0' && ch <= '9' ) || ".-*_" . indexOf ( ch ) > - 1 ) { buf . append ( ch ) ; } else if ( ch == '-' ) { buf . append ( '+' ) ; } else { byte [ ] bytes = new String ( new char [ ] { ch } ) . getBytes ( ) ; for ( int j = 0 ; j < bytes . length ; j ++ ) { buf . append ( '%' ) ; buf . append ( digits . charAt ( ( bytes [ j ] & 0xf0 ) >> 4 ) ) ; buf . append ( digits . charAt ( bytes [ j ] & 0xf ) ) ; } } } return buf . toString ( ) ; } 
@ XmlElementDecl ( namespace = "http://sessionBeans/" , name = "shareFile" ) public JAXBElement < ShareFile > createShareFile ( ShareFile value ) { return new JAXBElement < ShareFile > ( _ShareFile_QNAME , ShareFile . class , null , value ) ; } 
public void prompt ( ) { if ( promptOnError ) { System . err . println ( getLocalizedString ( "resume.abort" ) ) ; char ch ; try { while ( true ) { switch ( System . in . read ( ) ) { case 'a' : case 'A' : System . exit ( - 1 ) ; return ; case 'r' : case 'R' : return ; case 'x' : case 'X' : throw new AssertionError ( "user-abort" ) ; default : } } } catch ( IOException e ) { } } } 
public int getRouteCount ( ) { return sStatic . mRoutes . size ( ) ; } 
static public void setMaxDepth ( int maxDepth ) { Stack stack = getCurrentStack ( ) ; if ( stack != null && maxDepth < stack . size ( ) ) stack . setSize ( maxDepth ) ; } 
@ Override public Enumeration < String > enumerateMeasures ( ) { Vector < String > newVector = new Vector < String > ( ) ; if ( m_SplitEvaluator instanceof AdditionalMeasureProducer ) { Enumeration < String > en = ( ( AdditionalMeasureProducer ) m_SplitEvaluator ) . enumerateMeasures ( ) ; while ( en . hasMoreElements ( ) ) { String mname = en . nextElement ( ) ; newVector . add ( mname ) ; } } return newVector . elements ( ) ; } 
public Set < String > getParameterSet ( ) { return mEntries . keySet ( ) ; } 
List < Class < ? >> lookupParameterTypes ( ) { List < Class < ? >> parameterTypes = Arrays . asList ( writeMethod . getParameterTypes ( ) ) ; return parameterTypes . subList ( 2 , parameterTypes . size ( ) ) ; } 
@ Override public Object acceptVisitor ( final Visitor visitor ) { return visitor . visit ( this ) ; } 
public String readAll ( ) { if ( ! scanner . hasNextLine ( ) ) return "" ; String result = scanner . useDelimiter ( EVERYTHING_PATTERN ) . next ( ) ; scanner . useDelimiter ( WHITESPACE_PATTERN ) ; return result ; } 
protected File getTemporaryFile ( Context context ) { assert ( context != null ) ; try { return File . createTempFile ( "temp_" , "_handled" , context . getCacheDir ( ) ) ; } catch ( Throwable t ) { Log . e ( LOG_TAG , "Cannot-create-temporary-file" , t ) ; } return null ; } 
void deleteFromHeaderList ( int item , Comparator < Integer > itemComparator ) { int index = Collections . binarySearch ( headerList , item , itemComparator ) ; headerList . remove ( index ) ; } 
public InvocationConstraints getUnfulfilledConstraints ( ) { logger . entering ( getClass ( ) . getName ( ) , "getUnfulfilledConstraints" ) ; if ( unfulfilledConstraintsException != null ) { if ( unfulfilledConstraintsException instanceof RuntimeException ) { throw ( RuntimeException ) unfulfilledConstraintsException ; } else if ( unfulfilledConstraintsException instanceof Error ) { throw ( Error ) unfulfilledConstraintsException ; } else { throw new AssertionError ( ) ; } } return unfulfilledConstraintsReturn ; } 
< T > InvocationHandler getInvocationHandler ( Object instance , String method , Class < T > policyIF ) { Method [ ] policyIFMethods = policyIF . getMethods ( ) ; if ( policyIFMethods . length != 1 ) { throw new PolicyException ( "Policy-interface-" + policyIF . getCanonicalName ( ) + "-must-have-only-one-method" ) ; } try { Class instanceClass = instance . getClass ( ) ; Method delegateMethod = instanceClass . getMethod ( method , ( Class [ ] ) policyIFMethods [ 0 ] . getParameterTypes ( ) ) ; return new JavaMethodInvocationHandler ( this , delegateMethod ) ; } catch ( NoSuchMethodException e ) { throw new PolicyException ( "Method-" + method + "-not-found-or-accessible-on-" + instance . getClass ( ) , e ) ; } } 
public void setName ( String name ) { nameLbl . setText ( name ) ; } 
public final boolean hasQueuedPredecessors ( ) { Node t = tail ; Node h = head ; Node s ; return h != t && ( ( s = h . next ) == null || s . thread != Thread . currentThread ( ) ) ; } 
public static void initServiceInfo ( Provider p ) { StringBuilder sb = new StringBuilder ( 128 ) ; for ( Provider . Service serv : p . getServices ( ) ) { String type = serv . getType ( ) ; if ( secureRandom == null && type . equals ( "SecureRandom" ) ) { secureRandom = serv ; } sb . delete ( 0 , sb . length ( ) ) ; String key = sb . append ( type ) . append ( "." ) . append ( Util . toUpperCase ( serv . getAlgorithm ( ) ) ) . toString ( ) ; if ( ! services . containsKey ( key ) ) { services . put ( key , serv ) ; } for ( String alias : Engine . door . getAliases ( serv ) ) { sb . delete ( 0 , sb . length ( ) ) ; key = sb . append ( type ) . append ( "." ) . append ( Util . toUpperCase ( alias ) ) . toString ( ) ; if ( ! services . containsKey ( key ) ) { services . put ( key , serv ) ; } } } } 
public void cancelDrag ( ) { if ( mDragging ) { if ( mLastDropTarget != null ) { mLastDropTarget . onDragExit ( mDragObject ) ; } mDragObject . deferDragViewCleanupPostAnimation = false ; mDragObject . cancelled = true ; mDragObject . dragComplete = true ; mDragObject . dragSource . onDropCompleted ( null , mDragObject , false , false ) ; } endDrag ( ) ; } 
protected void charactersFlush ( ) { if ( m_textPendingStart >= 0 ) { int length = m_chars . size ( ) - m_textPendingStart ; boolean doStrip = false ; if ( getShouldStripWhitespace ( ) ) { doStrip = m_chars . isWhitespace ( m_textPendingStart , length ) ; } if ( doStrip ) { m_chars . setLength ( m_textPendingStart ) ; } else { if ( length > 0 ) { int exName = m_expandedNameTable . getExpandedTypeID ( DTM . TEXT_NODE ) ; int dataIndex = m_data . size ( ) ; m_previous = addNode ( m_coalescedTextType , exName , m_parents . peek ( ) , m_previous , dataIndex , false ) ; m_data . addElement ( m_textPendingStart ) ; m_data . addElement ( length ) ; } } m_textPendingStart = - 1 ; m_textType = m_coalescedTextType = DTM . TEXT_NODE ; } } 
@ Override public boolean addAll ( Collection < ? extends E > collection ) { Object [ ] newPart = collection . toArray ( ) ; int newPartSize = newPart . length ; if ( newPartSize == 0 ) { return false ; } Object [ ] a = array ; int s = size ; int newSize = s + newPartSize ; if ( newSize > a . length ) { int newCapacity = newCapacity ( newSize - 1 ) ; Object [ ] newArray = new Object [ newCapacity ] ; System . arraycopy ( a , 0 , newArray , 0 , s ) ; array = a = newArray ; } System . arraycopy ( newPart , 0 , a , s , newPartSize ) ; size = newSize ; modCount ++ ; return true ; } 
public final void popCurrentNodeAndExpression ( ) { m_currentNodes . quickPop ( 1 ) ; m_currentExpressionNodes . quickPop ( 1 ) ; } 
public synchronized int getConnectionCount ( ) { return connections . size ( ) ; } 
public static File getContainingDirectory ( File file ) throws NullPointerException { File result = null ; if ( file . isFile ( ) ) { result = new File ( file . getAbsoluteFile ( ) . getParent ( ) ) ; } else { result = file ; } return result ; } 
public int hashCode ( ) { int code = super . hashCode ( ) ; if ( fEntityName != null ) { code += fEntityName . hashCode ( ) ; } return code ; } 
public boolean containsKey ( Object key ) { Iterator entries = entrySet ( ) . iterator ( ) ; int pos = size ( ) ; while ( -- pos >= 0 ) if ( equals ( key , ( ( Map . Entry ) entries . next ( ) ) . getKey ( ) ) ) return true ; return false ; } 
private void replaceTop ( JsonScope newTop ) { stack . set ( stack . size ( ) - 1 , newTop ) ; } 
public void finishConstruction ( ) { if ( ! parents . isEmpty ( ) ) { throw new UnsupportedOperationException ( "computeDepth()-can-only-be-invoked-on-root-plugin" ) ; } int currentDepth = 0 ; List < PluginInfo > pluginsAtThisDepth = new ArrayList < PluginInfo > ( ) ; List < PluginInfo > pluginsAtNextDepth = new ArrayList < PluginInfo > ( ) ; pluginsAtThisDepth . add ( this ) ; do { for ( PluginInfo plugin : pluginsAtThisDepth ) { if ( currentDepth < plugin . depth ) { plugin . depth = currentDepth ; for ( ChildInfo child : plugin . getChildren ( ) ) { for ( PluginInfo childPlugin : child . getAllowedNodes ( ) ) { pluginsAtNextDepth . add ( childPlugin ) ; } } } } currentDepth ++ ; List < PluginInfo > temp = pluginsAtThisDepth ; pluginsAtThisDepth = pluginsAtNextDepth ; pluginsAtNextDepth = temp ; pluginsAtNextDepth . clear ( ) ; } while ( ! pluginsAtThisDepth . isEmpty ( ) ) ; } 
public List < ErrorDetail > getDetail ( ) { if ( detail == null ) { detail = new ArrayList < ErrorDetail > ( ) ; } return this . detail ; } 
public List < String > getReturnval ( ) { if ( returnval == null ) { returnval = new ArrayList < String > ( ) ; } return this . returnval ; } 
public List < CommentType > getComment ( ) { if ( comment == null ) { comment = new ArrayList < CommentType > ( ) ; } return this . comment ; } 
public URLStreamHandler createURLStreamHandler ( final String protocol ) { if ( ! protocol . equals ( "http" ) && ! protocol . equals ( "https" ) ) return null ; return new URLStreamHandler ( ) { @ Override protected URLConnection openConnection ( URL url ) { return open ( url ) ; } @ Override protected URLConnection openConnection ( URL url , Proxy proxy ) { return open ( url , proxy ) ; } @ Override protected int getDefaultPort ( ) { if ( protocol . equals ( "http" ) ) return 80 ; if ( protocol . equals ( "https" ) ) return 443 ; throw new AssertionError ( ) ; } } ; } 
public void close ( ) throws IOException { br . close ( ) ; } 
public void close ( ) throws IOException { isClosed = true ; impl . close ( ) ; } 
public Type readType ( ) throws IOException { int code = - 1 ; try { code = in . readUnsignedByte ( ) ; } catch ( EOFException eof ) { return null ; } for ( Type type : Type . values ( ) ) { if ( type . code == code ) { return type ; } } return null ; } 
public < A extends Appendable > A appendTo ( A appendable , Iterable < ? > parts ) throws IOException { checkNotNull ( appendable ) ; Iterator < ? > iterator = parts . iterator ( ) ; if ( iterator . hasNext ( ) ) { appendable . append ( toString ( iterator . next ( ) ) ) ; while ( iterator . hasNext ( ) ) { appendable . append ( separator ) ; appendable . append ( toString ( iterator . next ( ) ) ) ; } } return appendable ; } 
public void removeIIOReadProgressListener ( IIOReadProgressListener listener ) { if ( listener == null || progressListeners == null ) { return ; } progressListeners = removeFromList ( progressListeners , listener ) ; } 
public static < T > Collection < T > synchronizedCollection ( Collection < T > collection ) { if ( collection == null ) { throw new NullPointerException ( ) ; } return new SynchronizedCollection < T > ( collection ) ; } 
public Builder toBuilder ( ) { return new Builder ( this ) ; } 
void cancel ( ) { mActive = STATE_CANCEL_REQUESTED ; closeConnection ( ) ; if ( HttpLog . LOGV ) HttpLog . v ( "Connection.cancel():-connection-closed-" + mHost ) ; } 
public static InputStream toInputStream ( String input , String encoding ) throws IOException { byte [ ] bytes = encoding != null ? input . getBytes ( encoding ) : input . getBytes ( ) ; return new ByteArrayInputStream ( bytes ) ; } 
public ConversationFactory addConversationAbandonedListener ( ConversationAbandonedListener listener ) { abandonedListeners . add ( listener ) ; return this ; } 
private Class getPrimativeClass ( Object obj ) { if ( obj instanceof XPath ) return XPath . class ; Class cl = obj . getClass ( ) ; if ( cl == Double . class ) { cl = double . class ; } if ( cl == Float . class ) { cl = float . class ; } else if ( cl == Boolean . class ) { cl = boolean . class ; } else if ( cl == Byte . class ) { cl = byte . class ; } else if ( cl == Character . class ) { cl = char . class ; } else if ( cl == Short . class ) { cl = short . class ; } else if ( cl == Integer . class ) { cl = int . class ; } else if ( cl == Long . class ) { cl = long . class ; } return cl ; } 
public CharSequence convertResultToString ( Object resultValue ) { return resultValue == null ? "" : resultValue . toString ( ) ; } 
private static ArrayList < String [ ] > createCurrentEmulatorLanguageAndCountryCommand ( String serialNumber ) { String languageCommand [ ] ; String countryCommand [ ] ; String sdkPath = SdkUtils . getSdkPath ( ) ; String GET_LANGUAGE_CMD = "getprop-persist.sys.language" ; String GET_COUNTRY_CMD = "getprop-persist.sys.country" ; File f = new File ( sdkPath + DDMSFacade . PLATFORM_TOOLS_FOLDER + File . separator ) ; if ( ! f . exists ( ) ) { StudioLogger . error ( "Language:-Could-not-find-tools-folder-on-" + sdkPath + DDMSFacade . PLATFORM_TOOLS_FOLDER + File . separator ) ; } else { if ( ! f . isDirectory ( ) ) { StudioLogger . error ( "Language:-Invalid-tools-folder-" + sdkPath + DDMSFacade . PLATFORM_TOOLS_FOLDER + File . separator ) ; } } String langCmdTemp [ ] = { sdkPath + DDMSFacade . PLATFORM_TOOLS_FOLDER + File . separator + DDMSFacade . ADB_COMMAND , DDMSFacade . ADB_INSTANCE_PARAMETER , serialNumber , "shell" , GET_LANGUAGE_CMD } ; String countryCmdTemp [ ] = { sdkPath + DDMSFacade . PLATFORM_TOOLS_FOLDER + File . separator + DDMSFacade . ADB_COMMAND , DDMSFacade . ADB_INSTANCE_PARAMETER , serialNumber , "shell" , GET_COUNTRY_CMD } ; languageCommand = langCmdTemp ; countryCommand = countryCmdTemp ; ArrayList < String [ ] > commands = new ArrayList < String [ ] > ( ) ; commands . add ( 0 , languageCommand ) ; commands . add ( 1 , countryCommand ) ; return commands ; } 
public boolean isInstalled ( ) { File rootDirectory = installation . getRootDirectory ( ) ; return rootDirectory == null || ! rootDirectory . exists ( ) || ! rootDirectory . isDirectory ( ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public List < Object > getContent ( ) { if ( content == null ) { content = new ArrayList < Object > ( ) ; } return this . content ; } 
void addInstance ( Instance instance ) { mInstances . add ( instance ) ; } 
public void write ( String fileName ) throws IOException { RandomAccessFile rf = new RandomAccessFile ( fileName , "rw" ) ; FileChannel ch = rf . getChannel ( ) ; int fileLength = 4 * 3 + data . capacity ( ) ; rf . setLength ( fileLength ) ; MappedByteBuffer buffer = ch . map ( FileChannel . MapMode . READ_WRITE , 0 , fileLength ) ; write ( buffer ) ; buffer . force ( ) ; ch . close ( ) ; } 
public String getConfigurationValue ( String key ) { return configuration . get ( key ) ; } 
private static HashMap < String , String > removeSubscribedFeeds ( HashMap < String , String > feeds ) { HashMap < String , String > validFeeds = new HashMap < String , String > ( ) ; Set < String > endpoints = feeds . keySet ( ) ; for ( String endpoint : endpoints ) { try { FeedReference feedRef = FeedReferenceLocalServiceUtil . findByFeedHref ( endpoint ) ; if ( ! feedRef . getPshbSubscribed ( ) ) { validFeeds . put ( endpoint , feeds . get ( endpoint ) ) ; } } catch ( NoSuchFeedReferenceException ne ) { validFeeds . put ( endpoint , feeds . get ( endpoint ) ) ; } catch ( Exception e ) { log . error ( "Error-attempting-to-find-feed-with-endpoint:-" + endpoint ) ; } } return validFeeds ; } 
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; } 
public void removeColumn ( TableColumn column ) { int columnIndex = tableColumns . indexOf ( column ) ; if ( columnIndex != - 1 ) { if ( selectionModel != null ) { selectionModel . removeIndexInterval ( columnIndex , columnIndex ) ; } column . removePropertyChangeListener ( this ) ; tableColumns . removeElementAt ( columnIndex ) ; invalidateWidthCache ( ) ; fireColumnRemoved ( new TableColumnModelEvent ( this , columnIndex , 0 ) ) ; } } 
public Cursor fetchQuickMessage ( long id ) throws SQLException { boolean found = false ; Cursor mCursor = mDb . query ( true , QUICKMESSAGES_DB_TABLE , new String [ ] { KEY_ROWID , KEY_QUICKMESSAGE , KEY_ORDER } , KEY_ROWID + "=" + id , null , null , null , null , null ) ; if ( mCursor != null ) { found = mCursor . moveToFirst ( ) ; } if ( ! found ) { if ( mCursor != null ) { mCursor . close ( ) ; } return null ; } return mCursor ; } 
@ SuppressWarnings ( "boxing" ) public int nextInt ( int radix ) { checkClosed ( ) ; Object obj = cacheHasNextValue ; cacheHasNextValue = null ; if ( obj instanceof Integer ) { findStartIndex = cachehasNextIndex ; return ( Integer ) obj ; } Pattern integerPattern = getIntegerPattern ( radix ) ; String intString = next ( integerPattern ) ; intString = removeLocaleInfo ( intString , DataType . INT ) ; int intValue = 0 ; try { intValue = Integer . parseInt ( intString , radix ) ; } catch ( NumberFormatException e ) { matchSuccessful = false ; recoverPreviousStatus ( ) ; throw new InputMismatchException ( ) ; } return intValue ; } 
public void set ( int index , String value ) throws IOException { Writer writer = null ; try { writer = new OutputStreamWriter ( newOutputStream ( index ) , Util . UTF_8 ) ; writer . write ( value ) ; } finally { Util . closeQuietly ( writer ) ; } } 
private void writeStartElement ( java . lang . String prefix , java . lang . String namespace , java . lang . String localPart , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String writerPrefix = xmlWriter . getPrefix ( namespace ) ; if ( writerPrefix != null ) { xmlWriter . writeStartElement ( namespace , localPart ) ; } else { if ( namespace . length ( ) == 0 ) { prefix = "" ; } else if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; } xmlWriter . writeStartElement ( prefix , localPart , namespace ) ; xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } } 
public static Map < String , String > getQueryMap ( String query ) throws UnsupportedEncodingException { String [ ] params = query . split ( "&" ) ; Map < String , String > map = new HashMap < String , String > ( ) ; for ( String param : params ) { String [ ] keyValue = param . split ( "=" ) ; map . put ( keyValue [ 0 ] , URLDecoder . decode ( keyValue [ 1 ] , "UTF-8" ) ) ; } return map ; } 
String getFile ( final int fileid ) { return ( String ) sourceFiles . get ( fileid ) ; } 
@ Override public InetAddress getInetAddress ( ) { return ( delegate == null ) ? super . getInetAddress ( ) : delegate . getInetAddress ( ) ; } 
public static List < Class < ? >> discoverClasses ( String packageName ) { List < Class < ? >> ret = new ArrayList < Class < ? >> ( ) ; ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { Enumeration < URL > resources = classLoader . getResources ( toPath ( packageName ) ) ; List < File > dirs = new ArrayList < File > ( ) ; List < JarInputStream > jars = new ArrayList < JarInputStream > ( ) ; while ( resources . hasMoreElements ( ) ) { URL resource = resources . nextElement ( ) ; if ( isJar ( resource ) ) { jars . add ( new JarInputStream ( new FileInputStream ( URLDecoder . decode ( getJarName ( resource ) , "UTF-8" ) ) ) ) ; } else if ( containsJar ( resource ) ) { jars . add ( getContainingResource ( classLoader , resource ) ) ; } else { dirs . add ( new File ( URLDecoder . decode ( resource . getFile ( ) , "UTF-8" ) ) ) ; } } walkJars ( ret , packageName , jars ) ; walkDirs ( ret , packageName , dirs ) ; } catch ( Exception e ) { ret = Collections . emptyList ( ) ; } return ret ; } 
public static void fill ( int [ ] array , int start , int end , int value ) { checkFillBounds ( array . length , start , end ) ; for ( int i = start ; i < end ; i ++ ) { array [ i ] = value ; } } 
public String get_string ( ) throws TypeMismatch , InvalidValue { throw new MARSHAL ( NOT_APPLICABLE ) ; } 
public static String [ ] splitNoCompress ( String src , String delimiter ) { if ( src == null || delimiter == null ) { return null ; } int maxparts = ( src . length ( ) / delimiter . length ( ) ) + 2 ; int [ ] positions = new int [ maxparts ] ; int dellen = delimiter . length ( ) ; int i , j = 0 ; int count = 0 ; positions [ 0 ] = - dellen ; while ( ( i = src . indexOf ( delimiter , j ) ) != - 1 ) { count ++ ; positions [ count ] = i ; j = i + dellen ; } count ++ ; positions [ count ] = src . length ( ) ; String [ ] result = new String [ count ] ; for ( i = 0 ; i < count ; i ++ ) { result [ i ] = src . substring ( positions [ i ] + dellen , positions [ i + 1 ] ) ; } return result ; } 
public void addFileset ( FileSet set ) { filesets . add ( set ) ; } 
public static double parseDouble ( String lexicalXSDDouble ) { if ( theConverter == null ) initConverter ( ) ; return theConverter . parseDouble ( lexicalXSDDouble ) ; } 
public static String hideHTMLTags ( String htmlText ) { StringBuffer sb = new StringBuffer ( htmlText ) ; int i = 0 ; while ( i < sb . length ( ) ) { if ( sb . charAt ( i ) == '<' ) { sb . setCharAt ( i , 'l' ) ; sb . insert ( i + 1 , "EsS_tHaN" ) ; } else if ( sb . charAt ( i ) == '&' ) { sb . setCharAt ( i , 'a' ) ; sb . insert ( i + 1 , "Nd_cHaR" ) ; } else if ( sb . charAt ( i ) == '"' ) { sb . setCharAt ( i , 'q' ) ; sb . insert ( i + 1 , "uote_cHaR" ) ; } i ++ ; } return sb . toString ( ) ; } 
public boolean hasNext ( ) { return spot . before ( endFinal ) ; } 
public Enumeration listOptions ( ) { Vector result = enumToVector ( super . listOptions ( ) ) ; result . addElement ( new Option ( "-The-number-of-attributes-(default-" + defaultNumAttributes ( ) + ")." , "a" , 1 , "-a-<num>" ) ) ; result . addElement ( new Option ( "-The-number-of-classes-(default-" + defaultNumClasses ( ) + ")" , "c" , 1 , "-c-<num>" ) ) ; result . addElement ( new Option ( "-maximum-size-for-rules-(default-" + defaultMaxRuleSize ( ) + ")-" , "R" , 1 , "-R-<num>" ) ) ; result . addElement ( new Option ( "-minimum-size-for-rules-(default-" + defaultMinRuleSize ( ) + ")-" , "M" , 1 , "-M-<num>" ) ) ; result . addElement ( new Option ( "-number-of-irrelevant-attributes-(default-" + defaultNumIrrelevant ( ) + ")" , "I" , 1 , "-I-<num>" ) ) ; result . addElement ( new Option ( "-number-of-numeric-attributes-(default-" + defaultNumNumeric ( ) + ")" , "N" , 1 , "-N" ) ) ; result . addElement ( new Option ( "-switch-on-voting-(default-is-no-voting)" , "V" , 1 , "-V" ) ) ; return result . elements ( ) ; } 
public void create ( String name , PlanPhase p ) { HashMap < String , Object > attrs = new HashMap < String , Object > ( ) ; attrs . put ( "default_phase" , p ) ; attrs . put ( "phase" , p ) ; cache . createObject ( name , attrs ) ; } 
public static double ceil ( double x ) { return Math . ceil ( x ) ; } 
public static boolean startsWith ( String full , String head ) { return full != null && head != null && full . startsWith ( head ) && full . length ( ) > head . length ( ) ; } 
public Selector setRecordOnly ( boolean recordOnly ) { this . recordOnly = recordOnly ; setRecordOnlyIsSet ( true ) ; return this ; } 
public static Quaternion idt ( ) { return new Quaternion ( 0 , 0 , 0 , 1 ) ; } 
private E dequeue ( ) { synchronized ( delegate ) { Iterator < E > it = delegate . iterator ( ) ; E x = it . next ( ) ; it . remove ( ) ; return x ; } } 
public static < T > List < T > getAt ( T [ ] self , Collection indices ) { List < T > answer = new ArrayList < T > ( indices . size ( ) ) ; for ( Object value : indices ) { if ( value instanceof Range ) { answer . addAll ( getAt ( self , ( Range ) value ) ) ; } else if ( value instanceof Collection ) { answer . addAll ( getAt ( self , ( Collection ) value ) ) ; } else { int idx = DefaultTypeTransformation . intUnbox ( value ) ; answer . add ( getAtImpl ( self , idx ) ) ; } } return answer ; } 
public static TypeInfo findTypeInfo ( Class < ? > type ) { Util . checkNull ( type ) ; if ( typeInfos . get ( type ) == null ) { TypeInfo oldTypeInfo = typeInfos . putIfAbsent ( type , TypeInfo . parse ( type ) ) ; if ( oldTypeInfo == null ) { log . info ( "register-TypeInfo-" + typeInfos . get ( type ) ) ; } } return typeInfos . get ( type ) ; } 
public synchronized boolean shouldPostpone ( Route route ) { return failedRoutes . contains ( route ) ; } 
@ Override public void processingInstruction ( String target , String data ) throws SAXException { this . ensureInitialization ( ) ; super . processingInstruction ( target , data ) ; } 
@ Override public boolean connectionAllowed ( String eventName ) { if ( m_listenees . containsKey ( eventName ) ) { return false ; } return true ; } 
private void lineTo ( float x , float y ) { mPath . lineTo ( mLastX = x , mLastY = y ) ; } 
public boolean isUserInAllowedGroup ( JID jid ) { ArrayList < String > allowedGroups = new ArrayList < String > ( ) ; Connection con = null ; PreparedStatement pstmt = null ; ResultSet rs = null ; try { con = DbConnectionManager . getConnection ( ) ; pstmt = con . prepareStatement ( GROUPS_LISTED ) ; pstmt . setString ( 1 , transportType . toString ( ) ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { allowedGroups . add ( rs . getString ( 1 ) ) ; } } catch ( SQLException sqle ) { Log . error ( sqle ) ; } finally { DbConnectionManager . closeConnection ( rs , pstmt , con ) ; } Collection < Group > userGroups = GroupManager . getInstance ( ) . getGroups ( jid ) ; for ( Group g : userGroups ) { if ( allowedGroups . contains ( g . getName ( ) ) ) { return true ; } } return false ; } 
ConstantPool ( DataInput file ) throws IOException , ClassFormatException { int constant_pool_count = file . readUnsignedShort ( ) ; constant_pool = new Constant [ constant_pool_count ] ; for ( int i = 1 ; i < constant_pool_count ; i ++ ) { constant_pool [ i ] = Constant . readConstant ( file ) ; if ( constant_pool [ i ] != null ) { byte tag = constant_pool [ i ] . getTag ( ) ; if ( ( tag == Constants . CONSTANT_Double ) || ( tag == Constants . CONSTANT_Long ) ) { i ++ ; } } } } 
public List < DAOVueTypeClasse > countTypeClasse ( ) { List < DAOVueTypeClasse > listeTypeClasse = new ArrayList < DAOVueTypeClasse > ( ) ; Statement stmt = null ; ResultSet res = null ; ConnexionJDBC instance = ConnexionJDBC . getInstance ( ) ; Connection conn = ( Connection ) instance . getConnection ( ) ; try { stmt = conn . createStatement ( ) ; res = stmt . executeQuery ( "SELECT" + "CASE" + "-WHEN-nom_classe-LIKE-'3%'-THEN-'3'" + "-WHEN-nom_classe-LIKE-'4%'-THEN-'4'" + "-WHEN-nom_classe-LIKE-'5%'-THEN-'5'" + "-WHEN-nom_classe-LIKE-'6%'-THEN-'6'" + "-END-AS-type_classe" + "-,-COUNT(*)-AS-nombre" + "-FROM-classe" + "-GROUP-BY-" + "-CASE" + "-WHEN-nom_classe-LIKE-'3%'-THEN-'3'" + "-WHEN-nom_classe-LIKE-'4%'-THEN-'4'" + "-WHEN-nom_classe-LIKE-'5%'-THEN-'5'" + "-WHEN-nom_classe-LIKE-'6%'-THEN-'6'" + "END);" ) ; while ( res . next ( ) ) { listeTypeClasse . add ( new DAOVueTypeClasse ( res . getString ( "type_classe" ) , res . getInt ( "nombre" ) ) ) ; } } catch ( SQLException e ) { log4j . info ( e . getMessage ( ) , e ) ; } return listeTypeClasse ; } 
public java . util . ArrayList getAllChildren ( ) { java . util . ArrayList list = new java . util . ArrayList ( ) ; list . add ( _expression ) ; list . add ( _postfix_unary_op ) ; return list ; } 
public JoinTypeHolder add ( String associationPath , JoinType type ) { joinTypes . put ( associationPath , type ) ; return this ; } 
public BigInteger min ( BigInteger val ) { return ( compareTo ( val ) < 0 ? this : val ) ; } 
public void addFunctionBean ( CFCFunctionBean bean ) { functionBeans . add ( bean ) ; } 
public synchronized Object remove ( Object key ) { check ( "removeProviderProperty." + name ) ; if ( debug != null ) { debug . println ( "Remove-" + name + "-provider-property-" + key ) ; } return implRemove ( key ) ; } 
public void setFloat ( Object object , float value ) throws IllegalAccessException , IllegalArgumentException { setFField ( object , declaringClass , type , slot , flag , TYPE_FLOAT , value ) ; } 
private ResourceBundle getPropertyFile ( Object o ) { Class < ? > referencedClass = getReferencedClass ( o ) ; return ResourceBundle . getBundle ( referencedClass . getName ( ) , Locale . getDefault ( ) ) ; } 
public JMenuItem add ( String s ) { return add ( new JMenuItem ( s ) ) ; } 
private int externalInterruptibleAwaitDone ( ) throws InterruptedException { int s ; if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; ForkJoinPool . externalHelpJoin ( this ) ; while ( ( s = status ) >= 0 ) { if ( U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ) { synchronized ( this ) { if ( status >= 0 ) wait ( ) ; else notifyAll ( ) ; } } } return s ; } 
public Dimension getTrayIconSize ( ) { return peer . getTrayIconSize ( ) ; } 
private static int processPoly ( Polygon poly , Element element , StringTokenizer tokens ) throws ParsingException { int count = 0 ; while ( tokens . hasMoreTokens ( ) ) { String nextToken = tokens . nextToken ( ) ; if ( nextToken . equals ( "L" ) ) { continue ; } if ( nextToken . equals ( "z" ) ) { break ; } if ( nextToken . equals ( "M" ) ) { continue ; } if ( nextToken . equals ( "C" ) ) { return 0 ; } String tokenX = nextToken ; String tokenY = tokens . nextToken ( ) ; try { float x = Float . parseFloat ( tokenX ) ; float y = Float . parseFloat ( tokenY ) ; poly . addPoint ( x , y ) ; count ++ ; } catch ( NumberFormatException e ) { throw new ParsingException ( element . getAttribute ( "id" ) , "Invalid-token-in-points-list" , e ) ; } } return count ; } 
public MailMessage ( Packet packet ) throws MalformedPacketException { this . packet = packet ; if ( packet . contents . length < headerLength || packet . contents [ 0 ] < 0 || packet . contents [ 0 ] >= portLimit || packet . contents [ 1 ] < 0 || packet . contents [ 1 ] >= portLimit ) throw new MalformedPacketException ( ) ; dstPort = packet . contents [ 0 ] ; srcPort = packet . contents [ 1 ] ; contents = new byte [ packet . contents . length - headerLength ] ; System . arraycopy ( packet . contents , headerLength , contents , 0 , contents . length ) ; } 
public static Object autoConnect ( Object obj , ORB orb , boolean convertToStub ) { if ( obj == null ) { return obj ; } if ( StubAdapter . isStub ( obj ) ) { try { StubAdapter . getDelegate ( obj ) ; } catch ( BAD_OPERATION okay ) { try { StubAdapter . connect ( obj , orb ) ; } catch ( RemoteException e ) { throw wrapper . objectNotConnected ( e , obj . getClass ( ) . getName ( ) ) ; } } return obj ; } if ( obj instanceof Remote ) { Remote remoteObj = ( Remote ) obj ; Tie theTie = Util . getTie ( remoteObj ) ; if ( theTie != null ) { try { theTie . orb ( ) ; } catch ( SystemException okay ) { theTie . orb ( orb ) ; } if ( convertToStub ) { Object result = loadStub ( theTie , null , null , true ) ; if ( result != null ) { return result ; } else { throw wrapper . couldNotLoadStub ( obj . getClass ( ) . getName ( ) ) ; } } else { return StubAdapter . activateTie ( theTie ) ; } } else { throw wrapper . objectNotExported ( obj . getClass ( ) . getName ( ) ) ; } } return obj ; } 
public HttpRequest readTimeout ( final int timeout ) { connection . setReadTimeout ( timeout ) ; return this ; } 
public void accionExit_mouseEntered ( MouseEvent e ) { barraExit . setIcon ( new ImageIcon ( this . getClass ( ) . getResource ( "/keel/GraphInterKeel/resources/imag/menu/exit2.png" ) ) ) ; labelSalir . setVisible ( true ) ; this . setCursor ( Cursor . HAND_CURSOR ) ; } 
public Image getScaledCopy ( float scale ) { init ( ) ; return getScaledCopy ( ( int ) ( width * scale ) , ( int ) ( height * scale ) ) ; } 
public boolean addObject ( LQTObject obj ) { hasNewObject = true ; return objects . add ( obj ) ; } 
private void getResolutionInfo ( ImageReader reader ) throws IOException , TransformException { final Rectangle actualDim = new Rectangle ( 0 , 0 , reader . getWidth ( 0 ) , reader . getHeight ( 0 ) ) ; originalGridRange = new GridEnvelope2D ( actualDim ) ; highestRes = getResolution ( originalEnvelope , actualDim , crs ) ; } 
public List < CashOneDetails > getCashOneDet ( ) { if ( cashOneDet == null ) { cashOneDet = new ArrayList < CashOneDetails > ( ) ; } return this . cashOneDet ; } 
public Object clone ( ) { Reference r = new Reference ( className , classFactory , classFactoryLocation ) ; Enumeration < RefAddr > a = getAll ( ) ; r . addrs = new Vector ( ) ; while ( a . hasMoreElements ( ) ) r . addrs . addElement ( a . nextElement ( ) ) ; return r ; } 
public void setBoolean ( String name , boolean value ) { set ( name , Boolean . toString ( value ) ) ; } 
public Enumeration listOptions ( ) { Vector newVector = new Vector ( ) ; newVector . addElement ( new Option ( "-Percentage-of-weight-mass-to-base-training-on.-" + "-(default-100,-reduce-to-around-90-speed-up)" , "P" , 1 , "-P-<num>" ) ) ; newVector . addElement ( new Option ( "-Use-resampling-for-boosting." , "Q" , 0 , "-Q" ) ) ; Enumeration enu = super . listOptions ( ) ; while ( enu . hasMoreElements ( ) ) { newVector . addElement ( enu . nextElement ( ) ) ; } return newVector . elements ( ) ; } 
TrieNode ( char chr ) { this . character = chr ; this . children = new HashMap < Character , TrieNode < WORD >> ( ) ; this . words = null ; } 
public boolean isExpired ( ) { return this . ttl < System . currentTimeMillis ( ) ; } 
@ XmlElementDecl ( namespace = "http://www.devspringsoftware.com" , name = "DayTimeInterval" ) public JAXBElement < DayTimeIntervalType > createDayTimeInterval ( DayTimeIntervalType value ) { return new JAXBElement < DayTimeIntervalType > ( _DayTimeInterval_QNAME , DayTimeIntervalType . class , null , value ) ; } 
protected String createToken ( String value , int start , int end ) { return value . substring ( start , end ) ; } 
private static boolean validName ( String name ) { if ( name . trim ( ) . equals ( "" ) ) { return false ; } for ( int i = 0 ; i < INVALID_NAME_CHARS . length ; i ++ ) { if ( name . indexOf ( INVALID_NAME_CHARS [ i ] ) >= 0 ) { return false ; } } return true ; } 
public String toSummaryString ( ) { String result = "Selected-values:-" + Utils . joinOptions ( m_BestClassifierOptions ) ; return result + '|n' ; } 
@ Deprecated public void setMinutes ( int minutes ) { getCalendarDate ( ) . setMinutes ( minutes ) ; } 
public void testSerialization ( ) { DialTextAnnotation a1 = new DialTextAnnotation ( "A1" ) ; DialTextAnnotation a2 = null ; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; ObjectOutput out = new ObjectOutputStream ( buffer ) ; out . writeObject ( a1 ) ; out . close ( ) ; ObjectInput in = new ObjectInputStream ( new ByteArrayInputStream ( buffer . toByteArray ( ) ) ) ; a2 = ( DialTextAnnotation ) in . readObject ( ) ; in . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } assertEquals ( a1 , a2 ) ; a1 = new DialTextAnnotation ( "A1" ) ; a1 . setPaint ( new GradientPaint ( 1.0f , 2.0f , Color . red , 3.0f , 4.0f , Color . blue ) ) ; a2 = null ; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; ObjectOutput out = new ObjectOutputStream ( buffer ) ; out . writeObject ( a1 ) ; out . close ( ) ; ObjectInput in = new ObjectInputStream ( new ByteArrayInputStream ( buffer . toByteArray ( ) ) ) ; a2 = ( DialTextAnnotation ) in . readObject ( ) ; in . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } assertEquals ( a1 , a2 ) ; } 
public void subscribeFailed ( final Topic topic ) { Integer count = ( Integer ) failed . get ( topic ) ; if ( count == null ) { count = new Integer ( 0 ) ; } if ( count . intValue ( ) < MAX_FAILED_SUBSCRIPTION ) { count = new Integer ( count . intValue ( ) + 1 ) ; if ( logger . level <= Logger . WARNING ) logger . log ( "DEBUG-::-Subscription-failed-at-" + channel . getLocalId ( ) + "-for-topic-" + topic + "---retrying." ) ; scribe . subscribe ( topic , this ) ; failed . put ( topic , count ) ; } else { TimerTask resubscribeTask = new TimerTask ( ) { public void run ( ) { if ( getParent ( ) == null ) { scribe . subscribe ( topic , Stripe . this ) ; } } } ; scribe . getEnvironment ( ) . getSelectorManager ( ) . getTimer ( ) . schedule ( resubscribeTask , scribe . getEnvironment ( ) . getParameters ( ) . getInt ( "p2p_splitStream_stripe_max_failed_subscription_retry_delay" ) ) ; } } 
private boolean isAlphabet ( int code ) { if ( Character . isLetter ( code ) ) { return true ; } else { return false ; } } 
@ Override public ClassLoader getParentClassLoader ( ) { if ( parentClassLoader != null ) return ( parentClassLoader ) ; if ( server != null ) { return ( server . getParentClassLoader ( ) ) ; } return ( ClassLoader . getSystemClassLoader ( ) ) ; } 
public VarType visit ( NotExpression n , HashMap < String , ClassBinding > symbolTable ) { VarType v = n . f1 . accept ( this , symbolTable ) ; if ( v == null ) return null ; if ( v . type == VariableType . BOOLEAN ) return v ; else return null ; } 
@ Override public boolean equals ( Object that ) { if ( this == that ) { return true ; } if ( that == null || getClass ( ) != that . getClass ( ) ) { return false ; } Spec spec = ( Spec ) that ; if ( ! alignment . equals ( spec . alignment ) ) { return false ; } if ( ! span . equals ( spec . span ) ) { return false ; } return true ; } 
public void putDefaults ( Object [ ] entries ) { for ( int i = 0 ; ( 2 * i + 1 ) < entries . length ; ++ i ) { checkAndPut ( entries [ 2 * i ] , entries [ 2 * i + 1 ] ) ; } firePropertyChange ( "UIDefaults" , null , null ) ; } 
public byte [ ] getValue ( ) { byte [ ] result = new byte [ p . length ] ; System . arraycopy ( p , 0 , result , 0 , p . length ) ; return result ; } 
public ParseException generateParseException ( ) { jj_expentries . clear ( ) ; boolean [ ] la1tokens = new boolean [ 55 ] ; if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 19 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 32 + j ] = true ; } } } } for ( int i = 0 ; i < 55 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . add ( jj_expentry ) ; } } int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = ( int [ ] ) jj_expentries . get ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; } 
public String toExternalForm ( ) { if ( streamHandler == null ) { return "unknown-protocol(" + protocol + ")://" + host + file ; } return streamHandler . toExternalForm ( this ) ; } 
@ Override public String readLine ( ) throws IOException { synchronized ( lock ) { if ( lastWasCR ) { chompNewline ( ) ; lastWasCR = false ; } String result = super . readLine ( ) ; if ( result != null ) { lineNumber ++ ; } return result ; } } 
@ Override public void write ( byte [ ] buffer , int off , int nbytes ) throws java . io . IOException { if ( ( off < 0 || ( nbytes < 0 ) || off > buffer . length ) || ( buffer . length - off < nbytes ) ) { throw new IndexOutOfBoundsException ( ) ; } if ( currentEntry == null ) { throw new ZipException ( "No-active-entry" ) ; } if ( currentEntry . getMethod ( ) == STORED ) { out . write ( buffer , off , nbytes ) ; } else { super . write ( buffer , off , nbytes ) ; } crc . update ( buffer , off , nbytes ) ; } 
public static LocalDate getLater ( LocalDate date1 , LocalDate date2 ) { if ( date1 . isAfter ( date2 ) ) { return date1 ; } else { return date2 ; } } 
private static synchronized CoordinatorService getCoordinatorService ( ) { if ( coordinatorService . get ( ) == null ) { coordinatorService . set ( new CoordinatorService ( ) ) ; } return coordinatorService . get ( ) ; } 
protected void checkProperty ( String propertyId ) throws XMLConfigurationException { if ( propertyId . startsWith ( Constants . XERCES_PROPERTY_PREFIX ) ) { final int suffixLength = propertyId . length ( ) - Constants . XERCES_PROPERTY_PREFIX . length ( ) ; if ( suffixLength == Constants . DTD_SCANNER_PROPERTY . length ( ) && propertyId . endsWith ( Constants . DTD_SCANNER_PROPERTY ) ) { return ; } } if ( propertyId . startsWith ( Constants . JAXP_PROPERTY_PREFIX ) ) { final int suffixLength = propertyId . length ( ) - Constants . JAXP_PROPERTY_PREFIX . length ( ) ; if ( suffixLength == Constants . SCHEMA_SOURCE . length ( ) && propertyId . endsWith ( Constants . SCHEMA_SOURCE ) ) { return ; } } super . checkProperty ( propertyId ) ; } 
public void setVariable ( ElemVariable v ) { if ( null == m_topLevelVariables ) m_topLevelVariables = new Vector ( ) ; m_topLevelVariables . addElement ( v ) ; } 
public static double [ ] getDoubles ( List < Double > values ) { int length = values . size ( ) ; double [ ] result = new double [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { result [ i ] = values . get ( i ) . doubleValue ( ) ; } return result ; } 
public Arg getArg ( ArgDecl argDecl ) { Arg arg = null ; for ( Iterator < Arg > iter = args . values ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Arg a = iter . next ( ) ; if ( argDecl . matches ( a ) ) arg = a ; } return arg ; } 
public static String replaceWhiteSpace ( String input , String replace ) { StringBuffer buf = new StringBuffer ( ) ; boolean lastWasWhiteSpace = false ; for ( int i = 0 , len = input . length ( ) ; i < len ; i ++ ) { char c = input . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { lastWasWhiteSpace = true ; continue ; } else if ( lastWasWhiteSpace ) { buf . append ( replace ) ; lastWasWhiteSpace = false ; } buf . append ( c ) ; } if ( lastWasWhiteSpace ) buf . append ( replace ) ; return buf . toString ( ) ; } 
public static int binarySearch ( byte [ ] array , byte value ) { return binarySearch ( array , 0 , array . length , value ) ; } 
public void printHelp ( OutputStream out ) { printHelp ( new PrintWriter ( new OutputStreamWriter ( out ) ) ) ; } 
public static Category createCategory ( String rawJSON ) throws TwitterException { try { JSONObject json = new JSONObject ( rawJSON ) ; return categoryConstructor . newInstance ( json ) ; } catch ( InstantiationException e ) { throw new TwitterException ( e ) ; } catch ( IllegalAccessException e ) { throw new AssertionError ( e ) ; } catch ( InvocationTargetException e ) { throw new TwitterException ( e ) ; } catch ( JSONException e ) { throw new TwitterException ( e ) ; } } 
public boolean isCellEditable ( int row , int column ) { return getModel ( ) . isCellEditable ( row , convertColumnIndexToModel ( column ) ) ; } 
public void skip ( K key ) throws IOException { ArrayList < ComposableRecordReader < K , ? >> tmp = new ArrayList < ComposableRecordReader < K , ? >> ( ) ; while ( ! q . isEmpty ( ) && cmp . compare ( q . peek ( ) . key ( ) , key ) <= 0 ) { tmp . add ( q . poll ( ) ) ; } for ( ComposableRecordReader < K , ? > rr : tmp ) { rr . skip ( key ) ; if ( rr . hasNext ( ) ) { q . add ( rr ) ; } } } 
public void setContentType ( String type ) { m_PrintPane . setContentType ( type ) ; } 
public String convertToCursiveBold ( final String line , final Set < String > dict ) { String tempResult = line ; for ( String word : dict ) { tempResult = tempResult . replaceAll ( "|b" + Pattern . quote ( word ) + "|b" , "<b><i>" + word + "</i></b>" ) ; } return tempResult + "<br-/>-" ; } 
public void altReferencesRule ( String enclosingRuleName , GrammarAST refScopeAST , GrammarAST refAST , int outerAltNum ) { Rule r = getRule ( enclosingRuleName ) ; if ( r == null ) { return ; } r . trackRuleReferenceInAlt ( refAST , outerAltNum ) ; antlr . Token refToken = refAST . getToken ( ) ; if ( ! ruleRefs . contains ( refAST ) ) { ruleRefs . add ( refAST ) ; } } 
public static String readAsciiLine ( InputStream in ) throws IOException { StringBuilder result = new StringBuilder ( 80 ) ; while ( true ) { int c = in . read ( ) ; if ( c == - 1 ) { throw new EOFException ( ) ; } else if ( c == '|n' ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > 0 && result . charAt ( length - 1 ) == '|r' ) { result . setLength ( length - 1 ) ; } return result . toString ( ) ; } 
public InitialContext ( ) throws NamingException { init ( null ) ; } 
@ SuppressWarnings ( "unchecked" ) protected void base_add ( int index , Object element ) { list . add ( index , element ) ; } 
protected void waitForExternalStoreMount ( ) throws Exception { String extStorageState = Environment . getExternalStorageState ( ) ; int currentWaitTime = 0 ; while ( ! extStorageState . equals ( Environment . MEDIA_MOUNTED ) ) { Log . i ( LOG_TAG , "Waiting-for-SD-card..." ) ; currentWaitTime = timeoutWait ( currentWaitTime , DEFAULT_WAIT_POLL_TIME , DEFAULT_MAX_WAIT_TIME , "Timed-out-waiting-for-SD-Card-to-be-ready!" ) ; extStorageState = Environment . getExternalStorageState ( ) ; } } 
public static final float getTokenListWidth ( final Token tokenList , RSyntaxTextArea textArea , TabExpander e , float x0 ) { float width = x0 ; for ( Token t = tokenList ; t != null && t . isPaintable ( ) ; t = t . getNextToken ( ) ) { width += t . getWidth ( textArea , e , width ) ; } return width - x0 ; } 
@ Override public Tree normalizeWholeTree ( Tree tree , TreeFactory tf ) { if ( tree . label ( ) . value ( ) . equals ( root ) && tree . children ( ) . length > 1 ) { Tree underRoot = tree . treeFactory ( ) . newTreeNode ( root , tree . getChildrenAsList ( ) ) ; tree . setChildren ( new Tree [ 1 ] ) ; tree . setChild ( 0 , underRoot ) ; } return tree ; } 
public static void cancelAll ( ) { Iterator < Sync > it = pending . iterator ( ) ; while ( it . hasNext ( ) ) { it . next ( ) . cancel ( ) ; } } 
public String getParameter ( String name ) { synchronized ( parameters ) { Object value = parameters . get ( name ) ; if ( value == null ) return ( null ) ; else if ( value instanceof String [ ] ) return ( ( ( String [ ] ) value ) [ 0 ] ) ; else if ( value instanceof String ) return ( ( String ) value ) ; else return ( value . toString ( ) ) ; } } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public static int [ ] remove ( int [ ] ArrayOne , int [ ] ArrayTwo ) { if ( ArrayTwo == null || ArrayTwo . length == 0 ) if ( ArrayOne == null ) return new int [ 0 ] ; else return ArrayOne ; int [ ] result = new int [ ArrayOne . length ] ; int iter = 0 , i = 0 , j = 0 ; while ( i < ArrayOne . length && j < ArrayTwo . length ) { if ( ArrayOne [ i ] > ArrayTwo [ j ] ) j ++ ; else if ( ArrayOne [ i ] == ArrayTwo [ j ] ) { i ++ ; j ++ ; } else { result [ iter ] = ArrayOne [ i ] ; i ++ ; iter ++ ; } } while ( i < ArrayOne . length ) { result [ iter ] = ArrayOne [ i ] ; i ++ ; iter ++ ; } return Arrays . copyOfRange ( result , 0 , iter ) ; } 
public static Pattern getRegexForExtension ( final String ext ) { return Pattern . compile ( "([^|s]+(|.(?i)(" + ext + "))$)" ) ; } 
public StringBuilder insert ( int offset , boolean b ) { insert0 ( offset , b ? "true" : "false" ) ; return this ; } 
public Short EnchantLevel ( Enchantment enchant ) { return enchantments . get ( enchant ) ; } 
private static Object await ( Node node , Slot slot ) { Thread w = Thread . currentThread ( ) ; int spins = SPINS ; for ( ; ; ) { Object v = node . get ( ) ; if ( v != null ) return v ; else if ( spins > 0 ) -- spins ; else if ( node . waiter == null ) node . waiter = w ; else if ( w . isInterrupted ( ) ) tryCancel ( node , slot ) ; else LockSupport . park ( node ) ; } } 
private List < Order > getSingleTaskOrders ( int amount ) { List < Order > orders = new ArrayList < Order > ( ) ; for ( int i = 0 ; i < amount ; i ++ ) { orders . add ( getSingleTaskOrder ( ) ) ; } return orders ; } 
public void selectCard ( CardEntity card , boolean sendMessage ) throws Exception { boolean foundSelected = false ; String curSelected = null ; if ( card == null ) { throw new Exception ( "Card-selected-was-NOT-on-the-table!" ) ; } for ( int selectedIndex = 1 ; ( selectedIndex <= 3 ) && ! foundSelected ; selectedIndex ++ ) { curSelected = "selected-" + selectedIndex ; foundSelected = ! selected . containsKey ( curSelected ) ; } if ( foundSelected ) { selected . put ( curSelected , card ) ; card . resetAnimation ( ) ; card . setEndPosition ( curSelected ) ; card . setAnimationTime ( 500 ) ; card . setAnimationDelay ( animBuffer ) ; animBuffer += 500 ; card . setAnimating ( true ) ; if ( sendMessage ) { MessageManager . sendMessage ( new GameMessage ( GameMessage . MessageType . SELECT_CARD , card . getCardObj ( ) ) , GameMessage . MessageDest . CF_LOGIC , GameMessage . MessageDest . CF_STATE , GameMessage . MessageDest . CF_SOUND ) ; } } } 
public void put ( String name , boolean value ) { fields . put ( name , new Boolean ( value ) ) ; } 
public Icon getDisabledSelectedIcon ( JComponent component , Icon icon ) { return getDisabledIcon ( component , icon ) ; } 
public void deselectNode ( Node n ) { n . dehighlight ( ) ; selectedNodes . remove ( n ) ; } 
private void invoke ( Method method , Object instance , Object [ ] params ) throws SlickXMLException { try { method . setAccessible ( true ) ; method . invoke ( instance , params ) ; } catch ( IllegalArgumentException e ) { throw new SlickXMLException ( "Failed-to-invoke:-" + method + "-for-an-XML-attribute,-is-it-valid?" , e ) ; } catch ( IllegalAccessException e ) { throw new SlickXMLException ( "Failed-to-invoke:-" + method + "-for-an-XML-attribute,-is-it-valid?" , e ) ; } catch ( InvocationTargetException e ) { throw new SlickXMLException ( "Failed-to-invoke:-" + method + "-for-an-XML-attribute,-is-it-valid?" , e ) ; } finally { method . setAccessible ( false ) ; } } 
protected void setRootPane ( JRootPane root ) { if ( rootPane != null ) { remove ( rootPane ) ; } rootPane = root ; if ( rootPane != null ) { boolean checkingEnabled = isRootPaneCheckingEnabled ( ) ; try { setRootPaneCheckingEnabled ( false ) ; add ( rootPane , BorderLayout . CENTER ) ; } finally { setRootPaneCheckingEnabled ( checkingEnabled ) ; } } } 
public YearMonth withYear ( int year ) { int [ ] newValues = getValues ( ) ; newValues = getChronology ( ) . year ( ) . set ( this , YEAR , newValues , year ) ; return new YearMonth ( this , newValues ) ; } 
@ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof Level ) ) { return false ; } return ( ( Level ) o ) . intValue ( ) == this . value ; } 
public boolean isEqualNode ( Node arg ) { if ( arg == this ) { return true ; } if ( arg . getNodeType ( ) != getNodeType ( ) ) { return false ; } if ( getNodeName ( ) == null ) { if ( arg . getNodeName ( ) != null ) { return false ; } } else if ( ! getNodeName ( ) . equals ( arg . getNodeName ( ) ) ) { return false ; } if ( getLocalName ( ) == null ) { if ( arg . getLocalName ( ) != null ) { return false ; } } else if ( ! getLocalName ( ) . equals ( arg . getLocalName ( ) ) ) { return false ; } if ( getNamespaceURI ( ) == null ) { if ( arg . getNamespaceURI ( ) != null ) { return false ; } } else if ( ! getNamespaceURI ( ) . equals ( arg . getNamespaceURI ( ) ) ) { return false ; } if ( getPrefix ( ) == null ) { if ( arg . getPrefix ( ) != null ) { return false ; } } else if ( ! getPrefix ( ) . equals ( arg . getPrefix ( ) ) ) { return false ; } if ( getNodeValue ( ) == null ) { if ( arg . getNodeValue ( ) != null ) { return false ; } } else if ( ! getNodeValue ( ) . equals ( arg . getNodeValue ( ) ) ) { return false ; } return true ; } 
public void setRptno ( String rptno ) { this . rptno = rptno == null ? null : rptno . trim ( ) ; } 
protected float getTopFadingEdgeStrength ( ) { return computeVerticalScrollOffset ( ) > 0 ? 1.0f : 0.0f ; } 
@ Override public void clear ( ) { E o ; do { o = poll ( ) ; } while ( null != o ) ; } 
public Enumeration < ? extends ZipEntry > entries ( ) { return new Enumeration < ZipEntry > ( ) { private int i = 0 ; public boolean hasMoreElements ( ) { if ( mRaf == null ) throw new IllegalStateException ( "Zip-File-closed." ) ; return i < mEntryList . size ( ) ; } public ZipEntry nextElement ( ) { if ( mRaf == null ) throw new IllegalStateException ( "Zip-File-closed." ) ; if ( i >= mEntryList . size ( ) ) throw new NoSuchElementException ( ) ; return ( ZipEntry ) mEntryList . get ( i ++ ) ; } } ; } 
public static List < Operation > getSupportedOperations ( View v ) { ArrayList < Operation > supportedOperations = new ArrayList < Operation > ( ) ; for ( SupportedOperation supportedOperation : SUPPORTED_OPERATIONS ) { if ( supportedOperation . mClass . isAssignableFrom ( v . getClass ( ) ) ) { for ( Operation operation : supportedOperation . mSupportedOperations ) { supportedOperations . add ( operation ) ; } } } return supportedOperations ; } 
public boolean clearFooters ( ) { boolean removed = false ; if ( ! footers . isEmpty ( ) ) { FixedViewInfo [ ] infos = footers . toArray ( new FixedViewInfo [ footers . size ( ) ] ) ; for ( FixedViewInfo info : infos ) removed = super . removeFooter ( info . view ) || removed ; } if ( removed ) wrapped . notifyDataSetChanged ( ) ; return removed ; } 
@ XmlElementDecl ( namespace = "http://www.xbrl.org/tw/fr/gaap/tw-gaap-ci-2010-03-31" , name = "NonOperatingExpensesInvestmentLossAbstract" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < StringItemType > createNonOperatingExpensesInvestmentLossAbstract ( StringItemType value ) { return new JAXBElement < StringItemType > ( _NonOperatingExpensesInvestmentLossAbstract_QNAME , StringItemType . class , null , value ) ; } 
public void setData ( byte [ ] newdata , int pos ) throws IOException { long curpos = data . getFilePointer ( ) ; data . seek ( pos ) ; data . write ( newdata ) ; data . seek ( curpos ) ; } 
@ XmlElementDecl ( namespace = "http://www.imsglobal.org/xsd/imsmd_v1p2" , name = "catalog" ) public JAXBElement < String > createCatalog ( String value ) { return new JAXBElement < String > ( _Catalog_QNAME , String . class , null , value ) ; } 
public void showBannerPanel ( ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { bannerPanel . setVisible ( true ) ; } } ) ; } 
public void getColor ( int _nIndex , Color3f _color ) { int nIdx = _nIndex * m_nVertexInfoSize + m_nColorOffset ; _color . x = m_colors . get ( nIdx + 0 ) ; _color . y = m_colors . get ( nIdx + 1 ) ; _color . z = m_colors . get ( nIdx + 2 ) ; } 
public void removeAllListeners ( ) { if ( mListeners != null ) { mListeners . clear ( ) ; mListeners = null ; } } 
private void relayoutMeasuredItem ( View child ) { final int w = child . getMeasuredWidth ( ) ; final int h = child . getMeasuredHeight ( ) ; final int childLeft = mListPadding . left ; final int childRight = childLeft + w ; final int childTop = child . getTop ( ) ; final int childBottom = childTop + h ; child . layout ( childLeft , childTop , childRight , childBottom ) ; } 
private void createSlot ( int index ) { Slot newSlot = new Slot ( ) ; Slot [ ] a = arena ; synchronized ( a ) { if ( a [ index ] == null ) a [ index ] = newSlot ; } } 
public static boolean compareParameters ( Parameter p1 , Parameter p2 ) { return p1 . getType ( ) . equals ( p2 . getType ( ) ) && p1 . getValue ( ) . equals ( p2 . getValue ( ) ) ; } 
public void clearSounds ( ) { mSoundMap . clear ( ) ; } 
public static double [ ] normalizeArray ( double [ ] values , double normalizedSum ) throws MathIllegalArgumentException , MathArithmeticException { if ( Double . isInfinite ( normalizedSum ) ) { throw new MathIllegalArgumentException ( LocalizedFormats . NORMALIZE_INFINITE ) ; } if ( Double . isNaN ( normalizedSum ) ) { throw new MathIllegalArgumentException ( LocalizedFormats . NORMALIZE_NAN ) ; } double sum = 0d ; final int len = values . length ; double [ ] out = new double [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { if ( Double . isInfinite ( values [ i ] ) ) { throw new MathIllegalArgumentException ( LocalizedFormats . INFINITE_ARRAY_ELEMENT , values [ i ] , i ) ; } if ( ! Double . isNaN ( values [ i ] ) ) { sum += values [ i ] ; } } if ( sum == 0 ) { throw new MathArithmeticException ( LocalizedFormats . ARRAY_SUMS_TO_ZERO ) ; } for ( int i = 0 ; i < len ; i ++ ) { if ( Double . isNaN ( values [ i ] ) ) { out [ i ] = Double . NaN ; } else { out [ i ] = values [ i ] * normalizedSum / sum ; } } return out ; } 
private void writeObject ( ObjectOutputStream out ) throws IOException { ObjectOutputStream . PutField fields = out . putFields ( ) ; fields . put ( "thisProfile" , profile ) ; fields . put ( "minVal" , null ) ; fields . put ( "maxVal" , null ) ; fields . put ( "diffMinMax" , null ) ; fields . put ( "invDiffMinMax" , null ) ; fields . put ( "needScaleInit" , true ) ; out . writeFields ( ) ; } 
public Xfermode setXfermode ( Xfermode xfermode ) { int xfermodeNative = 0 ; if ( xfermode != null ) xfermodeNative = xfermode . native_instance ; native_setXfermode ( mNativePaint , xfermodeNative ) ; mXfermode = xfermode ; return xfermode ; } 
@ SuppressWarnings ( "rawtypes" ) private void printToConsole ( List cellDataList ) { for ( int i = 0 ; i < cellDataList . size ( ) ; i ++ ) { List cellTempList = ( List ) cellDataList . get ( i ) ; for ( int j = 0 ; j < cellTempList . size ( ) ; j ++ ) { HSSFCell hssfCell = ( HSSFCell ) cellTempList . get ( j ) ; try { String CellValue = hssfCell . getStringCellValue ( ) ; System . out . print ( CellValue + "-" ) ; } catch ( NumberFormatException e ) { double CellValue = hssfCell . getNumericCellValue ( ) ; System . out . print ( CellValue + "-" ) ; } } System . out . println ( ) ; } } 
public int getAttributeDefaultValueType ( String name , String aname ) { Object attribute [ ] = getAttribute ( name , aname ) ; if ( attribute == null ) { return ATTRIBUTE_DEFAULT_UNDECLARED ; } else { return ( ( Integer ) attribute [ 2 ] ) . intValue ( ) ; } } 
public boolean loadFile ( String filePath ) { BufferedReader bReader ; FileInputStream istream = null ; try { istream = new FileInputStream ( filePath ) ; DataInputStream distream = new DataInputStream ( istream ) ; bReader = new BufferedReader ( new InputStreamReader ( distream ) ) ; String entry ; String values [ ] ; while ( ( entry = bReader . readLine ( ) ) != null ) { values = entry . split ( "," ) ; map . put ( values [ 0 ] , values [ 1 ] ) ; } istream . close ( ) ; } catch ( FileNotFoundException e ) { System . out . println ( "File-not-found!" ) ; } catch ( IOException e ) { System . out . println ( "IO-Error-occured." ) ; } if ( ! map . isEmpty ( ) ) { System . out . println ( "File-loaded" ) ; return true ; } System . out . println ( "Failed-to-load-file" ) ; return false ; } 
@ XmlElementDecl ( namespace = "http://schemas.microsoft.com/dynamics/2008/01/documents/Item" , name = "Override" , scope = AxdEntityInventItemSalesSetup . class ) public JAXBElement < AxdExtTypeNoYesId > createAxdEntityInventItemSalesSetupOverride ( AxdExtTypeNoYesId value ) { return new JAXBElement < AxdExtTypeNoYesId > ( _AxdEntityInventItemSalesSetupOverride_QNAME , AxdExtTypeNoYesId . class , AxdEntityInventItemSalesSetup . class , value ) ; } 
public Criteria createCriteria ( ) { Criteria criteria = createCriteriaInternal ( ) ; if ( oredCriteria . size ( ) == 0 ) { oredCriteria . add ( criteria ) ; } return criteria ; } 
private ExceptionBean ( Throwable t ) { this . className = t . getClass ( ) . getName ( ) ; this . message = t . getMessage ( ) ; for ( StackTraceElement f : t . getStackTrace ( ) ) { stackTrace . add ( new StackFrame ( f ) ) ; } Throwable cause = t . getCause ( ) ; if ( t != cause && cause != null ) this . cause = new ExceptionBean ( cause ) ; } 
public static Predicate instanceofPredicate ( Class type ) { return InstanceofPredicate . getInstance ( type ) ; } 
private void removeLongPressCallback ( ) { if ( mPendingCheckForLongPress != null ) { removeCallbacks ( mPendingCheckForLongPress ) ; } } 
static ArrayObject factory ( Class classType , Index index ) { return ArrayObject . factory ( classType , index , null ) ; } 
public boolean isTerminating ( ) { int c = ctl . get ( ) ; return ! isRunning ( c ) && runStateLessThan ( c , TERMINATED ) ; } 
public static void runEchoServerTest ( int port ) { String url = "socket://127.0.0.1:" + port ; for ( int i = 0 ; i < NUM_TEST_CLIENTS ; i ++ ) { EchoServerTest client = new EchoServerTest ( url ) ; Thread clientThread = new Thread ( client , "Client-#-" + i + "-for-port:-" + port ) ; clientThread . start ( ) ; } } 
public Primitives . LinPoly . Vertex createPrimitivesLinPolyVertex ( ) { return new Primitives . LinPoly . Vertex ( ) ; } 
public static FontSize fromInt ( int value ) { for ( FontSize e : FontSize . values ( ) ) { if ( e . mValue == value ) { return e ; } } return null ; } 
public void run ( ) { try { accept ( ) ; } catch ( Exception e ) { pause ( ) ; } } 
public < T > Iterator < T > getServiceProviders ( Class < T > category , Filter filter , boolean useOrdering ) { SubRegistry reg = ( SubRegistry ) categoryMap . get ( category ) ; if ( reg == null ) { throw new IllegalArgumentException ( "category-unknown!" ) ; } Iterator iter = getServiceProviders ( category , useOrdering ) ; return new FilterIterator ( iter , filter ) ; } 
private String getParamString ( StringTokenizer s ) { String contenido = "" ; String val = s . nextToken ( ) ; while ( s . hasMoreTokens ( ) ) contenido += s . nextToken ( ) + "-" ; return contenido . trim ( ) ; } 
private String getStringAttribute ( JSONObject jsonObject , String attributeName , String defaultValue ) throws Exception { Object oAttributeValue = jsonObject . get ( attributeName ) ; if ( oAttributeValue != null ) { if ( oAttributeValue instanceof String ) { return ( String ) oAttributeValue ; } else { throw new Exception ( "JSON-error-:-attribute-'" + attributeName + "'-is-not-a-String" ) ; } } else { if ( defaultValue != null ) { return defaultValue ; } else { throw new Exception ( "JSON-error-:-attribute-'" + attributeName + "'-not-found" ) ; } } } 
public final void evolve ( final Population < T > pop ) { this . initialPopulation = pop ; evolve ( true ) ; } 
public static void main ( String [ ] args ) { System . out . println ( "Introduzca-el-apartado:-" ) ; String linea = Teclado . leerLinea ( ) ; String nombreClase = CLASE + linea ; System . out . println ( "Introduzca-el-ejercicio:-" ) ; linea = Teclado . leerLinea ( ) ; String nombreMetodo = METODO + linea ; try { Class clase = Class . forName ( nombreClase ) ; Method metodo = clase . getMethod ( nombreMetodo ) ; metodo . invoke ( clase . newInstance ( ) ) ; } catch ( ClassNotFoundException classNotFound ) { System . out . println ( ) ; System . out . println ( "Codigo-de-apartado-incorrecto.-Por-favor,-revise-el-enunciado-de-la-practica" ) ; System . out . println ( ) ; } catch ( InvocationTargetException invocation ) { System . out . println ( ) ; invocation . printStackTrace ( ) ; System . out . println ( ) ; } catch ( Exception e ) { System . out . println ( ) ; System . out . println ( "Numero-de-ejercicio-incorrecto.-Por-favor,-revise-el-enunciado-de-la-practica" ) ; System . out . println ( ) ; } } 
public static BufferedReader getBufferedReader ( URL source ) throws IOException { URLConnection conn = source . openConnection ( ) ; boolean isGzipped = conn . getContentType ( ) != null && conn . getContentType ( ) . equalsIgnoreCase ( "application/x-gzip" ) || conn . getContentEncoding ( ) != null && conn . getContentEncoding ( ) . equalsIgnoreCase ( "gzip" ) ; InputStream uis = conn . getInputStream ( ) ; return new BufferedReader ( isGzipped ? new InputStreamReader ( new GZIPInputStream ( uis ) ) : new InputStreamReader ( uis ) ) ; } 
@ Override public String getText ( Object object ) { String label = ( ( Parameter ) object ) . getName ( ) ; return label == null || label . length ( ) == 0 ? getString ( "_UI_Parameter_type" ) : getString ( "_UI_Parameter_type" ) + "-" + label ; } 
public static void setFieldValue ( Object obj , String fieldName , Object value ) throws NoSuchFieldException , IllegalArgumentException , IllegalAccessException { Field field = obj . getClass ( ) . getDeclaredField ( fieldName ) ; field . setAccessible ( true ) ; field . set ( obj , value ) ; field . setAccessible ( false ) ; } 
private JsExpression tryGetReplacementExpression ( SourceInfo sourceInfo , JsName name ) { if ( paramsToArgsMap . containsKey ( name ) ) { return paramsToArgsMap . get ( name ) ; } else if ( nameReplacements . containsKey ( name ) ) { return nameReplacements . get ( name ) . makeRef ( sourceInfo ) ; } else { return null ; } } 
public static String right ( String str , int len ) { if ( str == null ) { return null ; } if ( len < 0 ) { return EMPTY ; } if ( str . length ( ) <= len ) { return str ; } return str . substring ( str . length ( ) - len ) ; } 
public static DERObjectIdentifier getInstance ( Object obj ) { if ( obj == null || obj instanceof DERObjectIdentifier ) { return ( DERObjectIdentifier ) obj ; } if ( obj instanceof ASN1OctetString ) { return new DERObjectIdentifier ( ( ( ASN1OctetString ) obj ) . getOctets ( ) ) ; } if ( obj instanceof ASN1TaggedObject ) { return getInstance ( ( ( ASN1TaggedObject ) obj ) . getObject ( ) ) ; } throw new IllegalArgumentException ( "illegal-object-in-getInstance:-" + obj . getClass ( ) . getName ( ) ) ; } 
protected static String urlEncodeSafe ( String data ) { try { return URLEncoder . encode ( data , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } 
static public List < TRowResult > rowResultFromHBase ( Result [ ] in ) { List < TRowResult > results = new ArrayList < TRowResult > ( ) ; for ( Result result_ : in ) { if ( result_ == null || result_ . isEmpty ( ) ) { continue ; } TRowResult result = new TRowResult ( ) ; result . row = result_ . getRow ( ) ; result . columns = new TreeMap < byte [ ] , TCell > ( Bytes . BYTES_COMPARATOR ) ; for ( KeyValue kv : result_ . sorted ( ) ) { result . columns . put ( KeyValue . makeColumn ( kv . getFamily ( ) , kv . getQualifier ( ) ) , new TCell ( kv . getValue ( ) , kv . getTimestamp ( ) ) ) ; } results . add ( result ) ; } return results ; } 
@ Override protected Object clone ( ) { Edge ed = new Edge ( ) ; ed . src = new String ( src ) ; ed . dst = new String ( dst ) ; return ed ; } 
protected boolean usefulAsDigits ( CharSequence cons ) { int len = cons . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = cons . charAt ( i ) ; if ( ( c >= '0' ) && ( c <= '9' ) ) { continue ; } if ( ( c == '-' ) || ( c == '-' ) || ( c == '(' ) || ( c == ')' ) || ( c == '.' ) || ( c == '+' ) || ( c == '#' ) || ( c == '*' ) ) { continue ; } if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { continue ; } if ( ( c >= 'a' ) && ( c <= 'z' ) ) { continue ; } return false ; } return true ; } 
public final Object clone ( ) { return new Path2D . Double ( this ) ; } 
public void sendDealerCards ( ) { Card dcard = null ; Iterator < Card > dscan = ( dealer . inHand ) . iterator ( ) ; while ( dscan . hasNext ( ) ) { String sendString = "" ; dcard = dscan . next ( ) ; String suit = dcard . getsuit ( ) ; String face = dcard . getface ( ) ; int value = dcard . getvalue ( ) ; sendString = "card-dealer-" + value + "-" + suit + "-" + face ; System . out . println ( sendString ) ; networkHandler . send ( sendString ) ; } } 
public Enumeration < String > getElements ( ) { return mAttributeNames . elements ( ) ; } 
public final void setHomePage ( URL homePageUrl , boolean redirect ) { homePage = homePageUrl . toString ( ) ; homeRedirection = redirect ; } 
public static BufferedImage getBufferedImage ( File file ) { Icon icon = SparkRes . getImageIcon ( SparkRes . DOCUMENT_INFO_32x32 ) ; BufferedImage bi = new BufferedImage ( icon . getIconWidth ( ) , icon . getIconHeight ( ) , BufferedImage . OPAQUE ) ; Graphics bg = bi . getGraphics ( ) ; ImageIcon i = ( ImageIcon ) icon ; bg . drawImage ( i . getImage ( ) , 0 , 0 , null ) ; bg . dispose ( ) ; return bi ; } 
public static ColorUIResource getSeparatorForeground ( ) { return getCurrentTheme ( ) . getSeparatorForeground ( ) ; } 
public int saveLayer ( float left , float top , float right , float bottom , Paint paint , int saveFlags ) { return native_saveLayer ( mNativeCanvas , left , top , right , bottom , paint != null ? paint . mNativePaint : 0 , saveFlags ) ; } 
public String render ( String path , HttpServletRequest request , HttpServletResponse response ) throws GeneralException { Writer writer = new StringWriter ( ) ; String content = null ; render ( path , request , response , writer ) ; try { content = writer . toString ( ) ; writer . close ( ) ; } catch ( IOException e ) { throw new GeneralException ( "Problems-closing-the-Writer" , e ) ; } return content ; } 
public void appendCloseEmTag ( ) { text . append ( "</em>" ) ; } 
public static < T extends PlatformManagedObject > T getPlatformMXBean ( MBeanServerConnection connection , Class < T > mxbeanInterface ) throws java . io . IOException { PlatformComponent pc = PlatformComponent . getPlatformComponent ( mxbeanInterface ) ; if ( pc == null ) throw new IllegalArgumentException ( mxbeanInterface . getName ( ) + "-is-not-a-platform-management-interface" ) ; if ( ! pc . isSingleton ( ) ) throw new IllegalArgumentException ( mxbeanInterface . getName ( ) + "-can-have-zero-or-more-than-one-instances" ) ; return pc . getSingletonMXBean ( connection , mxbeanInterface ) ; } 
private static int [ ] extractQuotedString ( String rawData ) { boolean inQuotes = false ; char quoteChar = '"' ; int start = 0 ; for ( int pos = 0 ; pos < rawData . length ( ) ; pos ++ ) { char currentChar = rawData . charAt ( pos ) ; if ( currentChar == '"' || currentChar == '|'' ) { if ( ! inQuotes ) { quoteChar = currentChar ; inQuotes = true ; start = pos + 1 ; } else if ( quoteChar == currentChar ) { inQuotes = false ; return new int [ ] { start , pos } ; } } } return null ; } 
public byte [ ] decodeToByteArray ( byte [ ] data ) { return Base64 . decodeBase64 ( data ) ; } 
public DataOutputBuffer reset ( ) { this . written = 0 ; buffer . reset ( ) ; return this ; } 
public Enumeration listOptions ( ) { Vector newVector = new Vector ( 7 ) ; newVector . addElement ( new Option ( "-Population-size" , "L" , 1 , "-L-<integer>" ) ) ; newVector . addElement ( new Option ( "-Descendant-population-size" , "A" , 1 , "-A-<integer>" ) ) ; newVector . addElement ( new Option ( "-Number-of-runs" , "U" , 1 , "-U-<integer>" ) ) ; newVector . addElement ( new Option ( "-Use-mutation.-(default-true)" , "M" , 0 , "-M" ) ) ; newVector . addElement ( new Option ( "-Use-cross-over.-(default-true)" , "C" , 0 , "-C" ) ) ; newVector . addElement ( new Option ( "-Use-tournament-selection-(true)-or-maximum-subpopulatin-(false).-(default-false)" , "O" , 0 , "-O" ) ) ; newVector . addElement ( new Option ( "-Random-number-seed" , "R" , 1 , "-R-<seed>" ) ) ; Enumeration enu = super . listOptions ( ) ; while ( enu . hasMoreElements ( ) ) { newVector . addElement ( enu . nextElement ( ) ) ; } return newVector . elements ( ) ; } 
private static Object getURLObject ( String scheme , Object urlInfo , Name name , Context nameCtx , Hashtable < ? , ? > environment ) throws NamingException { ObjectFactory factory = ( ObjectFactory ) ResourceManager . getFactory ( Context . URL_PKG_PREFIXES , environment , nameCtx , "." + scheme + "." + scheme + "URLContextFactory" , defaultPkgPrefix ) ; if ( factory == null ) return null ; try { return factory . getObjectInstance ( urlInfo , name , nameCtx , environment ) ; } catch ( NamingException e ) { throw e ; } catch ( Exception e ) { NamingException ne = new NamingException ( ) ; ne . setRootCause ( e ) ; throw ne ; } } 
public static String todayString ( ) { String ret = LocalDate . now ( ) . toString ( ) ; ret = ret . replaceAll ( "-" , "" ) ; return ParseDate . standardFromyyyyMMdd ( ret ) ; } 
public void dispatchDestroy ( boolean finishing ) { final int N = mActivityArray . size ( ) ; for ( int i = 0 ; i < N ; i ++ ) { LocalActivityRecord r = mActivityArray . get ( i ) ; if ( localLOGV ) Log . v ( TAG , r . id + ":-destroying" ) ; mActivityThread . performDestroyActivity ( r , finishing ) ; } mActivities . clear ( ) ; mActivityArray . clear ( ) ; } 
@ XmlElementDecl ( namespace = "http://earth.google.com/kml/2.1" , name = "LookAt" , substitutionHeadNamespace = "http://earth.google.com/kml/2.1" , substitutionHeadName = "Object" ) public JAXBElement < LookAtType > createLookAt ( LookAtType value ) { return new JAXBElement < > ( _LookAt_QNAME , LookAtType . class , null , value ) ; } 
private void initAnsiWidths ( ) { ansiWidth = new int [ 256 ] ; for ( int i = 0 ; i < 256 ; i ++ ) { ansiWidth [ i ] = mtxTab [ 0 ] . getWx ( ) ; } ansiIndex = new java . util . HashMap ( ) ; for ( int i = 32 ; i < Glyphs . WINANSI_ENCODING . length ; i ++ ) { Integer ansi = new Integer ( i ) ; Integer uni = new Integer ( ( int ) Glyphs . WINANSI_ENCODING [ i ] ) ; List v = ( List ) ansiIndex . get ( uni ) ; if ( v == null ) { v = new java . util . ArrayList ( ) ; ansiIndex . put ( uni , v ) ; } v . add ( ansi ) ; } } 
protected void setBorderToNonRollover ( Component c ) { if ( c instanceof AbstractButton ) { AbstractButton b = ( AbstractButton ) c ; Border border = borderTable . get ( b ) ; if ( border == null || border instanceof UIResource ) { borderTable . put ( b , b . getBorder ( ) ) ; } if ( b . getBorder ( ) instanceof UIResource ) { b . setBorder ( getNonRolloverBorder ( b ) ) ; } rolloverTable . put ( b , b . isRolloverEnabled ( ) ? Boolean . TRUE : Boolean . FALSE ) ; b . setRolloverEnabled ( false ) ; } } 
private void sendMultipacketResponse ( int par1 , String par2Str ) throws IOException { int var3 = par2Str . length ( ) ; do { int var4 = 4096 <= var3 ? 4096 : var3 ; this . sendResponse ( par1 , 0 , par2Str . substring ( 0 , var4 ) ) ; par2Str = par2Str . substring ( var4 ) ; var3 = par2Str . length ( ) ; } while ( 0 != var3 ) ; } 
public static float calculateRadiusOffset ( float strokeSize , float diamondStrokeSize , float markerStrokeSize ) { return Math . max ( strokeSize , Math . max ( diamondStrokeSize , markerStrokeSize ) ) ; } 
public static String convert ( String path , String filename ) { if ( path == null ) { throw new NullPointerException ( "Initial-path-required-to-handle-relative-filenames" ) ; } List < String > folderPath = names ( path ) ; List < String > filePath = names ( convert ( filename ) ) ; List < String > resolvedPath = new ArrayList < String > ( folderPath . size ( ) + filePath . size ( ) ) ; resolvedPath . addAll ( folderPath ) ; for ( String item : filePath ) { if ( item == null ) continue ; if ( item . equals ( "." ) ) continue ; if ( item . equals ( ".." ) ) { if ( ! resolvedPath . isEmpty ( ) ) { resolvedPath . remove ( resolvedPath . size ( ) - 1 ) ; continue ; } else { throw new IllegalStateException ( "File-location-" + filename + "-outside-of-" + path ) ; } } resolvedPath . add ( item ) ; } return toPath ( STRICT_PATH , resolvedPath ) ; } 
public synchronized boolean containsValue ( Object value ) { if ( value == null ) { throw new NullPointerException ( ) ; } HashtableEntry [ ] tab = table ; int len = tab . length ; for ( int i = 0 ; i < len ; i ++ ) { for ( HashtableEntry e = tab [ i ] ; e != null ; e = e . next ) { if ( value . equals ( e . value ) ) { return true ; } } } return false ; } 
public GoodwillSchemaField getFieldByPosition ( final short i ) { return thriftItems . get ( i ) ; } 
private static String [ ] createRegexp ( String directory , Query query ) { String [ ] args = new String [ query . getSlotsCount ( ) ] ; int cc = query . getSlotsCount ( ) ; for ( int i = 0 ; i < cc ; i ++ ) { args [ i ] = SearchHelper . toIgnoreCaseRegExp ( query . getSlot ( i ) , true ) ; } return args ; } 
public static final int guessCoorinateDims ( final Coordinate [ ] cs ) { int dims = 2 ; for ( int t = cs . length - 1 ; t >= 0 ; t -- ) { if ( ! ( Double . isNaN ( cs [ t ] . z ) ) ) { dims = 4 ; break ; } } return dims ; } 
public String readLine ( ) throws IOException { StringBuilder sb = null ; boolean eol = false ; int nextChar = read ( ) ; while ( ! eol && ( nextChar != - 1 ) ) { if ( nextChar == 10 ) { eol = true ; } else if ( nextChar == 13 ) { eol = true ; nextChar = read ( ) ; if ( nextChar != 10 ) { this . savedNextChar = nextChar ; } } if ( ! eol ) { if ( sb == null ) { sb = new StringBuilder ( ) ; } sb . append ( ( char ) nextChar ) ; nextChar = read ( ) ; } } return ( sb == null ) ? null : sb . toString ( ) ; } 
protected int skipSpaces ( ) { int lex = scanner . getType ( ) ; while ( lex == LexicalUnits . SPACE ) { lex = next ( ) ; } return lex ; } 
public static java . awt . Color toAwtColor ( Color color ) { return new java . awt . Color ( color . getRed ( ) , color . getGreen ( ) , color . getBlue ( ) ) ; } 
public void loadNative ( ) throws Throwable { if ( aprHome == null ) aprHome = baseDir ; if ( jniMode ) { if ( jniModeSo . equals ( "inprocess" ) ) { ok = true ; return ; } try { log . info ( "Loading-" + jniModeSo ) ; if ( jniModeSo != null ) System . load ( jniModeSo ) ; } catch ( Throwable ex ) { return ; } ok = true ; return ; } try { if ( nativeSo == null ) { log . debug ( "Loading-jkjni-from-" + System . getProperty ( "java.library.path" ) ) ; System . loadLibrary ( "jkjni" ) ; } else { System . load ( nativeSo ) ; } } catch ( Throwable ex ) { ok = false ; throw ex ; } } 
private void invalidateWeekFields ( ) { if ( stamp [ WEEK_OF_MONTH ] != COMPUTED && stamp [ WEEK_OF_YEAR ] != COMPUTED ) { return ; } Calendar cal = ( Calendar ) clone ( ) ; cal . setLenient ( true ) ; cal . clear ( WEEK_OF_MONTH ) ; cal . clear ( WEEK_OF_YEAR ) ; if ( stamp [ WEEK_OF_MONTH ] == COMPUTED ) { int weekOfMonth = cal . get ( WEEK_OF_MONTH ) ; if ( fields [ WEEK_OF_MONTH ] != weekOfMonth ) { fields [ WEEK_OF_MONTH ] = weekOfMonth ; } } if ( stamp [ WEEK_OF_YEAR ] == COMPUTED ) { int weekOfYear = cal . get ( WEEK_OF_YEAR ) ; if ( fields [ WEEK_OF_YEAR ] != weekOfYear ) { fields [ WEEK_OF_YEAR ] = weekOfYear ; } } } 
public void dispatchStop ( ) { mCurState = CREATED ; final int N = mActivityArray . size ( ) ; for ( int i = 0 ; i < N ; i ++ ) { LocalActivityRecord r = mActivityArray . get ( i ) ; moveToState ( r , CREATED ) ; } } 
static Method getStartFinalizer ( Class < ? > finalizer ) { try { return finalizer . getMethod ( "startFinalizer" , Class . class , ReferenceQueue . class , PhantomReference . class ) ; } catch ( NoSuchMethodException e ) { throw new AssertionError ( e ) ; } } 
public void addUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { mUpdateListeners = new ArrayList < AnimatorUpdateListener > ( ) ; } mUpdateListeners . add ( listener ) ; } 
public void handleSslErrorResponse ( boolean proceed ) { if ( mRequest != null ) { mRequest . handleSslErrorResponse ( proceed ) ; } } 
private void controlSimHost ( final Account account ) { synchronized ( CTRLLOCK ) { if ( usedHost == null ) { return ; } int was , current ; if ( account != null && account . getBooleanProperty ( "free" ) ) { was = maxFreeAccSimDlPerHost . get ( ) ; maxFreeAccSimDlPerHost . set ( getHashedHashedValue ( account ) - 1 ) ; current = maxFreeAccSimDlPerHost . get ( ) ; } else if ( account != null && ! account . getBooleanProperty ( "free" ) ) { was = maxPremAccSimDlPerHost . get ( ) ; maxPremAccSimDlPerHost . set ( getHashedHashedValue ( account ) - 1 ) ; current = maxPremAccSimDlPerHost . get ( ) ; } else { was = maxNonAccSimDlPerHost . get ( ) ; maxNonAccSimDlPerHost . set ( getHashedHashedValue ( account ) - 1 ) ; current = maxNonAccSimDlPerHost . get ( ) ; } if ( account == null ) { logger . info ( "maxSimPerHost-=-Guest-@-" + acctype + "-->-was-=-" + was + "-&&-new-upper-limit-=-" + current ) ; } else { logger . info ( "maxSimPerHost-=-" + account . getUser ( ) + "-@-" + acctype + "-->-was-=-" + was + "-&&-new-upper-limit-=-" + current ) ; } } } 
public Marker add ( int line , int column , boolean hasIndent , NodeWriter out ) { Marker m = new Marker ( line , column , hasIndent ) ; _marks . add ( m ) ; this . count ++ ; if ( hasIndent ) out . indent ( ) ; return m ; } 
public static void encode ( java . nio . ByteBuffer raw , java . nio . CharBuffer encoded ) { byte [ ] raw3 = new byte [ 3 ] ; byte [ ] enc4 = new byte [ 4 ] ; while ( raw . hasRemaining ( ) ) { int rem = Math . min ( 3 , raw . remaining ( ) ) ; raw . get ( raw3 , 0 , rem ) ; Base64 . encode3to4 ( enc4 , raw3 , rem , Base64 . NO_OPTIONS ) ; for ( int i = 0 ; i < 4 ; i ++ ) { encoded . put ( ( char ) ( enc4 [ i ] & 0xFF ) ) ; } } } 
public static String unescapeName ( String txtName ) { if ( txtName == null ) { return txtName ; } int len = txtName . length ( ) ; if ( len == 0 ) { return txtName ; } int indx ; for ( int i = 0 ; i < txtName . length ( ) ; i ++ ) { indx = txtName . indexOf ( SLASH_ESC_SEQ ) ; if ( indx >= 0 ) { String prefixID = txtName . substring ( 0 , indx ) ; String postfixID = txtName . substring ( indx + 5 ) ; txtName = prefixID + "/" + postfixID ; } } return ( txtName ) ; } 
public static Field findStaticField ( String fieldName_ , Class < ? > target_ ) { if ( ( fieldName_ == null ) || ( target_ == null ) ) return null ; try { Field [ ] declaredFields = target_ . getDeclaredFields ( ) ; if ( ( declaredFields == null ) || ( declaredFields . length == 0 ) ) return null ; for ( Field field : declaredFields ) { int modifiers = field . getModifiers ( ) ; if ( ! Modifier . isStatic ( modifiers ) ) continue ; if ( ! fieldName_ . equals ( field . getName ( ) ) ) continue ; return field ; } } catch ( Exception e_ ) { LOG . error ( null , e_ ) ; return null ; } return findStaticField ( fieldName_ , target_ . getSuperclass ( ) ) ; } 
public Dimension preferredLayoutSize ( Container parent ) { int width = 0 ; int height = 0 ; Insets insets = parent . getInsets ( ) ; Component [ ] comps = parent . getComponents ( ) ; Dimension pref ; for ( int i = 0 ; i < comps . length ; i ++ ) { pref = comps [ i ] . getPreferredSize ( ) ; if ( pref != null ) { width = Math . max ( width , pref . width ) ; height += pref . height ; } } return new Dimension ( width + insets . left + insets . right , height + insets . top + insets . bottom ) ; } 
public static MozuClient < com . mozu . api . contracts . content . Document > getTreeDocumentClient ( com . mozu . api . DataViewMode dataViewMode , String documentListName , String documentName , Boolean includeInactive , String responseFields ) throws Exception { MozuUrl url = com . mozu . api . urls . content . documentlists . DocumentTreeUrl . getTreeDocumentUrl ( documentListName , documentName , includeInactive , responseFields ) ; String verb = "GET" ; Class < ? > clz = com . mozu . api . contracts . content . Document . class ; MozuClient < com . mozu . api . contracts . content . Document > mozuClient = ( MozuClient < com . mozu . api . contracts . content . Document > ) MozuClientFactory . getInstance ( clz ) ; mozuClient . setVerb ( verb ) ; mozuClient . setResourceUrl ( url ) ; mozuClient . addHeader ( Headers . X_VOL_DATAVIEW_MODE , dataViewMode . toString ( ) ) ; return mozuClient ; } 
public Map < String , List < String >> toMultimap ( boolean response ) { Map < String , List < String >> result = new TreeMap < String , List < String >> ( FIELD_NAME_COMPARATOR ) ; for ( int i = 0 ; i < namesAndValues . size ( ) ; i += 2 ) { String fieldName = namesAndValues . get ( i ) ; String value = namesAndValues . get ( i + 1 ) ; List < String > allValues = new ArrayList < String > ( ) ; List < String > otherValues = result . get ( fieldName ) ; if ( otherValues != null ) { allValues . addAll ( otherValues ) ; } allValues . add ( value ) ; result . put ( fieldName , Collections . unmodifiableList ( allValues ) ) ; } if ( response && statusLine != null ) { result . put ( null , Collections . unmodifiableList ( Collections . singletonList ( statusLine ) ) ) ; } else if ( requestLine != null ) { result . put ( null , Collections . unmodifiableList ( Collections . singletonList ( requestLine ) ) ) ; } return Collections . unmodifiableMap ( result ) ; } 
public final XSAttributeGroupDecl getGlobalAttributeGroupDecl ( String declName ) { return ( XSAttributeGroupDecl ) fGlobalAttrGrpDecls . get ( declName ) ; } 
public String getOutputFormatedText ( ) { String text = textArea . getText ( ) ; text = text . replaceAll ( "(-)|(-)" , "-" ) ; return text . replaceAll ( "-" , "&/&/&" ) ; } 
public boolean isCascadeRefresh ( ) { return ( getCascade_ ( ) & EOConstants . CASCADE_REFRESH ) != 0 ; } 
public static Integer getResourceId ( ResourceType type , String name ) { Map < String , Integer > map = sRFullMap . get ( type ) ; if ( map != null ) { return map . get ( name ) ; } return null ; } 
protected JScrollPane makeScrollPane ( Component comp ) { JScrollPane pane = new JScrollPane ( comp ) ; pane . setPreferredSize ( pane . getMinimumSize ( ) ) ; return pane ; } 
public void nextRequest ( ) { request . recycle ( ) ; if ( lastValid - pos > 0 ) { int npos = 0 ; int opos = pos ; while ( lastValid - opos > opos - npos ) { System . arraycopy ( buf , opos , buf , npos , opos - npos ) ; npos += pos ; opos += pos ; } System . arraycopy ( buf , opos , buf , npos , lastValid - opos ) ; } for ( int i = 0 ; i <= lastActiveFilter ; i ++ ) { activeFilters [ i ] . recycle ( ) ; } lastValid = lastValid - pos ; pos = 0 ; lastActiveFilter = - 1 ; parsingHeader = true ; swallowInput = true ; } 
public void removeAll ( ) { mParts . clear ( ) ; } 
protected void closeServer ( ) throws IOException { IIOPHelper . unexportObject ( this ) ; } 
private Painter getPainter ( TreeMap < String , Object > defaults , String key ) { Object p = defaults . get ( key ) ; if ( p instanceof UIDefaults . LazyValue ) { p = ( ( UIDefaults . LazyValue ) p ) . createValue ( UIManager . getDefaults ( ) ) ; } return ( p instanceof Painter ? ( Painter ) p : null ) ; } 
@ XmlElementDecl ( namespace = "" , name = "MerchantInitializationRequest" ) public JAXBElement < MerchantInitializationRequest > createMerchantInitializationRequest ( MerchantInitializationRequest value ) { return new JAXBElement < MerchantInitializationRequest > ( _MerchantInitializationRequest_QNAME , MerchantInitializationRequest . class , null , value ) ; } 
private void updateAvailableTypes ( ) { IProject project = mValues . project ; IAndroidTarget target = project != null ? Sdk . getCurrent ( ) . getTarget ( project ) : null ; int currentApiLevel = 1 ; if ( target != null ) { currentApiLevel = target . getVersion ( ) . getApiLevel ( ) ; } List < String > items = new ArrayList < String > ( sTypes . length ) ; List < TypeInfo > types = new ArrayList < TypeInfo > ( sTypes . length ) ; for ( int i = 0 , n = sTypes . length ; i < n ; i ++ ) { TypeInfo type = sTypes [ i ] ; if ( type . getTargetApiLevel ( ) <= currentApiLevel ) { items . add ( type . getUiName ( ) ) ; types . add ( type ) ; } } mTypeCombo . setItems ( items . toArray ( new String [ items . size ( ) ] ) ) ; mTypeCombo . setData ( types . toArray ( new TypeInfo [ types . size ( ) ] ) ) ; } 
private void writeObject ( final ObjectOutputStream oos ) throws IOException { oos . defaultWriteObject ( ) ; if ( logger != null ) { oos . writeBoolean ( true ) ; oos . writeUTF ( logger . getName ( ) ) ; } else { oos . writeBoolean ( false ) ; } } 
void remove ( ThreadLocal < ? > key ) { cleanUp ( ) ; for ( int index = key . hash & mask ; ; index = next ( index ) ) { Object reference = table [ index ] ; if ( reference == key . reference ) { table [ index ] = TOMBSTONE ; table [ index + 1 ] = null ; tombstones ++ ; size -- ; return ; } if ( reference == null ) { return ; } } } 
public boolean isAnnotationPresent ( Class < ? extends Annotation > annotationType ) { return getAnnotation ( annotationType ) != null ; } 
public boolean accept ( File dir , String name ) { final Pattern targetPattern = Pattern . compile ( targetRegexName ) ; final Matcher matchTarget = targetPattern . matcher ( name ) ; return matchTarget . find ( ) ; } 
int adjustAcceleratorWidth ( int width ) { maxAcceleratorWidth = Math . max ( maxAcceleratorWidth , width ) ; return maxAcceleratorWidth ; } 
public void replaceData ( int offset , int count , String data ) throws DOMException { CoreDocumentImpl ownerDocument = ownerDocument ( ) ; if ( ownerDocument . errorChecking && isReadOnly ( ) ) { String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . DOM_DOMAIN , "NO_MODIFICATION_ALLOWED_ERR" , null ) ; throw new DOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR , msg ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } ownerDocument . replacingData ( this ) ; String oldvalue = this . data ; internalDeleteData ( offset , count , true ) ; internalInsertData ( offset , data , true ) ; ownerDocument . replacedCharacterData ( this , oldvalue , this . data ) ; } 
public List < java . lang . Object > getAny ( ) { if ( any == null ) { any = new ArrayList < java . lang . Object > ( ) ; } return this . any ; } 
public final boolean postAtFrontOfQueue ( Runnable r ) { return sendMessageAtFrontOfQueue ( getPostMessage ( r ) ) ; } 
public static String format ( final Iterable < ? extends NameValuePair > parameters , final Charset charset ) { final StringBuilder result = new StringBuilder ( ) ; for ( final NameValuePair parameter : parameters ) { final String encodedName = encodeFormFields ( parameter . getName ( ) , charset ) ; final String encodedValue = encodeFormFields ( parameter . getValue ( ) , charset ) ; if ( result . length ( ) > 0 ) { result . append ( PARAMETER_SEPARATOR ) ; } result . append ( encodedName ) ; if ( encodedValue != null ) { result . append ( NAME_VALUE_SEPARATOR ) ; result . append ( encodedValue ) ; } } return result . toString ( ) ; } 
public final void replaceStream ( OutputStream replacementStream ) throws IOException { if ( ! isRecoverable ( ) ) { throw new IllegalStateException ( ) ; } if ( this . out == replacementStream ) { return ; } replayBuffer . writeTo ( replacementStream ) ; Util . closeQuietly ( out ) ; out = replacementStream ; } 
public boolean contains ( Object value ) { return containsValue ( value ) ; } 
protected InputStream getStreamFromOtherSource ( String imageUri , Object extra ) throws IOException { throw new UnsupportedOperationException ( String . format ( ERROR_UNSUPPORTED_SCHEME , imageUri ) ) ; } 
private void storeStore ( PrintWriter writer , int indent , Store store ) throws Exception { for ( int i = 0 ; i < indent ; i ++ ) { writer . print ( '-' ) ; } writer . print ( "<Store" ) ; storeAttributes ( writer , store ) ; writer . println ( "/>" ) ; } 
public void saveItemData ( OutputStream output ) throws IOException { ObjectOutputStream stream = new ObjectOutputStream ( output ) ; stream . writeObject ( m_items ) ; stream . writeObject ( m_exclusives ) ; stream . flush ( ) ; } 
public void addSoundEvent ( State event , int resId ) { mSoundMap . put ( event , resId ) ; } 
boolean areACLsEnabled ( ) { return conf . getBoolean ( JobConf . MR_ACLS_ENABLED , false ) ; } 
public static String escape ( String string ) { StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 , len = string . length ( ) ; i < len ; i ++ ) { char c = string . charAt ( i ) ; switch ( c ) { case '&' : sb . append ( "&amp;" ) ; break ; case '<' : sb . append ( "&lt;" ) ; break ; case '>' : sb . append ( "&gt;" ) ; break ; case '"' : sb . append ( "&quot;" ) ; break ; default : sb . append ( c ) ; } } return sb . toString ( ) ; } 
public static Object get ( Object list , int i ) { if ( list == null ) throw new IndexOutOfBoundsException ( ) ; if ( list instanceof List ) return ( ( List ) list ) . get ( i ) ; if ( i == 0 ) return list ; throw new IndexOutOfBoundsException ( ) ; } 
public Shader setShader ( Shader shader ) { int shaderNative = 0 ; if ( shader != null ) shaderNative = shader . native_instance ; native_setShader ( mNativePaint , shaderNative ) ; mShader = shader ; return shader ; } 
public int compareTo ( Object o ) { Name arg = ( Name ) o ; if ( this == arg ) return ( 0 ) ; int labels = labels ( ) ; int alabels = arg . labels ( ) ; int compares = labels > alabels ? alabels : labels ; for ( int i = 1 ; i <= compares ; i ++ ) { int start = offset ( labels - i ) ; int astart = arg . offset ( alabels - i ) ; int length = name [ start ] ; int alength = arg . name [ astart ] ; for ( int j = 0 ; j < length && j < alength ; j ++ ) { int n = lowercase [ ( name [ j + start + 1 ] ) & 0xFF ] - lowercase [ ( arg . name [ j + astart + 1 ] ) & 0xFF ] ; if ( n != 0 ) return ( n ) ; } if ( length != alength ) return ( length - alength ) ; } return ( labels - alabels ) ; } 
public void putAll ( Map < ? extends K , ? extends Double > map ) { Iterator < ? extends Entry < ? extends K , ? extends Double >> it = map . entrySet ( ) . iterator ( ) ; for ( int i = map . size ( ) ; i -- > 0 ; ) { Entry < ? extends K , ? extends Double > e = it . next ( ) ; this . put ( e . getKey ( ) , e . getValue ( ) ) ; } } 
public static void readFile ( String fileName ) { if ( fileName == null ) readStandardInput ( ) ; else { BufferedReader newin ; try { newin = new BufferedReader ( new FileReader ( fileName ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Can't-open-file-"" + fileName + ""-for-input.-" + "(Error-:" + e + ")" ) ; } if ( ! readingStandardInput ) { try { in . close ( ) ; } catch ( Exception e ) { } } in = newin ; readingStandardInput = false ; inputErrorCount = 0 ; inputFileName = fileName ; } } 
static final public DateFormat getInstance ( Calendar cal , ULocale locale ) { return getDateTimeInstance ( cal , SHORT , SHORT , locale ) ; } 
static String compactClassName ( String str ) { return str . replace ( '/' , '.' ) ; } 
public synchronized int getRangeFrom ( Object key ) { Range tmp = ranges . get ( key ) ; return tmp . from ; } 
public static Sdk loadSdk ( String sdkLocation ) { synchronized ( sLock ) { if ( sCurrentSdk != null ) { sCurrentSdk . dispose ( ) ; sCurrentSdk = null ; } final ArrayList < String > logMessages = new ArrayList < String > ( ) ; ISdkLog log = new ISdkLog ( ) { public void error ( Throwable throwable , String errorFormat , Object ... arg ) { if ( errorFormat != null ) { logMessages . add ( String . format ( "Error:-" + errorFormat , arg ) ) ; } if ( throwable != null ) { logMessages . add ( throwable . getMessage ( ) ) ; } } public void warning ( String warningFormat , Object ... arg ) { logMessages . add ( String . format ( "Warning:-" + warningFormat , arg ) ) ; } public void printf ( String msgFormat , Object ... arg ) { logMessages . add ( String . format ( msgFormat , arg ) ) ; } } ; SdkManager manager = SdkManager . createManager ( sdkLocation , log ) ; if ( manager != null ) { AvdManager avdManager = null ; try { avdManager = new AvdManager ( manager , log ) ; } catch ( AndroidLocationException e ) { log . error ( e , "Error-parsing-the-AVDs" ) ; } sCurrentSdk = new Sdk ( manager , avdManager ) ; return sCurrentSdk ; } else { StringBuilder sb = new StringBuilder ( "Error-Loading-the-SDK:-" ) ; for ( String msg : logMessages ) { sb . append ( '|n' ) ; sb . append ( msg ) ; } AdtPlugin . displayError ( "Android-SDK" , sb . toString ( ) ) ; } return null ; } } 
public static String referenceToString ( Object obj , DOM dom ) { if ( obj instanceof String ) { return ( String ) obj ; } else if ( obj instanceof DTMAxisIterator ) { return dom . getStringValueX ( ( ( DTMAxisIterator ) obj ) . reset ( ) . next ( ) ) ; } else if ( obj instanceof Node ) { return dom . getStringValueX ( ( ( Node ) obj ) . node ) ; } else if ( obj instanceof DOM ) { return ( ( DOM ) obj ) . getStringValue ( ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , className , String . class ) ; return null ; } } 
public static void randomBytes ( byte [ ] buffer ) { if ( secureRandom == null ) { throw new RuntimeException ( "SecureRandom-not-instantiated!" ) ; } secureRandom . nextBytes ( buffer ) ; } 
public QName get ( String localName ) { if ( uri != null && uri . length ( ) > 0 ) { if ( prefix != null ) { return new QName ( uri , localName , prefix ) ; } else { return new QName ( uri , localName ) ; } } else { return new QName ( localName ) ; } } 
public void setTimeToLive ( int ttl ) throws IOException { mSocket . setTimeToLive ( ttl ) ; } 
public boolean isBoundary ( int offset ) { return wrapped . isBoundary ( offset ) ; } 
private static int [ ] WindowsRegQueryInfoKey1 ( int hKey ) { int [ ] result = WindowsRegQueryInfoKey ( hKey ) ; if ( result [ ERROR_CODE ] == ERROR_SUCCESS ) { return result ; } else { long sleepTime = INIT_SLEEP_TIME ; for ( int i = 0 ; i < MAX_ATTEMPTS ; i ++ ) { try { Thread . sleep ( sleepTime ) ; } catch ( InterruptedException e ) { return result ; } sleepTime *= 2 ; result = WindowsRegQueryInfoKey ( hKey ) ; if ( result [ ERROR_CODE ] == ERROR_SUCCESS ) { return result ; } } } return result ; } 
public com . google . protobuf . ByteString getNameBytes ( ) { java . lang . Object ref = name_ ; if ( ref instanceof java . lang . String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; name_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public Iterator < String > getInstructions ( ) { synchronized ( instructions ) { return Collections . unmodifiableList ( new ArrayList < String > ( instructions ) ) . iterator ( ) ; } } 
public static final String [ ] getCopy ( String [ ] array ) { if ( array == null ) { return null ; } String [ ] copy = new String [ array . length ] ; System . arraycopy ( array , 0 , copy , 0 , array . length ) ; return copy ; } 
protected final Statement getSelectStatement ( final Connection connection ) throws DaoException { try { final Statement statement = connection . createStatement ( ResultSet . TYPE_FORWARD_ONLY , ResultSet . CONCUR_READ_ONLY ) ; return statement ; } catch ( SQLException sqle ) { LOG . fatal ( CANNOT_GET_SQL_STATEMENT , sqle ) ; throw new DaoException ( CANNOT_GET_SQL_STATEMENT , sqle ) ; } } 
public QueryFileChooser addFileChooser ( String name , String label , String defaultName , URI base , File startingDirectory , boolean allowFiles , boolean allowDirectories , boolean save , Color background , Color foreground ) { JLabel lbl = new JLabel ( label + ":-" ) ; lbl . setBackground ( _background ) ; QueryFileChooser fileChooser = new QueryFileChooser ( this , name , defaultName , base , startingDirectory , allowFiles , allowDirectories , save , background , foreground ) ; _addPair ( name , lbl , fileChooser , fileChooser ) ; return fileChooser ; } 
public static byte [ ] serialize ( Serializable p_serObj ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( baos ) ; oos . writeObject ( p_serObj ) ; oos . flush ( ) ; return baos . toByteArray ( ) ; } 
protected int addInnerLoad ( LOInnerLoad load ) { List < Operator > sources = foreachInnerPlan . getSources ( ) ; if ( sources != null ) { for ( int i = 0 ; i < sources . size ( ) ; i ++ ) { if ( operatorsAreEqual ( sources . get ( i ) , load ) ) { return i ; } } } foreachInnerPlan . add ( load ) ; foreachInnerPlan . connect ( load , generate ) ; return foreachInnerPlan . getSources ( ) . size ( ) - 1 ; } 
public float getTextRunAdvances ( char [ ] chars , int index , int count , int contextIndex , int contextCount , int flags , float [ ] advances , int advancesIndex ) { return getTextRunAdvances ( chars , index , count , contextIndex , contextCount , flags , advances , advancesIndex , 0 ) ; } 
public int compareTo ( Integer object ) { return compare ( value , object . value ) ; } 
public int clusterInstance ( Instance instance ) throws Exception { Instance inst = null ; if ( ! m_dontReplaceMissing ) { m_ReplaceMissingFilter . input ( instance ) ; m_ReplaceMissingFilter . batchFinished ( ) ; inst = m_ReplaceMissingFilter . output ( ) ; } else { inst = instance ; } return clusterProcessedInstance ( inst , false , true ) ; } 
public Builder withSelection ( String selection , String [ ] selectionArgs ) { if ( mType != TYPE_UPDATE && mType != TYPE_DELETE && mType != TYPE_ASSERT ) { throw new IllegalArgumentException ( "only-updates,-deletes,-and-asserts-can-have-selections" ) ; } mSelection = selection ; if ( selectionArgs == null ) { mSelectionArgs = null ; } else { mSelectionArgs = new String [ selectionArgs . length ] ; System . arraycopy ( selectionArgs , 0 , mSelectionArgs , 0 , selectionArgs . length ) ; } return this ; } 
public SKOSObjectPropertyOld getInverseProperty ( ) { return inverseProperties . get ( this ) ; } 
public static Media [ ] getAssociatedAttributeArray ( Set set ) { MediaSupported tmp ; Media tmp2 ; ArrayList result = new ArrayList ( ) ; Iterator it = set . iterator ( ) ; while ( it . hasNext ( ) ) { tmp = ( MediaSupported ) it . next ( ) ; tmp2 = ( Media ) IppUtilities . getEnumAttribute ( "media" , tmp . toString ( ) ) ; if ( tmp2 != null ) result . add ( tmp2 ) ; } return ( Media [ ] ) result . toArray ( new Media [ result . size ( ) ] ) ; } 
@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "{" ) ; if ( getInstanceId ( ) != null ) sb . append ( "InstanceId:-" + getInstanceId ( ) ) ; sb . append ( "}" ) ; return sb . toString ( ) ; } 
public boolean addService ( Class serviceClass , BeanContextServiceProvider bcsp ) { return addService ( serviceClass , bcsp , true ) ; } 
public static void startWithFragment ( Context context , String fragmentName , Bundle args , Fragment resultTo , int resultRequestCode , String titleResPackageName , int titleResId , CharSequence title ) { startWithFragment ( context , fragmentName , args , resultTo , resultRequestCode , titleResPackageName , titleResId , title , false ) ; } 
public static final Optional < String > toString ( final AnnotatedLogMessage message , final @ Nullable Level level ) { final @ NonNull Level logLevel = ( level != null ) ? level : Level . INFO ; final Level messageLevel = getEffectiveLevel ( message ) ; if ( ! isLoggable ( messageLevel , logLevel ) ) return Optional . empty ( ) ; final StringBuffer sb = new StringBuffer ( ) ; sb . append ( message . getAnnotatedLogMessage ( ) ) ; boolean first = true ; for ( Map . Entry < Level , List < Map . Entry < String , Object >>> levelAnnotations : message . getLogMessageAnnotations ( ) . entrySet ( ) ) { if ( ! isLoggable ( levelAnnotations . getKey ( ) , logLevel ) ) continue ; for ( Map . Entry < String , Object > annotation : levelAnnotations . getValue ( ) ) { if ( ( first ) && ( sb . length ( ) > 0 ) ) sb . append ( '-' ) ; sb . append ( '[' ) ; sb . append ( annotation . getKey ( ) ) ; sb . append ( "='" ) ; sb . append ( String . valueOf ( annotation . getValue ( ) ) . replace ( "|" , "||" ) . replace ( "'" , "|'" ) ) ; sb . append ( "']" ) ; first = false ; } } return Optional . of ( sb . toString ( ) ) ; } 
public static String wrap ( String str , int wrapLength , String newLineStr , boolean wrapLongWords ) { if ( str == null ) { return null ; } if ( newLineStr == null ) { newLineStr = SystemUtils . LINE_SEPARATOR ; } if ( wrapLength < 1 ) { wrapLength = 1 ; } int inputLineLength = str . length ( ) ; int offset = 0 ; StringBuffer wrappedLine = new StringBuffer ( inputLineLength + 32 ) ; while ( ( inputLineLength - offset ) > wrapLength ) { if ( str . charAt ( offset ) == '-' ) { offset ++ ; continue ; } int spaceToWrapAt = str . lastIndexOf ( '-' , wrapLength + offset ) ; if ( spaceToWrapAt >= offset ) { wrappedLine . append ( str . substring ( offset , spaceToWrapAt ) ) ; wrappedLine . append ( newLineStr ) ; offset = spaceToWrapAt + 1 ; } else { if ( wrapLongWords ) { wrappedLine . append ( str . substring ( offset , wrapLength + offset ) ) ; wrappedLine . append ( newLineStr ) ; offset += wrapLength ; } else { spaceToWrapAt = str . indexOf ( '-' , wrapLength + offset ) ; if ( spaceToWrapAt >= 0 ) { wrappedLine . append ( str . substring ( offset , spaceToWrapAt ) ) ; wrappedLine . append ( newLineStr ) ; offset = spaceToWrapAt + 1 ; } else { wrappedLine . append ( str . substring ( offset ) ) ; offset = inputLineLength ; } } } } wrappedLine . append ( str . substring ( offset ) ) ; return wrappedLine . toString ( ) ; } 
private void commit ( final boolean close ) { if ( ! close && ( intermediateBatchSize == 0L || counter . get ( ) . incrementAndGet ( ) % intermediateBatchSize != 0 ) ) return ; if ( null != graph ) { if ( graph . features ( ) . graph ( ) . supportsTransactions ( ) ) { LOGGER . info ( "Committing-transaction-on-Graph-instance:-{}-[{}]" , graph , counter . get ( ) . get ( ) ) ; try { graph . tx ( ) . commit ( ) ; LOGGER . debug ( "Committed-transaction-on-Graph-instance:-{}" , graph ) ; } catch ( Exception e ) { LOGGER . error ( "Failed-to-commit-transaction-on-Graph-instance:-{}" , graph ) ; graph . tx ( ) . rollback ( ) ; throw e ; } } if ( close ) { try { graph . close ( ) ; LOGGER . info ( "Closed-Graph-instance:-{}" , graph ) ; graph = null ; } catch ( Exception e ) { LOGGER . warn ( "Failed-to-close-Graph-instance" , e ) ; } } } } 
protected void fireTreeNodesInserted ( Object source , Object [ ] path , int [ ] childIndices , Object [ ] children ) { Object [ ] listeners = listenerList . getListenerList ( ) ; TreeModelEvent e = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == TreeModelListener . class ) { if ( e == null ) e = new TreeModelEvent ( source , path , childIndices , children ) ; ( ( TreeModelListener ) listeners [ i + 1 ] ) . treeNodesInserted ( e ) ; } } } 
protected String trimString ( String s , int length ) { if ( ( length > 0 ) && ( s . length ( ) > length ) ) { return s . substring ( 0 , length ) ; } else { return s ; } } 
public int getLengths ( int index ) { return lengths_ . get ( index ) ; } 
public static final Date parseXMPPDateTime ( final String dateTime ) { final String date = dateTime . endsWith ( "Z" ) ? dateTime . substring ( 0 , dateTime . length ( ) - 1 ) + "GMT" : dateTime ; try { return dtf . parse ( date ) ; } catch ( final IllegalArgumentException e ) { logger . warning ( "Cannot-parse-date-time-'" + date + "'-with-normal-pattern" ) ; return noMillisDtf . parse ( date ) ; } } 
public int percentToColorIndex ( double percent ) { double index = percent * colorList . size ( ) ; return Math . min ( Math . max ( 0 , ( int ) index ) , colorList . size ( ) - 1 ) ; } 
public static void enableDefaults ( ) { StrictMode . setThreadPolicy ( new StrictMode . ThreadPolicy . Builder ( ) . detectAll ( ) . penaltyLog ( ) . build ( ) ) ; StrictMode . setVmPolicy ( new StrictMode . VmPolicy . Builder ( ) . detectAll ( ) . penaltyLog ( ) . build ( ) ) ; } 
@ Override public void changeCursor ( Cursor c ) { if ( DBG ) Log . d ( LOG_TAG , "changeCursor(" + c + ")" ) ; if ( mClosed ) { Log . w ( LOG_TAG , "Tried-to-change-cursor-after-adapter-was-closed." ) ; if ( c != null ) c . close ( ) ; return ; } try { super . changeCursor ( c ) ; if ( c != null ) { mText1Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_TEXT_1 ) ; mText2Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_TEXT_2 ) ; mText2UrlCol = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_TEXT_2_URL ) ; mIconName1Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_ICON_1 ) ; mIconName2Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_ICON_2 ) ; mFlagsCol = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_FLAGS ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , "error-changing-cursor-and-caching-columns" , e ) ; } } 
public void setScheme ( String scheme ) { if ( scheme . compareToIgnoreCase ( SIP ) != 0 && scheme . compareToIgnoreCase ( SIPS ) != 0 ) throw new IllegalArgumentException ( "bad-scheme-" + scheme ) ; this . scheme = scheme . toLowerCase ( ) ; } 
private List < String > getOutputFields ( SimpleSearchPerimeter simpleSearchPerimeter ) { List < String > outputFields = null ; if ( simpleSearchPerimeter . equals ( SimpleSearchPerimeter . EXTRACT ) ) { outputFields = new ArrayList < String > ( 6 ) ; outputFields . add ( "Sender" ) ; outputFields . add ( "Recipient" ) ; outputFields . add ( "Date" ) ; outputFields . add ( "Sender-Location" ) ; outputFields . add ( "Recipient-Location" ) ; outputFields . add ( "Volume-<br-/>-(Ins/Pa)-<br-/>-Folio" ) ; outputFields . add ( "Document-Transcription" ) ; } else if ( simpleSearchPerimeter . equals ( SimpleSearchPerimeter . SYNOPSIS ) ) { outputFields = new ArrayList < String > ( 6 ) ; outputFields . add ( "Sender" ) ; outputFields . add ( "Recipient" ) ; outputFields . add ( "Date" ) ; outputFields . add ( "Sender-Location" ) ; outputFields . add ( "Recipient-Location" ) ; outputFields . add ( "Volume-<br-/>-(Ins/Pa)-<br-/>-Folio" ) ; outputFields . add ( "Document-Synopsis" ) ; } return outputFields ; } 
private long parseUptime ( String up ) { try { return Long . parseLong ( up ) ; } catch ( Exception e ) { return 0 ; } } 
public static int toInt32 ( Object val ) { if ( val instanceof Integer ) return ( ( Integer ) val ) . intValue ( ) ; return toInt32 ( toNumber ( val ) ) ; } 
public boolean hasVertex ( float x , float y ) { if ( points . length == 0 ) { return false ; } checkPoints ( ) ; for ( int i = 0 ; i < points . length ; i += 2 ) { if ( ( points [ i ] == x ) && ( points [ i + 1 ] == y ) ) { return true ; } } return false ; } 
void addAllForTreeSet ( SortedSet < Map . Entry < K , V >> set , V defaultVal ) { try { buildFromSorted ( set . size ( ) , set . iterator ( ) , null , defaultVal ) ; } catch ( java . io . IOException cannotHappen ) { } catch ( ClassNotFoundException cannotHappen ) { } } 
public byte [ ] toByteArray ( ) { byte [ ] b = new byte [ this . len ] ; if ( this . len > 0 ) { System . arraycopy ( this . buffer , 0 , b , 0 , this . len ) ; } return b ; } 
public void paintFormattedTextFieldBorder ( SynthContext context , Graphics g , int x , int y , int w , int h ) { if ( context . getComponent ( ) . getComponentOrientation ( ) . isLeftToRight ( ) ) { paintBorder ( context , g , x , y , w , h , null ) ; } else { AffineTransform transform = new AffineTransform ( ) ; transform . translate ( x , y ) ; transform . scale ( - 1 , 1 ) ; transform . translate ( - w , 0 ) ; paintBorder ( context , g , 0 , 0 , w , h , transform ) ; } } 
private static List computeUniqueCatchList ( Class [ ] exceptions ) { List uniqueList = new ArrayList ( ) ; uniqueList . add ( Error . class ) ; uniqueList . add ( RuntimeException . class ) ; nextException : for ( int i = 0 ; i < exceptions . length ; i ++ ) { Class ex = exceptions [ i ] ; if ( ex . isAssignableFrom ( Throwable . class ) ) { uniqueList . clear ( ) ; break ; } else if ( ! Throwable . class . isAssignableFrom ( ex ) ) { continue ; } for ( int j = 0 ; j < uniqueList . size ( ) ; ) { Class ex2 = ( Class ) uniqueList . get ( j ) ; if ( ex2 . isAssignableFrom ( ex ) ) { continue nextException ; } else if ( ex . isAssignableFrom ( ex2 ) ) { uniqueList . remove ( j ) ; } else { j ++ ; } } uniqueList . add ( ex ) ; } return uniqueList ; } 
protected BaseAbstractUnivariateIntegrator ( final double relativeAccuracy , final double absoluteAccuracy , final int minimalIterationCount , final int maximalIterationCount ) throws NotStrictlyPositiveException , NumberIsTooSmallException { this . relativeAccuracy = relativeAccuracy ; this . absoluteAccuracy = absoluteAccuracy ; if ( minimalIterationCount <= 0 ) { throw new NotStrictlyPositiveException ( minimalIterationCount ) ; } if ( maximalIterationCount <= minimalIterationCount ) { throw new NumberIsTooSmallException ( maximalIterationCount , minimalIterationCount , false ) ; } this . minimalIterationCount = minimalIterationCount ; this . iterations = new Incrementor ( ) ; iterations . setMaximalCount ( maximalIterationCount ) ; evaluations = new Incrementor ( ) ; } 
private long computeAge ( long nowMillis ) { long apparentReceivedAge = servedDate != null ? Math . max ( 0 , receivedResponseMillis - servedDate . getTime ( ) ) : 0 ; long receivedAge = ageSeconds != - 1 ? Math . max ( apparentReceivedAge , TimeUnit . SECONDS . toMillis ( ageSeconds ) ) : apparentReceivedAge ; long responseDuration = receivedResponseMillis - sentRequestMillis ; long residentDuration = nowMillis - receivedResponseMillis ; return receivedAge + responseDuration + residentDuration ; } 
public boolean hasSameRules ( TimeZone timeZone ) { if ( timeZone == null ) { return false ; } return getRawOffset ( ) == timeZone . getRawOffset ( ) ; } 
public boolean isWrapperFor ( Class iface ) throws SQLException { return iface . isInstance ( this ) ; } 
public static boolean isNullType ( String shapeType ) { if ( shapeType == null ) { String message = Logging . getMessage ( "nullValue.ShapeType" ) ; Logging . logger ( ) . severe ( message ) ; throw new IllegalArgumentException ( message ) ; } return shapeType . equals ( Shapefile . SHAPE_NULL ) ; } 
public static int replaceAll ( JTextArea textArea , String toFind , String replaceWith , boolean matchCase , boolean wholeWord , boolean regex ) throws PatternSyntaxException { int count = 0 ; if ( regex ) { StringBuffer sb = new StringBuffer ( ) ; String findIn = textArea . getText ( ) ; int lastEnd = 0 ; Pattern p = Pattern . compile ( toFind ) ; Matcher m = p . matcher ( findIn ) ; try { while ( m . find ( ) ) { sb . append ( findIn . substring ( lastEnd , m . start ( ) ) ) ; sb . append ( getReplacementText ( m , replaceWith ) ) ; lastEnd = m . end ( ) ; count ++ ; } sb . append ( findIn . substring ( lastEnd ) ) ; textArea . setText ( sb . toString ( ) ) ; } finally { findIn = null ; } } else { textArea . setCaretPosition ( 0 ) ; while ( SearchEngine . find ( textArea , toFind , true , matchCase , wholeWord , false ) ) { textArea . replaceSelection ( replaceWith ) ; count ++ ; } } return count ; } 
public @ NonNull ContentProviderResult [ ] applyBatch ( @ NonNull ArrayList < ContentProviderOperation > operations ) throws OperationApplicationException { final int numOperations = operations . size ( ) ; final ContentProviderResult [ ] results = new ContentProviderResult [ numOperations ] ; for ( int i = 0 ; i < numOperations ; i ++ ) { results [ i ] = operations . get ( i ) . apply ( this , results , i ) ; } return results ; } 
public synchronized void addChangeListener ( javax . swing . event . ChangeListener listener ) { if ( changeListenerList == null ) { changeListenerList = new java . util . ArrayList ( ) ; } changeListenerList . add ( listener ) ; } 
public void uninstallUI ( JComponent c ) { editor . removePropertyChangeListener ( updateHandler ) ; editor . getDocument ( ) . removeDocumentListener ( updateHandler ) ; painted = false ; uninstallDefaults ( ) ; rootView . setView ( null ) ; c . removeAll ( ) ; LayoutManager lm = c . getLayout ( ) ; if ( lm instanceof UIResource ) { c . setLayout ( null ) ; } uninstallKeyboardActions ( ) ; uninstallListeners ( ) ; editor = null ; } 
public StringBuffer insert ( int offset , double d ) { return insert ( offset , String . valueOf ( d ) ) ; } 
private boolean hasBadChars ( String value ) { char [ ] chars = value . toCharArray ( ) ; int size = chars . length ; for ( int i = 0 ; i < size ; i ++ ) { char ch = chars [ i ] ; if ( ch < 32 || 126 < ch || ch == '<' || ch == '>' || ch == '&' || ch == '|"' ) return true ; } return false ; } 
private boolean equals ( String aName , EventListener a , EventListener b ) { while ( b instanceof PropertyChangeListenerProxy ) { PropertyChangeListenerProxy bProxy = ( PropertyChangeListenerProxy ) b ; String bName = bProxy . getPropertyName ( ) ; b = bProxy . getListener ( ) ; if ( aName == null ) { if ( ! ( a instanceof PropertyChangeListenerProxy ) ) { return false ; } PropertyChangeListenerProxy aProxy = ( PropertyChangeListenerProxy ) a ; aName = aProxy . getPropertyName ( ) ; a = aProxy . getListener ( ) ; } if ( ! Objects . equal ( aName , bName ) ) { return false ; } aName = null ; } return aName == null && Objects . equal ( a , b ) ; } 
public static Long getLong ( String string , Long defaultValue ) { if ( string == null || string . length ( ) == 0 ) { return defaultValue ; } String prop = System . getProperty ( string ) ; if ( prop == null ) { return defaultValue ; } try { return decode ( prop ) ; } catch ( NumberFormatException ex ) { return defaultValue ; } } 
public synchronized int read ( byte b [ ] , int off , int len ) throws IOException { ensureOpen ( ) ; Arrays . boundsCheck ( b . length , off , len ) ; if ( len == 0 ) { return 0 ; } int n = read1 ( b , off , len ) ; if ( n <= 0 ) return n ; while ( ( n < len ) && ( in . available ( ) > 0 ) ) { int n1 = read1 ( b , off + n , len - n ) ; if ( n1 <= 0 ) break ; n += n1 ; } return n ; } 
@ XmlElementDecl ( namespace = "http://www.xbrl.org/tw/fr/gaap/tw-gaap-bd-2010-03-31" , name = "AllowanceBadDebtsOtherReceivablesRelatedParties" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < MonetaryItemType > createAllowanceBadDebtsOtherReceivablesRelatedParties ( MonetaryItemType value ) { return new JAXBElement < MonetaryItemType > ( _AllowanceBadDebtsOtherReceivablesRelatedParties_QNAME , MonetaryItemType . class , null , value ) ; } 
public void rejectedExecution ( Runnable r , ThreadPoolExecutor e ) { if ( ! e . isShutdown ( ) ) { e . getQueue ( ) . poll ( ) ; e . execute ( r ) ; } } 
public DeviceStatus getDeviceStatus ( String deviceId ) { DeviceStatus get = myDeviceStatuses . get ( deviceId ) ; return get ; } 
public OutputStream newDeflaterOutputStream ( OutputStream out , Deflater deflater , boolean syncFlush ) { try { Constructor < DeflaterOutputStream > constructor = deflaterConstructor ; if ( constructor == null ) { constructor = deflaterConstructor = DeflaterOutputStream . class . getConstructor ( OutputStream . class , Deflater . class , boolean . class ) ; } return constructor . newInstance ( out , deflater , syncFlush ) ; } catch ( NoSuchMethodException e ) { throw new UnsupportedOperationException ( "Cannot-SPDY;-no-SYNC_FLUSH-available" ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) instanceof RuntimeException ? ( RuntimeException ) e . getCause ( ) : new RuntimeException ( e . getCause ( ) ) ; } catch ( InstantiationException e ) { throw new RuntimeException ( e ) ; } catch ( IllegalAccessException e ) { throw new AssertionError ( ) ; } } 
public Iterator < GCEvent > getGCEvents ( ) { return gcEvents . iterator ( ) ; } 
protected void refreshButtons ( ) { displVisibility . setSelection ( ( propertyValue & ICustomAppearence . DISP_VISIBILITY ) == ICustomAppearence . DISP_VISIBILITY ) ; displDerive . setSelection ( ( propertyValue & ICustomAppearence . DISP_DERIVE ) == ICustomAppearence . DISP_DERIVE ) ; displName . setSelection ( ( propertyValue & ICustomAppearence . DISP_NAME ) == ICustomAppearence . DISP_NAME ) ; displType . setSelection ( ( propertyValue & ICustomAppearence . DISP_TYPE ) == ICustomAppearence . DISP_TYPE ) ; displMutliplicity . setSelection ( ( propertyValue & ICustomAppearence . DISP_MULTIPLICITY ) == ICustomAppearence . DISP_MULTIPLICITY ) ; displDfltValue . setSelection ( ( propertyValue & ICustomAppearence . DISP_DFLT_VALUE ) == ICustomAppearence . DISP_DFLT_VALUE ) ; displModifiers . setSelection ( ( propertyValue & ICustomAppearence . DISP_MOFIFIERS ) == ICustomAppearence . DISP_MOFIFIERS ) ; } 
public static void print ( int x ) { out . print ( x ) ; out . flush ( ) ; } 
public EjbMethodPattern < X > getMethodPattern ( AnnotatedMethod < ? > method , String intf ) { EjbMethodPattern < X > bestMethod = null ; int bestCost = - 1 ; for ( int i = 0 ; i < _methodList . size ( ) ; i ++ ) { EjbMethodPattern < X > ejbMethod = _methodList . get ( i ) ; MethodSignature sig = ejbMethod . getSignature ( ) ; if ( sig . isMatch ( method , intf ) && bestCost < sig . getCost ( ) ) { bestMethod = ejbMethod ; bestCost = sig . getCost ( ) ; } } return bestMethod ; } 
public void clear ( ) { getProps ( ) . clear ( ) ; getOverlay ( ) . clear ( ) ; } 
public long toMillis ( ) { return systemDur . toMillis ( ) ; } 
public List < CustomPortletModeType < PortletDescriptor >> getAllCustomPortletMode ( ) { List < CustomPortletModeType < PortletDescriptor >> list = new ArrayList < CustomPortletModeType < PortletDescriptor >> ( ) ; List < Node > nodeList = model . get ( "custom-portlet-mode" ) ; for ( Node node : nodeList ) { CustomPortletModeType < PortletDescriptor > type = new CustomPortletModeTypeImpl < PortletDescriptor > ( this , "custom-portlet-mode" , model , node ) ; list . add ( type ) ; } return list ; } 
public static void minusTest ( ) { for ( int i = 0 ; i < TestComplex . MINUS_LOOP_COUNTER ; i ++ ) { double a = Math . random ( ) ; double b = Math . random ( ) ; double c = Math . random ( ) ; double d = Math . random ( ) ; Complex complexNumber = new Complex ( a , b ) ; Complex complexNumbertwo = new Complex ( c , d ) ; Complex complexNumberthree = null ; Complex testMinus = ( complexNumber . minus ( complexNumbertwo ) ) ; if ( ! testMinus . equals ( new Complex ( a - c , b - d ) ) ) { System . out . println ( "minus-test-failed" ) ; } if ( complexNumber . minus ( complexNumberthree ) != null ) { System . out . println ( "minus-test-failed" ) ; } } } 
protected static String readFileContent ( BufferedReader reader ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; String tmp ; while ( ( tmp = reader . readLine ( ) ) != null ) { sb . append ( tmp ) ; } return sb . toString ( ) ; } 
public boolean empty ( ) { return isEmpty ( ) ; } 
private boolean validateOnlyNumbers ( String str ) { if ( ! str . matches ( "^[0-9]+$" ) ) { errorMessage += "Bokstaver-ar-ej-tillatna!" ; return false ; } return true ; } 
static String buildOrWhereString ( String column , int [ ] values ) { StringBuilder selectWhere = new StringBuilder ( ) ; for ( int i = values . length - 1 ; i >= 0 ; i -- ) { selectWhere . append ( column ) . append ( "=" ) . append ( values [ i ] ) ; if ( i > 0 ) { selectWhere . append ( "-OR-" ) ; } } return selectWhere . toString ( ) ; } 
@ Override public long getLastMillisecond ( Calendar calendar ) { int month = Quarter . LAST_MONTH_IN_QUARTER [ this . quarter ] ; int eom = SerialDate . lastDayOfMonth ( month , this . year ) ; calendar . set ( this . year , month - 1 , eom , 23 , 59 , 59 ) ; calendar . set ( Calendar . MILLISECOND , 999 ) ; return calendar . getTimeInMillis ( ) ; } 
public int getGenreSongCount ( String genreName ) { String selection = SONG_GENRE + "=" + "'" + genreName . replace ( "'" , "''" ) + "'" ; Cursor cursor = getDatabase ( ) . query ( MUSIC_LIBRARY_TABLE , null , selection , null , null , null , null ) ; int songCount = cursor . getCount ( ) ; cursor . close ( ) ; return songCount ; } 
public Map getParameterMap ( ) { Hashtable params = new Hashtable ( ) ; Enumeration en = parameter . elements ( ) ; while ( en . hasMoreElements ( ) ) { Parameter param = ( Parameter ) en . nextElement ( ) ; params . put ( param . getName ( ) , param . getValue ( ) ) ; } return params ; } 
private void zzDoEOF ( ) throws java . io . IOException { if ( ! zzEOFDone ) { zzEOFDone = true ; yyclose ( ) ; } } 
public String toString ( ) { int mod = getModifiers ( ) ; return ( ( ( mod == 0 ) ? "" : ( Modifier . toString ( mod ) + "-" ) ) + getTypeName ( getType ( ) ) + "-" + getTypeName ( getDeclaringClass ( ) ) + "." + getName ( ) ) ; } 
public int getEntryBySubEntry ( long k ) { int i = Collections . binarySearch ( numSubEntriesAt , k ) ; if ( i >= 0 ) return i + 1 ; return - i - 1 ; } 
protected void export ( ) throws BuildException { Collection < String > files = reportFilesMap . keySet ( ) ; if ( files != null && files . size ( ) > 0 ) { boolean isError = false ; System . out . println ( "Exporting-" + files . size ( ) + "-report-files." ) ; String srcFileName = null ; String destFileName = null ; File destFileParent = null ; for ( Iterator < String > it = files . iterator ( ) ; it . hasNext ( ) ; ) { srcFileName = it . next ( ) ; destFileName = reportFilesMap . get ( srcFileName ) ; destFileParent = new File ( destFileName ) . getParentFile ( ) ; if ( ! destFileParent . exists ( ) ) { destFileParent . mkdirs ( ) ; } try { System . out . print ( "File-:-" + srcFileName + "-...-" ) ; JasperPrint jasperPrint = ( JasperPrint ) JRLoader . loadObjectFromFile ( srcFileName ) ; JasperExportManager . getInstance ( jasperReportsContext ) . exportToXmlFile ( jasperPrint , destFileName , false ) ; System . out . println ( "OK." ) ; } catch ( JRException e ) { System . out . println ( "FAILED." ) ; System . out . println ( "Error-updating-report-design-:-" + srcFileName ) ; e . printStackTrace ( System . out ) ; isError = true ; } } if ( isError ) { throw new BuildException ( "Errors-were-encountered-when-updating-report-designs." ) ; } } } 
@ XmlElementDecl ( namespace = "http://www.isotc211.org/2005/gmd" , name = "Country" , substitutionHeadNamespace = "http://www.isotc211.org/2005/gco" , substitutionHeadName = "CharacterString" ) public JAXBElement < CodeListValueType > createCountry ( CodeListValueType value ) { return new JAXBElement < CodeListValueType > ( _Country_QNAME , CodeListValueType . class , null , value ) ; } 
public void print ( String value ) { boolean quote = false ; if ( value . length ( ) > 0 ) { char c = value . charAt ( 0 ) ; if ( newLine && ( c < '0' || ( c > '9' && c < 'A' ) || ( c > 'Z' && c < 'a' ) || ( c > 'z' ) ) ) { quote = true ; } if ( c == '-' || c == '|f' || c == '|t' ) { quote = true ; } for ( int i = 0 ; i < value . length ( ) ; i ++ ) { c = value . charAt ( i ) ; if ( c == '"' || c == this . strategy . getDelimiter ( ) || c == '|n' || c == '|r' ) { quote = true ; c = value . charAt ( value . length ( ) - 1 ) ; break ; } } if ( c == '-' || c == '|f' || c == '|t' ) { quote = true ; } } else if ( newLine ) { quote = true ; } if ( newLine ) { newLine = false ; } else { out . print ( this . strategy . getDelimiter ( ) ) ; } if ( quote ) { out . print ( escapeAndQuote ( value ) ) ; } else { out . print ( value ) ; } out . flush ( ) ; } 
private String deriveNestedProperty ( ) { Object idObj = pageContext . getAttribute ( id ) ; if ( idObj instanceof Map . Entry ) { return nesting + "(" + ( ( Map . Entry ) idObj ) . getKey ( ) + ")" ; } else { return nesting + "[" + this . getIndex ( ) + "]" ; } } 
protected boolean deriveProcessEnvironment ( HttpServletRequest req ) { Hashtable envp = new Hashtable ( ) ; command = getCommand ( ) ; if ( command != null ) { workingDirectory = new File ( command . substring ( 0 , command . lastIndexOf ( File . separator ) ) ) ; envp . put ( "X_TOMCAT_COMMAND_PATH" , command ) ; } this . env = envp ; return true ; } 
private String getModifiersString ( ) { String strMod = "" ; if ( shiftDown ( ) ) { strMod += ",shift" ; } if ( controlDown ( ) ) { strMod += ",control" ; } if ( metaDown ( ) ) { strMod += ",meta" ; } return strMod ; } 
@ Override public float getFloatValue ( String columnName ) { for ( int i = 0 ; i < values . size ( ) ; i ++ ) { if ( values . get ( i ) . getName ( ) . equals ( columnName ) ) { return Float . parseFloat ( values . get ( i ) . getValue ( ) ) ; } } return 0 ; } 
public void addProcessListener ( ProcessListener theProcessListener ) { ped_ProcessListenerList . add ( theProcessListener ) ; } 
private static String doReplacements ( StringBuffer sb , Map < String , String > replacements ) { if ( ! replacements . containsKey ( "datetime" ) ) replacements . put ( "datetime" , new Date ( ) . toString ( ) ) ; if ( ! replacements . containsKey ( "siteurl" ) ) replacements . put ( "siteurl" , AppServerConstants . getSiteUrl ( ) ) ; if ( ! replacements . containsKey ( "techcontactname" ) ) replacements . put ( "techcontactname" , AppServerConstants . getTechContactName ( ) ) ; if ( ! replacements . containsKey ( "techcontactemail" ) ) replacements . put ( "techcontactemail" , AppServerConstants . getTechContactName ( ) ) ; if ( ! replacements . containsKey ( "techcontact" ) ) replacements . put ( "techcontact" , AppServerConstants . getTechContactName ( ) ) ; replacements . put ( "allparms" , replacements . toString ( ) ) ; int idx = 0 ; while ( idx >= 0 && idx < sb . length ( ) ) { idx = sb . indexOf ( AppServerConstants . REPLACEMENT_START , idx ) ; if ( idx < 0 ) { break ; } int end = sb . indexOf ( AppServerConstants . REPLACEMENT_END , idx + 2 ) ; if ( end < 0 ) { break ; } String key = sb . substring ( idx + 2 , end ) ; if ( replacements . containsKey ( key ) ) { sb . replace ( idx , end + 2 , replacements . get ( key ) ) ; idx = idx + replacements . get ( key ) . length ( ) ; } else { idx = end + 2 ; } } return sb . toString ( ) ; } 
public void runTestOnUiThread ( final Runnable r ) throws Throwable { final Throwable [ ] exceptions = new Throwable [ 1 ] ; getInstrumentation ( ) . runOnMainSync ( new Runnable ( ) { public void run ( ) { try { r . run ( ) ; } catch ( Throwable throwable ) { exceptions [ 0 ] = throwable ; } } } ) ; if ( exceptions [ 0 ] != null ) { throw exceptions [ 0 ] ; } } 
public Collection < PKCS10Attribute > getAttributes ( ) { return ( Collections . unmodifiableCollection ( map . values ( ) ) ) ; } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; elementList . add ( new javax . xml . namespace . QName ( "http://s3.amazonaws.com/doc/2006-03-01/" , "Owner" ) ) ; if ( localOwner == null ) { throw new org . apache . axis2 . databinding . ADBException ( "Owner-cannot-be-null!!" ) ; } elementList . add ( localOwner ) ; elementList . add ( new javax . xml . namespace . QName ( "http://s3.amazonaws.com/doc/2006-03-01/" , "AccessControlList" ) ) ; if ( localAccessControlList == null ) { throw new org . apache . axis2 . databinding . ADBException ( "AccessControlList-cannot-be-null!!" ) ; } elementList . add ( localAccessControlList ) ; return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
public static Image loadFromResource ( String imageName , Class cls ) { try { final URL url = cls . getResource ( imageName ) ; if ( url == null ) { return null ; } Image image = ( Image ) imageCache . get ( url . toString ( ) ) ; if ( image == null ) { image = Toolkit . getDefaultToolkit ( ) . createImage ( url ) ; imageCache . put ( url . toString ( ) , image ) ; } return image ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } 
public static Position of ( int x , int y , int height ) { return new Position ( x , y , height ) ; } 
public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ComboBoxDemo . class . getAnnotation ( DemoProperties . class ) . value ( ) ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . getContentPane ( ) . add ( new ComboBoxDemo ( ) ) ; frame . setPreferredSize ( new Dimension ( 800 , 600 ) ) ; frame . pack ( ) ; frame . setLocationRelativeTo ( null ) ; frame . setVisible ( true ) ; } 
private ThreadPool getThreadPoolInstance ( ) { ThreadPool threadPoolInstance ; if ( isUsingGhostScript ) { threadPoolInstance = ThreadPool . getInstanceForGhostScript ( ) ; } else { threadPoolInstance = ThreadPool . getInstance ( ) ; } return threadPoolInstance ; } 
public Name add ( int posn , String comp ) throws InvalidNameException { impl . add ( posn , comp ) ; return this ; } 
public void addDragDetectListener ( DragDetectListener listener ) { checkWidget ( ) ; DragDetectEvent . addListener ( this , listener ) ; } 
private void replace ( String name ) { String value = filter . replace ( name ) ; if ( value == null ) { text . append ( "${" ) ; text . append ( name ) ; text . append ( "}" ) ; } else { text . append ( value ) ; } } 
public static void setProperty ( String name , String value ) { if ( manager == null ) { synchronized ( managerLock ) { if ( manager == null ) { manager = new PropertyManager ( propsName ) ; } } } manager . setProp ( name , value ) ; } 
private int enumerationSize ( Enumeration < Object > anEnumeration ) { int counter = 0 ; while ( anEnumeration . hasMoreElements ( ) ) { anEnumeration . nextElement ( ) ; counter ++ ; } return counter ; } 
public void writeByte ( int value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeByte ( value ) ; } 
public void append ( final char [ ] b , int off , int len ) { if ( b == null ) { return ; } if ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) < 0 ) || ( ( off + len ) > b . length ) ) { throw new IndexOutOfBoundsException ( "off:-" + off + "-len:-" + len + "-b.length:-" + b . length ) ; } if ( len == 0 ) { return ; } int newlen = this . len + len ; if ( newlen > this . buffer . length ) { expand ( newlen ) ; } System . arraycopy ( b , off , this . buffer , this . len , len ) ; this . len = newlen ; } 
@ SuppressWarnings ( "unchecked" ) public static < T > T doAsPrivileged ( Subject subject , PrivilegedAction < T > action , AccessControlContext context ) { if ( context == null ) { return doAs_PrivilegedAction ( subject , action , new AccessControlContext ( new ProtectionDomain [ 0 ] ) ) ; } return doAs_PrivilegedAction ( subject , action , context ) ; } 
public double getNestedListWeight ( final String nestedListName ) { if ( mNestedListWeights == null ) { return 0 ; } Double weight = mNestedListWeights . get ( nestedListName ) ; return weight == null ? 0 : weight ; } 
public void removeLayoutComponent ( Component component ) { ComponentInfo info = componentInfos . remove ( component ) ; if ( info != null ) { info . dispose ( ) ; springsChanged = true ; isValid = false ; } } 
public void actionPerformed ( ActionEvent e ) { if ( myActionListener != null ) { myActionListener . actionPerformed ( e ) ; } } 
public List < ScanResult > syncGetScanResultsList ( ) { synchronized ( mScanResultCache ) { List < ScanResult > scanList = new ArrayList < ScanResult > ( ) ; for ( ScanResult result : mScanResults ) { scanList . add ( new ScanResult ( result ) ) ; } return scanList ; } } 
public final int decrementAndGet ( int i ) { return addAndGet ( i , - 1 ) ; } 
public DataInputStream next ( LogKey key ) throws IOException { if ( ! this . atBeginning ) { this . scanner . advance ( ) ; } else { this . atBeginning = false ; } if ( this . scanner . atEnd ( ) ) { return null ; } TFile . Reader . Scanner . Entry entry = this . scanner . entry ( ) ; key . readFields ( entry . getKeyStream ( ) ) ; if ( RESERVED_KEYS . containsKey ( key . toString ( ) ) ) { return next ( key ) ; } DataInputStream valueStream = entry . getValueStream ( ) ; return valueStream ; } 
@ Override public boolean graphBaseContains ( Triple t ) { for ( Iterator < Graph > i = m_subGraphs . iterator ( ) ; i . hasNext ( ) ; ) if ( i . next ( ) . contains ( t ) ) return true ; return false ; } 
public static String [ ] getCorruptFiles ( DistributedFileSystem dfs ) throws IOException { Set < String > corruptFiles = new HashSet < String > ( ) ; RemoteIterator < Path > cfb = dfs . listCorruptFileBlocks ( new Path ( "/" ) ) ; while ( cfb . hasNext ( ) ) { corruptFiles . add ( cfb . next ( ) . toUri ( ) . getPath ( ) ) ; } return corruptFiles . toArray ( new String [ corruptFiles . size ( ) ] ) ; } 
public static String hexEncode ( byte [ ] b ) { return hexEncode ( b , b . length ) ; } 
protected boolean isKidOK ( Node parent , Node child ) { if ( allowGrammarAccess && parent . getNodeType ( ) == Node . DOCUMENT_TYPE_NODE ) { return child . getNodeType ( ) == Node . ELEMENT_NODE ; } return 0 != ( kidOK [ parent . getNodeType ( ) ] & 1 << child . getNodeType ( ) ) ; } 
public static BigInteger toBigInt ( Number n ) { if ( n instanceof BigInteger ) return ( BigInteger ) n ; else return BigInteger . valueOf ( n . longValue ( ) ) ; } 
public void setBasicPixel ( int x , int y , int rgb ) { bufferedImage . setRGB ( x , y , rgb ) ; } 
private Object [ ] getValuesToInsert ( String number , long date , int duration , int type ) { Object [ ] values = CallLogQueryTestUtils . createTestExtendedValues ( ) ; values [ CallLogQuery . ID ] = mIndex ; values [ CallLogQuery . NUMBER ] = number ; values [ CallLogQuery . DATE ] = date == NOW ? new Date ( ) . getTime ( ) : date ; values [ CallLogQuery . DURATION ] = duration < 0 ? mRnd . nextInt ( 10 * 60 ) : duration ; if ( mVoicemail != null && mVoicemail . equals ( number ) ) { assertEquals ( Calls . OUTGOING_TYPE , type ) ; } values [ CallLogQuery . CALL_TYPE ] = type ; values [ CallLogQuery . COUNTRY_ISO ] = TEST_COUNTRY_ISO ; values [ CallLogQuery . SECTION ] = CallLogQuery . SECTION_OLD_ITEM ; return values ; } 
public static int selectNaive ( long x , int r ) { assert r >= 1 ; int s = - 1 ; while ( ( x != 0L ) && ( r > 0 ) ) { int ntz = Long . numberOfTrailingZeros ( x ) ; x >>>= ( ntz + 1 ) ; s += ( ntz + 1 ) ; r -= 1 ; } int res = ( r > 0 ) ? 72 : s ; return res ; } 
public static String decode ( String s ) { try { return decode ( s , "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return s ; } } 
public IIOMetadataNode getTiffField ( int tag ) { IIOMetadataNode result = null ; IIOMetadataNode tiffDirectory = getTiffDirectory ( ) ; NodeList children = tiffDirectory . getElementsByTagName ( TIFF_FIELD_TAG ) ; for ( int i = 0 ; i < children . getLength ( ) && result == null ; i ++ ) { Node child = children . item ( i ) ; Node number = child . getAttributes ( ) . getNamedItem ( NUMBER_ATTR ) ; if ( number != null ) { int num = Integer . parseInt ( number . getNodeValue ( ) ) ; if ( num == tag ) { result = ( IIOMetadataNode ) child ; } } } return result ; } 
private void updateTexts ( DocumentEvent e ) { Document doc = e . getDocument ( ) ; if ( doc == projectNameTextField . getDocument ( ) || doc == projectLocationTextField . getDocument ( ) ) { String projectName = projectNameTextField . getText ( ) ; String projectFolder = projectLocationTextField . getText ( ) ; createdFolderTextField . setText ( projectFolder + File . separatorChar + projectName ) ; } panel . fireChangeEvent ( ) ; } 
public static double nextDown ( double d ) { if ( isNaN ( d ) || d == Double . NEGATIVE_INFINITY ) return d ; else { if ( d == 0.0 ) return - Double . MIN_VALUE ; else return Double . longBitsToDouble ( Double . doubleToRawLongBits ( d ) + ( ( d > 0.0d ) ? - 1L : + 1L ) ) ; } } 
public String getParameter ( String name ) { return stub . getParameter ( name ) ; } 
public void init ( ) throws GIPCException { this . oDictionary = new Dictionary ( ) ; } 
public String getLanguage ( ) { return properties . getProperty ( LANGUAGE_KEY ) ; } 
public static void renameTo ( @ OsUntrusted File src , @ OsUntrusted File dst ) throws IOException { if ( ! nativeLoaded ) { if ( ! src . renameTo ( dst ) ) { throw new @ OsUntrusted IOException ( "renameTo(src=" + src + ",-dst=" + dst + ")-failed." ) ; } } else { renameTo0 ( src . getAbsolutePath ( ) , dst . getAbsolutePath ( ) ) ; } } 
private void setCounters ( BitArray row ) throws NotFoundException { counterLength = 0 ; int i = row . getNextUnset ( 0 ) ; int end = row . getSize ( ) ; if ( i >= end ) { throw NotFoundException . getNotFoundInstance ( ) ; } boolean isWhite = true ; int count = 0 ; while ( i < end ) { if ( row . get ( i ) ^ isWhite ) { count ++ ; } else { counterAppend ( count ) ; count = 1 ; isWhite = ! isWhite ; } i ++ ; } counterAppend ( count ) ; } 
public final String format ( ) { StringBuilder sb = new StringBuilder ( ) ; FormatState state = new FormatState ( this ) ; state . work . add ( this ) ; while ( ! state . work . isEmpty ( ) ) { MuSyntax syntax = state . work . removeFirst ( ) ; if ( ! state . done . add ( syntax ) ) { continue ; } if ( sb . length ( ) > 0 ) { sb . append ( "-" ) ; } String l = state . getLabel ( syntax ) ; sb . append ( l ) . append ( "-::=-" ) ; sb . append ( syntax . format ( state ) ) ; } return sb . toString ( ) ; } 
private File getFile ( DataEntry dataEntry ) { return isFile ? baseFile : new File ( baseFile , dataEntry . getName ( ) . replace ( ClassConstants . PACKAGE_SEPARATOR , File . separatorChar ) ) ; } 
protected FloatBuffer ( float [ ] array , int mode ) { if ( array == null ) { throw_constructor ( ) ; } this . nx = array . length ; this . ny = 1 ; this . nz = 1 ; allocate ( ) ; putX ( 0 , 0 , 0 , array ) ; } 
@ Override public V get ( Object key ) { if ( key == null ) { key = NULL_OBJECT ; } int index = findIndex ( key , elementData ) ; if ( elementData [ index ] == key ) { Object result = elementData [ index + 1 ] ; return massageValue ( result ) ; } return null ; } 
@ Override public void reduce ( Text key , Iterable < Text > values , Context context ) { for ( Text t : values ) { try { context . write ( key , t ) ; } catch ( Exception e ) { StringWriter sw = new StringWriter ( ) ; e . printStackTrace ( new PrintWriter ( sw ) ) ; String exceptionAsString = sw . toString ( ) ; System . out . println ( exceptionAsString ) ; } } } 
public Object getContent ( ) throws java . io . IOException { if ( ! connected ) { connect ( ) ; } if ( ( contentType = getContentType ( ) ) == null ) { if ( ( contentType = guessContentTypeFromName ( url . getFile ( ) ) ) == null ) { contentType = guessContentTypeFromStream ( getInputStream ( ) ) ; } } if ( contentType != null ) { return getContentHandler ( contentType ) . getContent ( this ) ; } return null ; } 
List getValueList ( Environment env ) throws TemplateException { int size = values . size ( ) ; switch ( size ) { case 0 : { return Collections . EMPTY_LIST ; } case 1 : { return Collections12 . singletonList ( ( ( Expression ) values . get ( 0 ) ) . getStringValue ( env ) ) ; } default : { List result = new ArrayList ( values . size ( ) ) ; for ( ListIterator iterator = values . listIterator ( ) ; iterator . hasNext ( ) ; ) { Expression exp = ( Expression ) iterator . next ( ) ; result . add ( exp . getStringValue ( env ) ) ; } return result ; } } } 
private String characterIteratorToString ( CharacterIterator iterator ) { int endIndex = iterator . getEndIndex ( ) ; int beginIndex = iterator . getBeginIndex ( ) ; int count = endIndex - beginIndex ; if ( count <= 0 ) { return "" ; } char [ ] chars = new char [ count ] ; int i = 0 ; char c = iterator . first ( ) ; while ( c != CharacterIterator . DONE ) { chars [ i ] = c ; i ++ ; c = iterator . next ( ) ; } return new String ( chars ) ; } 
public boolean run ( char [ ] s , int offset , int length ) { int p = initial ; int l = offset + length ; for ( int i = offset , cp = 0 ; i < l ; i += Character . charCount ( cp ) ) { p = step ( p , cp = Character . codePointAt ( s , i , l ) ) ; if ( p == - 1 ) return false ; } return accept [ p ] ; } 
public XObject execute ( XPathContext xctxt , int context ) throws javax . xml . transform . TransformerException { DTM dtm = xctxt . getDTM ( context ) ; short nodeType = dtm . getNodeType ( context ) ; if ( m_whatToShow == DTMFilter . SHOW_ALL ) return m_score ; int nodeBit = ( m_whatToShow & ( 0x00000001 << ( nodeType - 1 ) ) ) ; switch ( nodeBit ) { case DTMFilter . SHOW_DOCUMENT_FRAGMENT : case DTMFilter . SHOW_DOCUMENT : return SCORE_OTHER ; case DTMFilter . SHOW_COMMENT : return m_score ; case DTMFilter . SHOW_CDATA_SECTION : case DTMFilter . SHOW_TEXT : return m_score ; case DTMFilter . SHOW_PROCESSING_INSTRUCTION : return subPartMatch ( dtm . getNodeName ( context ) , m_name ) ? m_score : SCORE_NONE ; case DTMFilter . SHOW_NAMESPACE : { String ns = dtm . getLocalName ( context ) ; return ( subPartMatch ( ns , m_name ) ) ? m_score : SCORE_NONE ; } case DTMFilter . SHOW_ATTRIBUTE : case DTMFilter . SHOW_ELEMENT : { return ( m_isTotallyWild || ( subPartMatchNS ( dtm . getNamespaceURI ( context ) , m_namespace ) && subPartMatch ( dtm . getLocalName ( context ) , m_name ) ) ) ? m_score : SCORE_NONE ; } default : return SCORE_NONE ; } } 
public static final void setHorizontalTextPosition ( Map map , int textPosition ) { map . put ( HORIZONTAL_TEXT_POSITION , new Integer ( textPosition ) ) ; } 
public MapMaker initialCapacity ( int initialCapacity ) { builder . initialCapacity ( initialCapacity ) ; return this ; } 
@ Override public synchronized int compress ( byte [ ] b , int off , int len ) throws IOException { if ( b == null ) { throw new NullPointerException ( ) ; } if ( off < 0 || len < 0 || off > b . length - len ) { throw new ArrayIndexOutOfBoundsException ( ) ; } int n = compressedDirectBuf . remaining ( ) ; if ( n > 0 ) { n = Math . min ( n , len ) ; ( ( ByteBuffer ) compressedDirectBuf ) . get ( b , off , n ) ; bytesWritten += n ; return n ; } compressedDirectBuf . clear ( ) ; compressedDirectBuf . limit ( 0 ) ; if ( 0 == uncompressedDirectBuf . position ( ) ) { setInputFromSavedData ( ) ; if ( 0 == uncompressedDirectBuf . position ( ) ) { finished = true ; return 0 ; } } n = useLz4HC ? compressBytesDirectHC ( ) : compressBytesDirect ( ) ; compressedDirectBuf . limit ( n ) ; uncompressedDirectBuf . clear ( ) ; if ( 0 == userBufLen ) { finished = true ; } n = Math . min ( n , len ) ; bytesWritten += n ; ( ( ByteBuffer ) compressedDirectBuf ) . get ( b , off , n ) ; return n ; } 
public long getDate ( ) { return getHeaderFieldDate ( "Date" , 0 ) ; } 
protected static String debugIndent ( int depth ) { StringBuilder spaces = new StringBuilder ( ( depth * 2 + 3 ) * 2 ) ; for ( int i = 0 ; i < ( depth * 2 ) + 3 ; i ++ ) { spaces . append ( '-' ) . append ( '-' ) ; } return spaces . toString ( ) ; } 
public static String [ ] getFileTimestamps ( Configuration conf ) { return conf . getStrings ( "mapred.cache.files.timestamps" ) ; } 
public Quaternion setFromAxisRad ( final Vector3 axis , final float radians ) { return setFromAxisRad ( axis . x , axis . y , axis . z , radians ) ; } 
public void setFinalResponse ( TransactionServer ts , Message resp ) { TransactionIdentifier sid = ts . getTransactionId ( ) ; s_response . remove ( sid ) ; s_response . put ( sid , resp ) ; } 
public void componentHidden ( ComponentEvent e ) { ( ( ComponentListener ) a ) . componentHidden ( e ) ; ( ( ComponentListener ) b ) . componentHidden ( e ) ; } 
public static Integer getWidth ( final HWND hWnd , final HWND hCtrl ) { return ( ( hWnd == null ) || ( hCtrl == null ) ) ? null : getWidth ( buildTitle ( hWnd ) , buildControlId ( hCtrl ) ) ; } 
@ XmlElementDecl ( namespace = "http://flowframe.org/kernel/common/mdm/domain/preferences" , name = "prefentry" ) public JAXBElement < Prefentry > createPrefentry ( Prefentry value ) { return new JAXBElement < Prefentry > ( _Prefentry_QNAME , Prefentry . class , null , value ) ; } 
public StringBuffer toStringBuffer ( ) { return new StringBuffer ( size ) . append ( buffer , 0 , size ) ; } 
void makeDescriptionString ( ) { if ( fi . description != null ) { if ( fi . description . charAt ( fi . description . length ( ) - 1 ) != ( char ) 0 ) fi . description += "-" ; description = fi . description . getBytes ( ) ; description [ description . length - 1 ] = ( byte ) 0 ; } else description = null ; } 
public void setSelected ( GraphItem [ ] items ) { graph . setSelection ( items ) ; } 
public Enumerated ( int valueIndex ) throws IllegalArgumentException { if ( getIntTable ( ) . get ( new Integer ( valueIndex ) ) == null ) { throw new IllegalArgumentException ( ) ; } value = valueIndex ; } 
public ArrayList < BindingEntry > getBindings ( ) { return new ArrayList < BindingEntry > ( this . contents ) ; } 
private static void makeServer ( ) { Server application = new Server ( ) ; application . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; application . setResizable ( false ) ; application . setVisible ( true ) ; application . runServer ( ) ; } 
public static boolean isBinaryType ( int jdbcTypeCode ) { Set < Integer > typesInCategory = _typesPerCategory . get ( JdbcTypeCategoryEnum . BINARY ) ; return typesInCategory == null ? false : typesInCategory . contains ( new Integer ( jdbcTypeCode ) ) ; } 
public ValueType get ( KeyType key ) { Map . Entry < KeyType , ValueType > match = theSet . getMatch ( makePair ( key ) ) ; if ( match == null ) return null ; else return match . getValue ( ) ; } 
public String getColumnName ( int column ) { Object id = null ; if ( column < columnIdentifiers . size ( ) && ( column >= 0 ) ) { id = columnIdentifiers . elementAt ( column ) ; } return ( id == null ) ? super . getColumnName ( column ) : id . toString ( ) ; } 
@ Internal public boolean isFNeverBeenAutofit ( ) { return fNeverBeenAutofit . isSet ( field_13_widthAndFitsFlags ) ; } 
public BSPTree < S > copySelf ( ) { if ( cut == null ) { return new BSPTree < S > ( attribute ) ; } return new BSPTree < S > ( cut . copySelf ( ) , plus . copySelf ( ) , minus . copySelf ( ) , attribute ) ; } 
public void updateGeometry ( ) { resize ( width , height ) ; float [ ] uv = { 0 , hRatio , wRatio , hRatio , 0 , 0 , wRatio , 0 } ; mTexBuffer . clear ( ) ; for ( int i = 0 ; i < VERTS ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { mTexBuffer . put ( uv [ i * 2 + j ] ) ; } } mIndexBuffer . clear ( ) ; for ( int i = 0 ; i < VERTS ; i ++ ) { mIndexBuffer . put ( ( short ) i ) ; } mTexBuffer . position ( 0 ) ; mIndexBuffer . position ( 0 ) ; } 
public void unmarshalHeader ( ) { if ( ! unmarshaledHeader ) { msg . read ( this ) ; unmarshaledHeader = true ; } } 
Values ( ) { initializeTable ( INITIAL_SIZE ) ; this . size = 0 ; this . tombstones = 0 ; } 
public void insert_long ( int _0 ) throws TypeMismatch , InvalidValue { throw new MARSHAL ( _DynAnyStub . NOT_APPLICABLE ) ; } 
public static String shorten ( String s , int len ) { if ( s == null ) return null ; if ( s . length ( ) > len ) s = s . substring ( 0 , len - 2 ) + ".." ; return s ; } 
public void add ( Song s , int i ) { if ( i < 0 || i > size ( ) ) { System . out . println ( "Index-out-of-bounds." ) ; } else { if ( i == 0 ) { first = new Node ( s , first ) ; } else { Node prev = get ( i - 1 ) ; prev . setNext ( new Node ( s , prev . getNext ( ) ) ) ; } } } 
public int getSubtypeCount ( ) { return mSubtypes . size ( ) ; } 
public Vector3f getLocalScale ( ) { return localTransform . getScale ( ) ; } 
public boolean isEqual ( Symbol other ) { if ( ( pName . equals ( other . getName ( ) ) ) & ( pKind == other . getKind ( ) ) ) { return true ; } return false ; } 
protected void fireStateChanged ( ) { Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == ChangeListener . class ) { if ( changeEvent == null ) changeEvent = new ChangeEvent ( this ) ; ( ( ChangeListener ) listeners [ i + 1 ] ) . stateChanged ( changeEvent ) ; } } } 
public boolean isSameTypes ( List < Type > ts , List < Type > ss ) { while ( ts . tail != null && ss . tail != null && isSameType ( ts . head , ss . head ) ) { ts = ts . tail ; ss = ss . tail ; } return ts . tail == null && ss . tail == null ; } 
protected static void initLogDir ( ) { String logDir = System . getProperty ( "logDir" ) ; File dir = null ; if ( logDir != null ) { dir = new File ( logDir ) ; if ( dir . exists ( ) ) { if ( ! dir . isDirectory ( ) ) { System . err . println ( logDir + "-is-not-a-valid-directory,-log-files-will-NOT-be-written!" ) ; dir = INVALID_DIR ; } } else { int n = 0 ; boolean created = false ; while ( ! created && n < 3 ) { created = dir . mkdir ( ) ; if ( ! created ) { dir = dir . getParentFile ( ) ; } n ++ ; } if ( ! created ) { System . err . println ( "Cannot-create-" + logDir + ",-log-files-will-NOT-be-written!" ) ; dir = INVALID_DIR ; } } String [ ] subdirs = ( PATCH_ID == null ) ? new String [ ] { LOG_VERSION , RUN_ID } : new String [ ] { LOG_VERSION , PATCH_ID , RUN_ID } ; for ( int i = 0 ; i < subdirs . length ; i ++ ) { dir = new File ( dir , subdirs [ i ] ) ; if ( dir . exists ( ) ) { if ( ! dir . isDirectory ( ) ) { System . err . println ( dir . getPath ( ) + "-is-not-a-valid-directory,-log-files-will-NOT-be-written!" ) ; dir = INVALID_DIR ; break ; } } else if ( ! dir . mkdirs ( ) ) { System . err . println ( "Cannot-create-" + dir . getPath ( ) + ",-log-files-will-NOT-be-written!" ) ; dir = INVALID_DIR ; break ; } } } LOG_DIR = dir ; } 
public void setTopBorderPaletteIdx ( short border ) { field_8_adtl_palette_options = _top_border_palette_idx . setValue ( field_8_adtl_palette_options , border ) ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public static double getFloor ( double value ) { return Math . floor ( value ) ; } 
public void paint ( Graphics g ) { g . clearRect ( 0 , 0 , width , height ) ; } 
public String getDisplayName ( ) { String key = ProtocolProviderFactory . ACCOUNT_DISPLAY_NAME ; String accountDisplayName = accountProperties . get ( key ) ; if ( accountDisplayName != null && accountDisplayName . length ( ) > 0 ) { return accountDisplayName ; } String returnValue = getUserID ( ) ; String protocolName = getProtocolDisplayName ( ) ; if ( protocolName != null && protocolName . trim ( ) . length ( ) > 0 ) returnValue += "-(" + protocolName + ")" ; return returnValue ; } 
protected Iterator < T > getConnected ( T n ) { return G . getSuccNodes ( n ) ; } 
public static String toString ( Object obj , String nullStr ) { return obj == null ? nullStr : obj . toString ( ) ; } 
public Integer getListNumber ( String listName ) { Connection c = null ; Statement stmt = null ; Integer listNumber = new Integer ( 0 ) ; try { Class . forName ( "org.sqlite.JDBC" ) ; c = DriverManager . getConnection ( "jdbc:sqlite:Crime.db" ) ; c . setAutoCommit ( false ) ; stmt = c . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( "SELECT-LIST_ID-FROM-USERLISTTABLE-WHERE-(DISPLAYTEXT-=-'" + listName + "');" ) ; while ( rs . next ( ) ) { listNumber = rs . getInt ( "LIST_ID" ) ; } rs . close ( ) ; stmt . close ( ) ; c . close ( ) ; } catch ( Exception e ) { System . err . println ( e . getClass ( ) . getName ( ) + ":-" + e . getMessage ( ) ) ; System . exit ( 0 ) ; } return listNumber ; } 
public synchronized void removeInstanceListener ( InstanceListener dsl ) { m_instanceListeners . remove ( dsl ) ; } 
public long getUptime ( ) { return System . currentTimeMillis ( ) - bootTime ; } 
private void checkAutoLoadDir ( ) { final String pref = mainApp . getPrefValue ( "GeneralSettingsAutoLoadDir" ) ; if ( pref . isEmpty ( ) ) return ; final File autoLoadDir = new File ( pref ) ; if ( ! autoLoadDir . isDirectory ( ) || ! autoLoadDir . canRead ( ) || ! autoLoadDir . canExecute ( ) ) return ; boolean okToDel = false ; File [ ] files = autoLoadDir . listFiles ( ) ; for ( File file : files ) { okToDel = false ; try { if ( file . isDirectory ( ) ) continue ; String filename = file . getCanonicalPath ( ) ; if ( ! filename . substring ( filename . length ( ) - 4 , filename . length ( ) ) . equalsIgnoreCase ( ".nzb" ) ) continue ; logger . msg ( "Loading-new-NZB-file-from-auto-load-directory:-" + filename , MyLogger . SEV_INFO ) ; mainApp . addNzbToQueue ( new NzbParser ( mainApp , file . getAbsolutePath ( ) ) ) ; okToDel = true ; } catch ( Exception e ) { logger . msg ( "Failed-to-load-NZB-file-from-auto-load-directory" , MyLogger . SEV_ERROR ) ; logger . printStackTrace ( e ) ; } finally { if ( okToDel && file != null && file . canWrite ( ) ) file . delete ( ) ; } } } 
public static double round ( double x ) { return Math . floor ( x + 0.5d ) ; } 
public FileOutputStream ( File file ) throws FileNotFoundException { this ( file , false ) ; } 
public ArrayList < Object > getRowAsArrayByName_food ( String food_name ) { ArrayList < Object > rowArray = new ArrayList < Object > ( ) ; Cursor cursor ; try { cursor = db . query ( TABLE_NAME , new String [ ] { TABLE_ROW_ID , TABLE_ROW_ONE , TABLE_ROW_TWO } , TABLE_ROW_ONE + "='" + food_name + "'" , null , null , null , null , null ) ; cursor . moveToFirst ( ) ; if ( ! cursor . isAfterLast ( ) ) { do { rowArray . add ( cursor . getLong ( 0 ) ) ; rowArray . add ( cursor . getString ( 1 ) ) ; rowArray . add ( cursor . getString ( 2 ) ) ; } while ( cursor . moveToNext ( ) ) ; } cursor . close ( ) ; } catch ( SQLException e ) { Log . e ( "DB-ERROR" , e . toString ( ) ) ; e . printStackTrace ( ) ; } return rowArray ; } 
private void init ( InputStream inputStream ) throws IOException { ZipInputStream _zin = new ZipInputStream ( inputStream ) ; ZipEntry entry ; while ( ( entry = _zin . getNextEntry ( ) ) != null ) { zipEntryList . add ( entry . getName ( ) ) ; } _zin . close ( ) ; } 
public Pair < RequestHolder , Long > jpegProduced ( ) { final ReentrantLock lock = this . mLock ; lock . lock ( ) ; try { CaptureHolder h = mJpegProduceQueue . poll ( ) ; if ( h == null ) { Log . w ( TAG , "jpegProduced-called-with-no-jpeg-request-on-queue!" ) ; return null ; } h . setJpegProduced ( ) ; return new Pair < > ( h . mRequest , h . mTimestamp ) ; } finally { lock . unlock ( ) ; } } 
public static BufferedImage read ( InputStream input ) throws IOException { if ( input == null ) { throw new IllegalArgumentException ( "input-==-null!" ) ; } ImageInputStream stream = createImageInputStream ( input ) ; return read ( stream ) ; } 
public void setMag ( double newMag ) { normalize ( ) ; for ( int i = 0 ; i < numComponents ; i ++ ) { components [ i ] *= newMag ; } } 
private Border createNonRolloverToggleBorder ( ) { return UIManager . getBorder ( "Button.border" ) ; } 
public void set ( T value ) { Thread currentThread = Thread . currentThread ( ) ; Values values = values ( currentThread ) ; if ( values == null ) { values = initializeValues ( currentThread ) ; } values . put ( this , value ) ; } 
@ Deprecated public Path makeQualified ( FileSystem fs ) { return makeQualified ( fs . getUri ( ) , fs . getWorkingDirectory ( ) ) ; } 
private boolean isdecl ( Pair name , String value ) { if ( name . chars [ 0 ] == 0 ) { if ( "xmlns" . equals ( name . name ) == true ) { mPref = pair ( mPref ) ; mPref . list = mElm ; mPref . value = value ; mPref . name = "" ; mPref . chars = NONS ; mElm . num ++ ; return true ; } } else { if ( name . eqpref ( XMLNS ) == true ) { int len = name . name . length ( ) ; mPref = pair ( mPref ) ; mPref . list = mElm ; mPref . value = value ; mPref . name = name . name ; mPref . chars = new char [ len + 1 ] ; mPref . chars [ 0 ] = ( char ) ( len + 1 ) ; name . name . getChars ( 0 , len , mPref . chars , 1 ) ; mElm . num ++ ; return true ; } } return false ; } 
public List getOptions ( ) { if ( options == null ) return Collections . EMPTY_LIST ; return Collections . unmodifiableList ( options ) ; } 
private List < String > fragmentToList ( String fragment ) { String [ ] fragments = fragment . split ( ";" ) ; return new ArrayList < String > ( Arrays . asList ( fragments ) ) ; } 
public synchronized void setModulus ( Number value ) throws IllegalArgumentException { if ( value == null ) { throw new IllegalArgumentException ( "Null-modulus" ) ; } if ( value . longValue ( ) < 0L ) { throw new IllegalArgumentException ( "Negative-modulus" ) ; } if ( modulus . equals ( value ) ) return ; modulus = value ; int index = 0 ; for ( ObservedObject o : observedObjects ) { resetAlreadyNotified ( o , index ++ , THRESHOLD_ERROR_NOTIFIED ) ; final CounterMonitorObservedObject cmo = ( CounterMonitorObservedObject ) o ; cmo . setModulusExceeded ( false ) ; } } 
public static float nextUp ( float f ) { return Math . nextUp ( f ) ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public int getWidth ( ) { return nativeGetWidth ( mNativeBox ) ; } 
@ RemotableViewMethod public void setLabelFor ( int id ) { mLabelForId = id ; if ( mLabelForId != View . NO_ID && mID == View . NO_ID ) { mID = generateViewId ( ) ; } } 
public int dealDamage ( int damageDealt , DamageModifier dMod , int dModDegree ) { return myPlayer . recieveDamage ( damageDealt , dMod , dModDegree ) ; } 
@ Deprecated public static User create ( Connection c , User . Record record ) throws BadServerResponse , XenAPIException , XmlRpcException { String method_call = "user.create" ; String session = c . getSessionReference ( ) ; Map < String , Object > record_map = record . toMap ( ) ; Object [ ] method_params = { Marshalling . toXMLRPC ( session ) , Marshalling . toXMLRPC ( record_map ) } ; Map response = c . dispatch ( method_call , method_params ) ; Object result = response . get ( "Value" ) ; return Types . toUser ( result ) ; } 
public Enumeration listOptions ( ) { Vector newVector = new Vector ( 4 ) ; newVector . addElement ( new Option ( "-Random-number-seed-for-cross-validation-" + "-(default-=-1)" , "S" , 1 , "-S-<seed>" ) ) ; newVector . addElement ( new Option ( "-Number-of-folds-for-cross-validation-" + "-(default-=-10)" , "F" , 1 , "-F-<folds>" ) ) ; newVector . addElement ( new Option ( "-Use-training-data-for-evaluation-rather-than-cross-validaton" , "D" , 0 , "-D" ) ) ; newVector . addElement ( new Option ( "-Minimum-number-of-objects-in-a-bucket-" + "-(passed-on-to-" + "OneR,-default-=-6)" , "B" , 1 , "-B-<minimum-bucket-size>" ) ) ; return newVector . elements ( ) ; } 
protected int checkCompilerVersion ( String clazzVersion ) { if ( clazzVersion == null ) { return NOT_COMPATIBLE ; } StringTokenizer st = new StringTokenizer ( clazzVersion , "." ) ; try { int v ; v = Integer . parseInt ( st . nextToken ( ) ) ; Version version = this . version ; if ( v != version . major ( ) ) { return NOT_COMPATIBLE ; } v = Integer . parseInt ( st . nextToken ( ) ) ; if ( v != version . minor ( ) ) { return MINOR_NOT_COMPATIBLE ; } } catch ( NumberFormatException e ) { return NOT_COMPATIBLE ; } return COMPATIBLE ; } 
public static double parseDoubleWithDefault ( String par0Str , double par1 ) { double var3 = par1 ; try { var3 = Double . parseDouble ( par0Str ) ; } catch ( Throwable var6 ) { ; } return var3 ; } 
public Object [ ] toArray ( ) { return Arrays . copyOf ( queue , size ) ; } 
public void visitAttribute ( final Attribute attr ) { if ( attrs == null ) { attrs = new ArrayList ( 1 ) ; } attrs . add ( attr ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public static HttpHost extractHost ( final URI uri ) { if ( uri == null ) { return null ; } HttpHost target = null ; if ( uri . isAbsolute ( ) ) { int port = uri . getPort ( ) ; String host = uri . getHost ( ) ; if ( host == null ) { host = uri . getAuthority ( ) ; if ( host != null ) { int at = host . indexOf ( '@' ) ; if ( at >= 0 ) { if ( host . length ( ) > at + 1 ) { host = host . substring ( at + 1 ) ; } else { host = null ; } } if ( host != null ) { int colon = host . indexOf ( ':' ) ; if ( colon >= 0 ) { if ( colon + 1 < host . length ( ) ) { port = Integer . parseInt ( host . substring ( colon + 1 ) ) ; } host = host . substring ( 0 , colon ) ; } } } } String scheme = uri . getScheme ( ) ; if ( host != null ) { target = new HttpHost ( host , port , scheme ) ; } } return target ; } 
public String optString ( int index , String defaultValue ) { Object object = this . opt ( index ) ; return JSONObject . NULL . equals ( object ) ? defaultValue : object . toString ( ) ; } 
public double getNumericalMean ( ) { final double a = getAlpha ( ) ; return a / ( a + getBeta ( ) ) ; } 
CppGenerator ( String name , ArrayList < JFile > ilist , ArrayList < JRecord > rlist , File outputDirectory ) { this . outputDirectory = outputDirectory ; mName = ( new File ( name ) ) . getName ( ) ; mInclFiles = ilist ; mRecList = rlist ; } 
private void listJobs ( Cluster cluster ) throws IOException , InterruptedException { List < JobStatus > runningJobs = new ArrayList < JobStatus > ( ) ; for ( JobStatus job : cluster . getAllJobStatuses ( ) ) { if ( ! job . isJobComplete ( ) ) { runningJobs . add ( job ) ; } } displayJobList ( runningJobs . toArray ( new JobStatus [ 0 ] ) ) ; } 
public static String normalize ( String s , Locale locale ) { if ( StringUtil . isEmpty ( s ) ) { return null ; } DecimalFormatSymbols symbols = new DecimalFormatSymbols ( locale ) ; char groupingSeparator = symbols . getGroupingSeparator ( ) ; char decimalSeparator = symbols . getDecimalSeparator ( ) ; final StringBuilder builder = new StringBuilder ( 20 ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { char c = s . charAt ( i ) ; if ( c == groupingSeparator ) { continue ; } else if ( c == decimalSeparator ) { c = '.' ; } else if ( ArrayUtil . contains ( SPECIAL_CURRENCY_SYMBOLS , Character . valueOf ( c ) ) ) { continue ; } builder . append ( c ) ; } return builder . toString ( ) ; } 
@ XmlElementDecl ( namespace = "" , name = "draw_volume" ) public JAXBElement < VolumeValue > createDrawVolume ( VolumeValue value ) { return new JAXBElement < VolumeValue > ( _DrawVolume_QNAME , VolumeValue . class , null , value ) ; } 
public void reSeed ( long seed ) { delegate . reSeed ( seed ) ; } 
public void unmarkJobFromLogDeletion ( JobID jobid ) { if ( completedJobs . remove ( jobid ) != null ) { LOG . info ( "Removing-" + jobid + "-from-user-log-deletion" ) ; } } 
ImageIcon getBackgroundImage ( AttributeSet attr ) { Object value = attr . getAttribute ( CSS . Attribute . BACKGROUND_IMAGE ) ; if ( value != null ) { return ( ( CSS . BackgroundImage ) value ) . getImage ( getBase ( ) ) ; } return null ; } 
@ Override public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( Math . abs ( mLatitude ) ) ; buffer . append ( ( mLatitude >= 0 ) ? 'N' : 'S' ) ; buffer . append ( ';' ) ; buffer . append ( Math . abs ( mLongitude ) ) ; buffer . append ( ( mLongitude >= 0 ) ? 'E' : 'W' ) ; buffer . append ( ';' ) ; return buffer . toString ( ) ; } 
public boolean fire ( InputEvent e ) { Descriptor d ; InputAction a = e . getAction ( ) ; if ( a == InputAction . KEY || a == InputAction . MOUSE_CLICKS ) { d = new Descriptor ( e . getAction ( ) , e . getButtonState ( ) ) ; } else { d = new Descriptor ( e . getAction ( ) ) ; } if ( rawMap . containsKey ( d ) ) { return rawMap . get ( d ) . invoke ( e ) ; } return true ; } 
public void setSecureLevel ( short secureLevel ) throws ClassException { if ( secureLevel == SECURE_CFSSL_BASIC ) { env . put ( "java.naming.security.protocol" , "ssl" ) ; env . put ( "java.naming.ldap.factory.socket" , "javax.net.ssl.SSLSocketFactory" ) ; ClassUtil . loadClass ( "com.sun.net.ssl.internal.ssl.Provider" ) ; Security . addProvider ( new com . sun . net . ssl . internal . ssl . Provider ( ) ) ; } else if ( secureLevel == SECURE_CFSSL_CLIENT_AUTH ) { env . put ( "java.naming.security.protocol" , "ssl" ) ; env . put ( "java.naming.security.authentication" , "EXTERNAL" ) ; } else { env . put ( "java.naming.security.authentication" , "simple" ) ; env . remove ( "java.naming.security.protocol" ) ; env . remove ( "java.naming.ldap.factory.socket" ) ; } } 
public boolean setWidths ( float widths [ ] ) { if ( widths . length != cells . length ) return false ; System . arraycopy ( widths , 0 , this . widths , 0 , cells . length ) ; float total = 0 ; calculated = false ; for ( int k = 0 ; k < widths . length ; ++ k ) { PdfPCell cell = cells [ k ] ; if ( cell == null ) { total += widths [ k ] ; continue ; } cell . setLeft ( total ) ; int last = k + cell . getColspan ( ) ; for ( ; k < last ; ++ k ) total += widths [ k ] ; -- k ; cell . setRight ( total ) ; cell . setTop ( 0 ) ; } return true ; } 
public void addAllOf ( FloatArrayList list ) { int listSize = list . size ( ) ; if ( this . size + listSize >= this . capacity ) flush ( ) ; this . target . addAllOf ( list ) ; } 
public Image getImage ( URL url ) { try { Image image = super . getImage ( url ) ; MediaTracker tracker = new MediaTracker ( this ) ; tracker . addImage ( image , 0 ) ; tracker . waitForAll ( ) ; if ( ! tracker . isErrorAny ( ) ) { return image ; } } catch ( Exception e ) { } return null ; } 
public int valueForXPosition ( int xPos ) { int value ; final int minValue = slider . getMinimum ( ) ; final int maxValue = slider . getMaximum ( ) ; final int trackLength = trackRect . width ; final int trackLeft = trackRect . x ; final int trackRight = trackRect . x + ( trackRect . width - 1 ) ; if ( xPos <= trackLeft ) { value = drawInverted ( ) ? maxValue : minValue ; } else if ( xPos >= trackRight ) { value = drawInverted ( ) ? minValue : maxValue ; } else { int distanceFromTrackLeft = xPos - trackLeft ; double valueRange = ( double ) maxValue - ( double ) minValue ; double valuePerPixel = valueRange / ( double ) trackLength ; int valueFromTrackLeft = ( int ) Math . round ( distanceFromTrackLeft * valuePerPixel ) ; value = drawInverted ( ) ? maxValue - valueFromTrackLeft : minValue + valueFromTrackLeft ; } return value ; } 
public String getSelection ( ) { return mSelection . toString ( ) ; } 
private String getPropertyStringValue ( String propertyName , boolean required ) throws PolicyException { Set values = ( Set ) properties . get ( propertyName ) ; if ( values == null || values . isEmpty ( ) ) { if ( required ) { String args [ ] = { propertyName } ; throw new PolicyException ( ResBundleUtils . rbName , "property_value_not_defined" , args , null ) ; } else { return null ; } } return ( ( String ) values . iterator ( ) . next ( ) ) ; } 
public List < String > getAllKeys ( String startingWith ) { List < String > keys = new ArrayList < String > ( ) ; Properties props = getSettings ( ) ; if ( StringUtils . isEmpty ( startingWith ) ) { keys . addAll ( props . stringPropertyNames ( ) ) ; } else { startingWith = startingWith . toLowerCase ( ) ; for ( Object o : props . keySet ( ) ) { String key = o . toString ( ) ; if ( key . toLowerCase ( ) . startsWith ( startingWith ) ) { keys . add ( key ) ; } } } return keys ; } 
@ Override public boolean isExported ( String name , boolean local ) { return super . isExported ( name , local ) || ( ! local && name . startsWith ( "_" ) ) ; } 
public static void writeMyEphemeralNodeOnDisk ( String fileContent ) { String fileName = ZNodeClearer . getMyEphemeralNodeFileName ( ) ; if ( fileName == null ) { LOG . warn ( "Environment-variable-HBASE_ZNODE_FILE-not-set;-znodes-will-not-be-cleared-" + "on-crash-by-start-scripts-(Longer-MTTR!)" ) ; return ; } FileWriter fstream ; try { fstream = new FileWriter ( fileName ) ; } catch ( IOException e ) { LOG . warn ( "Can't-write-znode-file-" + fileName , e ) ; return ; } BufferedWriter out = new BufferedWriter ( fstream ) ; try { try { out . write ( fileContent + "-" ) ; } finally { try { out . close ( ) ; } finally { fstream . close ( ) ; } } } catch ( IOException e ) { LOG . warn ( "Can't-write-znode-file-" + fileName , e ) ; } } 
void readSlot ( int position , int [ ] buffer ) { { position *= slotsize ; int chunkpos = position >> lowbits ; int slotpos = ( position & lowmask ) ; if ( chunkpos > chunks . size ( ) - 1 ) chunks . addElement ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; System . arraycopy ( chunk , slotpos , buffer , 0 , slotsize ) ; } } 
public Canvas lockCanvas ( Rect dirty ) { if ( mDestroyed ) { return null ; } if ( mCanvas == null ) { mCanvas = new Canvas ( ) ; } if ( nLockCanvas ( mNativeObject , mCanvas , dirty ) ) { mSaveCount = mCanvas . save ( ) ; return mCanvas ; } return null ; } 
@ LayoutlibDelegate static long elapsedRealtimeNanos ( ) { return System . nanoTime ( ) - sBootTimeNano ; } 
@ XmlElementDecl ( namespace = "http://www.xbrl.org/tw/fr/gaap/tw-gaap-ci-2010-03-31" , name = "AccountsPayableRelatedPartiesAbstract" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < StringItemType > createAccountsPayableRelatedPartiesAbstract ( StringItemType value ) { return new JAXBElement < StringItemType > ( _AccountsPayableRelatedPartiesAbstract_QNAME , StringItemType . class , null , value ) ; } 
public static Builder newBuilder ( String delimiter ) { return new Builder ( delimiter , 10 ) ; } 
@ Override public Set < Map . Entry < K , V >> entrySet ( ) { poll ( ) ; return new AbstractSet < Map . Entry < K , V >> ( ) { @ Override public int size ( ) { return WeakHashMap . this . size ( ) ; } @ Override public void clear ( ) { WeakHashMap . this . clear ( ) ; } @ Override public boolean remove ( Object object ) { if ( contains ( object ) ) { WeakHashMap . this . remove ( ( ( Map . Entry < ? , ? > ) object ) . getKey ( ) ) ; return true ; } return false ; } @ Override public boolean contains ( Object object ) { if ( object instanceof Map . Entry ) { Entry < ? , ? > entry = getEntry ( ( ( Map . Entry < ? , ? > ) object ) . getKey ( ) ) ; if ( entry != null ) { Object key = entry . get ( ) ; if ( key != null || entry . isNull ) { return object . equals ( entry ) ; } } } return false ; } @ Override public Iterator < Map . Entry < K , V >> iterator ( ) { return new HashIterator < Map . Entry < K , V >> ( new Entry . Type < Map . Entry < K , V > , K , V > ( ) { public Map . Entry < K , V > get ( Map . Entry < K , V > entry ) { return entry ; } } ) ; } } ; } 
public int hashCode ( ) { int result = 0 ; result += this . tabularType . hashCode ( ) ; for ( Object value : values ( ) ) result += value . hashCode ( ) ; return result ; } 
public static void v ( String tag , String s , Object ... args ) { if ( LOG . VERBOSE >= LOGLEVEL ) Log . v ( tag , String . format ( s , args ) ) ; } 
protected void setRowHeight ( int rowHeight ) { completeEditing ( ) ; if ( treeState != null ) { setLargeModel ( tree . isLargeModel ( ) ) ; treeState . setRowHeight ( rowHeight ) ; updateSize ( ) ; } } 
@ SuppressWarnings ( "unchecked" ) public Collection < Object > getFieldValues ( String name ) { Object v = _fields . get ( name ) ; if ( v instanceof Collection ) { return ( Collection < Object > ) v ; } if ( v != null ) { ArrayList < Object > arr = new ArrayList < Object > ( 1 ) ; arr . add ( v ) ; return arr ; } return null ; } 
public boolean hasNextChar ( ) { scanner . useDelimiter ( EMPTY_PATTERN ) ; boolean result = scanner . hasNext ( ) ; scanner . useDelimiter ( WHITESPACE_PATTERN ) ; return result ; } 
public void flipHorizontally ( ) { int width = bufferedImage . getWidth ( ) ; int height = bufferedImage . getHeight ( ) ; BufferedImage result = new BufferedImage ( width , height , bufferedImage . TYPE_INT_BGR ) ; for ( int x = 0 ; x < width ; x ++ ) { for ( int y = 0 ; y < height ; y ++ ) { int rgb0 = bufferedImage . getRGB ( x , y ) ; int rgb1 = bufferedImage . getRGB ( x , y ) ; int rgb = bufferedImage . getRGB ( x , y ) ; result . setRGB ( width - x - 1 , y , rgb ) ; } } bufferedImage = result ; } 
static void readKeysFromBuffer ( byte [ ] buffer , String [ ] keys , int [ ] keys_sz , HashMap < String , Long > props , HashMap < String , String > sprops ) { int offset = 0 ; for ( int i = 0 ; i < keys . length ; i ++ ) { if ( keys_sz [ i ] < 5 ) { props . put ( keys [ i ] , getUnsignedIntFromBytes ( buffer , offset , keys_sz [ i ] ) ) ; } else { sprops . put ( keys [ i ] , new String ( buffer , offset , keys_sz [ i ] ) ) ; } offset += keys_sz [ i ] ; } } 
public int getCurrentTokenEndPosition ( ) { return getCurrentPosition ( ) - 1 ; } 
public ISchema parse ( Reader reader ) throws ParseError , IOException { return parse ( new InputSource ( reader ) , null ) ; } 
public List < FeatureVendorServer > getFeatureVendorServer ( ) { if ( featureVendorServer == null ) { featureVendorServer = new ArrayList < FeatureVendorServer > ( ) ; } return this . featureVendorServer ; } 
@ RequestMapping ( value = "/" , method = RequestMethod . GET ) public String home ( Locale locale , Model model ) { logger . info ( "Welcome-home!-The-client-locale-is-{}." , locale ) ; Date date = new Date ( ) ; DateFormat dateFormat = DateFormat . getDateTimeInstance ( DateFormat . LONG , DateFormat . LONG , locale ) ; String formattedDate = dateFormat . format ( date ) ; model . addAttribute ( "serverTime" , formattedDate ) ; return "home" ; } 
protected int inverseLabel ( double [ ] probs ) throws Exception { double [ ] invProbs = new double [ probs . length ] ; for ( int i = 0 ; i < probs . length ; i ++ ) { if ( probs [ i ] == 0 ) { invProbs [ i ] = Double . MAX_VALUE / probs . length ; } else { invProbs [ i ] = 1.0 / probs [ i ] ; } } Utils . normalize ( invProbs ) ; double [ ] cdf = new double [ invProbs . length ] ; cdf [ 0 ] = invProbs [ 0 ] ; for ( int i = 1 ; i < invProbs . length ; i ++ ) { cdf [ i ] = invProbs [ i ] + cdf [ i - 1 ] ; } if ( Double . isNaN ( cdf [ invProbs . length - 1 ] ) ) System . err . println ( "Cumulative-class-membership-probability-is-NaN!" ) ; return selectIndexProbabilistically ( cdf ) ; } 
private boolean journalRebuildRequired ( ) { final int redundantOpCompactThreshold = 2000 ; return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries . size ( ) ; } 
protected static Vector vectorize ( RenderedImage image1 , RenderedImage image2 ) { if ( image1 == null || image2 == null ) { throw new IllegalArgumentException ( JaiI18N . getString ( "OpImage3" ) ) ; } Vector v = new Vector ( 2 ) ; v . addElement ( image1 ) ; v . addElement ( image2 ) ; return v ; } 
public boolean hasParameter ( String name ) { return m_parameters . containsKey ( name ) ; } 
public void setDefaultTimeout ( int mils ) { conn_timeout = mils ; if ( owsocket != null ) try { owsocket . setSoTimeout ( mils ) ; } catch ( Exception E ) { } } 
protected void layoutColumns ( int targetSpan , int [ ] offsets , int [ ] spans , SizeRequirements [ ] reqs ) { Arrays . fill ( offsets , 0 ) ; Arrays . fill ( spans , 0 ) ; colIterator . setLayoutArrays ( offsets , spans , targetSpan ) ; CSS . calculateTiledLayout ( colIterator , targetSpan ) ; } 
void dumpUnsafe ( Printer printer , boolean verbose ) { printer . println ( "Connection-#" + mConnectionId + ":" ) ; if ( verbose ) { printer . println ( "-connectionPtr:-0x" + Long . toHexString ( mConnectionPtr ) ) ; } printer . println ( "-isPrimaryConnection:-" + mIsPrimaryConnection ) ; printer . println ( "-onlyAllowReadOnlyOperations:-" + mOnlyAllowReadOnlyOperations ) ; mRecentOperations . dump ( printer , verbose ) ; if ( verbose ) { mPreparedStatementCache . dump ( printer ) ; } } 
protected void checkRowExists ( String sql ) throws Exception { Statement s = this . conn . createStatement ( ) ; ResultSet rs = s . executeQuery ( sql ) ; assertTrue ( "Row-should-exist" , rs . next ( ) ) ; rs . close ( ) ; s . close ( ) ; } 
public T walkInDefaultOrder ( final FieldVectorChangingVisitor < T > visitor ) { final int dim = getDimension ( ) ; visitor . start ( dim , 0 , dim - 1 ) ; for ( int i = 0 ; i < dim ; i ++ ) { setEntry ( i , visitor . visit ( i , getEntry ( i ) ) ) ; } return visitor . end ( ) ; } 
public boolean compareAndSet ( V expectedReference , V newReference , boolean expectedMark , boolean newMark ) { ReferenceBooleanPair < V > current = atomicRef . get ( ) ; return expectedReference == current . reference && expectedMark == current . bit && ( ( newReference == current . reference && newMark == current . bit ) || atomicRef . compareAndSet ( current , new ReferenceBooleanPair < V > ( newReference , newMark ) ) ) ; } 
public void clearMarker ( ) { Set < String > cles = mapAction . keySet ( ) ; Iterator < String > it = cles . iterator ( ) ; while ( it . hasNext ( ) ) { String cle = ( String ) it . next ( ) ; GraphMarker marker = ( GraphMarker ) mapAction . get ( cle ) ; marker . removeMarker ( ) ; } } 
private void addCommand ( List < String > list , String ... args ) { for ( String command : args ) { list . add ( command ) ; } } 
public Node nextNode ( ) throws DOMException { if ( ( m_next ) < this . size ( ) ) { Node next = this . elementAt ( m_next ) ; m_next ++ ; return next ; } else return null ; } 
@ XmlElementDecl ( namespace = "http://www.wfmc.org/2002/XPDL1.0" , name = "Codepage" ) public JAXBElement < String > createCodepage ( String value ) { return new JAXBElement < String > ( _Codepage_QNAME , String . class , null , value ) ; } 
protected static final < T > void add ( Set < T > set , T [ ] values ) { for ( T v : values ) set . add ( v ) ; } 
public void addBookmarkedURL ( BookmarkedURL bookmarkedURL ) { bookmarkedURLS . add ( bookmarkedURL ) ; } 
private void refill ( ) throws IOException { try { do { pos = 0 ; if ( unread > 0 ) { int n = in . read ( buf , 0 , Math . min ( unread , MAX_BLOCK_SIZE ) ) ; if ( n >= 0 ) { end = n ; unread -= n ; } else { throw new StreamCorruptedException ( "unexpected-EOF-in-middle-of-data-block" ) ; } } else { int n = readBlockHeader ( true ) ; if ( n >= 0 ) { end = 0 ; unread = n ; } else { end = - 1 ; unread = 0 ; } } } while ( pos == end ) ; } catch ( IOException ex ) { pos = 0 ; end = - 1 ; unread = 0 ; throw ex ; } } 
public Request addQueryParameter ( String name , String value ) { this . query . put ( name , value ) ; return this ; } 
public static String urlEncode ( String s , String codec ) { if ( s == null ) { return "" ; } try { String tmp = URLEncoder . encode ( s , codec ) ; return tmp . replace ( "+" , "%20" ) ; } catch ( UnsupportedEncodingException e ) { return s ; } } 
@ Experimental public final static < T > Observable < T > merge ( Observable < ? extends T > [ ] sequences , int maxConcurrent ) { return merge ( from ( sequences ) , maxConcurrent ) ; } 
private void dumpFocusStack ( PrintWriter pw ) { pw . println ( "-Audio-Focus-stack-entries-(last-is-top-of-stack):" ) ; synchronized ( mAudioFocusLock ) { Iterator < FocusRequester > stackIterator = mFocusStack . iterator ( ) ; while ( stackIterator . hasNext ( ) ) { stackIterator . next ( ) . dump ( pw ) ; } } pw . println ( "-Notify-on-duck:-" + mNotifyFocusOwnerOnDuck + "-" ) ; } 
public static BasicMediaProcessor get ( int mpid ) { return ( BasicMediaProcessor ) ( mprocessors . get ( new Integer ( mpid ) ) ) ; } 
private void writeProjectXml ( ) { try { File templateFile = Constants . TEMPLATE_PROJECT_FILE ; DocumentBuilder db ; db = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; Document doc = db . parse ( templateFile ) ; doc . getElementsByTagName ( "name" ) . item ( 0 ) . setTextContent ( projectName ) ; doc . getElementsByTagName ( "source-root" ) . item ( 0 ) . setTextContent ( userObject . toString ( ) ) ; Node dataNode = doc . getElementsByTagName ( "data" ) . item ( 0 ) ; for ( Entry < String , Path > entry : this . upkAssociations . entrySet ( ) ) { Element upkElem = doc . createElement ( "upk-file" ) ; upkElem . setAttribute ( "name" , entry . getKey ( ) ) ; upkElem . setAttribute ( "path" , entry . getValue ( ) . toString ( ) ) ; dataNode . appendChild ( upkElem ) ; } Transformer tr = TransformerFactory . newInstance ( ) . newTransformer ( ) ; tr . setOutputProperties ( Constants . PROJECT_XML_OUTPUT_PROPERTIES ) ; tr . transform ( new DOMSource ( doc ) , new StreamResult ( new FileOutputStream ( xmlPath . toFile ( ) ) ) ) ; } catch ( Exception e ) { logger . log ( Level . SEVERE , "Failed-to-save-project-file-" + xmlPath , e ) ; } } 
public static String shortDebugString ( final UnknownFieldSet fields ) { try { final StringBuilder sb = new StringBuilder ( ) ; SINGLE_LINE_PRINTER . printUnknownFields ( fields , new TextGenerator ( sb ) ) ; return sb . toString ( ) . trim ( ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } } 
public void addItemset ( Itemset itemset , int k ) { while ( levels . size ( ) <= k ) { levels . add ( new ArrayList < Itemset > ( ) ) ; } levels . get ( k ) . add ( itemset ) ; itemsetsCount ++ ; } 
private AuthenticationPermission getAuthPermission ( X509Certificate cert , String peer , String action ) { Set server = Collections . singleton ( cert . getSubjectX500Principal ( ) ) ; Set client = ( peer == null ) ? null : Collections . singleton ( new X500Principal ( peer ) ) ; return new AuthenticationPermission ( server , client , action ) ; } 
public void copyDataFrom ( Entity par1Entity , boolean par2 ) { NBTTagCompound var3 = new NBTTagCompound ( ) ; par1Entity . writeToNBT ( var3 ) ; this . readFromNBT ( var3 ) ; this . timeUntilPortal = par1Entity . timeUntilPortal ; this . teleportDirection = par1Entity . teleportDirection ; } 
public static double avg ( List < Integer > X ) { double xbar = 0.0 ; int m = X . size ( ) ; if ( m == 0 ) { return 0 ; } for ( int i = 0 ; i < m ; i ++ ) { xbar += X . get ( i ) ; } if ( xbar >= 0.0 ) { return xbar / m ; } return 0.0 ; } 
private boolean compareCommand ( String propertyCommand , String serverCommand ) { if ( propertyCommand . length ( ) == serverCommand . length ( ) ) { char [ ] propertyCommandChars = new char [ propertyCommand . length ( ) ] ; char [ ] serverCommandChars = new char [ serverCommand . length ( ) ] ; boolean equal = true ; propertyCommand . toUpperCase ( ) . getChars ( 0 , propertyCommand . length ( ) , propertyCommandChars , 0 ) ; serverCommand . toUpperCase ( ) . getChars ( 0 , serverCommand . length ( ) , serverCommandChars , 0 ) ; ; for ( int i = 0 ; i < propertyCommand . length ( ) ; i ++ ) { if ( ( serverCommandChars [ i ] != propertyCommandChars [ i ] ) && ( serverCommandChars [ i ] != '?' ) ) { equal = false ; break ; } } return equal ; } return false ; } 
public E next ( ) { return order . poll ( ) ; } 
public static RenderedOp create ( String opName , Object param1 , Object param2 ) { ParameterBlock args = new ParameterBlock ( ) ; args . add ( param1 ) ; args . add ( param2 ) ; return create ( opName , args , null ) ; } 
public void writeExif ( byte [ ] jpeg , String exifOutFileName ) throws FileNotFoundException , IOException { if ( jpeg == null || exifOutFileName == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = null ; try { s = getExifWriterStream ( exifOutFileName ) ; s . write ( jpeg , 0 , jpeg . length ) ; s . flush ( ) ; } catch ( IOException e ) { closeSilently ( s ) ; throw e ; } s . close ( ) ; } 
public void set ( int [ ] index , Object value ) { final Class xcls = value . getClass ( ) ; if ( componentType . isPrimitive ( ) ) { try { if ( componentType == ( Class ) xcls . getDeclaredField ( "TYPE" ) . get ( value ) ) { obj = value ; return ; } } catch ( NoSuchFieldException ee ) { } catch ( IllegalAccessException ee ) { } Method tValueMethod ; try { tValueMethod = xcls . getMethod ( componentType . getName ( ) + "Value" , new Class [ 0 ] ) ; } catch ( NoSuchMethodException nsme ) { throw new IllegalArgumentException ( ) ; } try { obj = tValueMethod . invoke ( value , new Object [ 0 ] ) ; return ; } catch ( IllegalAccessException iae ) { throw new Error ( ) ; } catch ( InvocationTargetException ite ) { throw ( RuntimeException ) ite . getTargetException ( ) ; } } if ( ! componentType . isAssignableFrom ( xcls ) ) { throw new IllegalArgumentException ( ) ; } obj = value ; } 
static public Name formFullName ( Name name , Symbol owner ) { if ( owner == null ) return name ; if ( ( ( owner . kind != ERR ) ) && ( ( owner . kind & ( VAR | MTH ) ) != 0 || ( owner . kind == TYP && owner . type . tag == TYPEVAR ) ) ) return name ; Name prefix = owner . getQualifiedName ( ) ; if ( prefix == null || prefix == prefix . table . names . empty ) return name ; else return prefix . append ( '.' , name ) ; } 
public ParameterBlock add ( int i ) { return add ( new Integer ( i ) ) ; } 
@ XmlElementDecl ( namespace = "" , name = "flights" ) public JAXBElement < Flights > createFlights ( Flights value ) { return new JAXBElement < Flights > ( _Flights_QNAME , Flights . class , null , value ) ; } 
public void removeAt ( int index ) { if ( index < 0 || index >= getSize ( ) ) { throw new ArrayIndexOutOfBoundsException ( Strings . IndexIsOutOfRange ) ; } items . remove ( index ) ; changed ( ) ; } 
private void initControlList ( ) { controlComboBox . addItem ( CONTROL_PANELS ) ; controlComboBox . addItem ( REGIONS_OF_INTEREST_CONTROL ) ; controlComboBox . addItem ( X_VALUES_CONTROL ) ; controlComboBox . addItem ( DISTANCE_CONTROL ) ; } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null || ! ( obj instanceof StringValue ) ) { return false ; } StringValue v = ( StringValue ) obj ; if ( unitType != v . unitType ) { return false ; } if ( value != null ) { return value . equals ( v . value ) ; } else { if ( v . value == null ) { return true ; } } return false ; } 
public void setBounds ( int x , int y , int width , int height ) { reshape ( x , y , width , height ) ; } 
private JCheckBoxMenuItem getEditLinkCreationMenuItem ( ) { if ( editLinkCreationMenuItem == null ) { editLinkCreationMenuItem = new LocalizedCheckBoxMenuItem ( MenuItemNames . EDIT_MODE_LINK_MENUITEM , ActionCommands . LINK_CREATION , IconLoader . ICON_LINK_ENABLED ) ; editLinkCreationMenuItem . addActionListener ( listener ) ; groupEditOptions . add ( editLinkCreationMenuItem ) ; } return editLinkCreationMenuItem ; } 
public static final void registerFactory ( String identifier , FunctionFactoryProxy proxy ) throws IllegalArgumentException { synchronized ( registeredFactories ) { if ( registeredFactories . containsKey ( identifier ) ) throw new IllegalArgumentException ( "Identifier-is-already-" + "registered-as-" + "FunctionFactory:-" + identifier ) ; registeredFactories . put ( identifier , proxy ) ; } } 
private synchronized InetAddress getHostAddress ( ) { if ( hostAddressKnown ) return hostAddress ; if ( host == null ) return null ; try { hostAddress = InetAddress . getByName ( host ) ; } catch ( UnknownHostException ex ) { hostAddress = null ; } hostAddressKnown = true ; return hostAddress ; } 
public void addCommunicationListener ( FTPCommunicationListener listener ) { communicationListeners . add ( listener ) ; } 
public static String unqualify ( String qualifiedName , char separator ) { return qualifiedName . substring ( qualifiedName . lastIndexOf ( separator ) + 1 ) ; } 
public static long renewDelegationToken ( String tokenStrForm ) throws IOException { return saslServer . renewDelegationToken ( tokenStrForm ) ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public boolean isToggleButtonChecked ( String text ) { return checker . isButtonChecked ( ToggleButton . class , text ) ; } 
public Insets getInsets ( SynthContext context , Insets insets ) { if ( insets == null ) { insets = new Insets ( 0 , 0 , 0 , 0 ) ; } insets . top = insets . bottom = insets . left = insets . right = 0 ; return insets ; } 
public static boolean equals ( final Object obj1 , final Object obj2 ) { return obj1 == null ? obj2 == null : obj1 . equals ( obj2 ) ; } 
public static boolean isEventDispatchThread ( ) { return EventQueue . isDispatchThread ( ) ; } 
public StringMap getQuotaDirExtensions ( ) { return quotaDirectory . getExtensions ( ) ; } 
@ Deprecated public String substring ( int start , int end ) { StringBuilder buf = ( StringBuilder ) _buf ; if ( start < 0 ) { throw new StringIndexOutOfBoundsException ( "Can't-request-a-substring-before-0---asked-for-" + start ) ; } if ( end > buf . length ( ) ) { throw new StringIndexOutOfBoundsException ( "Index-" + end + "-out-of-range-0-->-" + buf . length ( ) ) ; } if ( end < start ) { throw new StringIndexOutOfBoundsException ( "Asked-for-text-from-" + start + "-to-" + end + ",-which-has-an-end-before-the-start!" ) ; } return buf . substring ( start , end ) ; } 
public static void unmangleI18N ( Document dom ) { NodeList elementNodes = dom . getElementsByTagName ( "*" ) ; for ( int i = 0 ; i < elementNodes . getLength ( ) ; i ++ ) { NodeList textNodes = elementNodes . item ( i ) . getChildNodes ( ) ; for ( int j = 0 ; j < textNodes . getLength ( ) ; j ++ ) { Node oldNode = textNodes . item ( j ) ; if ( oldNode . getNodeType ( ) == Node . TEXT_NODE && oldNode . getNodeValue ( ) != null && oldNode . getNodeValue ( ) . startsWith ( I18N_PREFIX ) ) { Node parent = oldNode . getParentNode ( ) ; String key = oldNode . getNodeValue ( ) . substring ( I18N_PREFIX . length ( ) ) ; Element newNode = dom . createElementNS ( I18N_NAMESPACE , "text" ) ; newNode . setAttribute ( "key" , key ) ; newNode . setAttribute ( "catalogue" , "default" ) ; parent . replaceChild ( newNode , oldNode ) ; } } } } 
@ Override public Set < K > keySet ( ) { return map . keySet ( ) ; } 
void clearFocusForRemoval ( ) { if ( ( mPrivateFlags & FOCUSED ) != 0 ) { mPrivateFlags &= ~ FOCUSED ; onFocusChanged ( false , 0 , null ) ; refreshDrawableState ( ) ; } } 
public static List < String > readCharacters ( String line ) { List < String > escapedChars = new ArrayList < String > ( ) ; int i = 0 ; while ( i < line . length ( ) ) { Tuple2 < String , Integer > escapedCharAndLength = Charset . readCharAt ( line , i ) ; String c = escapedCharAndLength . _1 ; int length = escapedCharAndLength . _2 ; escapedChars . add ( c ) ; i += length ; } return escapedChars ; } 
public String getString ( final String key , final Object ... args ) { String value = getString ( key ) ; if ( value == null ) { value = key ; } MessageFormat mf = new MessageFormat ( value ) ; mf . setLocale ( locale ) ; return mf . format ( args , new StringBuffer ( ) , null ) . toString ( ) ; } 
public int getOpenCount ( ) { return refCount . get ( ) ; } 
public static Method getCurrentlyInvokedFactoryMethod ( ) { return currentlyInvokedFactoryMethod . get ( ) ; } 
public boolean isAllowed ( Object o , String displayName ) { Enumeration enm ; Class c ; boolean result ; HashSet list ; result = true ; enm = allowed ( ) ; while ( enm . hasMoreElements ( ) ) { c = ( Class ) enm . nextElement ( ) ; if ( c . isInstance ( o ) ) { list = ( HashSet ) m_Allowed . get ( c ) ; result = list . contains ( displayName ) ; break ; } } return result ; } 
public List < JAXBElement < Object >> get_GenericApplicationPropertyOfWaterClosureSurface ( ) { if ( _GenericApplicationPropertyOfWaterClosureSurface == null ) { _GenericApplicationPropertyOfWaterClosureSurface = new ArrayList < JAXBElement < Object >> ( ) ; } return this . _GenericApplicationPropertyOfWaterClosureSurface ; } 
public void setRole ( final String role ) { if ( role != null && role . equalsIgnoreCase ( "-1" ) ) { this . role = "" ; } else { this . role = role ; } } 
@ Override protected Method getMethod ( PropertyDescriptor descriptor ) { return descriptor . getReadMethod ( ) ; } 
public int getLength ( ) { return names . size ( ) ; } 
public Type bindTypeParameter ( List < TypeParameter > parameters , List < ? extends Type > types ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "bindTypeParameter(parameters=" + parameters + ",-types=" + types + ")---enter" ) ; } GenericElements . checkBindingParameters ( parameters , types ) ; Binding binding ; Type boundType ; binding = new Binding ( this , parameters , types ) ; boundType = getBoundTypes ( ) . get ( binding ) ; if ( boundType == null ) { boundType = this . clone ( ) ; ListUtil . removeAll ( boundType . getOwnedTypeParameter ( ) , parameters ) ; boundTypes . put ( binding , boundType ) ; for ( Property property : boundType . getOwnedProperty ( ) ) { GenericElements . bindTypedElement ( property , parameters , types ) ; } for ( Operation operation : boundType . getOwnedOperation ( ) ) { GenericElements . bindOperation ( operation , parameters , types ) ; } for ( Iterator < GenericType > it = boundType . getGenericSuperType ( ) . iterator ( ) ; it . hasNext ( ) ; ) { GenericType genericSuperType = it . next ( ) ; if ( genericSuperType . bindGenericSuperType ( parameters , types , boundType ) ) { it . remove ( ) ; } } } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "bindTypeParameter()---exit---return-value=" + boundType ) ; } return boundType ; } 
@ Override public String toString ( ) { StringBuffer sb = new StringBuffer ( "MWMSectionType[" ) . append ( get_ID ( ) ) . append ( "-" ) . append ( getName ( ) ) . append ( "]" ) ; return sb . toString ( ) ; } 
@ SuppressWarnings ( "unchecked" ) protected static Set < String > getDoNotLoadList ( ) { Set < String > doNotLoad = new HashSet < String > ( ) ; File doNotLoadList = new File ( PACKAGES_DIR . toString ( ) + File . separator + "doNotLoad.ser" ) ; if ( doNotLoadList . exists ( ) && doNotLoadList . isFile ( ) ) { ObjectInputStream ois = null ; try { ois = new ObjectInputStream ( new BufferedInputStream ( new FileInputStream ( doNotLoadList ) ) ) ; doNotLoad = ( Set < String > ) ois . readObject ( ) ; } catch ( FileNotFoundException ex ) { } catch ( IOException e ) { System . err . println ( "An-error-occurred-while-reading-the-doNotLoad-list:-" + e . getMessage ( ) ) ; } catch ( ClassNotFoundException e ) { System . err . println ( "An-error-occurred-while-reading-the-doNotLoad-list:-" + e . getMessage ( ) ) ; } finally { if ( ois != null ) { try { ois . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } } return doNotLoad ; } 
public List < RouteInfo > getRoutes ( List < RouteInfo > out ) { if ( out == null ) { out = new ArrayList < RouteInfo > ( ) ; } else { out . clear ( ) ; } final int count = getRouteCountStatic ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final RouteInfo route = getRouteAtStatic ( i ) ; if ( route . mCategory == this ) { out . add ( route ) ; } } return out ; } 
private static void elementti ( Graphics g , Color pohja , Color tekstinVari , String teksti ) { g . setColor ( pohja ) ; g . fillRect ( X , Y , LEV , KOR ) ; g . setColor ( tekstinVari ) ; g . drawString ( teksti , X + 20 , Y + 27 ) ; } 
private void paste ( ) { Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; DataFlavor flavor = DataFlavor . imageFlavor ; if ( clipboard . isDataFlavorAvailable ( flavor ) ) { try { image = ( Image ) clipboard . getData ( flavor ) ; label . setIcon ( new ImageIcon ( image ) ) ; } catch ( UnsupportedFlavorException exception ) { JOptionPane . showMessageDialog ( this , exception ) ; } catch ( IOException exception ) { JOptionPane . showMessageDialog ( this , exception ) ; } } } 
private int find ( TableRow row ) { for ( int i = 0 ; i < rows . size ( ) ; i ++ ) { if ( rows . get ( i ) == row ) return i ; } return - 1 ; } 
public Predicable toPredicate ( ) { return toPredicate ( this . values ( ) ) ; } 
public Date getDate ( ) { for ( int i = 0 ; i < info . length ( ) - 9 ; i ++ ) { if ( Character . isWhitespace ( info . charAt ( i ) ) ) { String dateString = info . substring ( i + 1 , i + 9 ) ; try { synchronized ( formatter ) { return formatter . parse ( dateString ) ; } } catch ( ParseException pe ) { } break ; } } return null ; } 
protected void fall ( float par1 ) { if ( riddenByEntity != null ) { riddenByEntity . fall ( par1 ) ; } } 
public Complex multiply ( double factor ) { if ( isNaN || Double . isNaN ( factor ) ) { return NaN ; } if ( Double . isInfinite ( real ) || Double . isInfinite ( imaginary ) || Double . isInfinite ( factor ) ) { return INF ; } return createComplex ( real * factor , imaginary * factor ) ; } 
public double asDouble ( ) { return value . doubleValue ( ) ; } 
static public String asString ( final long [ ] array ) { final StringJoiner joiner = new StringJoiner ( ",-" ) ; joiner . append ( array ) ; return "{" + joiner . toString ( ) + "}" ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public static boolean metaStateHasModifiers ( int metaState , int modifiers ) { if ( ( modifiers & META_INVALID_MODIFIER_MASK ) != 0 ) { throw new IllegalArgumentException ( "modifiers-must-not-contain-" + "META_CAPS_LOCK_ON,-META_NUM_LOCK_ON,-META_SCROLL_LOCK_ON,-" + "META_CAP_LOCKED,-META_ALT_LOCKED,-META_SYM_LOCKED,-" + "or-META_SELECTING" ) ; } metaState = normalizeMetaState ( metaState ) & META_MODIFIER_MASK ; metaState = metaStateFilterDirectionalModifiers ( metaState , modifiers , META_SHIFT_ON , META_SHIFT_LEFT_ON , META_SHIFT_RIGHT_ON ) ; metaState = metaStateFilterDirectionalModifiers ( metaState , modifiers , META_ALT_ON , META_ALT_LEFT_ON , META_ALT_RIGHT_ON ) ; metaState = metaStateFilterDirectionalModifiers ( metaState , modifiers , META_CTRL_ON , META_CTRL_LEFT_ON , META_CTRL_RIGHT_ON ) ; metaState = metaStateFilterDirectionalModifiers ( metaState , modifiers , META_META_ON , META_META_LEFT_ON , META_META_RIGHT_ON ) ; return metaState == modifiers ; } 
public boolean hasOtherCoordinators ( Vector suspects ) { synchronized ( members ) { for ( Iterator it = members . iterator ( ) ; it . hasNext ( ) ; ) { Address a = ( Address ) it . next ( ) ; if ( a . preferredForCoordinator ( ) && ! suspects . contains ( a ) ) { return true ; } } } return false ; } 
public static KeyEvent changeTimeRepeat ( KeyEvent event , long eventTime , int newRepeat , int newFlags ) { KeyEvent ret = new KeyEvent ( event ) ; ret . mEventTime = eventTime ; ret . mRepeatCount = newRepeat ; ret . mFlags = newFlags ; return ret ; } 
public static < T > T parseFile ( Readable readable , CompositionBuilder < T > piece ) { Scanner scanner = new Scanner ( readable ) ; while ( scanner . hasNext ( ) ) { String lineType = scanner . next ( ) ; switch ( lineType ) { case "tempo" : try { piece . setTempo ( scanner . nextInt ( ) ) ; } catch ( NoSuchElementException e ) { throw new IllegalArgumentException ( "Malformed-tempo-line:-" + scanner . nextLine ( ) ) ; } break ; case "note" : try { int startBeat = scanner . nextInt ( ) ; int endBeat = scanner . nextInt ( ) ; int instrument = scanner . nextInt ( ) ; int pitch = scanner . nextInt ( ) ; int volume = scanner . nextInt ( ) ; piece . addNote ( startBeat , endBeat , instrument , pitch , volume ) ; } catch ( NoSuchElementException e ) { throw new IllegalArgumentException ( "Malformed-note-line:-" + scanner . nextLine ( ) ) ; } break ; default : throw new IllegalArgumentException ( "Bad-line-type:-" + lineType ) ; } } return piece . build ( ) ; } 
@ Override public Complex multiply ( Complex factor ) throws NullArgumentException { MathUtils . checkNotNull ( factor ) ; if ( isNaN || factor . isNaN ) { return NaN ; } if ( Double . isInfinite ( real ) || Double . isInfinite ( imaginary ) || Double . isInfinite ( factor . real ) || Double . isInfinite ( factor . imaginary ) ) { return INF ; } return createComplex ( real * factor . real - imaginary * factor . imaginary , real * factor . imaginary + imaginary * factor . real ) ; } 
private long overflowFree ( long delay ) { Delayed head = ( Delayed ) super . getQueue ( ) . peek ( ) ; if ( head != null ) { long headDelay = head . getDelay ( TimeUnit . NANOSECONDS ) ; if ( headDelay < 0 && ( delay - headDelay < 0 ) ) delay = Long . MAX_VALUE + headDelay ; } return delay ; } 
protected void parseNode ( String nodeName , Node data ) { NodeList children = data . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node child = children . item ( i ) ; parseAttributes ( nodeName , child ) ; String name = child . getNodeName ( ) ; String value = LimeXMLUtils . getTextContent ( child ) ; if ( value == null ) continue ; value = value . trim ( ) ; if ( value . equals ( "" ) ) continue ; parseChild ( nodeName , name , null , value ) ; } } 
public void startDrag ( Cursor dragCursor , Transferable transferable , DragSourceListener dsl ) throws InvalidDnDOperationException { dragSource . startDrag ( this , dragCursor , transferable , dsl ) ; } 
public static int getIntegerAttributeValue ( AttributeSet set , HTML . Attribute attribute , int defaultValue ) { Object v = set . getAttribute ( attribute ) ; if ( v == null ) { return defaultValue ; } try { return Integer . parseInt ( v . toString ( ) . trim ( ) ) ; } catch ( Exception ex ) { return defaultValue ; } } 
public static void appendToRule ( StringBuffer rule , String text , boolean isLiteral , boolean escapeUnprintable , StringBuffer quoteBuf ) { for ( int i = 0 ; i < text . length ( ) ; ++ i ) { appendToRule ( rule , text . charAt ( i ) , isLiteral , escapeUnprintable , quoteBuf ) ; } } 
Reaper ( ) { super ( "File-Reaper" ) ; setPriority ( Thread . MAX_PRIORITY ) ; setDaemon ( true ) ; } 
public void drawRoundRect ( RectF rect , float rx , float ry , Paint paint ) { if ( rect == null ) { throw new NullPointerException ( ) ; } native_drawRoundRect ( mNativeCanvas , rect , rx , ry , paint . mNativePaint ) ; } 
@ Override public synchronized void initialize ( ) { if ( ! mRootDirectory . exists ( ) ) { if ( ! mRootDirectory . mkdirs ( ) ) { VolleyLog . e ( "Unable-to-create-cache-dir-%s" , mRootDirectory . getAbsolutePath ( ) ) ; } return ; } File [ ] files = mRootDirectory . listFiles ( ) ; if ( files == null ) { return ; } for ( File file : files ) { FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; CacheHeader entry = CacheHeader . readHeader ( fis ) ; entry . size = file . length ( ) ; putEntry ( entry . key , entry ) ; } catch ( IOException e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ignored ) { } } } } 
public static DataSet < Vertex < Long , String >> getVertices ( ExecutionEnvironment env ) { List < Vertex < Long , String >> vertices = Lists . newArrayListWithExpectedSize ( 6 ) ; vertices . add ( new Vertex < > ( 0L , "A" ) ) ; vertices . add ( new Vertex < > ( 1L , "A" ) ) ; vertices . add ( new Vertex < > ( 2L , "B" ) ) ; vertices . add ( new Vertex < > ( 3L , "B" ) ) ; vertices . add ( new Vertex < > ( 4L , "B" ) ) ; vertices . add ( new Vertex < > ( 5L , "C" ) ) ; return env . fromCollection ( vertices ) ; } 
public LexicalUnit parsePropertyValue ( InputSource source ) throws CSSException , IOException { return parser . parsePropertyValue ( source ) ; } 
public TableGenerator < T > name ( String name ) { childNode . attribute ( "name" , name ) ; return this ; } 
public BatchStatus getBatchStatus ( ) { return getExtension ( BatchStatus . class ) ; } 
public Field [ ] getDeclaredFields ( ) { int initial_size = sFields == null ? 0 : sFields . length ; initial_size += iFields == null ? 0 : iFields . length ; ArrayList < Field > fields = new ArrayList ( initial_size ) ; getDeclaredFieldsUnchecked ( false , fields ) ; Field [ ] result = fields . toArray ( new Field [ fields . size ( ) ] ) ; for ( Field f : result ) { f . getType ( ) ; } return result ; } 
public synchronized void runTask ( HeadTaskRunnable toRun ) { this . task = toRun ; this . notify ( ) ; } 
public List < Track > getTrack ( ) { if ( track == null ) { track = new ArrayList < Track > ( ) ; } return this . track ; } 
public static double roundToDecimals ( double number , int decimalPlaces ) { int pow = ( int ) Math . pow ( 10 , decimalPlaces ) ; return Math . round ( number * pow ) / pow ; } 
public Principal getPeerPrincipal ( ) throws SSLPeerUnverifiedException { Certificate [ ] certs = getServerCertificates ( ) ; if ( certs == null || certs . length == 0 || ( ! ( certs [ 0 ] instanceof X509Certificate ) ) ) { throw new SSLPeerUnverifiedException ( "No-server's-end-entity-certificate" ) ; } return ( ( X509Certificate ) certs [ 0 ] ) . getSubjectX500Principal ( ) ; } 
public DTMIterator iter ( ) throws javax . xml . transform . TransformerException { error ( XPATHErrorResources . ER_CANT_CONVERT_TO_NODELIST , new Object [ ] { getTypeString ( ) } ) ; return null ; } 
public SelectionBuilder reset ( ) { mTable = null ; mGroupBy = null ; mHaving = null ; mSelection . setLength ( 0 ) ; mSelectionArgs . clear ( ) ; return this ; } 
@ XmlElementDecl ( namespace = "http://xmlns.oracle.com/apps/cdm/foundation/parties/personService/" , name = "RequestId" , scope = AdditionalPersonName . class ) public JAXBElement < Long > createAdditionalPersonNameRequestId ( Long value ) { return new JAXBElement < Long > ( _PersonProfileRequestId_QNAME , Long . class , AdditionalPersonName . class , value ) ; } 
public List < UIElement > getChilds ( ) { return Collections . unmodifiableList ( childElements ) ; } 
public static void sleep ( long ms , int ns ) { try { Thread . sleep ( ms , ns ) ; } catch ( Exception e ) { } } 
private void getFileDate ( ) { String [ ] theMonths = { "Jan" , "Feb" , "Mar" , "Apr" , "May" , "Jun" , "Jul" , "Aug" , "Sep" , "Oct" , "Nov" , "Dec" } ; String strMonth , strDay , strDate , strYear ; int c = 0 ; File file = new File ( fileName ) ; Long lastModified = file . lastModified ( ) ; Date fileDate = new Date ( lastModified ) ; strDate = fileDate . toString ( ) ; strMonth = strDate . substring ( 4 , 7 ) ; while ( ! strMonth . equals ( theMonths [ c ] ) ) c ++ ; c ++ ; if ( c < 10 ) strMonth = "0" + c ; else strMonth = "" + c ; strDay = strDate . substring ( 8 , 10 ) ; strYear = strDate . substring ( strDate . length ( ) - 4 , strDate . length ( ) ) ; date = "" + strYear + "-" + strMonth + "-" + strDay ; } 
public void addFragment ( final TextFragment fragment ) { this . fragments . add ( fragment ) ; } 
@ Deprecated public int getMaxDecent ( ) { return getMaxDescent ( ) ; } 
static Implementation getImplementation ( String baseName , String algorithm , Provider prov , Class [ ] ctorparamtype , Object [ ] ctorparam ) throws InvalidAlgorithmParameterException { String alias ; while ( ( alias = prov . getProperty ( "Alg.Alias." + baseName + "." + algorithm ) ) != null ) { algorithm = alias ; } String className = prov . getProperty ( baseName + "." + algorithm ) ; if ( className != null ) { try { return new Implementation ( Class . forName ( className ) . getConstructor ( ctorparamtype ) . newInstance ( ctorparam ) , prov ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( "algorithm-" + algorithm + "-in-provider-" + prov . getName ( ) + "-but-no-class-found!" ) ; } catch ( Exception e ) { if ( e instanceof InvalidAlgorithmParameterException ) { throw ( InvalidAlgorithmParameterException ) e ; } throw new IllegalStateException ( "algorithm-" + algorithm + "-in-provider-" + prov . getName ( ) + "-but-class-inaccessible!" ) ; } } return null ; } 
protected int getOctet ( int field ) { Integer octet = ( Integer ) mHeaderMap . get ( field ) ; if ( null == octet ) { return 0 ; } return octet ; } 
public DatagramSocket createDatagramSocket ( ) throws SocketException { return new DatagramSocket ( ) ; } 
private void replaceTop ( JsonScope topOfStack ) { stack . set ( stack . size ( ) - 1 , topOfStack ) ; } 
public static File getFile ( URL resourceUrl , String description ) throws FileNotFoundException { if ( ! URL_PROTOCOL_FILE . equals ( resourceUrl . getProtocol ( ) ) ) { throw new FileNotFoundException ( description + "-cannot-be-resolved-to-absolute-file-path-" + "because-it-does-not-reside-in-the-file-system:-" + resourceUrl ) ; } try { return new File ( toURI ( resourceUrl ) . getSchemeSpecificPart ( ) ) ; } catch ( URISyntaxException ex ) { return new File ( resourceUrl . getFile ( ) ) ; } } 
@ Override public StringBuffer format ( long number , StringBuffer toAppendTo , FieldPosition pos ) { String l_hex = Long . toHexString ( number ) . toUpperCase ( ) ; int l_pad = this . m_numDigits - l_hex . length ( ) ; l_pad = ( 0 < l_pad ) ? l_pad : 0 ; StringBuffer l_extended = new StringBuffer ( "0x" ) ; for ( int i = 0 ; i < l_pad ; i ++ ) { l_extended . append ( 0 ) ; } l_extended . append ( l_hex ) ; return l_extended ; } 
public ArrayList < PostingDocWeight > getPosting ( HashMap < Long , ArrayList < PostingDocWeight >> dynSIndex , long t ) { if ( ! dynSIndex . containsKey ( t ) ) { dynSIndex . put ( t , new ArrayList < PostingDocWeight > ( ) ) ; } return dynSIndex . get ( t ) ; } 
@ Override public StringBuffer format ( final double value , final StringBuffer buffer , final FieldPosition position ) { return format ( Double . valueOf ( value ) , buffer , position ) ; } 
public boolean containsAll ( Collection < ? > c ) { Iterator < ? > itr = c . iterator ( ) ; int pos = c . size ( ) ; while ( -- pos >= 0 ) if ( ! contains ( itr . next ( ) ) ) return false ; return true ; } 
private javax . swing . JLabel getJLabel1 ( ) { if ( ivjJLabel1 == null ) { try { ivjJLabel1 = new javax . swing . JLabel ( ) ; ivjJLabel1 . setName ( "JLabel1" ) ; ivjJLabel1 . setIcon ( new javax . swing . ImageIcon ( getClass ( ) . getResource ( "/images/splash.gif" ) ) ) ; ivjJLabel1 . setText ( "" ) ; ivjJLabel1 . setHorizontalTextPosition ( javax . swing . SwingConstants . CENTER ) ; ivjJLabel1 . setHorizontalAlignment ( javax . swing . SwingConstants . CENTER ) ; } catch ( java . lang . Throwable ivjExc ) { handleException ( ivjExc ) ; } } return ivjJLabel1 ; } 
public void setTag ( int key , final Object tag ) { if ( ( key >>> 24 ) < 2 ) { throw new IllegalArgumentException ( "The-key-must-be-an-application-specific-" + "resource-id." ) ; } setKeyedTag ( key , tag ) ; } 
public static String [ ] getNames ( JSONObject jo ) { int length = jo . length ( ) ; if ( length == 0 ) { return null ; } Iterator iterator = jo . keys ( ) ; String [ ] names = new String [ length ] ; int i = 0 ; while ( iterator . hasNext ( ) ) { names [ i ] = ( String ) iterator . next ( ) ; i += 1 ; } return names ; } 
public synchronized void removeRemoteMessageBox ( Agent agent ) throws RemoteException { List < RemoteMessageBox > toDelete = getRMBsOfAgent ( agent ) ; if ( toDelete . size ( ) != 1 ) throw new RemoteException ( "you-can-delete-only-your-message-box" ) ; messageBoxes . remove ( toDelete . get ( 0 ) ) ; notifyObservers ( "Box-removed-of-" + toDelete . get ( 0 ) . getOwner ( ) . toString ( ) + "-" ) ; } 
@ SuppressWarnings ( "unchecked" ) public Node getEnclosingFunction ( ) { if ( scopes . size ( ) + scopeRoots . size ( ) < 2 ) { return null ; } else { if ( scopeRoots . isEmpty ( ) ) { return scopes . peek ( ) . getRootNode ( ) ; } else { return scopeRoots . peek ( ) ; } } } 
public void setDomain ( String domain ) { if ( domain != null ) { cookieDomain = domain . toLowerCase ( Locale . ENGLISH ) ; } else { cookieDomain = null ; } } 
public Object visit ( ASTPrimaryExpression node , Object data ) { node . childrenAccept ( this , data ) ; return data ; } 
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = false ; } 
public Object readUpdate ( LogInputStream in , Object state ) throws Exception { MarshalInputStream s = new MarshalInputStream ( in ) ; return applyUpdate ( s . readObject ( ) , state ) ; } 
public static CipherSuite getByName ( String name ) { return cuitesByName . get ( name ) ; } 
public static double [ ] readDoubleArray ( DataInput in ) throws IOException { int length = in . readInt ( ) ; double [ ] array = new double [ length ] ; for ( int index = 0 ; index < length ; index ++ ) { array [ index ] = in . readDouble ( ) ; } return array ; } 
public Elements getElementsByClass ( String className ) { Validate . notEmpty ( className ) ; return Collector . collect ( new Evaluator . Class ( className ) , this ) ; } 
static void setBaseViewPath ( String baseViewPath ) { if ( baseViewPath == null ) throw new IllegalArgumentException ( "The-baseViewPath-can-not-be-null" ) ; baseViewPath = baseViewPath . trim ( ) ; if ( "" . equals ( baseViewPath ) ) throw new IllegalArgumentException ( "The-baseViewPath-can-not-be-blank" ) ; if ( ! baseViewPath . startsWith ( "/" ) ) baseViewPath = "/" + baseViewPath ; if ( baseViewPath . endsWith ( "/" ) ) baseViewPath = baseViewPath . substring ( 0 , baseViewPath . length ( ) - 1 ) ; Routes . baseViewPath = baseViewPath ; } 
public static boolean hasSeconds ( CharSequence inFormat ) { if ( inFormat == null ) return false ; final int length = inFormat . length ( ) ; int c ; int count ; for ( int i = 0 ; i < length ; i += count ) { count = 1 ; c = inFormat . charAt ( i ) ; if ( c == QUOTE ) { count = skipQuotedText ( inFormat , i , length ) ; } else if ( c == SECONDS ) { return true ; } } return false ; } 
void unlink ( Node < E > p , Node < E > trail ) { p . item = null ; trail . next = p . next ; if ( last == p ) last = trail ; if ( count . getAndDecrement ( ) == capacity ) notFull . signal ( ) ; } 
public void insertar ( int index , DatoParaTabla dato ) { datos . add ( index , dato ) ; } 
public void setPKProxy ( JAXBElement < String > value ) { this . pkProxy = ( ( JAXBElement < String > ) value ) ; } 
public final String yytext ( ) { return new String ( zzBuffer , zzStartRead , zzMarkedPos - zzStartRead ) ; } 
@ XmlElementDecl ( namespace = "" , name = "registrationMetadata" ) public JAXBElement < RegistrationMetadata > createRegistrationMetadata ( RegistrationMetadata value ) { return new JAXBElement < > ( _RegistrationMetadata_QNAME , RegistrationMetadata . class , null , value ) ; } 
public void Test4101481 ( ) { DecimalFormat sdf = new DecimalFormat ( "#,##0" ) ; if ( sdf . getMinimumIntegerDigits ( ) != 1 ) errln ( "Minimum-integer-digits-:-" + sdf . getMinimumIntegerDigits ( ) ) ; } 
public final ResourceReference getResourceReference ( final Key key , final boolean strict , final boolean createIfNotFound ) { ResourceReference resource = _getResourceReference ( key . getScope ( ) , key . getName ( ) , key . getLocale ( ) , key . getStyle ( ) , key . getVariation ( ) , strict ) ; if ( resource == null ) { if ( scanner . scanClass ( key . getScopeClass ( ) ) > 0 ) { resource = _getResourceReference ( key . getScope ( ) , key . getName ( ) , key . getLocale ( ) , key . getStyle ( ) , key . getVariation ( ) , strict ) ; } if ( ( resource == null ) && createIfNotFound ) { resource = addDefaultResourceReference ( key ) ; } } return resource ; } 
public static RequestAsyncTask executeBatchAsync ( Request ... requests ) { Validate . notNull ( requests , "requests" ) ; return executeBatchAsync ( Arrays . asList ( requests ) ) ; } 
public LinkedHashSet < String > getTestSet ( ) { return ( LinkedHashSet < String > ) testSet . clone ( ) ; } 
public void setInvertSelection ( boolean invert ) { m_SelectedRange . setInvert ( invert ) ; } 
private int lastIndexOfNumericTag ( String category ) { if ( category == null ) { return - 1 ; } int last = - 1 ; for ( int i = category . length ( ) - 1 ; i >= 0 ; i -- ) { if ( isLabelAnnotationIntroducingCharacter ( category . charAt ( i ) ) ) { boolean onlyDigitsFollow = false ; for ( int j = i + 1 ; j < category . length ( ) ; j ++ ) { onlyDigitsFollow = true ; if ( ! ( Character . isDigit ( category . charAt ( j ) ) ) ) { onlyDigitsFollow = false ; break ; } } if ( onlyDigitsFollow ) { last = i ; } } } return last ; } 
public ArrayList toArrayList ( ) { ArrayList a = new ArrayList ( ) ; String line [ ] = new String [ rangingConstants . size ( ) + 1 ] ; toArrayListRec ( a , line ) ; return a ; } 
public void element ( String elementName , Augmentations augs ) throws XNIException { if ( fMixed ) { if ( fNodeIndexStack [ fDepth ] == - 1 ) { fNodeIndexStack [ fDepth ] = addUniqueLeafNode ( elementName ) ; } else { fNodeIndexStack [ fDepth ] = addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_CHOICE , fNodeIndexStack [ fDepth ] , addUniqueLeafNode ( elementName ) ) ; } } else { fNodeIndexStack [ fDepth ] = addContentSpecNode ( XMLContentSpec . CONTENTSPECNODE_LEAF , elementName ) ; } } 
public int size ( ) { return queue . size ( ) ; } 
public static Document parse ( String html ) { return Parser . parse ( html , "" ) ; } 
public File mapUriToFile ( Uri uri ) { assertBackgroundThread ( ) ; switch ( getUriType ( uri ) ) { case URI_TYPE_FILE : return new File ( uri . getPath ( ) ) ; case URI_TYPE_CONTENT : { Cursor cursor = contentResolver . query ( uri , LOCAL_FILE_PROJECTION , null , null , null ) ; if ( cursor != null ) { try { int columnIndex = cursor . getColumnIndex ( LOCAL_FILE_PROJECTION [ 0 ] ) ; if ( columnIndex != - 1 && cursor . getCount ( ) > 0 ) { cursor . moveToFirst ( ) ; String realPath = cursor . getString ( columnIndex ) ; if ( realPath != null ) { return new File ( realPath ) ; } } } finally { cursor . close ( ) ; } } } } return null ; } 
public static final int getDefaultPort ( ) { if ( getDefaultHost ( ) == null ) return - 1 ; try { return Integer . parseInt ( System . getProperty ( "http.proxyPort" ) ) ; } catch ( NumberFormatException e ) { return - 1 ; } } 
private CallerInfoAsyncQueryHandler ( Context context ) { super ( context . getContentResolver ( ) ) ; } 
long freeSpaceWindows ( String path , long timeout ) throws IOException { path = FilenameUtils . normalize ( path , false ) ; if ( path . length ( ) > 0 && path . charAt ( 0 ) != '"' ) { path = """ + path + """ ; } String [ ] cmdAttribs = new String [ ] { "cmd.exe" , "/C" , "dir-/a-/-c-" + path } ; List < String > lines = performCommand ( cmdAttribs , Integer . MAX_VALUE , timeout ) ; for ( int i = lines . size ( ) - 1 ; i >= 0 ; i -- ) { String line = lines . get ( i ) ; if ( line . length ( ) > 0 ) { return parseDir ( line , path ) ; } } throw new IOException ( "Command-line-'dir-/-c'-did-not-return-any-info-" + "for-path-'" + path + "'" ) ; } 
File getOutputFile ( String urlPath ) { return new File ( current . get ( ) . getWarDir ( ) , urlPath ) ; } 
public final void sendTo ( SocketChannel sc , ByteBuffer buf ) throws IOException { if ( getLength ( ) > 0 ) { final int BUF_MAX = buf . capacity ( ) ; if ( this . part instanceof byte [ ] ) { final byte [ ] bytes = ( byte [ ] ) this . part ; int off = 0 ; int len = bytes . length ; buf . clear ( ) ; while ( len > 0 ) { int bytesThisTime = len ; if ( bytesThisTime > BUF_MAX ) { bytesThisTime = BUF_MAX ; } buf . put ( bytes , off , bytesThisTime ) ; len -= bytesThisTime ; off += bytesThisTime ; buf . flip ( ) ; while ( buf . remaining ( ) > 0 ) { sc . write ( buf ) ; } buf . clear ( ) ; } } else { HeapDataOutputStream hdos = ( HeapDataOutputStream ) this . part ; hdos . sendTo ( sc , buf ) ; hdos . rewind ( ) ; } } } 
protected Classifier ( String n ) { int lastDot = n . lastIndexOf ( '.' ) ; containingPackage = lastDot == - 1 ? "" : n . substring ( 0 , lastDot ) ; containingPackage = containingPackage . intern ( ) ; name = n . substring ( lastDot + 1 ) . intern ( ) ; } 
private void ensureAccessibilityEnabled ( Context context , boolean enabled ) throws Exception { boolean isEnabled = ( Settings . Secure . getInt ( context . getContentResolver ( ) , Settings . Secure . ACCESSIBILITY_ENABLED , 0 ) == 1 ? true : false ) ; if ( isEnabled == enabled ) { return ; } Settings . Secure . putInt ( context . getContentResolver ( ) , Settings . Secure . ACCESSIBILITY_ENABLED , enabled ? 1 : 0 ) ; Thread . sleep ( TIMEOUT_BINDER_CALL ) ; } 
public static void shutdown ( ) { helpMenus . clear ( ) ; helpMenus = null ; } 
@ Override public boolean remove ( Object object ) { return backingMap . remove ( object ) != null ; } 
private byte [ ] windowsAbsolutePath ( ) { ByteArrayOutputStream bstream = new ByteArrayOutputStream ( ) ; bstream . write ( WINDOWS_ROOT_PATH , 0 , WINDOWS_ROOT_PATH . length - 1 ) ; StringTokenizer tokenizer = new StringTokenizer ( absolutePath ( ) , "/" ) ; while ( tokenizer . hasMoreTokens ( ) ) { bstream . write ( ( byte ) '|' ) ; String nextName = tokenizer . nextToken ( ) ; byte [ ] windowsNextName = toWindowsName ( nextName ) ; bstream . write ( windowsNextName , 0 , windowsNextName . length - 1 ) ; } bstream . write ( 0 ) ; return bstream . toByteArray ( ) ; } 
public AccessibleStateSet getAccessibleStateSet ( ) { AccessibleStateSet states = super . getAccessibleStateSet ( ) ; if ( getFocusOwner ( ) != null ) { states . add ( AccessibleState . ACTIVE ) ; } return states ; } 
private static Uri . Builder buildGetMethod ( ) { final Uri . Builder builder = new Uri . Builder ( ) ; builder . path ( API_REST_URL ) ; return builder ; } 
public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , ObjectType type ) { methodGen . getInstructionList ( ) . append ( NOP ) ; } 
public Line getPositionedLine ( ROVector2f displacement , float rotation ) { Vector2f [ ] verts = getVertices ( displacement , rotation ) ; Line line = new Line ( verts [ 0 ] , verts [ 1 ] ) ; return line ; } 
private JTextArea getAssertText ( ) { if ( assertText == null ) { assertText = new JTextArea ( ) ; assertText . setLineWrap ( false ) ; assertText . setName ( "assert" ) ; assertText . setText ( "Assert-messages-goes-here:" ) ; assertText . setWrapStyleWord ( true ) ; } return assertText ; } 
void addChildToBack ( Node parent , Node child ) { parent . addChildToBack ( child ) ; } 
public void addViewInstance ( View view ) { views . push ( view ) ; } 
public void setEntityResolver ( XMLEntityResolver entityResolver ) { if ( fEntityResolver != entityResolver ) { if ( ++ fModCount < 0 ) { clearModCounts ( ) ; } fEntityResolver = entityResolver ; } } 
public void remove ( V removeobj ) { final String key = objectKeyMap . get ( removeobj ) ; if ( key != null ) { objectKeyMap . remove ( removeobj ) ; keyObjectMap . remove ( key ) ; } } 
@ XmlElementDecl ( namespace = "http://www.collada.org/2005/11/COLLADASchema" , name = "fixed3" , scope = CgSetuserType . class ) public JAXBElement < List < java . lang . Float >> createCgSetuserTypeFixed3 ( List < java . lang . Float > value ) { return new JAXBElement < List < java . lang . Float >> ( _CgNewarrayTypeFixed3_QNAME , ( ( Class ) List . class ) , CgSetuserType . class , ( ( List < java . lang . Float > ) value ) ) ; } 
public boolean getBoolean ( int index ) throws JSONException { Object object = get ( index ) ; if ( object . equals ( Boolean . FALSE ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( Boolean . TRUE ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONArray[" + index + "]-is-not-a-boolean." ) ; } 
public void initializeEhcache ( final Ehcache cache ) { try { Method method = this . cacheManager . getClass ( ) . getDeclaredMethod ( "initializeEhcache" , Ehcache . class , boolean . class ) ; method . setAccessible ( true ) ; method . invoke ( cacheManager , cache , false ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } 
public synchronized boolean remove ( String key ) throws IOException { checkNotClosed ( ) ; validateKey ( key ) ; Entry entry = lruEntries . get ( key ) ; if ( entry == null || entry . currentEditor != null ) { return false ; } for ( int i = 0 ; i < valueCount ; i ++ ) { File file = entry . getCleanFile ( i ) ; if ( ! file . delete ( ) ) { throw new IOException ( "failed-to-delete-" + file ) ; } size -= entry . lengths [ i ] ; entry . lengths [ i ] = 0 ; } redundantOpCount ++ ; journalWriter . append ( REMOVE + '-' + key + '|n' ) ; lruEntries . remove ( key ) ; if ( journalRebuildRequired ( ) ) { executorService . submit ( cleanupCallable ) ; } return true ; } 
public static void pr ( String s ) { if ( showStructure ) System . out . print ( indentStr . substring ( 0 , level * 2 ) ) ; System . out . println ( s ) ; } 
public List < IntrospectedColumn > getAllColumns ( ) { List < IntrospectedColumn > answer = new ArrayList < IntrospectedColumn > ( ) ; answer . addAll ( primaryKeyColumns ) ; answer . addAll ( baseColumns ) ; answer . addAll ( blobColumns ) ; return answer ; } 
public int columnAtPoint ( Point point ) { int x = point . x ; if ( ! getComponentOrientation ( ) . isLeftToRight ( ) ) { x = getWidth ( ) - x - 1 ; } return getColumnModel ( ) . getColumnIndexAtX ( x ) ; } 
public static void intBenchmarkPrimitive ( int runs , int rows , int columns , boolean print ) { throw new InternalError ( ) ; } 
public static void clearDnsCache ( ) { addressCache . clear ( ) ; } 
private Uri whichContentStore ( ) { if ( Environment . getExternalStorageState ( ) . equals ( Environment . MEDIA_MOUNTED ) ) { return android . provider . MediaStore . Images . Media . EXTERNAL_CONTENT_URI ; } else { return android . provider . MediaStore . Images . Media . INTERNAL_CONTENT_URI ; } } 
public static int getNumWindows ( ) { synchronized ( windowList ) { return windowList . size ( ) ; } } 
public String getValueClassName ( ) { return in . getValueClassName ( ) ; } 
public Integer getNumber ( ) { if ( this . name != null ) { final StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < this . name . length ( ) ; i ++ ) { char c = this . name . charAt ( i ) ; if ( Character . isDigit ( c ) ) { sb . append ( c ) ; } } if ( sb . length ( ) > 0 ) { return Integer . parseInt ( sb . toString ( ) ) ; } } return null ; } 
public static boolean addElement ( EZElement ve , int index ) { if ( index < 0 || index > EZ . app . elements . size ( ) ) { System . out . println ( "ERROR:-attempting-to-add-an-element-into-an-invalid-index." ) ; return false ; } EZ . app . elements . add ( index , ve ) ; return true ; } 
public String getSchemeSpecificPart ( ) { return decode ( schemeSpecificPart ) ; } 
private boolean isRequestValid ( ) { if ( IPMessageMap . get ( request . getAddress ( ) ) != null ) return dividedMessage [ 0 ] . hashCode ( ) == Integer . parseInt ( dividedMessage [ 1 ] ) && IPMessageMap . get ( request . getAddress ( ) ) != request . hashCode ( ) ; else return dividedMessage [ 0 ] . hashCode ( ) == Integer . parseInt ( dividedMessage [ 1 ] ) ; } 
public HashSet < String > readStringSet ( String endTag ) throws IOException { HashSet < String > result = new HashSet < String > ( ) ; while ( true ) { String string = readString ( ) ; if ( string == null ) { throw new IOException ( "Expected-" + endTag + "-but-found-EOF" ) ; } if ( string . equals ( endTag ) ) { return result ; } result . add ( string ) ; } } 
public int populateAllSampleKeywords ( ) throws Exception { sampleIds . clear ( ) ; try { Statement stmt = con . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( "SELECT-SampleID-FROM-Sample-WHERE-KeywordLookupStatus-<>-0" ) ; while ( rs . next ( ) ) { Integer newInteger = new Integer ( rs . getInt ( 1 ) ) ; sampleIds . add ( newInteger ) ; } } catch ( SQLException ex ) { System . err . println ( "KeywordLookup-SQLException:-" + ex . getMessage ( ) ) ; ex . printStackTrace ( ) ; throw ex ; } int numSuccess = 0 ; if ( ! sampleIds . isEmpty ( ) ) { Iterator idIt = sampleIds . iterator ( ) ; while ( idIt . hasNext ( ) ) { Integer tmpInteger = ( Integer ) idIt . next ( ) ; int sampleId = tmpInteger . intValue ( ) ; try { System . out . print ( "SampleID:-" + sampleId ) ; int numKeywords = populateSampleKeywords ( sampleId ) ; System . out . println ( "---Keywords-Found:-" + numKeywords ) ; numSuccess = numSuccess + 1 ; } catch ( Exception ex ) { System . err . println ( "SampleID:-" + sampleId + ",-Exception:-" + ex . getMessage ( ) ) ; ex . printStackTrace ( ) ; } } } int result = numSuccess - sampleIds . size ( ) ; if ( result == 0 ) { result = sampleIds . size ( ) ; } return ( result ) ; } 
public static Context getContinuationContext ( CannotProceedException cpe ) throws NamingException { Hashtable env = cpe . getEnvironment ( ) ; if ( env == null ) { env = new Hashtable ( 7 ) ; } else { env = ( Hashtable ) env . clone ( ) ; } env . put ( CPE , cpe ) ; ContinuationContext cctx = new ContinuationContext ( cpe , env ) ; return cctx . getTargetContext ( ) ; } 
public boolean willNotMoveInCurrentCollection ( ObjectReference object ) { return ! Space . isInSpace ( MC . MARK_COMPACT , object ) ; } 
public final Date getTime ( ) { return new Date ( getTimeInMillis ( ) ) ; } 
public boolean isDefaultLut ( ) { if ( cm == null ) makeDefaultColorModel ( ) ; if ( ! ( cm instanceof IndexColorModel ) ) return false ; IndexColorModel icm = ( IndexColorModel ) cm ; int mapSize = icm . getMapSize ( ) ; if ( mapSize != 256 ) return false ; byte [ ] reds = new byte [ mapSize ] ; byte [ ] greens = new byte [ mapSize ] ; byte [ ] blues = new byte [ mapSize ] ; icm . getReds ( reds ) ; icm . getGreens ( greens ) ; icm . getBlues ( blues ) ; boolean isDefault = true ; for ( int i = 0 ; i < mapSize ; i ++ ) { if ( ( reds [ i ] & 255 ) != i || ( greens [ i ] & 255 ) != i || ( blues [ i ] & 255 ) != i ) { isDefault = false ; break ; } } return isDefault ; } 
public ColorUIResource getMenuSelectedBackground ( ) { return getPrimary2 ( ) ; } 
public synchronized Set getChildren ( ObjectName parent ) { Set children = ( Set ) parentToChildMap . get ( parent ) ; if ( children == null ) { return Collections . EMPTY_SET ; } return new HashSet ( children ) ; } 
public String emitPattern ( boolean withWhiteSpace ) { StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < patterns . size ( ) ; ++ i ) { PatternEntry entry = ( PatternEntry ) patterns . get ( i ) ; if ( entry != null ) { entry . addToBuffer ( result , true , withWhiteSpace , null ) ; } } return result . toString ( ) ; } 
public int sendCommand ( String command , String args ) throws IOException { if ( _writer == null ) { throw new IllegalStateException ( "Socket-is-not-connected" ) ; } StringBuilder __commandBuffer = new StringBuilder ( ) ; __commandBuffer . append ( command ) ; if ( args != null ) { __commandBuffer . append ( '-' ) ; __commandBuffer . append ( args ) ; } __commandBuffer . append ( SocketClient . NETASCII_EOL ) ; String message = __commandBuffer . toString ( ) ; _writer . write ( message ) ; _writer . flush ( ) ; fireCommandSent ( command , message ) ; __getReply ( ) ; return _replyCode ; } 
private SchemaFactory loadFromServicesFile ( String schemaLanguage , String resourceName , InputStream in ) { if ( debug ) debugPrintln ( "Reading-" + resourceName ) ; BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( in , "UTF-8" ) , DEFAULT_LINE_LENGTH ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( in ) , DEFAULT_LINE_LENGTH ) ; } String factoryClassName = null ; SchemaFactory resultFactory = null ; while ( true ) { try { factoryClassName = rd . readLine ( ) ; } catch ( IOException x ) { break ; } if ( factoryClassName != null ) { int hashIndex = factoryClassName . indexOf ( '#' ) ; if ( hashIndex != - 1 ) { factoryClassName = factoryClassName . substring ( 0 , hashIndex ) ; } factoryClassName = factoryClassName . trim ( ) ; if ( factoryClassName . length ( ) == 0 ) { continue ; } try { SchemaFactory foundFactory = ( SchemaFactory ) createInstance ( factoryClassName ) ; if ( foundFactory . isSchemaLanguageSupported ( schemaLanguage ) ) { resultFactory = foundFactory ; break ; } } catch ( Exception e ) { } } else { break ; } } try { rd . close ( ) ; } catch ( IOException exc ) { } return resultFactory ; } 
private static String [ ] calcPathIdAndPathLock ( final String namespace ) { String pathId = "/" + namespace . replaceAll ( "^|/+" , "" ) . replaceAll ( "|/+$" , "" ) ; String pathLock = pathId + "/lock" ; return new String [ ] { pathId , pathLock } ; } 
public static String toJvmName ( String classname ) { return classname . replace ( '.' , '/' ) ; } 
public static void d ( String tag , String s , Object ... args ) { if ( LOG . DEBUG >= LOGLEVEL ) Log . d ( tag , String . format ( s , args ) ) ; } 
static SimpleType < ? > getPrimitiveOpenType ( String primitiveTypeName ) { for ( Object [ ] typeDescr : PRIMITIVE_ARRAY_TYPES ) { if ( primitiveTypeName . equals ( typeDescr [ PRIMITIVE_TYPE_NAME_INDEX ] ) ) return ( SimpleType < ? > ) typeDescr [ PRIMITIVE_OPEN_TYPE_INDEX ] ; } return null ; } 
public static boolean linesIntersect ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 , double x4 , double y4 ) { return ( ( relativeCCW ( x1 , y1 , x2 , y2 , x3 , y3 ) * relativeCCW ( x1 , y1 , x2 , y2 , x4 , y4 ) <= 0 ) && ( relativeCCW ( x3 , y3 , x4 , y4 , x1 , y1 ) * relativeCCW ( x3 , y3 , x4 , y4 , x2 , y2 ) <= 0 ) ) ; } 
public String printAttributes ( ) { String forReturn = "" ; for ( Map . Entry < String , String > entry : attributes . entrySet ( ) ) { forReturn = forReturn + entry . getKey ( ) + ":-" + entry . getValue ( ) + "-" ; } return forReturn ; } 
synchronized void remove ( Range range ) { if ( range . isEmpty ( ) ) { return ; } long startIndex = range . getStartIndex ( ) ; long endIndex = range . getEndIndex ( ) ; SortedSet < Range > headSet = ranges . headSet ( range ) ; if ( headSet . size ( ) > 0 ) { Range previousRange = headSet . last ( ) ; LOG . debug ( "previousRange-" + previousRange ) ; if ( startIndex < previousRange . getEndIndex ( ) ) { if ( ranges . remove ( previousRange ) ) { indicesCount -= previousRange . getLength ( ) ; LOG . debug ( "removed-previousRange-" + previousRange ) ; } add ( previousRange . getStartIndex ( ) , startIndex ) ; if ( endIndex <= previousRange . getEndIndex ( ) ) { add ( endIndex , previousRange . getEndIndex ( ) ) ; } } } Iterator < Range > tailSetIt = ranges . tailSet ( range ) . iterator ( ) ; while ( tailSetIt . hasNext ( ) ) { Range nextRange = tailSetIt . next ( ) ; LOG . debug ( "nextRange-" + nextRange + "-startIndex:" + startIndex + "-endIndex:" + endIndex ) ; if ( endIndex > nextRange . getStartIndex ( ) ) { tailSetIt . remove ( ) ; indicesCount -= nextRange . getLength ( ) ; if ( endIndex < nextRange . getEndIndex ( ) ) { add ( endIndex , nextRange . getEndIndex ( ) ) ; break ; } } else { break ; } } } 
public final void removeCallback ( StatusCallback callback ) { synchronized ( callbacks ) { callbacks . remove ( callback ) ; } } 
private void checkAndValidateAttributes ( Tag tag , boolean checkIfAttributeIsWelcome ) { Vector newAttributes = new Vector ( ) ; for ( Iterator iter = tag . getAttributesEx ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Attribute a = ( Attribute ) iter . next ( ) ; String name = a . getName ( ) ; if ( name == null ) { newAttributes . add ( a ) ; } else { name = name . toUpperCase ( ) ; if ( a . getValue ( ) == null ) { newAttributes . add ( a ) ; continue ; } String value = a . getValue ( ) . toLowerCase ( ) ; if ( checkIfAttributeIsWelcome && ! this . isAttributeWelcome ( name ) ) { continue ; } if ( ! this . isAttributeSafe ( name , value ) ) { continue ; } if ( a . getValue ( ) . indexOf ( "&#" ) > - 1 ) { a . setValue ( a . getValue ( ) . replaceAll ( "&#" , "&amp;#" ) ) ; } newAttributes . add ( a ) ; } } tag . setAttributesEx ( newAttributes ) ; } 
private void writeObject ( ObjectOutputStream s ) throws java . io . IOException { s . defaultWriteObject ( ) ; s . writeObject ( toString ( ) ) ; } 
public void configure ( MediaFormat format , Surface surface , MediaCrypto crypto , int flags ) { Map < String , Object > formatMap = format . getMap ( ) ; String [ ] keys = null ; Object [ ] values = null ; if ( format != null ) { keys = new String [ formatMap . size ( ) ] ; values = new Object [ formatMap . size ( ) ] ; int i = 0 ; for ( Map . Entry < String , Object > entry : formatMap . entrySet ( ) ) { keys [ i ] = entry . getKey ( ) ; values [ i ] = entry . getValue ( ) ; ++ i ; } } native_configure ( keys , values , surface , crypto , flags ) ; } 
public int getRow ( ) throws SQLException { checkClosed ( ) ; int currentRowNumber = this . rowData . getCurrentRowNumber ( ) ; int row = 0 ; if ( ! this . rowData . isDynamic ( ) ) { if ( ( currentRowNumber < 0 ) || this . rowData . isAfterLast ( ) || this . rowData . isEmpty ( ) ) { row = 0 ; } else { row = currentRowNumber + 1 ; } } else { row = currentRowNumber + 1 ; } return row ; } 
@ Override public boolean await ( long timeout , TimeUnit unit ) { try { return latch . await ( timeout , unit ) ; } catch ( InterruptedException e ) { throw new RedisCommandInterruptedException ( e ) ; } } 
public void setVisible ( boolean b ) { parent . setVisible ( b ) ; } 
public Document build ( InputStream in , String systemId ) throws JDOMException , IOException { InputSource src = new InputSource ( in ) ; src . setSystemId ( systemId ) ; return build ( src ) ; } 
public static Icon getIcon ( AttributeSet a ) { return ( Icon ) a . getAttribute ( IconAttribute ) ; } 
public String [ ] getLocation ( String uri ) throws JasperException { if ( ! initialized ) { init ( ) ; } return ( String [ ] ) mappings . get ( uri ) ; } 
public static boolean equals ( Object [ ] a , Object [ ] a2 ) { if ( a == a2 ) return true ; if ( a == null || a2 == null ) return false ; int length = a . length ; if ( a2 . length != length ) return false ; for ( int i = 0 ; i < length ; i ++ ) { Object o1 = a [ i ] ; Object o2 = a2 [ i ] ; if ( ! ( o1 == null ? o2 == null : o1 . equals ( o2 ) ) ) return false ; } return true ; } 
public int compareTo ( LongBuffer otherBuffer ) { int compareRemaining = ( remaining ( ) < otherBuffer . remaining ( ) ) ? remaining ( ) : otherBuffer . remaining ( ) ; int thisPos = position ; int otherPos = otherBuffer . position ; long thisLong , otherLong ; while ( compareRemaining > 0 ) { thisLong = get ( thisPos ) ; otherLong = otherBuffer . get ( otherPos ) ; if ( thisLong != otherLong ) { return thisLong < otherLong ? - 1 : 1 ; } thisPos ++ ; otherPos ++ ; compareRemaining -- ; } return remaining ( ) - otherBuffer . remaining ( ) ; } 
public static void setStrValue ( String value , int position , byte [ ] data ) throws java . io . IOException { OutputStream out = new ByteArrayOutputStream ( ) ; DataOutputStream outstr = new DataOutputStream ( out ) ; outstr . writeUTF ( value ) ; byte [ ] B = ( ( ByteArrayOutputStream ) out ) . toByteArray ( ) ; int sz = outstr . size ( ) ; System . arraycopy ( B , 0 , data , position , sz ) ; } 
public boolean understandsProperty ( String propertyToTest ) { return this . _resolverSpi . understandsProperty ( propertyToTest ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public void releaseAgent ( IPacControl agent ) { if ( agentInstanceList . contains ( agent ) ) { agentInstanceList . remove ( agent ) ; } } 
public Expression getCompareValue ( ) { if ( _value != null ) { return _value ; } if ( _exp == null ) { return null ; } if ( _exp instanceof EqualityExpr ) { EqualityExpr exp = ( EqualityExpr ) _exp ; Expression left = exp . getLeft ( ) ; Expression right = exp . getRight ( ) ; if ( left instanceof LiteralExpr ) { _value = left ; return _value ; } if ( left instanceof VariableRefBase && left . getType ( ) == Type . String ) { _value = left ; return _value ; } if ( right instanceof LiteralExpr ) { _value = right ; return _value ; } if ( right instanceof VariableRefBase && right . getType ( ) == Type . String ) { _value = right ; return _value ; } } return null ; } 
public float minutes ( ) { return seconds ( ) / 60 ; } 
private void init ( ) { mSdkCommandLine = new SdkCommandLine ( mSdkLog ) ; String toolsDirProp = System . getProperty ( TOOLSDIR ) ; if ( toolsDirProp == null ) { toolsDirProp = System . getenv ( TOOLSDIR ) ; } if ( toolsDirProp != null ) { File tools ; if ( toolsDirProp . length ( ) > 0 ) { tools = new File ( toolsDirProp ) ; mOsSdkFolder = tools . getParent ( ) ; } else { try { tools = new File ( "." ) . getCanonicalFile ( ) ; mOsSdkFolder = tools . getParent ( ) ; } catch ( IOException e ) { } } } if ( mOsSdkFolder == null ) { errorAndExit ( "The-tools-directory-property-is-not-set,-please-make-sure-you-are-executing-%1$s" , SdkConstants . androidCmdName ( ) ) ; } String workDirProp = System . getProperty ( WORKDIR ) ; if ( workDirProp == null ) { workDirProp = System . getenv ( WORKDIR ) ; } if ( workDirProp != null ) { mWorkDir = new File ( workDirProp ) ; try { mWorkDir = mWorkDir . getCanonicalFile ( ) . getAbsoluteFile ( ) ; } catch ( IOException e ) { mWorkDir = null ; } if ( mWorkDir == null || ! mWorkDir . isDirectory ( ) ) { errorAndExit ( "The-working-directory-does-not-seem-to-be-valid:-'%1$s" , workDirProp ) ; } } } 
public List < Float > getHalf1X4 ( ) { if ( half1X4 == null ) { half1X4 = new ArrayList < Float > ( ) ; } return this . half1X4 ; } 
public boolean matchesCS ( String seq ) { return queue . startsWith ( seq , pos ) ; } 
public void testSerialization ( ) { DialTextAnnotation a1 = new DialTextAnnotation ( "A1" ) ; DialTextAnnotation a2 = null ; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; ObjectOutput out = new ObjectOutputStream ( buffer ) ; out . writeObject ( a1 ) ; out . close ( ) ; ObjectInput in = new ObjectInputStream ( new ByteArrayInputStream ( buffer . toByteArray ( ) ) ) ; a2 = ( DialTextAnnotation ) in . readObject ( ) ; in . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } assertEquals ( a1 , a2 ) ; a1 = new DialTextAnnotation ( "A1" ) ; a1 . setPaint ( new GradientPaint ( 1.0f , 2.0f , Color . red , 3.0f , 4.0f , Color . blue ) ) ; a2 = null ; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; ObjectOutput out = new ObjectOutputStream ( buffer ) ; out . writeObject ( a1 ) ; out . close ( ) ; ObjectInput in = new ObjectInputStream ( new ByteArrayInputStream ( buffer . toByteArray ( ) ) ) ; a2 = ( DialTextAnnotation ) in . readObject ( ) ; in . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } assertEquals ( a1 , a2 ) ; } 
public final void setFloat ( String name , float value ) { mMap . put ( name , new Float ( value ) ) ; } 
public void setValueFromPersistentRepresentation ( String a_representation ) throws UnsupportedRepresentationException { if ( a_representation != null ) { if ( isValidRepresentation ( a_representation ) ) { a_representation = a_representation . substring ( 1 , a_representation . length ( ) - 1 ) ; StringTokenizer st = new StringTokenizer ( a_representation , "," ) ; int index = 0 ; while ( st . hasMoreTokens ( ) ) { int i = Integer . parseInt ( st . nextToken ( ) ) ; setBit ( index ++ , i ) ; } if ( index < getLength ( ) ) { throw new UnsupportedRepresentationException ( "Invalid-gene-representation:-" + a_representation ) ; } } else { throw new UnsupportedRepresentationException ( "Invalid-gene-representation:-" + a_representation ) ; } } else { throw new UnsupportedRepresentationException ( "The-input-parameter-must-not-be-null!" ) ; } } 
ConstantLong ( DataInputStream file ) throws IOException { this ( file . readLong ( ) ) ; } 
private static boolean isAssignableFrom ( Type from , ParameterizedType to , Map < String , Type > typeVarMap ) { if ( from == null ) { return false ; } if ( to . equals ( from ) ) { return true ; } Class < ? > clazz = getRawType ( from ) ; ParameterizedType ptype = null ; if ( from instanceof ParameterizedType ) { ptype = ( ParameterizedType ) from ; } if ( ptype != null ) { Type [ ] tArgs = ptype . getActualTypeArguments ( ) ; TypeVariable < ? > [ ] tParams = clazz . getTypeParameters ( ) ; for ( int i = 0 ; i < tArgs . length ; i ++ ) { Type arg = tArgs [ i ] ; TypeVariable < ? > var = tParams [ i ] ; while ( arg instanceof TypeVariable ) { TypeVariable < ? > v = ( TypeVariable < ? > ) arg ; arg = typeVarMap . get ( v . getName ( ) ) ; } typeVarMap . put ( var . getName ( ) , arg ) ; } if ( typeEquals ( ptype , to , typeVarMap ) ) { return true ; } } for ( Type itype : clazz . getGenericInterfaces ( ) ) { if ( isAssignableFrom ( itype , to , new HashMap < String , Type > ( typeVarMap ) ) ) { return true ; } } Type sType = clazz . getGenericSuperclass ( ) ; if ( isAssignableFrom ( sType , to , new HashMap < String , Type > ( typeVarMap ) ) ) { return true ; } return false ; } 
public String getLastStringTerminator ( String terminator ) { StringBuilder dataStr = new StringBuilder ( ) ; String lineCur = getLineTerminator ( ) ; while ( lineCur != null ) { String firstOccur = getStringTerminator ( terminator ) ; if ( firstOccur != null ) { if ( dataStr . length ( ) != 0 ) { dataStr . append ( terminator ) ; dataStr . append ( "-" ) ; } dataStr . append ( lineCur ) ; if ( ! lineCur . equals ( "-" ) ) { dataStr . append ( "-" ) ; } dataStr . append ( firstOccur ) ; } else { break ; } lineCur = getLineTerminator ( ) ; } return dataStr . toString ( ) ; } 
public void reset ( XMLComponentManager componentManager ) throws XNIException { try { fNamespaces = componentManager . getFeature ( NAMESPACES ) ; } catch ( XMLConfigurationException e ) { fNamespaces = true ; } fSymbolTable = ( SymbolTable ) componentManager . getProperty ( SYMBOL_TABLE ) ; fErrorReporter = ( XMLErrorReporter ) componentManager . getProperty ( ERROR_REPORTER ) ; } 
protected boolean isUnsafe ( char ch ) { return UNSAFE_CHARS . indexOf ( ch ) >= 0 ; } 
public int getColumnCount ( ) { return getColumnModel ( ) . getColumnCount ( ) ; } 
public static String getClipboardString ( ) { try { Transferable var0 = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) . getContents ( ( Object ) null ) ; if ( var0 != null && var0 . isDataFlavorSupported ( DataFlavor . stringFlavor ) ) { return ( String ) var0 . getTransferData ( DataFlavor . stringFlavor ) ; } } catch ( Exception var1 ) { ; } return "" ; } 
public void accept ( Visitor v ) { v . visitPushInstruction ( this ) ; v . visitStackProducer ( this ) ; v . visitTypedInstruction ( this ) ; v . visitConstantPushInstruction ( this ) ; v . visitLCONST ( this ) ; } 
public void removeViewportListener ( ViewportListener l ) { viewportListeners . removeElement ( l ) ; } 
public Enumeration < ZipEntry > getEntriesInPhysicalOrder ( ) { ZipEntry [ ] allEntries = entries . toArray ( new ZipEntry [ 0 ] ) ; Arrays . sort ( allEntries , OFFSET_COMPARATOR ) ; return Collections . enumeration ( Arrays . asList ( allEntries ) ) ; } 
private void init ( String primary , String sub ) throws MimeTypeException { if ( ( primary == null ) || ( primary . length ( ) <= 0 ) || ( ! isValid ( primary ) ) ) { throw new MimeTypeException ( "Invalid-Primary-Type-" + primary ) ; } String clearedSub = null ; if ( sub != null ) { clearedSub = sub . split ( PARAMS_SEP ) [ 0 ] ; } if ( ( clearedSub == null ) || ( clearedSub . length ( ) <= 0 ) || ( ! isValid ( clearedSub ) ) ) { throw new MimeTypeException ( "Invalid-Sub-Type-" + clearedSub ) ; } this . name = primary + SEPARATOR + clearedSub ; this . primary = primary ; this . sub = clearedSub ; this . extensions = new ArrayList ( ) ; this . magics = new ArrayList ( ) ; } 
public FileCriteria endsWith ( String value ) { endsWith . add ( value ) ; return this ; } 
public void invalidate ( ) { invalidate ( true ) ; } 
public void consume ( ) { super . consume ( ) ; if ( _backingEvent != null ) { _backingEvent . consume ( ) ; } } 
protected boolean hasFeature ( Context cx , int featureIndex ) { int version ; switch ( featureIndex ) { case Context . FEATURE_NON_ECMA_GET_YEAR : version = cx . getLanguageVersion ( ) ; return ( version == Context . VERSION_1_0 || version == Context . VERSION_1_1 || version == Context . VERSION_1_2 ) ; case Context . FEATURE_MEMBER_EXPR_AS_FUNCTION_NAME : return false ; case Context . FEATURE_RESERVED_KEYWORD_AS_IDENTIFIER : return true ; case Context . FEATURE_TO_STRING_AS_SOURCE : version = cx . getLanguageVersion ( ) ; return version == Context . VERSION_1_2 ; case Context . FEATURE_PARENT_PROTO_PROPERTIES : return true ; case Context . FEATURE_E4X : version = cx . getLanguageVersion ( ) ; return ( version == Context . VERSION_DEFAULT || version >= Context . VERSION_1_6 ) ; case Context . FEATURE_DYNAMIC_SCOPE : return false ; case Context . FEATURE_STRICT_VARS : return false ; case Context . FEATURE_STRICT_EVAL : return false ; case Context . FEATURE_LOCATION_INFORMATION_IN_ERROR : return false ; case Context . FEATURE_STRICT_MODE : return false ; case Context . FEATURE_WARNING_AS_ERROR : return false ; case Context . FEATURE_ENHANCED_JAVA_ACCESS : return false ; } throw new IllegalArgumentException ( String . valueOf ( featureIndex ) ) ; } 
private String zeroEndByteArrayToString ( byte [ ] bytes ) throws IOException { int i = 0 ; for ( i = 0 ; i < bytes . length && bytes [ i ] != 0 ; i ++ ) ; return new String ( bytes , 0 , i ) ; } 
static String [ ] getStackFrames ( final String stackTrace ) { final String linebreak = SystemUtils . LINE_SEPARATOR ; final StringTokenizer frames = new StringTokenizer ( stackTrace , linebreak ) ; final List < String > list = new ArrayList < String > ( ) ; while ( frames . hasMoreTokens ( ) ) { list . add ( frames . nextToken ( ) ) ; } return list . toArray ( new String [ list . size ( ) ] ) ; } 
public List < AddressLine > getAddressLine ( ) { if ( addressLine == null ) { addressLine = new ArrayList < > ( ) ; } return this . addressLine ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public boolean resultSubtype ( Type t , Type s , Warner warner ) { List < Type > tvars = t . getTypeArguments ( ) ; List < Type > svars = s . getTypeArguments ( ) ; Type tres = t . getReturnType ( ) ; Type sres = subst ( s . getReturnType ( ) , svars , tvars ) ; return covariantReturnType ( tres , sres , warner ) ; } 
public int hashCode ( ) { return id . hashCode ( ) ; } 
public static byte [ ] computeMd5 ( String k ) { MessageDigest md5 ; try { md5 = ( MessageDigest ) md5Digest . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( "clone-of-MD5-not-supported" , e ) ; } md5 . update ( k . getBytes ( RedisConstants . UTF_8_CHARSET ) ) ; return md5 . digest ( ) ; } 
public static byte [ ] encodeInteger ( BigInteger bigInt ) { if ( bigInt == null ) { throw new NullPointerException ( "encodeInteger-called-with-null-parameter" ) ; } return encodeBase64 ( toIntegerBytes ( bigInt ) , false ) ; } 
private String urlToLocalPath ( String url ) { return mContext . getDir ( "" , Context . MODE_PRIVATE ) . getParent ( ) + "/ImageCache/" + url . replace ( "/" , "" ) ; } 
public static void sort ( Object [ ] a ) { if ( LegacyMergeSort . userRequested ) legacyMergeSort ( a ) ; else ComparableTimSort . sort ( a ) ; } 
private void drawCircle ( Canvas canvas , Paint paint , float x , float y , float radius ) { canvas . drawCircle ( x , y , radius , paint ) ; } 
static Document loadDocumentFromString ( String xml ) throws Exception { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; return builder . parse ( new ByteArrayInputStream ( xml . getBytes ( ) ) ) ; } 
public Object nextEntity ( char ampersand ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = next ( ) ; if ( Character . isLetterOrDigit ( c ) || c == '#' ) { sb . append ( Character . toLowerCase ( c ) ) ; } else if ( c == ';' ) { break ; } else { throw syntaxError ( "Missing-';'-in-XML-entity:-&" + sb ) ; } } String string = sb . toString ( ) ; Object object = entity . get ( string ) ; return object != null ? object : ampersand + string + ";" ; } 
public int tabForCoordinate ( JTabbedPane a , int b , int c ) { int returnValue = ( ( TabbedPaneUI ) ( uis . elementAt ( 0 ) ) ) . tabForCoordinate ( a , b , c ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( TabbedPaneUI ) ( uis . elementAt ( i ) ) ) . tabForCoordinate ( a , b , c ) ; } return returnValue ; } 
public String getAttributeDeprecatedDescription ( final ResourceBundle bundle , final String prefix ) { String bundleKey = prefix == null ? name : ( prefix + "." + name ) ; bundleKey += "." + ModelDescriptionConstants . DEPRECATED ; return bundle . getString ( bundleKey ) ; } 
public double getFlatness ( ) { return Math . sqrt ( squareflat ) ; } 
public void setBesideClimbableBlock ( boolean par1 ) { byte b0 = this . dataWatcher . getWatchableObjectByte ( 16 ) ; if ( par1 ) { b0 = ( byte ) ( b0 | 1 ) ; } else { b0 &= - 2 ; } this . dataWatcher . updateObject ( 16 , Byte . valueOf ( b0 ) ) ; } 
protected AdempiereServer [ ] getActive ( ) { ArrayList < AdempiereServer > list = new ArrayList < AdempiereServer > ( ) ; for ( int i = 0 ; i < m_servers . size ( ) ; i ++ ) { AdempiereServer server = ( AdempiereServer ) m_servers . get ( i ) ; if ( server != null && server . isAlive ( ) && ! server . isInterrupted ( ) ) list . add ( server ) ; } AdempiereServer [ ] retValue = new AdempiereServer [ list . size ( ) ] ; list . toArray ( retValue ) ; return retValue ; } 
public ValueAxis getRangeAxisForDataset ( int index ) { if ( index < 0 ) { throw new IllegalArgumentException ( "Negative-'index'." ) ; } ValueAxis axis = null ; List axisIndices = ( List ) this . datasetToRangeAxesMap . get ( new Integer ( index ) ) ; if ( axisIndices != null ) { Integer axisIndex = ( Integer ) axisIndices . get ( 0 ) ; axis = getRangeAxis ( axisIndex . intValue ( ) ) ; } else { axis = getRangeAxis ( 0 ) ; } return axis ; } 
@ SystemApi public boolean addNfcUnlockHandler ( final NfcUnlockHandler unlockHandler , String [ ] tagTechnologies ) { if ( tagTechnologies . length == 0 ) { return false ; } try { synchronized ( mLock ) { if ( mNfcUnlockHandlers . containsKey ( unlockHandler ) ) { sService . removeNfcUnlockHandler ( mNfcUnlockHandlers . get ( unlockHandler ) ) ; mNfcUnlockHandlers . remove ( unlockHandler ) ; } INfcUnlockHandler . Stub iHandler = new INfcUnlockHandler . Stub ( ) { @ Override public boolean onUnlockAttempted ( Tag tag ) throws RemoteException { return unlockHandler . onUnlockAttempted ( tag ) ; } } ; sService . addNfcUnlockHandler ( iHandler , Tag . getTechCodesFromStrings ( tagTechnologies ) ) ; mNfcUnlockHandlers . put ( unlockHandler , iHandler ) ; } } catch ( RemoteException e ) { attemptDeadServiceRecovery ( e ) ; return false ; } catch ( IllegalArgumentException e ) { Log . e ( TAG , "Unable-to-register-LockscreenDispatch" , e ) ; return false ; } return true ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public boolean sameFile ( URL other ) { if ( ! compare ( protocol , other . getProtocol ( ) ) ) return ( false ) ; if ( ! compare ( host , other . getHost ( ) ) ) return ( false ) ; if ( port != other . getPort ( ) ) return ( false ) ; if ( ! compare ( file , other . getFile ( ) ) ) return ( false ) ; return ( true ) ; } 
public void redo ( ) { if ( undoManager . canRedo ( ) ) { undoManager . redo ( ) ; editorPart . getSwingComponent ( ) . repaint ( ) ; } } 
public void addFile ( ResourceFile file ) { if ( mFiles == null ) { mFiles = new ArrayList < ResourceFile > ( ) ; } mFiles . add ( file ) ; } 
public File mapUriToFile ( Uri uri ) { assertBackgroundThread ( ) ; switch ( getUriType ( uri ) ) { case URI_TYPE_FILE : return new File ( uri . getPath ( ) ) ; case URI_TYPE_CONTENT : { Cursor cursor = contentResolver . query ( uri , LOCAL_FILE_PROJECTION , null , null , null ) ; if ( cursor != null ) { try { int columnIndex = cursor . getColumnIndex ( LOCAL_FILE_PROJECTION [ 0 ] ) ; if ( columnIndex != - 1 && cursor . getCount ( ) > 0 ) { cursor . moveToFirst ( ) ; String realPath = cursor . getString ( columnIndex ) ; if ( realPath != null ) { return new File ( realPath ) ; } } } finally { cursor . close ( ) ; } } } } return null ; } 
public static Enumeration < NetworkInterface > getNetworkInterfaces ( ) throws SocketException { return Collections . enumeration ( getNetworkInterfacesList ( ) ) ; } 
public static String stripFileProtocol ( String uriString ) { if ( uriString . startsWith ( "file://" ) ) { uriString = uriString . substring ( 7 ) ; } return uriString ; } 
public void writeLine ( String text ) throws IOException { write ( text ) ; out . newLine ( ) ; } 
static boolean isNonStandardICC ( ColorSpace cs ) { boolean retval = false ; if ( ( cs instanceof ICC_ColorSpace ) && ( ! cs . isCS_sRGB ( ) ) && ( ! cs . equals ( ColorSpace . getInstance ( ColorSpace . CS_CIEXYZ ) ) ) && ( ! cs . equals ( ColorSpace . getInstance ( ColorSpace . CS_GRAY ) ) ) && ( ! cs . equals ( ColorSpace . getInstance ( ColorSpace . CS_LINEAR_RGB ) ) ) && ( ! cs . equals ( ColorSpace . getInstance ( ColorSpace . CS_PYCC ) ) ) ) { retval = true ; } return retval ; } 
public double normalApproximateProbability ( int x ) throws MathException { return normal . cumulativeProbability ( x + 0.5 ) ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public static void closeQuietly ( Closeable c ) { if ( c != null ) { try { c . close ( ) ; } catch ( Exception e ) { } } } 
private String getXMLVersion ( ) { String xmlVersion = getVersion ( ) ; if ( xmlVersion == null || xmlVersion . equals ( XMLVERSION10 ) ) { xmlVersion = XMLVERSION10 ; } else if ( xmlVersion . equals ( XMLVERSION11 ) ) { xmlVersion = XMLVERSION11 ; } else { String msg = Utils . messages . createMessage ( MsgKey . ER_XML_VERSION_NOT_SUPPORTED , new Object [ ] { xmlVersion } ) ; try { Transformer tran = super . getTransformer ( ) ; ErrorListener errHandler = tran . getErrorListener ( ) ; if ( null != errHandler && m_sourceLocator != null ) errHandler . warning ( new TransformerException ( msg , m_sourceLocator ) ) ; else System . out . println ( msg ) ; } catch ( Exception e ) { } xmlVersion = XMLVERSION10 ; } return xmlVersion ; } 
public NodeList extractAllNodesThatMatch ( NodeFilter filter ) throws ParserException { NodeIterator e ; NodeList ret ; ret = new NodeList ( ) ; for ( e = elements ( ) ; e . hasMoreNodes ( ) ; ) e . nextNode ( ) . collectInto ( ret , filter ) ; return ( ret ) ; } 
private void readMetaEntries ( ) throws IOException { ZipEntry [ ] metaEntries = getMetaEntriesImpl ( ) ; if ( metaEntries == null ) { verifier = null ; return ; } boolean signed = false ; for ( ZipEntry entry : metaEntries ) { String entryName = entry . getName ( ) ; if ( manifestEntry == null && entryName . equalsIgnoreCase ( MANIFEST_NAME ) ) { manifestEntry = entry ; if ( verifier == null ) { break ; } } else { if ( verifier != null && ( endsWithIgnoreCase ( entryName , ".SF" ) || endsWithIgnoreCase ( entryName , ".DSA" ) || endsWithIgnoreCase ( entryName , ".RSA" ) || endsWithIgnoreCase ( entryName , ".EC" ) ) ) { signed = true ; InputStream is = super . getInputStream ( entry ) ; verifier . addMetaEntry ( entryName , Streams . readFully ( is ) ) ; } } } if ( ! signed ) { verifier = null ; } } 
public void append ( final char [ ] b , int off , int len ) { if ( b == null ) { return ; } if ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) < 0 ) || ( ( off + len ) > b . length ) ) { throw new IndexOutOfBoundsException ( "off:-" + off + "-len:-" + len + "-b.length:-" + b . length ) ; } if ( len == 0 ) { return ; } int newlen = this . len + len ; if ( newlen > this . buffer . length ) { expand ( newlen ) ; } System . arraycopy ( b , off , this . buffer , this . len , len ) ; this . len = newlen ; } 
public void endGame ( String message ) { new ErrorAlert ( message ) ; game = null ; mainPanel . removeAll ( ) ; setMinimumSize ( new Dimension ( 800 , 456 ) ) ; mainPanel . setLayout ( new BorderLayout ( ) ) ; mainPanel . add ( new SplashScreen ( ) ) ; mainPanel . revalidate ( ) ; mainPanel . repaint ( ) ; updateUI ( ) ; } 
static float powerOfTwoF ( int n ) { return Float . intBitsToFloat ( ( ( n + Float . MAX_EXPONENT ) << ( FloatConsts . SIGNIFICAND_WIDTH - 1 ) ) & FloatConsts . EXP_BIT_MASK ) ; } 
public static int lookupDataGroupNumberByTag ( int tag ) { switch ( tag ) { case EF_DG1_TAG : return 1 ; case EF_DG2_TAG : return 2 ; case EF_DG3_TAG : return 3 ; case EF_DG4_TAG : return 4 ; case EF_DG5_TAG : return 5 ; case EF_DG6_TAG : return 6 ; case EF_DG7_TAG : return 7 ; case EF_DG8_TAG : return 8 ; case EF_DG9_TAG : return 9 ; case EF_DG10_TAG : return 10 ; case EF_DG11_TAG : return 11 ; case EF_DG12_TAG : return 12 ; case EF_DG13_TAG : return 13 ; case EF_DG14_TAG : return 14 ; case EF_DG15_TAG : return 15 ; case EF_DG16_TAG : return 16 ; default : throw new NumberFormatException ( "Unknown-tag-" + Integer . toHexString ( tag ) ) ; } } 
RandomAccessFile openInputFile ( ) throws IOException { RandomAccessFile raf ; raf = openInputFileAsZip ( ) ; if ( raf == null ) { File inputFile = new File ( mInputFileName ) ; raf = new RandomAccessFile ( inputFile , "r" ) ; } return raf ; } 
private boolean databaseExists ( ) { File dbFile = mContext . getDatabasePath ( GitaDBProviderMetaData . DATABASE_NAME ) ; return dbFile . exists ( ) ; } 
HashMapEntry < K , V > constructorNewEntry ( K key , V value , int hash , HashMapEntry < K , V > first ) { return new HashMapEntry < K , V > ( key , value , hash , first ) ; } 
public void moveToLocalFile ( Path src , Path dst ) throws IOException { copyToLocalFile ( true , src , dst ) ; } 
private void ensureMutableMessageList ( ) { if ( ! isMessagesListMutable ) { messages = new ArrayList < MType > ( messages ) ; isMessagesListMutable = true ; } } 
private static void dispatchCellEvent ( Widget widget , Element target , int eventBits , Event event ) { if ( ! widget . getElement ( ) . isOrHasChild ( target ) ) { return ; } DOM . setEventListener ( target , widget ) ; DOM . sinkEvents ( target , eventBits | DOM . getEventsSunk ( target ) ) ; if ( event != null ) { target . dispatchEvent ( event ) ; } } 
public Object getEntry ( int pos ) { if ( entries == null ) return null ; return entries . get ( pos ) ; } 
public int size ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } } 
private final void createSlider ( ) { slider = new JSlider ( SwingConstants . HORIZONTAL , - 127 , 127 , 0 ) ; slider . setPaintTicks ( true ) ; slider . setMajorTickSpacing ( 127 ) ; slider . setSnapToTicks ( false ) ; slider . addChangeListener ( new ChangeListener ( ) { public void stateChanged ( ChangeEvent event ) { scaleFactor = slider . getValue ( ) ; if ( scaleFactor <= 0 ) { scaleFactor = 1.0f + ( ( float ) scaleFactor ) / 127.0f ; } else { scaleFactor = 1.0f + ( ( float ) scaleFactor ) / 127.0f ; } setLabel ( scaleFactor ) ; } } ) ; panel . add ( slider , BorderLayout . CENTER ) ; } 
protected static Object getField ( Object instance , String name ) throws IllegalAccessException { Class clazz = instance . getClass ( ) ; Field [ ] fields ; while ( clazz != null ) { fields = clazz . getDeclaredFields ( ) ; for ( int index = 0 ; index < fields . length ; index ++ ) { Field field = fields [ index ] ; if ( field . getName ( ) . equals ( name ) ) { field . setAccessible ( true ) ; return field . get ( instance ) ; } } clazz = clazz . getSuperclass ( ) ; } return null ; } 
public void setLength ( long newLength ) { if ( SysProperties . CHECK && newLength % Constants . FILE_BLOCK_SIZE != 0 ) { DbException . throwInternalError ( "unaligned-setLength-" + name + "-pos-" + newLength ) ; } checkPowerOff ( ) ; checkWritingAllowed ( ) ; try { if ( newLength > fileLength ) { long pos = filePos ; file . position ( newLength - 1 ) ; FileUtils . writeFully ( file , ByteBuffer . wrap ( new byte [ 1 ] ) ) ; file . position ( pos ) ; } else { file . truncate ( newLength ) ; } fileLength = newLength ; } catch ( IOException e ) { closeFileSilently ( ) ; throw DbException . convertIOException ( e , name ) ; } } 
public int convertBoundaryToAbsolutePosition ( int relativePosition ) { if ( relativePosition < 0 || relativePosition > length ( ) ) throw new IllegalArgumentException ( "Relative-position-outside-this-range-(" + relativePosition + ")." ) ; if ( reversed ) return upper - relativePosition ; else return relativePosition + lower ; } 
@ Deprecated private boolean DFS ( EventType event , LinkedList < EventType > path ) { if ( initialEvents . contains ( event ) ) { path . addFirst ( event ) ; return true ; } else { Vector < EventType > predEventList = preds . get ( event ) ; if ( predEventList == null ) { GUITARLog . log . info ( event . getEventId ( ) + "-is-unreachable-from-root" ) ; return false ; } if ( predEventList . size ( ) == 0 ) { GUITARLog . log . info ( event . getEventId ( ) + "-has-empty-predEventList" ) ; return false ; } for ( EventType pred : predEventList ) { if ( path . contains ( pred ) ) return false ; path . addFirst ( event ) ; boolean isFound = DFS ( pred , path ) ; if ( isFound ) { return true ; } path . removeFirst ( ) ; } } return false ; } 
public void setVariable ( String name , Value value ) { initVariables ( ) ; modificationId ++ ; Value old ; if ( value == ValueNull . INSTANCE ) { old = variables . remove ( name ) ; } else { value = value . link ( database , LobStorageFrontend . TABLE_ID_SESSION_VARIABLE ) ; old = variables . put ( name , value ) ; } if ( old != null ) { old . unlink ( database ) ; old . close ( ) ; } } 
public boolean findAuthRole ( String role ) { if ( role == null ) return ( false ) ; for ( int i = 0 ; i < authRoles . length ; i ++ ) { if ( role . equals ( authRoles [ i ] ) ) return ( true ) ; } return ( false ) ; } 
public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { this . ensureInitialization ( ) ; super . ignorableWhitespace ( ch , start , length ) ; } 
@ Inline public static boolean objectInVM ( ObjectReference object ) { return Space . isMappedObject ( object ) ; } 
public int indexOf ( int c ) { if ( c > 0xffff ) { return indexOfSupplementary ( c , 0 ) ; } return fastIndexOf ( c , 0 ) ; } 
public void processingInstruction ( String target , String data ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; flushPending ( ) ; if ( target . equals ( Result . PI_DISABLE_OUTPUT_ESCAPING ) ) { startNonEscaping ( ) ; } else if ( target . equals ( Result . PI_ENABLE_OUTPUT_ESCAPING ) ) { endNonEscaping ( ) ; } else { try { if ( m_elemContext . m_startTagOpen ) { closeStartTag ( ) ; m_elemContext . m_startTagOpen = false ; } else if ( m_needToCallStartDocument ) startDocumentInternal ( ) ; if ( shouldIndent ( ) ) indent ( ) ; final java . io . Writer writer = m_writer ; writer . write ( "<?" ) ; writer . write ( target ) ; if ( data . length ( ) > 0 && ! Character . isSpaceChar ( data . charAt ( 0 ) ) ) writer . write ( '-' ) ; int indexOfQLT = data . indexOf ( "?>" ) ; if ( indexOfQLT >= 0 ) { if ( indexOfQLT > 0 ) { writer . write ( data . substring ( 0 , indexOfQLT ) ) ; } writer . write ( "?->" ) ; if ( ( indexOfQLT + 2 ) < data . length ( ) ) { writer . write ( data . substring ( indexOfQLT + 2 ) ) ; } } else { writer . write ( data ) ; } writer . write ( '?' ) ; writer . write ( '>' ) ; m_startNewLine = true ; } catch ( IOException e ) { throw new SAXException ( e ) ; } } if ( m_tracer != null ) super . fireEscapingEvent ( target , data ) ; } 
public static Object invoke ( Object obj , String methodName , int newValue ) throws NoSuchMethodException { try { Method method = obj . getClass ( ) . getMethod ( methodName , new Class [ ] { Integer . TYPE } ) ; return method . invoke ( obj , new Object [ ] { newValue } ) ; } catch ( IllegalAccessException e ) { throw new NoSuchMethodException ( methodName + "-is-not-accessible" ) ; } catch ( InvocationTargetException e ) { throw new InternalError ( e . getMessage ( ) ) ; } } 
public boolean getCanSpawnHere ( ) { return this . worldObj . checkIfAABBIsClear ( this . boundingBox ) ; } 
public void setTickMarkStroke ( Stroke stroke ) { if ( stroke == null ) { throw new IllegalArgumentException ( "Null-'stroke'-argument." ) ; } if ( ! this . tickMarkStroke . equals ( stroke ) ) { this . tickMarkStroke = stroke ; fireChangeEvent ( ) ; } } 
protected String createUpdateString ( ) { StringBuilder updateStatement = new StringBuilder ( ) ; updateStatement . append ( "UPDATE-" ) ; if ( this . getSchemaName ( ) != null ) { updateStatement . append ( this . getSchemaName ( ) ) ; updateStatement . append ( "." ) ; } updateStatement . append ( this . getTableName ( ) ) ; updateStatement . append ( "-SET-" ) ; int columnCount = 0 ; for ( String columnName : reconciledUpdatingColumns ) { columnCount ++ ; if ( columnCount > 1 ) { updateStatement . append ( ",-" ) ; } updateStatement . append ( columnName ) ; updateStatement . append ( "-=-?-" ) ; } if ( restrictingColumns . size ( ) > 0 ) { updateStatement . append ( "-WHERE-" ) ; columnCount = 0 ; for ( Map . Entry < String , Operator > column : restrictingColumns . entrySet ( ) ) { columnCount ++ ; if ( columnCount > 1 ) { updateStatement . append ( "-AND-" ) ; } updateStatement . append ( column . getKey ( ) ) ; updateStatement . append ( "-" ) ; updateStatement . append ( column . getValue ( ) . toString ( ) ) ; updateStatement . append ( "-?-" ) ; } } return updateStatement . toString ( ) ; } 
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; String NEWLINE = System . getProperty ( "line.separator" ) ; s . append ( V + "-" + E + NEWLINE ) ; for ( int v = 0 ; v < V ; v ++ ) { s . append ( String . format ( "%d:-" , v ) ) ; for ( int w : adj [ v ] ) { s . append ( String . format ( "%d-" , w ) ) ; } s . append ( NEWLINE ) ; } return s . toString ( ) ; } 
public void randomize ( double probability ) { if ( probability < 0 || probability > 1 ) { throw new IllegalArgumentException ( "Probability-must-be-between-0-and-1" ) ; } Random random = new Random ( ) ; for ( int i = 0 , size = packedData . length ; i < size ; i ++ ) { byte packedcell = 0 ; for ( int j = BITS_PER_BYTE ; j > 0 ; j -- ) { int mask = 0x80 >>> ( j - 1 ) ; double d = random . nextDouble ( ) ; if ( d >= probability ) { packedcell = ( byte ) ( packedcell & ~ mask ) ; } else { packedcell = ( byte ) ( packedcell | mask ) ; } } packedData [ i ] = packedcell ; } } 
public String request ( Context context , String url , WeiboParameters params , String httpMethod , Token token ) throws WeiboException { String rlt = Utility . openUrl ( context , url , httpMethod , params , this . mAccessToken ) ; return rlt ; } 
private void parseSkipQuestionInfo ( Node skipQuestionNode ) { Element configChildNodeElement = ( Element ) skipQuestionNode ; skipQuestionInfo [ 0 ] = configChildNodeElement . getAttribute ( "title" ) ; skipQuestionInfo [ 1 ] = configChildNodeElement . getAttribute ( "message" ) ; skipQuestionInfo [ 2 ] = configChildNodeElement . getAttribute ( "yes" ) ; skipQuestionInfo [ 3 ] = configChildNodeElement . getAttribute ( "no" ) ; } 
public void setInputArtifacts ( java . util . Collection < Artifact > inputArtifacts ) { if ( inputArtifacts == null ) { this . inputArtifacts = null ; return ; } this . inputArtifacts = new java . util . ArrayList < Artifact > ( inputArtifacts ) ; } 
public Number getCurrentAccessibleValue ( ) { return Integer . valueOf ( 0 ) ; } 
private JPanel getPaneSelect ( ) { if ( paneSelect == null ) { paneSelect = new JPanel ( ) ; paneSelect . setLayout ( new CardLayout ( ) ) ; paneSelect . setBorder ( BorderFactory . createEmptyBorder ( 0 , 0 , 0 , 0 ) ) ; paneSelect . add ( getTabbedSelect ( ) , getTabbedSelect ( ) . getName ( ) ) ; } return paneSelect ; } 
private int locatePoint ( final double time , final StepInterpolator interval ) { if ( forward ) { if ( time < interval . getPreviousTime ( ) ) { return - 1 ; } else if ( time > interval . getCurrentTime ( ) ) { return + 1 ; } else { return 0 ; } } if ( time > interval . getPreviousTime ( ) ) { return - 1 ; } else if ( time < interval . getCurrentTime ( ) ) { return + 1 ; } else { return 0 ; } } 
public synchronized void removeWebBrowserListener ( WebBrowserListener listener ) { listenerList . remove ( WebBrowserListener . class , listener ) ; } 
public List < KeywordType > getKeyword ( ) { if ( keyword == null ) { keyword = new ArrayList < KeywordType > ( ) ; } return this . keyword ; } 
public SecurityAttributes . Builder getSecurityAttributes ( ) { if ( _securityAttributes == null ) _securityAttributes = new SecurityAttributes . Builder ( ) ; return _securityAttributes ; } 
public void setPrimaryAddressCounty ( JAXBElement < String > value ) { this . primaryAddressCounty = ( ( JAXBElement < String > ) value ) ; } 
public void translateRegionInWindowToScreen ( Region transparentRegion ) { transparentRegion . scale ( applicationScale ) ; } 
void setAttributeReadOnly ( String name ) { if ( attributes . containsKey ( name ) ) readOnlyAttributes . put ( name , name ) ; } 
public int getInt ( String name , int defaultValue ) { String valueString = getTrimmed ( name ) ; if ( valueString == null ) return defaultValue ; String hexString = getHexDigits ( valueString ) ; if ( hexString != null ) { return Integer . parseInt ( hexString , 16 ) ; } return Integer . parseInt ( valueString ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public Iterator < BusinessObject > findAllBusinessObjects ( ) { final Set < BusinessObject > result = new HashSet < BusinessObject > ( ) ; findAllBusinessObjects ( this , result ) ; return result . iterator ( ) ; } 
public Map < String , String > describeRepository ( String repositoryName ) { log . info ( "Retrieving-description-for-repository:-" + repositoryName ) ; Repository repository = getRepositoryFromJndi ( repositoryName ) ; Map < String , String > descriptors = new TreeMap < String , String > ( ) ; for ( String descriptorKey : repository . getDescriptorKeys ( ) ) { descriptors . put ( descriptorKey , repository . getDescriptor ( descriptorKey ) ) ; } return descriptors ; } 
public synchronized boolean shouldPostpone ( Route route ) { return failedRoutes . contains ( route ) ; } 
public static String encodeObject ( java . io . Serializable serializableObject ) throws java . io . IOException { return encodeObject ( serializableObject , NO_OPTIONS ) ; } 
public static URL makeURL ( String pathname ) throws MalformedURLException { File file = new File ( pathname ) ; return file . toURI ( ) . toURL ( ) ; } 
public static void main ( String [ ] args ) { final String DEFAULT_TITLE = "Java-Native-Access-(JNA)" ; final String DEFAULT_VERSION = VERSION ; final String DEFAULT_BUILD = VERSION + "-(package-information-missing)" ; Package pkg = Native . class . getPackage ( ) ; String title = pkg != null ? pkg . getSpecificationTitle ( ) : DEFAULT_TITLE ; if ( title == null ) title = DEFAULT_TITLE ; String version = pkg != null ? pkg . getSpecificationVersion ( ) : DEFAULT_VERSION ; if ( version == null ) version = DEFAULT_VERSION ; title += "-API-Version-" + version ; System . out . println ( title ) ; version = pkg != null ? pkg . getImplementationVersion ( ) : DEFAULT_BUILD ; if ( version == null ) version = DEFAULT_BUILD ; System . out . println ( "Version:-" + version ) ; System . out . println ( "-Native:-" + getNativeVersion ( ) + "-(" + getAPIChecksum ( ) + ")" ) ; System . out . println ( "-Prefix:-" + Platform . RESOURCE_PREFIX ) ; } 
@ XmlElementDecl ( namespace = "http://sas.beniculturali.it/catalogo/comparc" , name = "fk_voc_tipo_formato" ) public JAXBElement < FkVocTipoFormato > createFkVocTipoFormato ( FkVocTipoFormato value ) { return new JAXBElement < FkVocTipoFormato > ( _FkVocTipoFormato_QNAME , FkVocTipoFormato . class , null , value ) ; } 
public synchronized void reset ( ) { map . clear ( ) ; members = EMPTY_MEMBERS ; } 
public static boolean writeUserSelectedFile ( ) { if ( fileDialog == null ) fileDialog = new JFileChooser ( ) ; fileDialog . setDialogTitle ( "Select-File-for-Output" ) ; File selectedFile ; while ( true ) { int option = fileDialog . showSaveDialog ( null ) ; if ( option != JFileChooser . APPROVE_OPTION ) return false ; selectedFile = fileDialog . getSelectedFile ( ) ; if ( selectedFile . exists ( ) ) { int response = JOptionPane . showConfirmDialog ( null , "The-file-"" + selectedFile . getName ( ) + ""-already-exists.-Do-you-want-to-replace-it?" , "Replace-existing-file?" , JOptionPane . YES_NO_OPTION , JOptionPane . WARNING_MESSAGE ) ; if ( response == JOptionPane . YES_OPTION ) break ; } else { break ; } } PrintWriter newout ; try { newout = new PrintWriter ( new FileWriter ( selectedFile ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Can't-open-file-"" + selectedFile . getName ( ) + ""-for-output.-" + "(Error-:" + e + ")" ) ; } if ( ! writingStandardOutput ) { try { out . close ( ) ; } catch ( Exception e ) { } } out = newout ; writingStandardOutput = false ; outputFileName = selectedFile . getName ( ) ; outputErrorCount = 0 ; return true ; } 
public void writeAllMessages ( ) throws IOException { synchronized ( outgoingMessages ) { while ( ! outgoingMessages . isEmpty ( ) ) { out . writeMessage ( outgoingMessages . remove ( ) ) ; } } } 
public static SnmpEngineId createEngineId ( String str ) throws IllegalArgumentException , UnknownHostException { return createEngineId ( str , null ) ; } 
private static Set < Server > toServerSet ( List < Map > l ) throws FabricCommunicationException { Set < Server > servers = new HashSet < Server > ( ) ; for ( Map serverData : l ) { servers . add ( unmarshallServer ( serverData ) ) ; } return servers ; } 
public Object object ( ) { return new org . apache . xml . dtm . ref . DTMNodeIterator ( ( DTMIterator ) ( new org . apache . xpath . NodeSetDTM ( m_dtmRoot , m_xctxt . getDTMManager ( ) ) ) ) ; } 
private void setSqlExpandMode ( ) { for ( String key : shared . userVars . keySet ( ) ) { if ( key . charAt ( 0 ) != '*' && ! key . equals ( "?" ) ) { sqlExpandMode = Boolean . TRUE ; return ; } } sqlExpandMode = Boolean . FALSE ; } 
public void switchToConnectButton ( ) { mConnectOrSettingsButton . setText ( "Connect" ) ; } 
@ Override public Object clone ( ) { SnmpVarBind v = new SnmpVarBind ( ) ; v . copyValueAndOid ( this ) ; return v ; } 
private void purgeUnnecessaryDuplicateCells ( List < CellContext > compareList ) { Set < Cell > cells = new HashSet < Cell > ( ) ; for ( Iterator < CellContext > it = compareList . iterator ( ) ; it . hasNext ( ) && compareList . size ( ) > 2 ; ) { Cell c = ( it . next ( ) ) . cell ; if ( cells . contains ( c ) ) it . remove ( ) ; else cells . add ( c ) ; } } 
public HMMstate getState ( String stateName ) { Integer i = ( Integer ) statesByName . get ( stateName ) ; if ( i == null ) return null ; return ( HMMstate ) states . get ( i . intValue ( ) ) ; } 
private static void accumulate ( Vector ranges , int lb , int ub ) { if ( lb <= ub ) { ranges . add ( new int [ ] { lb , ub } ) ; for ( int j = ranges . size ( ) - 2 ; j >= 0 ; -- j ) { int [ ] rangea = ( int [ ] ) ranges . elementAt ( j ) ; int lba = rangea [ 0 ] ; int uba = rangea [ 1 ] ; int [ ] rangeb = ( int [ ] ) ranges . elementAt ( j + 1 ) ; int lbb = rangeb [ 0 ] ; int ubb = rangeb [ 1 ] ; if ( Math . max ( lba , lbb ) - Math . min ( uba , ubb ) <= 1 ) { ranges . setElementAt ( new int [ ] { Math . min ( lba , lbb ) , Math . max ( uba , ubb ) } , j ) ; ranges . remove ( j + 1 ) ; } else if ( lba > lbb ) { ranges . setElementAt ( rangeb , j ) ; ranges . setElementAt ( rangea , j + 1 ) ; } else { break ; } } } } 
public void setLabel ( String label ) { m_label . setText ( label ) ; } 
public Toggle getItem ( int theIndex ) { return _myRadioToggles . get ( theIndex ) ; } 
public void setTimeSeries ( org . gridsphere . services . core . charts . TimeSeries [ ] timeSeriesArray ) { _timeSeriesList . removeAllElements ( ) ; for ( int i = 0 ; i < timeSeriesArray . length ; i ++ ) { _timeSeriesList . addElement ( timeSeriesArray [ i ] ) ; } } 
public static List < UsageSection > getUsageSections ( Object o , Map < String , AbstractOptions > options ) { ArrayList < Object > allOptions = new ArrayList < Object > ( ) ; allOptions . add ( o ) ; for ( Entry < String , AbstractOptions > ent : options . entrySet ( ) ) { if ( ent . getValue ( ) != null ) { allOptions . add ( ent . getValue ( ) ) ; } } return getUsageSections ( allOptions . toArray ( ) ) ; } 
private String [ ] getRelationParts ( String relation , String delimiter ) { List < String > values = new ArrayList < String > ( ) ; int firstIndex = 0 ; int secondIndex = 0 ; secondIndex = relation . indexOf ( delimiter ) ; String part = null ; while ( secondIndex >= 0 ) { part = relation . substring ( firstIndex , secondIndex ) . trim ( ) ; values . add ( part ) ; firstIndex = secondIndex ; secondIndex = relation . indexOf ( delimiter , firstIndex + 1 ) ; } if ( firstIndex > 0 ) { part = relation . substring ( firstIndex ) . trim ( ) ; values . add ( part ) ; } return values . toArray ( new String [ 0 ] ) ; } 
public List < WabitObject > getChildren ( ) { List < WabitObject > children = new ArrayList < WabitObject > ( ) ; children . addAll ( contentBoxes ) ; children . addAll ( guides ) ; return Collections . unmodifiableList ( children ) ; } 
private String [ ] cut ( String prefix , char delimiter ) { String [ ] names = new String [ mLines . size ( ) ] ; int length = 0 ; for ( String line : mLines ) { if ( line . startsWith ( prefix ) ) { int i = line . indexOf ( delimiter ) ; if ( i == - 1 ) { i = line . length ( ) ; } names [ length ] = line . substring ( prefix . length ( ) , i ) ; ++ length ; } } return Arrays . copyOf ( names , length ) ; } 
private static void signalTask ( String signalFile , JobConf conf ) { try { FileSystem fs = FileSystem . getLocal ( conf ) ; fs . createNewFile ( new Path ( signalFile ) ) ; } catch ( IOException e ) { LOG . warn ( "Unable-to-create-signal-file.-" + e ) ; } } 
public void cancel ( CatalogFramework framework , Map properties ) { LOGGER . info ( "Cancelling-scheduled-polling." ) ; runner . shutdown ( ) ; handle . cancel ( true ) ; scheduler . shutdownNow ( ) ; } 
public void setSelected ( boolean s ) { ButtonModel mod = getModel ( ) ; if ( mod != null ) mod . setSelected ( s ) ; } 
private Element createKeyValue ( ) throws Exception { Element keyValueEle = null ; PrivateKey key = idmClient . getTenantPrivateKey ( tenantName ) ; if ( key != null ) { RSAPrivateKey rsaKey = ( RSAPrivateKey ) key ; Element rsaKeyEle = createRSAKeyValue ( rsaKey ) ; if ( rsaKeyEle != null ) { keyValueEle = doc . createElement ( SAMLNames . DS_KEYVALUE ) ; keyValueEle . appendChild ( rsaKeyEle ) ; } } return keyValueEle ; } 
@ Override public void add ( String q ) { if ( q == null ) { throw new NullPointerException ( "Cannot-add-null-queries-to-a-BestQueryStorer" ) ; } queries . add ( new Query ( q ) ) ; } 
public static < E > Builder < E > builder ( ) { return new Builder < E > ( ) ; } 
public Manifest ( InputStream is ) throws IOException { super ( ) ; read ( is ) ; } 
public Quaternion fromAxes ( Vector3f xAxis , Vector3f yAxis , Vector3f zAxis ) { return fromRotationMatrix ( xAxis . x , yAxis . x , zAxis . x , xAxis . y , yAxis . y , zAxis . y , xAxis . z , yAxis . z , zAxis . z ) ; } 
public byte [ ] generateSeed ( int numBytes ) { return secureRandomSpi . engineGenerateSeed ( numBytes ) ; } 
public int length ( ) { if ( longCount == 0 ) { return 0 ; } return 64 * ( longCount - 1 ) + ( 64 - Long . numberOfLeadingZeros ( bits [ longCount - 1 ] ) ) ; } 
@ Transactional @ SuppressWarnings ( "unchecked" ) public List < Person > findPersonsWithAttributes ( List < Value > values ) { StringBuffer query = new StringBuffer ( ) ; query . append ( "SELECT-p.ID-,-p.VERSION-,-p.FIRSTNAME-,p.TENANT,-p.LASTNAME,p.COMPANY,p.f_function,-p.TEXT,-p.title,-p.CITIES,-p.DELETED,-p.DELETEDAT-FROM-per_person-p,-per_person_val_value-att-WHERE-att.person_id=p.id-AND-att.attributes_id-IN(" ) ; for ( int i = 0 ; i < values . size ( ) ; i ++ ) { query . append ( "'" + values . get ( i ) . getId ( ) . toString ( ) + "'" ) ; if ( i < values . size ( ) - 1 ) { query . append ( ",-" ) ; } } query . append ( ")-AND-p.deleted-is-null" ) ; List < Person > ids = em . createNativeQuery ( query . toString ( ) , Person . class ) . getResultList ( ) ; return ids ; } 
public static int maxFill ( final int n , final float f ) { return Math . min ( ( int ) Math . ceil ( n * f ) , n - 1 ) ; } 
public static String encode ( byte [ ] buf ) { int size = buf . length ; char [ ] ar = new char [ ( ( size + 2 ) / 3 ) * 4 ] ; int a = 0 ; int i = 0 ; while ( i < size ) { byte b0 = buf [ i ++ ] ; byte b1 = ( i < size ) ? buf [ i ++ ] : 0 ; byte b2 = ( i < size ) ? buf [ i ++ ] : 0 ; int mask = 0x3F ; ar [ a ++ ] = ALPHABET [ ( b0 >> 2 ) & mask ] ; ar [ a ++ ] = ALPHABET [ ( ( b0 << 4 ) | ( ( b1 & 0xFF ) >> 4 ) ) & mask ] ; ar [ a ++ ] = ALPHABET [ ( ( b1 << 2 ) | ( ( b2 & 0xFF ) >> 6 ) ) & mask ] ; ar [ a ++ ] = ALPHABET [ b2 & mask ] ; } switch ( size % 3 ) { case 1 : ar [ -- a ] = '=' ; case 2 : ar [ -- a ] = '=' ; } return new String ( ar ) ; } 
protected Object writeReplace ( ) throws ObjectStreamException { try { return new CertPathRep ( getType ( ) , getEncoded ( ) ) ; } catch ( CertificateEncodingException e ) { throw new NotSerializableException ( "Could-not-create-serialization-object:-" + e ) ; } } 
public synchronized MetricsContext getContext ( String contextName ) throws IOException , ClassNotFoundException , InstantiationException , IllegalAccessException { AbstractMetricsContext metricsContext = contextMap . get ( contextName ) ; if ( metricsContext == null ) { String classNameAttribute = contextName + CONTEXT_CLASS_SUFFIX ; String className = ( String ) getAttribute ( classNameAttribute ) ; if ( className == null ) { className = DEFAULT_CONTEXT_CLASSNAME ; } Class contextClass = Class . forName ( className ) ; metricsContext = ( AbstractMetricsContext ) contextClass . newInstance ( ) ; metricsContext . init ( contextName , this ) ; contextMap . put ( contextName , metricsContext ) ; } return metricsContext ; } 
private void addComboBoxEditor ( ) { Term [ ] terms = new Term [ node . getTermsUsed ( ) . size ( ) ] ; node . getTermsUsed ( ) . toArray ( terms ) ; TableColumn col = this . getColumnModel ( ) . getColumn ( getColumnCount ( ) - 1 ) ; TermComboBox editor = new TermComboBox ( terms ) ; col . setCellEditor ( editor ) ; col . setCellRenderer ( new TermComboBoxRenderer ( terms ) ) ; } 
public void addLease ( final Lease lease ) throws LeaseStillHeldException { if ( this . stopRequested ) { return ; } lease . setExpirationTime ( System . currentTimeMillis ( ) + this . leasePeriod ) ; synchronized ( leaseQueue ) { if ( leases . containsKey ( lease . getLeaseName ( ) ) ) { throw new LeaseStillHeldException ( lease . getLeaseName ( ) ) ; } leases . put ( lease . getLeaseName ( ) , lease ) ; leaseQueue . add ( lease ) ; } } 
public void setBeanContext ( BeanContext in_bc ) throws PropertyVetoException { if ( in_bc != null ) { in_bc . addBeanContextMembershipListener ( this ) ; beanContextChildSupport . setBeanContext ( in_bc ) ; findAndInit ( in_bc . iterator ( ) ) ; } } 
public DOMSignatureProperty ( Element propElem ) throws MarshalException { target = DOMUtils . getAttributeValue ( propElem , "Target" ) ; if ( target == null ) { throw new MarshalException ( "target-cannot-be-null" ) ; } id = DOMUtils . getAttributeValue ( propElem , "Id" ) ; NodeList nodes = propElem . getChildNodes ( ) ; int length = nodes . getLength ( ) ; List content = new ArrayList ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { content . add ( new javax . xml . crypto . dom . DOMStructure ( nodes . item ( i ) ) ) ; } if ( content . isEmpty ( ) ) { throw new MarshalException ( "content-cannot-be-empty" ) ; } else { this . content = Collections . unmodifiableList ( content ) ; } } 
public final long getAndSet ( long newValue ) { while ( true ) { long current = get ( ) ; if ( compareAndSet ( current , newValue ) ) return current ; } } 
public boolean isVoteInProgress ( ) { if ( ! info . containsKey ( "votes" ) ) return false ; if ( info . get ( "votes" ) == null ) return false ; if ( info . get ( "votes" ) . trim ( ) . equals ( "" ) ) return false ; return true ; } 
@ Override public String getFactoryClassName ( ) { String factory = super . getFactoryClassName ( ) ; if ( factory != null ) { return factory ; } else { factory = System . getProperty ( Context . OBJECT_FACTORIES ) ; if ( factory != null ) { return null ; } else { return DEFAULT_FACTORY ; } } } 
private boolean isProtectedAccessible ( Symbol sym , ClassSymbol c , Type site ) { while ( c != null && ! ( c . isSubClass ( sym . owner , types ) && ( c . flags ( ) & INTERFACE ) == 0 && ( ( sym . flags ( ) & STATIC ) != 0 || sym . kind == TYP || site . tsym . isSubClass ( c , types ) ) ) ) c = c . owner . enclClass ( ) ; return c != null ; } 
public boolean isMultipart ( ) { return mimeType . startsWith ( "multipart/" ) ; } 
public void increaseTriangulation ( ) { checkPoints ( ) ; calculateTriangles ( ) ; tris = new OverTriangulator ( tris ) ; } 
public void skippedEntity ( String name ) { _parser . skippedEntity ( name ) ; } 
public void onComponentRemoved ( int count ) { if ( count == 0 ) { menuItem . setEnabled ( false ) ; menuItem . setSelected ( false ) ; } } 
public static boolean unregisterForThread ( ServiceInterceptorFactory factory ) { return threadLocalFactories . get ( ) . remove ( factory ) ; } 
public void dispatchWindowFocusChanged ( boolean hasFocus ) { onWindowFocusChanged ( hasFocus ) ; } 
public static NonpluginFunction forFunctionName ( String functionName ) { return NONPLUGIN_FUNCTIONS_BY_NAME . get ( functionName ) ; } 
public String getAccessibleActionDescription ( int i ) { if ( i < 0 || i >= getAccessibleActionCount ( ) ) { return null ; } AccessibleContext ac = getCurrentAccessibleContext ( ) ; if ( i == 0 ) { return AccessibleAction . TOGGLE_EXPAND ; } else if ( ac != null ) { AccessibleAction aa = ac . getAccessibleAction ( ) ; if ( aa != null ) { return aa . getAccessibleActionDescription ( i - 1 ) ; } } return null ; } 
public boolean isEmpty ( ) { return registeredPatterModels . isEmpty ( ) ; } 
public void append ( StringBuffer buffer , String fieldName , long value ) { appendFieldStart ( buffer , fieldName ) ; appendDetail ( buffer , fieldName , value ) ; appendFieldEnd ( buffer , fieldName ) ; } 
public static double angle ( Point p1 , Point p2 ) { double theta = Math . atan2 ( p1 . x - p2 . x , p1 . y - p2 . y ) ; double angle = Math . toDegrees ( theta ) ; if ( angle < 0 ) { angle += 360 ; } return angle % 360 ; } 
public void keyReleased ( KeyEvent e ) { int key = e . getKeyCode ( ) ; switch ( key ) { case KeyEvent . VK_W : this . currDirection = movement . UP ; break ; case KeyEvent . VK_X : this . currDirection = movement . DOWN ; break ; case KeyEvent . VK_A : this . currDirection = movement . LEFT ; break ; case KeyEvent . VK_D : this . currDirection = movement . RIGHT ; break ; case KeyEvent . VK_Q : this . currDirection = movement . UP_LEFT ; break ; case KeyEvent . VK_E : this . currDirection = movement . UP_RIGHT ; break ; case KeyEvent . VK_Z : this . currDirection = movement . DOWN_LEFT ; break ; case KeyEvent . VK_C : this . currDirection = movement . DOWN_RIGHT ; break ; case KeyEvent . VK_S : this . currDirection = movement . SIT ; break ; case KeyEvent . VK_J : this . currDirection = movement . JUMP ; break ; } } 
public Builder addRulesBytes ( com . google . protobuf . ByteString value ) { if ( value == null ) { throw new NullPointerException ( ) ; } ensureRulesIsMutable ( ) ; rules_ . add ( value ) ; onChanged ( ) ; return this ; } 
public int getInt ( int offset ) { return ( getShort ( offset ) << 16 ) | ( getUnsignedShort ( offset + 2 ) ) ; } 
protected void readFullyDirect ( byte [ ] b , int off , int len ) { readFully ( b , off , len ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public static Token newToken ( int ofKind , String image ) { switch ( ofKind ) { default : return new Token ( ofKind , image ) ; } } 
public static Log getLog ( final Class < ? > clazz ) { return getLog ( LoggerFactory . getLogger ( clazz . getName ( ) ) ) ; } 
public static int getInt ( Number target_ , int defalt_ ) { if ( target_ == null ) return defalt_ ; return target_ . intValue ( ) ; } 
public int getPrunedStackTrace ( int size ) { StackTraceElement [ ] var2 = Thread . currentThread ( ) . getStackTrace ( ) ; if ( var2 . length <= 0 ) { return 0 ; } else { this . stackTrace = new StackTraceElement [ var2 . length - 3 - size ] ; System . arraycopy ( var2 , 3 + size , this . stackTrace , 0 , this . stackTrace . length ) ; return this . stackTrace . length ; } } 
protected double applyOperator ( double first , double second ) { switch ( m_operator ) { case '+' : return ( first + second ) ; case '-' : return ( first - second ) ; case '*' : return ( first * second ) ; case '/' : return ( first / second ) ; case '^' : return Math . pow ( first , second ) ; } return Double . NaN ; } 
public char getMnemonic ( String key ) { String s = getStringRecursive ( key ) ; return ( s == null || s . length ( ) == 0 ) ? '|0' : s . charAt ( 0 ) ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
@ XmlElementDecl ( namespace = "http://www.ncbi.nlm.nih.gov/soap/eutils/efetch_taxonomy" , name = "EquivalentName" ) public JAXBElement < String > createEquivalentName ( String value ) { return new JAXBElement < String > ( _EquivalentName_QNAME , String . class , null , value ) ; } 
private static void calcSignature ( byte [ ] bytes ) { MessageDigest md ; try { md = MessageDigest . getInstance ( "SHA-1" ) ; } catch ( NoSuchAlgorithmException ex ) { throw new RuntimeException ( ex ) ; } md . update ( bytes , 32 , bytes . length - 32 ) ; try { int amt = md . digest ( bytes , 12 , 20 ) ; if ( amt != 20 ) { throw new RuntimeException ( "unexpected-digest-write:-" + amt + "-bytes" ) ; } } catch ( DigestException ex ) { throw new RuntimeException ( ex ) ; } } 
private static boolean isDigitOrPeriod ( char ch ) { return isDigit ( ch ) || ch == '.' ; } 
public void addProhibitedTerm ( String term ) { addProhibitedTerm ( term , Clause . DEFAULT_FIELD ) ; } 
public void mouseClicked ( MouseEvent me ) { if ( me . getClickCount ( ) == 2 ) { } } 
public boolean hasNextLong ( ) { return hasNextLong ( integerRadix ) ; } 
public void copyFromLocalFile ( boolean delSrc , Path src , Path dst ) throws IOException { fs . copyFromLocalFile ( delSrc , src , dst ) ; } 
public StringBuffer format ( Date date , StringBuffer dateStrBuf , FieldPosition fieldPosition ) { int start = dateStrBuf . length ( ) ; super . format ( date , dateStrBuf , fieldPosition ) ; int pos = 0 ; for ( pos = start + 25 ; dateStrBuf . charAt ( pos ) != 'X' ; pos ++ ) ; calendar . clear ( ) ; calendar . setTime ( date ) ; int offset = calendar . get ( Calendar . ZONE_OFFSET ) + calendar . get ( Calendar . DST_OFFSET ) ; if ( offset < 0 ) { dateStrBuf . setCharAt ( pos ++ , '-' ) ; offset = ( - offset ) ; } else dateStrBuf . setCharAt ( pos ++ , '+' ) ; int rawOffsetInMins = offset / 60 / 1000 ; int offsetInHrs = rawOffsetInMins / 60 ; int offsetInMins = rawOffsetInMins % 60 ; dateStrBuf . setCharAt ( pos ++ , Character . forDigit ( ( offsetInHrs / 10 ) , 10 ) ) ; dateStrBuf . setCharAt ( pos ++ , Character . forDigit ( ( offsetInHrs % 10 ) , 10 ) ) ; dateStrBuf . setCharAt ( pos ++ , Character . forDigit ( ( offsetInMins / 10 ) , 10 ) ) ; dateStrBuf . setCharAt ( pos ++ , Character . forDigit ( ( offsetInMins % 10 ) , 10 ) ) ; return dateStrBuf ; } 
public void println ( ) { newline ( ) ; } 
private Proxy nextProxy ( ) { if ( userSpecifiedProxy != null ) { hasNextProxy = false ; return userSpecifiedProxy ; } if ( proxySelectorProxies != null ) { while ( proxySelectorProxies . hasNext ( ) ) { Proxy candidate = proxySelectorProxies . next ( ) ; if ( candidate . type ( ) != Proxy . Type . DIRECT ) { return candidate ; } } } hasNextProxy = false ; return Proxy . NO_PROXY ; } 
public IMOps transparentColor ( String color ) { String oper ; StringBuffer buf = new StringBuffer ( ) ; iCmdArgs . add ( "-transparent-color" ) ; if ( color != null ) { buf . append ( color . toString ( ) ) ; } if ( buf . length ( ) > 0 ) { iCmdArgs . add ( buf . toString ( ) ) ; } return this ; } 
public String getTitleAt ( int index ) { return tabs . getTitleAt ( index ) ; } 
public static final DateFormat getInstance ( ) { return getDateTimeInstance ( SHORT , SHORT ) ; } 
private void readObject ( java . io . ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; type = TYPE_UNKNOWN ; } 
private static String getServiceValue ( final ClassLoader classLoader ) { String serviceId = "META-INF/services/" + PROPERTY ; try { InputStream is = getResourceAsStream ( classLoader , serviceId ) ; if ( is != null ) { BufferedReader rd ; try { rd = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) , DEFAULT_LINE_LENGTH ) ; } catch ( java . io . UnsupportedEncodingException e ) { rd = new BufferedReader ( new InputStreamReader ( is ) , DEFAULT_LINE_LENGTH ) ; } String serviceValue = rd . readLine ( ) ; rd . close ( ) ; if ( serviceValue != null && serviceValue . length ( ) > 0 ) { return serviceValue ; } } } catch ( Exception ex ) { return null ; } return null ; } 
public HttpRequest ( final CharSequence url , final String method ) throws HttpRequestException { try { this . url = new URL ( url . toString ( ) ) ; } catch ( MalformedURLException e ) { throw new HttpRequestException ( e ) ; } this . requestMethod = method ; } 
public void displayError ( final String title , final String message , final String button , final boolean exit ) { final DroidGap me = this ; me . runOnUiThread ( new Runnable ( ) { public void run ( ) { AlertDialog . Builder dlg = new AlertDialog . Builder ( me ) ; dlg . setMessage ( message ) ; dlg . setTitle ( title ) ; dlg . setCancelable ( false ) ; dlg . setPositiveButton ( button , new AlertDialog . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; if ( exit ) { me . finish ( ) ; } } } ) ; dlg . create ( ) ; dlg . show ( ) ; } } ) ; } 
@ GwtIncompatible ( "regular-expressions" ) @ Nullable @ Beta public static Float tryParse ( String string ) { if ( Doubles . FLOATING_POINT_PATTERN . matcher ( string ) . matches ( ) ) { try { return Float . parseFloat ( string ) ; } catch ( NumberFormatException e ) { } } return null ; } 
public static void updateChecksum ( CRC32 checksum , ByteBuffer buffer , int offset , int length ) { int position = buffer . position ( ) ; int limit = buffer . limit ( ) ; buffer . position ( offset ) . limit ( offset + length ) ; checksum . update ( buffer ) ; buffer . position ( position ) . limit ( limit ) ; } 
@ Override public void addComment ( String comment ) { current . appendChild ( document . createComment ( comment ) ) ; } 
protected void initializeAutoscrolling ( Point p ) { if ( component == null || ! ( component instanceof Autoscroll ) ) return ; autoScroller = createDropTargetAutoScroller ( component , p ) ; } 
public double getSumsq ( ) { return sumsqImpl . getResult ( ) ; } 
@ SuppressWarnings ( "nls" ) private static Properties getDataSourceProps ( Configuration conf ) { Properties prop = new Properties ( ) ; Iterator < Map . Entry < String , String >> iter = conf . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , String > e = iter . next ( ) ; if ( e . getKey ( ) . contains ( "datanucleus" ) || e . getKey ( ) . contains ( "jdo" ) ) { Object prevVal = prop . setProperty ( e . getKey ( ) , conf . get ( e . getKey ( ) ) ) ; if ( LOG . isDebugEnabled ( ) && ! e . getKey ( ) . equals ( HiveConf . ConfVars . METASTOREPWD . varname ) ) { LOG . debug ( "Overriding-" + e . getKey ( ) + "-value-" + prevVal + "-from-jpox.properties-with-" + e . getValue ( ) ) ; } } } if ( LOG . isDebugEnabled ( ) ) { for ( Entry < Object , Object > e : prop . entrySet ( ) ) { if ( ! e . getKey ( ) . equals ( HiveConf . ConfVars . METASTOREPWD . varname ) ) { LOG . debug ( e . getKey ( ) + "-=-" + e . getValue ( ) ) ; } } } return prop ; } 
public boolean getBoolean ( int index ) throws JSONException { Object o = get ( index ) ; if ( o . equals ( JSONObject . FALSE ) || ( o instanceof String && ( ( String ) o ) . toLowerCase ( ) . equals ( "false" ) ) ) { return false ; } else if ( o . equals ( JSONObject . TRUE ) || ( o instanceof String && ( ( String ) o ) . toLowerCase ( ) . equals ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONArray[" + index + "]-is-not-a-Boolean." ) ; } 
private static void setJobConf ( Object theObject , Configuration conf ) { try { Class < ? > jobConfClass = conf . getClassByNameOrNull ( "org.apache.hadoop.mapred.JobConf" ) ; if ( jobConfClass == null ) { return ; } Class < ? > jobConfigurableClass = conf . getClassByNameOrNull ( "org.apache.hadoop.mapred.JobConfigurable" ) ; if ( jobConfigurableClass == null ) { return ; } if ( jobConfClass . isAssignableFrom ( conf . getClass ( ) ) && jobConfigurableClass . isAssignableFrom ( theObject . getClass ( ) ) ) { Method configureMethod = jobConfigurableClass . getMethod ( "configure" , jobConfClass ) ; configureMethod . invoke ( theObject , conf ) ; } } catch ( Exception e ) { throw new RuntimeException ( "Error-in-configuring-object" , e ) ; } } 
private String newFid ( ) { return NEW_FID_PREFIX + UUID . randomUUID ( ) ; } 
void flushCacheStat ( ) { synchronized ( mCacheStatLock ) { if ( ! mCacheStat . isEmpty ( ) ) { long start = System . currentTimeMillis ( ) ; for ( Map . Entry < String , CacheAccessStat > entry : mCacheStat . entrySet ( ) ) { mCacheDatabase . execSQL ( "UPDATE-cache-SET-" + CACHE_LASTACCESSTIME_COL + "=" + entry . getValue ( ) . mLastAccessTime + "," + CACHE_ACCESSCOUNTER_COL + "=" + entry . getValue ( ) . mCacheAccessCounter + "," + CACHE_WEIGHT_COL + "=" + entry . getValue ( ) . mWeight + "-WHERE-url-=-?" , new String [ ] { entry . getKey ( ) } ) ; } mCacheStat . clear ( ) ; } } } 
public void initDiskCache ( final Context context ) { if ( mDiskCache == null || mDiskCache . isClosed ( ) ) { File diskCacheDir = getDiskCacheDir ( context , TAG ) ; if ( diskCacheDir != null ) { if ( ! diskCacheDir . exists ( ) ) { diskCacheDir . mkdirs ( ) ; } if ( getUsableSpace ( diskCacheDir ) > DISK_CACHE_SIZE ) { try { mDiskCache = DiskLruCache . open ( diskCacheDir , 1 , 1 , DISK_CACHE_SIZE ) ; } catch ( final IOException e ) { diskCacheDir = null ; } } } } } 
public Component getGlassPane ( ) { return getRootPane ( ) . getGlassPane ( ) ; } 
private void deSelectTreeNodes ( String treeId ) { List < TreeNode > categoryList ; Iterator < TreeNode > categoryIterator ; Iterator < TreeNode > privilegesIterator ; TreeNode node ; TreeNode categoryNode = null ; RichTree jsfTreeUI = ( RichTree ) findComponentInRoot ( treeId ) ; if ( ! currentTree . equals ( treeId ) ) { RowKeySet oppeRowSelection = jsfTreeUI . getSelectedRowKeys ( ) ; oppeRowSelection . removeAll ( ) ; } TreeNode areaNodeUI = ( TreeNode ) ( ( ( CapTreeModel ) jsfTreeUI . getValue ( ) ) . getWrappedData ( ) ) ; categoryList = areaNodeUI . getChildren ( ) ; categoryIterator = categoryList . iterator ( ) ; a : while ( categoryIterator . hasNext ( ) ) { categoryNode = categoryIterator . next ( ) ; if ( categoryNode . getChildren ( ) != null && ! categoryNode . getChildren ( ) . isEmpty ( ) ) { privilegesIterator = categoryNode . getChildren ( ) . iterator ( ) ; while ( privilegesIterator . hasNext ( ) ) { node = privilegesIterator . next ( ) ; if ( node . isIsNodeSelected ( ) ) { node . setIsNodeSelected ( false ) ; break a ; } } } else { if ( categoryNode . isIsNodeSelected ( ) ) { categoryNode . setIsNodeSelected ( false ) ; break a ; } } } } 
private String getFilenameForKey ( String key ) { int firstHalfLength = key . length ( ) / 2 ; String localFilename = String . valueOf ( key . substring ( 0 , firstHalfLength ) . hashCode ( ) ) ; localFilename += String . valueOf ( key . substring ( firstHalfLength ) . hashCode ( ) ) ; return localFilename ; } 
public static ImageTypeSpecifier createInterleaved ( ColorSpace colorSpace , int [ ] bandOffsets , int dataType , boolean hasAlpha , boolean isAlphaPremultiplied ) { return new ImageTypeSpecifier . Interleaved ( colorSpace , bandOffsets , dataType , hasAlpha , isAlphaPremultiplied ) ; } 
public void setStartSet ( String startSet ) throws Exception { m_startRange . setRanges ( startSet ) ; } 
@ XmlElementDecl ( namespace = "common" , name = "Airport" ) public JAXBElement < String > createAirport ( String value ) { return new JAXBElement < String > ( _Airport_QNAME , String . class , null , value ) ; } 
static void appendBytes ( String content , Mode mode , BitArray bits , String encoding ) throws WriterException { switch ( mode ) { case NUMERIC : appendNumericBytes ( content , bits ) ; break ; case ALPHANUMERIC : appendAlphanumericBytes ( content , bits ) ; break ; case BYTE : append8BitBytes ( content , bits , encoding ) ; break ; case KANJI : appendKanjiBytes ( content , bits ) ; break ; default : throw new WriterException ( "Invalid-mode:-" + mode ) ; } } 
public R visitNoType ( NoType t , P p ) { return defaultAction ( t , p ) ; } 
public void setLocale ( Locale locale ) throws XNIException { fLocale = locale ; fErrorReporter . setLocale ( locale ) ; } 
protected ResolveInfo getBestResolve ( Intent intent , List < ResolveInfo > matches ) { final ResolveInfo foundResolve = mPackageManager . resolveActivity ( intent , PackageManager . MATCH_DEFAULT_ONLY ) ; final boolean foundDisambig = ( foundResolve . match & IntentFilter . MATCH_CATEGORY_MASK ) == 0 ; if ( ! foundDisambig ) { return foundResolve ; } ResolveInfo firstSystem = null ; for ( ResolveInfo info : matches ) { final boolean isSystem = ( info . activityInfo . applicationInfo . flags & ApplicationInfo . FLAG_SYSTEM ) != 0 ; final boolean isPrefer = sPreferResolve . contains ( info . activityInfo . applicationInfo . packageName ) ; if ( isPrefer ) return info ; if ( isSystem && firstSystem == null ) firstSystem = info ; } return firstSystem != null ? firstSystem : matches . get ( 0 ) ; } 
public com . google . protobuf . ByteString getRackNameBytes ( ) { java . lang . Object ref = rackName_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; rackName_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public static String getFileExtension ( String fileName ) { String extension = "" ; int i = fileName . lastIndexOf ( '.' ) ; int p = Math . max ( fileName . lastIndexOf ( '/' ) , fileName . lastIndexOf ( '|' ) ) ; if ( i > p ) { extension = fileName . substring ( i + 1 ) ; } return extension ; } 
public Enumeration listOptions ( ) { Vector newVector = new Vector ( 1 ) ; newVector . addElement ( new Option ( "-Whether-to-use-K2-prior.-" , "k2" , 0 , "-k2" ) ) ; Enumeration enu = super . listOptions ( ) ; while ( enu . hasMoreElements ( ) ) { newVector . addElement ( enu . nextElement ( ) ) ; } return newVector . elements ( ) ; } 
public URI createNewURIFromPath ( URI locationOnSameFilesystem , String path ) { URI uri = locationOnSameFilesystem ; Path p = new Path ( path ) ; String pathString = p . toString ( ) ; final int length = pathString . length ( ) ; StringBuffer pathBuf = new StringBuffer ( length + 1 ) ; if ( length > 0 && ( pathString . charAt ( 0 ) != '/' ) ) { pathBuf . append ( '/' ) ; } if ( pathString . startsWith ( "//" ) ) pathBuf . append ( '/' ) . append ( '/' ) ; pathBuf . append ( pathString ) ; try { return new URI ( uri . getScheme ( ) , uri . getAuthority ( ) , pathBuf . toString ( ) , uri . getQuery ( ) , uri . getFragment ( ) ) ; } catch ( URISyntaxException e ) { CCorePlugin . log ( e ) ; } return null ; } 
public synchronized void addSubscriber ( String id , String hostname , String port , String callback , String tag , Conditions conditions , Attributes attributes ) { addSubscriber ( id , hostname , new Integer ( port ) . intValue ( ) , callback , tag , conditions , attributes ) ; } 
@ Override public Set < java . util . Map . Entry < K , V >> entrySet ( ) { final Set < Entry < K , V >> entries = new OpenHashSet < Map . Entry < K , V >> ( ) ; forEachPair ( new ObjectObjectProcedure < K , V > ( ) { @ Override public boolean apply ( K key , V value ) { entries . add ( new MapEntry ( key , value ) ) ; return true ; } } ) ; return entries ; } 
public ByteBuffer getValueAsByteBuffer ( byte [ ] family , byte [ ] qualifier ) { Cell kv = getColumnLatestCell ( family , 0 , family . length , qualifier , 0 , qualifier . length ) ; if ( kv == null ) { return null ; } return ByteBuffer . wrap ( kv . getValueArray ( ) , kv . getValueOffset ( ) , kv . getValueLength ( ) ) ; } 
public Node getHereContextNodeExclude ( ) { return this . getHereContextNode ( XPathFilterCHGPContainer . _TAG_EXCLUDE ) ; } 
@ Override @ Generated ( "org.nightlabs.eclipse.sdk.jdo.ObjectIdGenerator" ) public String toString ( ) { StringBuffer sb = new StringBuffer ( JDO_PREFIX ) ; sb . append ( JDO_PREFIX_SEPARATOR ) ; sb . append ( this . getClass ( ) . getName ( ) ) ; sb . append ( CLASS_SEPARATOR ) ; try { sb . append ( "organisationID=" ) ; sb . append ( URLEncoder . encode ( String . valueOf ( organisationID ) , ENCODING ) ) ; sb . append ( '&' ) ; sb . append ( "valueAcquisitionSetupID=" ) ; sb . append ( URLEncoder . encode ( Long . toString ( valueAcquisitionSetupID , RADIX ) , ENCODING ) ) ; sb . append ( '&' ) ; sb . append ( "valueProviderOrganisationID=" ) ; sb . append ( URLEncoder . encode ( String . valueOf ( valueProviderOrganisationID ) , ENCODING ) ) ; sb . append ( '&' ) ; sb . append ( "valueProviderCategoryID=" ) ; sb . append ( URLEncoder . encode ( String . valueOf ( valueProviderCategoryID ) , ENCODING ) ) ; sb . append ( '&' ) ; sb . append ( "valueProviderID=" ) ; sb . append ( URLEncoder . encode ( String . valueOf ( valueProviderID ) , ENCODING ) ) ; sb . append ( '&' ) ; sb . append ( "valueProviderConfigID=" ) ; sb . append ( URLEncoder . encode ( Long . toString ( valueProviderConfigID , RADIX ) , ENCODING ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( "Encoding-failed-with-encoding-" + ENCODING , e ) ; } return sb . toString ( ) ; } 
public SingularValueDecomposition svd ( ) { return new SingularValueDecomposition ( this ) ; } 
public int newLocal ( final Type type ) { localTypes . add ( type ) ; return super . newLocal ( type . getSize ( ) ) ; } 
public static void startQueryHaveLockedMessages ( AsyncQueryHandler handler , Collection < Long > threadIds , int token ) { handler . cancelOperation ( token ) ; Uri uri = MmsSms . CONTENT_LOCKED_URI ; String selection = null ; if ( threadIds != null ) { StringBuilder buf = new StringBuilder ( ) ; int i = 0 ; for ( long threadId : threadIds ) { if ( i ++ > 0 ) { buf . append ( "-OR-" ) ; } buf . append ( Mms . THREAD_ID ) . append ( "=" ) . append ( Long . toString ( threadId ) ) ; } selection = buf . toString ( ) ; } handler . startQuery ( token , threadIds , uri , ALL_THREADS_PROJECTION , selection , null , Conversations . DEFAULT_SORT_ORDER ) ; } 
public static IntegerBuf buffer ( int [ ] [ ] theMatrix ) { if ( theMatrix == null ) { throw new NullPointerException ( "IntegerBuf.buffer():-theMatrix-is-null" ) ; } int nr = Arrays . rowLength ( theMatrix ) ; int nc = Arrays . colLength ( theMatrix , 0 ) ; return new IntegerMatrixBuf_1 ( theMatrix , new Range ( 0 , nr - 1 ) , new Range ( 0 , nc - 1 ) ) ; } 
private void init ( ) { mPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mStrokePaint = new Paint ( mPaint ) ; mStrokePaint . setStyle ( Paint . Style . STROKE ) ; mStrokePaint . setStrokeWidth ( mStrokeWidth ) ; mStrokePaint . setColor ( Color . WHITE ) ; } 
public void saveFile ( ) { String wd = System . getProperty ( "user.dir" ) ; JFileChooser fc = new JFileChooser ( wd ) ; fc . setDialogType ( ( int ) JFileChooser . SAVE_DIALOG ) ; int rc = fc . showDialog ( null , "Save" ) ; if ( rc == JFileChooser . APPROVE_OPTION ) { File file = fc . getSelectedFile ( ) ; ObjectOutputStream output = null ; try { FileOutputStream fstream = new FileOutputStream ( file ) ; output = new ObjectOutputStream ( fstream ) ; output . writeObject ( classBoxVector ) ; output . writeObject ( relationshipVector ) ; output . flush ( ) ; output . close ( ) ; fstream . close ( ) ; } catch ( IOException x ) { } catch ( NullPointerException n ) { } } } 
public static float calculateRadiusOffset ( Resources resources ) { if ( resources != null ) { float strokeSize = resources . getDimension ( R . dimen . circletimer_circle_size ) ; float dotStrokeSize = resources . getDimension ( R . dimen . circletimer_dot_size ) ; float markerStrokeSize = resources . getDimension ( R . dimen . circletimer_marker_size ) ; return calculateRadiusOffset ( strokeSize , dotStrokeSize , markerStrokeSize ) ; } else { return 0f ; } } 
public boolean isVisible ( ) { int n = getLayoutViewCount ( ) - 1 ; for ( int i = 0 ; i < n ; i ++ ) { View v = getLayoutView ( i ) ; if ( v . isVisible ( ) ) { return true ; } } if ( n > 0 ) { View v = getLayoutView ( n ) ; if ( ( v . getEndOffset ( ) - v . getStartOffset ( ) ) == 1 ) { return false ; } } if ( getStartOffset ( ) == getDocument ( ) . getLength ( ) ) { boolean editable = false ; Component c = getContainer ( ) ; if ( c instanceof JTextComponent ) { editable = ( ( JTextComponent ) c ) . isEditable ( ) ; } if ( ! editable ) { return false ; } } return true ; } 
public static int decodeInPlace ( StringBuffer inout ) { final int n = inout . length ( ) ; int pos = 0 ; int val = 0 ; int pad = 0 ; int bits = 0 ; for ( int i = 0 ; i < n ; ++ i ) { char ch = inout . charAt ( i ) ; switch ( ch ) { case '-' : case '|t' : case '|n' : case '|r' : continue ; case '=' : ++ pad ; ch = 'A' ; default : if ( ch > 127 ) continue ; int ch2 = map2 [ ch ] ; if ( ch2 < 0 ) continue ; val <<= 6 ; val |= ch2 ; bits += 6 ; if ( bits == 24 ) { bits -= 8 * pad ; pad = 0 ; while ( bits > 0 ) { inout . setCharAt ( pos ++ , ( char ) ( ( val >>> 16 ) & 0xff ) ) ; val <<= 8 ; bits -= 8 ; } val = 0 ; } } } inout . setLength ( pos ) ; return pos ; } 
protected String findLibrary ( String libname ) { ensureInit ( ) ; String fileName = System . mapLibraryName ( libname ) ; for ( int i = 0 ; i < mLibPaths . length ; i ++ ) { String pathName = mLibPaths [ i ] + fileName ; File test = new File ( pathName ) ; if ( test . exists ( ) ) return pathName ; } return null ; } 
public static boolean isEmpty ( Map < ? , ? > map ) { return ( map == null ) || map . isEmpty ( ) ; } 
public static String convertToARGB ( int color ) { String alpha = Integer . toHexString ( Color . alpha ( color ) ) ; String red = Integer . toHexString ( Color . red ( color ) ) ; String green = Integer . toHexString ( Color . green ( color ) ) ; String blue = Integer . toHexString ( Color . blue ( color ) ) ; if ( alpha . length ( ) == 1 ) { alpha = "0" + alpha ; } if ( red . length ( ) == 1 ) { red = "0" + red ; } if ( green . length ( ) == 1 ) { green = "0" + green ; } if ( blue . length ( ) == 1 ) { blue = "0" + blue ; } return "#" + alpha + red + green + blue ; } 
public static boolean is64Bit ( ) { if ( osarch == null ) osarch = System . getProperty ( "os.arch" ) ; return osarch != null && osarch . indexOf ( "64" ) != - 1 ; } 
public static final String nodeToString ( Node node ) throws TransformerException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; printNode ( node , out ) ; return out . toString ( ) ; } 
public Dimension getMaximumSize ( JComponent a ) { Dimension returnValue = ( ( ComponentUI ) ( uis . elementAt ( 0 ) ) ) . getMaximumSize ( a ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . getMaximumSize ( a ) ; } return returnValue ; } 
public void setInstancesIndices ( String rangeList ) { m_Range . setRanges ( rangeList ) ; } 
@ XmlElementDecl ( namespace = "http://model.product.nbc.sitech.com/xsd" , name = "anotherName" , scope = Artist . class ) public JAXBElement < String > createArtistAnotherName ( String value ) { return new JAXBElement < String > ( _ArtistAnotherName_QNAME , String . class , Artist . class , value ) ; } 
private static boolean equalsHandlesNulls ( Object a , Object b ) { return ( a == null ) ? ( b == null ) : a . equals ( b ) ; } 
@ Deprecated public Builder setTicker ( CharSequence tickerText , RemoteViews views ) { mTickerText = safeCharSequence ( tickerText ) ; mTickerView = views ; return this ; } 
protected InetSocketAddress getHttpServerBindAddress ( Configuration conf ) { InetSocketAddress bindAddress = getHttpServerAddress ( conf ) ; final String bindHost = conf . getTrimmed ( DFS_NAMENODE_HTTP_BIND_HOST_KEY ) ; if ( bindHost != null && ! bindHost . isEmpty ( ) ) { bindAddress = new InetSocketAddress ( bindHost , bindAddress . getPort ( ) ) ; } return bindAddress ; } 
public Property dayOfMonth ( ) { return new Property ( this , DAY_OF_MONTH ) ; } 
public String getMethod ( ) { SipParser par = new SipParser ( value ) ; par . skipString ( ) ; return par . getString ( ) ; } 
public void SetTimeout ( int M ) { if ( M < 0 ) ReadTimeout = 0 ; else ReadTimeout = M ; { try { TheSocket . setSoTimeout ( ReadTimeout ) ; } catch ( Exception E ) { } } } 
public URI relativize ( URI relative ) { if ( relative . opaque || opaque ) { return relative ; } if ( scheme == null ? relative . scheme != null : ! scheme . equals ( relative . scheme ) ) { return relative ; } if ( authority == null ? relative . authority != null : ! authority . equals ( relative . authority ) ) { return relative ; } String thisPath = normalize ( path ) ; String relativePath = normalize ( relative . path ) ; if ( ! thisPath . equals ( relativePath ) ) { if ( ! thisPath . endsWith ( "/" ) ) { thisPath = thisPath + '/' ; } if ( ! relativePath . startsWith ( thisPath ) ) { return relative ; } } URI result = new URI ( ) ; result . fragment = relative . fragment ; result . query = relative . query ; result . path = relativePath . substring ( thisPath . length ( ) ) ; result . setSchemeSpecificPart ( ) ; return result ; } 
public boolean add ( Object obj ) { if ( obj instanceof Attribute ) { Attribute attribute = ( Attribute ) obj ; int duplicate = indexOfDuplicate ( attribute ) ; if ( duplicate < 0 ) { add ( size ( ) , attribute ) ; } else { set ( duplicate , attribute ) ; } } else if ( obj == null ) { throw new IllegalAddException ( "Cannot-add-null-attribute" ) ; } else { throw new IllegalAddException ( "Class-" + obj . getClass ( ) . getName ( ) + "-is-not-an-attribute" ) ; } return true ; } 
private void processJournal ( ) throws IOException { deleteIfExists ( journalFileTmp ) ; for ( Iterator < Entry > i = lruEntries . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Entry entry = i . next ( ) ; if ( entry . currentEditor == null ) { for ( int t = 0 ; t < valueCount ; t ++ ) { size += entry . lengths [ t ] ; } } else { entry . currentEditor = null ; for ( int t = 0 ; t < valueCount ; t ++ ) { deleteIfExists ( entry . getCleanFile ( t ) ) ; deleteIfExists ( entry . getDirtyFile ( t ) ) ; } i . remove ( ) ; } } } 
public void addParameter ( String name , IParameterSpecification spec ) { if ( _parameters == null ) _parameters = new HashMap ( ) ; if ( _parameters . containsKey ( name ) ) throw new IllegalArgumentException ( Tapestry . format ( "ComponentSpecification.duplicate-parameter" , this , name ) ) ; _parameters . put ( name , spec ) ; addReservedParameterName ( name ) ; } 
private Border getStatusBarComponentBorder ( ) { switch ( getStyle ( ) ) { case WINDOWS_98_STYLE : return BorderFactory . createCompoundBorder ( BorderFactory . createBevelBorder ( BevelBorder . LOWERED ) , BorderFactory . createEmptyBorder ( 0 , 3 , 0 , 3 ) ) ; case WINDOWS_XP_STYLE : return BorderFactory . createCompoundBorder ( new BevelDividerBorder ( BevelDividerBorder . LEFT , 2 ) , BorderFactory . createEmptyBorder ( 0 , 3 , 0 , 3 ) ) ; default : return null ; } } 
public long readLong ( ) { return scanner . nextLong ( ) ; } 
public Integer64 plus ( Integer64 that ) { Integer64 r = FACTORY . object ( ) ; r . _value = this . _value + that . _value ; return r ; } 
private final void updateTail ( ) { Node < E > t , p , q ; restartFromTail : while ( ( t = tail ) . item == null && ( p = t . next ) != null ) { for ( ; ; ) { if ( ( q = p . next ) == null || ( q = ( p = q ) . next ) == null ) { if ( casTail ( t , p ) ) return ; else continue restartFromTail ; } else if ( t != tail ) continue restartFromTail ; else p = q ; } } } 
public int hashCode ( ) { if ( hash == 0 ) { int hash0 = 11 ; hash0 = hash0 * 31 + field . hashCode ( ) ; hash0 = hash0 * 31 + a . hashCode ( ) ; hash0 = hash0 * 31 + b . hashCode ( ) ; if ( seed != null ) { for ( int i = 0 ; i < seed . length ; i ++ ) { hash0 = hash0 * 31 + seed [ i ] ; } } else { hash0 = hash0 * 31 ; } hash = hash0 ; } return hash ; } 
public void drawLegendShape ( Canvas canvas , SimpleSeriesRenderer renderer , float x , float y , int seriesIndex , Paint paint ) { float halfShapeWidth = SHAPE_WIDTH / 2 ; canvas . drawRect ( x , y - halfShapeWidth , x + SHAPE_WIDTH , y + halfShapeWidth , paint ) ; } 
public static String printAttributeValue ( Element node , String prefix ) { if ( node == null ) { return null ; } StringBuffer xml = new StringBuffer ( 100 ) ; xml . append ( '<' ) ; xml . append ( prefix ) . append ( node . getLocalName ( ) ) ; NamedNodeMap attrs = node . getAttributes ( ) ; int length = attrs . getLength ( ) ; for ( int i = 0 ; i < length ; i ++ ) { Attr attr = ( Attr ) attrs . item ( i ) ; xml . append ( '-' ) ; xml . append ( attr . getNodeName ( ) ) ; xml . append ( "="" ) ; xml . append ( attr . getNodeValue ( ) ) ; xml . append ( '"' ) ; } xml . append ( '>' ) ; NodeList children = node . getChildNodes ( ) ; if ( children != null ) { int len = children . getLength ( ) ; for ( int i = 0 ; i < len ; i ++ ) { xml . append ( print ( children . item ( i ) ) ) ; } } xml . append ( "</" ) ; xml . append ( prefix ) . append ( node . getLocalName ( ) ) ; xml . append ( '>' ) ; return xml . toString ( ) ; } 
public String getNamespacePrefix ( String namespaceURI , String defaultPrefix ) { if ( namespaceURI == null ) { throw new NullPointerException ( "namespaceURI-cannot-be-null" ) ; } String prefix = ( String ) nsMap . get ( namespaceURI ) ; return ( prefix != null ? prefix : defaultPrefix ) ; } 
public boolean validate ( String [ ] xmlFiles , boolean failOnWarning ) { DefaultListableBeanFactory beans = loadBeans ( xmlFiles ) ; return runValidations ( beans , failOnWarning ) ; } 
public static Insets getInsets ( Object key ) { Object o = get ( key ) ; if ( o instanceof Insets ) return ( Insets ) o ; else return null ; } 
public boolean isPageBreak ( ) { Object oo = get_Value ( "IsPageBreak" ) ; if ( oo != null ) { if ( oo instanceof Boolean ) return ( ( Boolean ) oo ) . booleanValue ( ) ; return "Y" . equals ( oo ) ; } return false ; } 
public int getLocalPort ( ) { return impl . getLocalPort ( ) ; } 
public static void addHorizontalRule ( DataOutputStream writer ) throws IOException { writer . writeBytes ( "<p><hr></p>-" ) ; } 
void lightweightPaint ( Graphics g ) { super . lightweightPaint ( g ) ; paintHeavyweightComponents ( g ) ; } 
static public double rint ( double x ) { int exp ; int sign ; long ix ; double w ; if ( x == 0 ) { return x ; } ix = Double . doubleToLongBits ( x ) ; sign = ( int ) ( ( ix >> 63 ) & 1 ) ; exp = ( ( int ) ( ix >> 52 ) & 0x7ff ) - 0x3ff ; if ( exp < 0 ) { if ( x < - 0.5 ) { return - 1.0 ; } else if ( x > 0.5 ) { return 1.0 ; } else if ( sign == 0 ) { return 0.0 ; } else { return NEGATIVE_ZERO ; } } else if ( exp < 53 ) { long mask = ( 0x000fffffffffffffL >>> exp ) ; if ( ( mask & ix ) == 0 ) { return x ; } } else if ( exp == 1024 ) { return x ; } x = Double . longBitsToDouble ( ix ) ; w = TWO52 [ sign ] + x ; return w - TWO52 [ sign ] ; } 
private ChromosomePair crossover ( final AbstractListChromosome < T > first , final AbstractListChromosome < T > second ) throws DimensionMismatchException { final int length = first . getLength ( ) ; if ( length != second . getLength ( ) ) { throw new DimensionMismatchException ( second . getLength ( ) , length ) ; } final List < T > parent1Rep = first . getRepresentation ( ) ; final List < T > parent2Rep = second . getRepresentation ( ) ; final ArrayList < T > child1Rep = new ArrayList < T > ( first . getLength ( ) ) ; final ArrayList < T > child2Rep = new ArrayList < T > ( second . getLength ( ) ) ; final int crossoverIndex = 1 + ( GeneticAlgorithm . getRandomGenerator ( ) . nextInt ( length - 2 ) ) ; for ( int i = 0 ; i < crossoverIndex ; i ++ ) { child1Rep . add ( parent1Rep . get ( i ) ) ; child2Rep . add ( parent2Rep . get ( i ) ) ; } for ( int i = crossoverIndex ; i < length ; i ++ ) { child1Rep . add ( parent2Rep . get ( i ) ) ; child2Rep . add ( parent1Rep . get ( i ) ) ; } return new ChromosomePair ( first . newFixedLengthChromosome ( child1Rep ) , second . newFixedLengthChromosome ( child2Rep ) ) ; } 
public void swithToSelectAndCopyTextMode ( ) { try { KeyEvent shiftPressEvent = new KeyEvent ( 0 , 0 , KeyEvent . ACTION_DOWN , KeyEvent . KEYCODE_SHIFT_LEFT , 0 , 0 ) ; shiftPressEvent . dispatch ( mCurrentWebView ) ; } catch ( Exception e ) { throw new AssertionError ( e ) ; } } 
public void set ( int index , String value ) throws IOException { Writer writer = null ; try { writer = new OutputStreamWriter ( newOutputStream ( index ) , Util . UTF_8 ) ; writer . write ( value ) ; } finally { Util . closeQuietly ( writer ) ; } } 
private int parseInt ( String number ) { try { return Integer . parseInt ( number ) ; } catch ( NumberFormatException e ) { } return 0 ; } 
static Serializable parseValue ( String value ) { value = value . trim ( ) ; if ( value . startsWith ( "{" ) ) { String [ ] elements = value . substring ( 1 , value . length ( ) - 1 ) . split ( "," ) ; Object [ ] values = new Object [ elements . length ] ; for ( int i = 0 ; i < elements . length ; i ++ ) { values [ i ] = parseValue ( elements [ i ] ) ; } return values ; } if ( value . startsWith ( "#" ) ) { try { return Color . decode ( value . substring ( 1 ) ) ; } catch ( NumberFormatException nfe1 ) { } } if ( value . equalsIgnoreCase ( "TRUE" ) || value . equalsIgnoreCase ( "FALSE" ) ) { return Boolean . valueOf ( value ) ; } try { return new Integer ( value ) ; } catch ( NumberFormatException nfe1 ) { } try { return new Double ( value ) ; } catch ( NumberFormatException nfe2 ) { } return value ; } 
public Process exec ( String prog , String [ ] envp ) throws java . io . IOException { return exec ( prog , envp , null ) ; } 
public void copyFrom ( PointerCoords other ) { final long bits = other . mPackedAxisBits ; mPackedAxisBits = bits ; if ( bits != 0 ) { final float [ ] otherValues = other . mPackedAxisValues ; final int count = Long . bitCount ( bits ) ; float [ ] values = mPackedAxisValues ; if ( values == null || count > values . length ) { values = new float [ otherValues . length ] ; mPackedAxisValues = values ; } System . arraycopy ( otherValues , 0 , values , 0 , count ) ; } x = other . x ; y = other . y ; pressure = other . pressure ; size = other . size ; touchMajor = other . touchMajor ; touchMinor = other . touchMinor ; toolMajor = other . toolMajor ; toolMinor = other . toolMinor ; orientation = other . orientation ; } 
@ SuppressWarnings ( { "TypeMayBeWeakened" } ) int getFrameNumber ( @ NotNull final DocumentFrame < D > frame ) { return frames . indexOf ( frame ) ; } 
public double lastYValue ( ) { if ( pointList . size ( ) == 0 ) return Double . NaN ; else return pointList . get ( pointList . size ( ) - 1 ) . getY ( ) ; } 
public static Provider [ ] getProviders ( ) { return providers . toArray ( new Provider [ providers . size ( ) ] ) ; } 
public static Bitmap decodeFile ( String pathName , Options opts ) { Bitmap bm = null ; InputStream stream = null ; try { stream = new FileInputStream ( pathName ) ; bm = decodeStream ( stream , null , opts ) ; } catch ( Exception e ) { Log . e ( "BitmapFactory" , "Unable-to-decode-stream:-" + e ) ; } finally { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { } } } return bm ; } 
private void sendSocks4BindReply ( ServerSocket socket , int rep ) { try { InetAddress address = InetAddress . getLocalHost ( ) ; byte [ ] port = Util . shortToByteArray ( socket . getLocalPort ( ) ) ; toClient . write ( ( byte ) 0x00 ) ; toClient . write ( ( byte ) rep ) ; toClient . write ( port ) ; toClient . write ( address . getAddress ( ) ) ; toClient . flush ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } 
public Number getNumericField ( String fieldName ) { return ( Number ) fields . get ( fieldName ) ; } 
public Collection < TimeZoneDefinition > getServerTimeZones ( Iterable < String > timeZoneIds ) { Date today = new Date ( ) ; Collection < TimeZoneDefinition > timeZoneList = new ArrayList < TimeZoneDefinition > ( ) ; for ( String timeZoneId : timeZoneIds ) { TimeZoneDefinition timeZoneDefinition = new TimeZoneDefinition ( ) ; timeZoneList . add ( timeZoneDefinition ) ; TimeZone timeZone = TimeZone . getTimeZone ( timeZoneId ) ; timeZoneDefinition . id = timeZone . getID ( ) ; timeZoneDefinition . name = timeZone . getDisplayName ( timeZone . inDaylightTime ( today ) , TimeZone . LONG ) ; } return timeZoneList ; } 
public String hitStyle ( String styleName ) { if ( styleName != null ) { Integer hits = stylesMap . get ( styleName ) ; if ( hits != null ) { hits ++ ; } else { hits = new Integer ( 1 ) ; } stylesMap . put ( styleName , hits ) ; } return styleName ; } 
public String getProperty ( String property ) { return properties . get ( property ) ; } 
public String getCSVTripList ( ) { String ret = "" ; for ( int i = 0 ; i < mPath . size ( ) - 1 ; i ++ ) { ret += '"' + mPath . get ( i ) . get_trip_id ( ) + '"' + ',' ; } if ( mPath . size ( ) > 0 ) { ret += '"' + mPath . get ( mPath . size ( ) - 1 ) . get_trip_id ( ) + '"' + "-" ; } return ret ; } 
public void setWorldClip ( Rectangle clip ) { if ( clip == null ) { clearWorldClip ( ) ; } else { setWorldClip ( clip . getX ( ) , clip . getY ( ) , clip . getWidth ( ) , clip . getHeight ( ) ) ; } } 
public void addDocumentation ( ProgramElementDoc ped , int indent ) { String rct = ( ( Doc ) ped ) . getRawCommentText ( ) ; if ( rct != null ) { rct = stripNonPrintingChars ( rct , ( Doc ) ped ) ; rct = rct . trim ( ) ; if ( rct . compareTo ( "" ) != 0 && rct . indexOf ( Comments . placeHolderText ) == - 1 && rct . indexOf ( "InsertOtherCommentsHere" ) == - 1 ) { int idx = endOfFirstSentence ( rct ) ; if ( idx == 0 ) return ; for ( int i = 0 ; i < indent ; i ++ ) outputFile . print ( "-" ) ; outputFile . println ( "<doc>" ) ; for ( int i = 0 ; i < indent ; i ++ ) outputFile . print ( "-" ) ; String firstSentence = null ; if ( idx == - 1 ) firstSentence = rct ; else firstSentence = rct . substring ( 0 , idx + 1 ) ; boolean checkForAts = false ; if ( checkForAts && firstSentence . indexOf ( "@" ) != - 1 && firstSentence . indexOf ( "@link" ) == - 1 ) { System . out . println ( "Warning:-@-tag-seen-in-comment:-" + firstSentence ) ; } String firstSentenceNoTags = API . stuffHTMLTags ( firstSentence ) ; outputFile . println ( firstSentenceNoTags ) ; for ( int i = 0 ; i < indent ; i ++ ) outputFile . print ( "-" ) ; outputFile . println ( "</doc>" ) ; } } } 
final public Expression preDecrementExpression ( ) throws ParseException { Expression pe ; Token t ; t = jj_consume_token ( DECREMENT ) ; pe = primaryExpression ( ) ; { if ( true ) { return new PreDecrement ( pe , this . filename , pe . getBeginLine ( ) , pe . getBeginColumn ( ) , t . endLine , t . endColumn ) ; } } throw new Error ( "Missing-return-statement-in-function" ) ; } 
private void yypushback ( int number ) { if ( number > yylength ( ) ) yy_ScanError ( YY_PUSHBACK_2BIG ) ; yy_markedPos -= number ; } 
public String getFileExtension ( String fileName ) { int index = fileName . lastIndexOf ( "." ) ; int length = fileName . length ( ) ; String extension = fileName . substring ( index , length ) ; return extension ; } 
public boolean isNull ( String name ) { Object value = nameValuePairs . get ( name ) ; return value == null || value == NULL ; } 
public boolean hasEntries ( ) { return ! fEntries . isEmpty ( ) ; } 
public void quadrantRotate ( int numquadrants , double anchorx , double anchory ) { switch ( numquadrants & 3 ) { case 0 : return ; case 1 : m02 += anchorx * ( m00 - m01 ) + anchory * ( m01 + m00 ) ; m12 += anchorx * ( m10 - m11 ) + anchory * ( m11 + m10 ) ; rotate90 ( ) ; break ; case 2 : m02 += anchorx * ( m00 + m00 ) + anchory * ( m01 + m01 ) ; m12 += anchorx * ( m10 + m10 ) + anchory * ( m11 + m11 ) ; rotate180 ( ) ; break ; case 3 : m02 += anchorx * ( m00 + m01 ) + anchory * ( m01 - m00 ) ; m12 += anchorx * ( m10 + m11 ) + anchory * ( m11 - m10 ) ; rotate270 ( ) ; break ; } if ( m02 == 0.0 && m12 == 0.0 ) { state &= ~ APPLY_TRANSLATE ; } else { state |= APPLY_TRANSLATE ; } } 
public static String removeNamespace ( String xmlSource ) throws TransformerException { TransformerFactory factory = TransformerFactory . newInstance ( ) ; Templates transformer = factory . newTemplates ( new StreamSource ( XSLT_REMOVE_NAMESPACE ) ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; Result result = new StreamResult ( baos ) ; transformer . newTransformer ( ) . transform ( new StreamSource ( new StringReader ( xmlSource ) ) , result ) ; return baos . toString ( ) ; } 
private Integer getValueForItemId ( int itemID ) { String identifier = mapItemIdIdentifier . get ( itemID ) ; int index = identifier . indexOf ( "-" ) ; return Integer . valueOf ( identifier . substring ( 0 , index ) ) ; } 
public String [ ] getBlacklisted ( String url ) { try { URL myConnection = new URL ( url ) ; URLConnection connectMe = myConnection . openConnection ( ) ; InputStreamReader lineReader = new InputStreamReader ( connectMe . getInputStream ( ) ) ; BufferedReader br = new BufferedReader ( new BufferedReader ( lineReader ) ) ; String Zeile ; String [ ] rt ; for ( i = 0 ; ( ( Zeile = br . readLine ( ) ) != null ) && i < 101 ; i ++ ) { rt = Zeile . split ( ":" ) ; if ( rt [ 0 ] . equalsIgnoreCase ( Float . toString ( plugin . Version ) ) ) { return rt ; } } } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; plugin . Logger ( "Exception:-IOException!" , "Error" ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; plugin . Logger ( "Exception:-Exception!" , "" ) ; } return null ; } 
protected void createMBeans ( ) { Context context = null ; try { context = ( Context ) ( new InitialContext ( ) ) . lookup ( "java:/" ) ; } catch ( NamingException e ) { log . error ( "No-global-naming-context-defined-for-server" ) ; return ; } try { createMBeans ( "" , context ) ; } catch ( NamingException e ) { log . error ( "Exception-processing-Global-JNDI-Resources" , e ) ; } } 
public static String fileNameFromGeneration ( String base , String ext , long gen ) { if ( gen == - 1 ) { return null ; } else if ( gen == 0 ) { return segmentFileName ( base , "" , ext ) ; } else { assert gen > 0 ; StringBuilder res = new StringBuilder ( base . length ( ) + 6 + ext . length ( ) ) . append ( base ) . append ( '_' ) . append ( Long . toString ( gen , Character . MAX_RADIX ) ) ; if ( ext . length ( ) > 0 ) { res . append ( '.' ) . append ( ext ) ; } return res . toString ( ) ; } } 
public void setDate ( Date date ) { if ( date != null ) this . date = ( Date ) date . clone ( ) ; else date = null ; } 
private void processJournal ( ) throws IOException { deleteIfExists ( journalFileTmp ) ; for ( Iterator < Entry > i = lruEntries . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Entry entry = i . next ( ) ; if ( entry . currentEditor == null ) { for ( int t = 0 ; t < valueCount ; t ++ ) { size += entry . lengths [ t ] ; } } else { entry . currentEditor = null ; for ( int t = 0 ; t < valueCount ; t ++ ) { deleteIfExists ( entry . getCleanFile ( t ) ) ; deleteIfExists ( entry . getDirtyFile ( t ) ) ; } i . remove ( ) ; } } } 
public void removeBookmarkedURL ( BookmarkedURL bookmarkedURL ) { bookmarkedURLS . remove ( bookmarkedURL ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public boolean isSetId ( ) { return __isset_bit_vector . get ( __ID_ISSET_ID ) ; } 
protected void append ( int value ) { mMessage . write ( value ) ; mPosition ++ ; } 
protected RouteSpecificPool getRoutePool ( HttpRoute route , boolean create ) { RouteSpecificPool rospl = null ; poolLock . lock ( ) ; try { rospl = routeToPool . get ( route ) ; if ( ( rospl == null ) && create ) { rospl = newRouteSpecificPool ( route ) ; routeToPool . put ( route , rospl ) ; } } finally { poolLock . unlock ( ) ; } return rospl ; } 
State addOnExitSelfTransaction ( SelfTransition onExitSelfTransaction ) { if ( onExitSelfTransaction == null ) { throw new IllegalArgumentException ( "transition" ) ; } onExits . add ( onExitSelfTransaction ) ; return this ; } 
private Method getPropertyFunction ( Class targetClass , String prefix , Class valueType ) { Method returnVal = null ; String methodName = getMethodName ( prefix , mPropertyName ) ; Class args [ ] = null ; if ( valueType == null ) { try { returnVal = targetClass . getMethod ( methodName , args ) ; } catch ( NoSuchMethodException e ) { Log . e ( "PropertyValuesHolder" , targetClass . getSimpleName ( ) + "---" + "Couldn't-find-no-arg-method-for-property-" + mPropertyName + ":-" + e ) ; } } else { args = new Class [ 1 ] ; Class typeVariants [ ] ; if ( mValueType . equals ( Float . class ) ) { typeVariants = FLOAT_VARIANTS ; } else if ( mValueType . equals ( Integer . class ) ) { typeVariants = INTEGER_VARIANTS ; } else if ( mValueType . equals ( Double . class ) ) { typeVariants = DOUBLE_VARIANTS ; } else { typeVariants = new Class [ 1 ] ; typeVariants [ 0 ] = mValueType ; } for ( Class typeVariant : typeVariants ) { args [ 0 ] = typeVariant ; try { returnVal = targetClass . getMethod ( methodName , args ) ; mValueType = typeVariant ; return returnVal ; } catch ( NoSuchMethodException e ) { } } Log . e ( "PropertyValuesHolder" , "Couldn't-find-" + prefix + "ter-property-" + mPropertyName + "-for-" + targetClass . getSimpleName ( ) + "-with-value-type-" + mValueType ) ; } return returnVal ; } 
public boolean emptyCredentials ( ) { return ( ( ticket == null || ticket . length ( ) == 0 ) && ( authorization == null || authorization . length ( ) == 0 ) ) ; } 
public static double colorDistance ( double r1 , double g1 , double b1 , double r2 , double g2 , double b2 ) { double a = r2 - r1 ; double b = g2 - g1 ; double c = b2 - b1 ; return Math . sqrt ( a * a + b * b + c * c ) ; } 
public final boolean isCancelled ( ) { return mCancelled . get ( ) ; } 
public float drawLine ( Token token , Graphics2D g , float x , float y ) { float nextX = x ; while ( token != null && token . isPaintable ( ) && nextX < clipEnd ) { nextX = token . paint ( g , nextX , y , host , this , clipStart ) ; token = token . getNextToken ( ) ; } if ( host . getEOLMarkersVisible ( ) ) { g . setColor ( host . getForegroundForTokenType ( Token . WHITESPACE ) ) ; g . setFont ( host . getFontForTokenType ( Token . WHITESPACE ) ) ; g . drawString ( "¶" , nextX , y ) ; } return nextX ; } 
@ Override public long fileLength ( String name ) throws IOException { ensureOpen ( ) ; File file = new File ( directory , name ) ; final long len = file . length ( ) ; if ( len == 0 && ! file . exists ( ) ) { throw new FileNotFoundException ( name ) ; } else { return len ; } } 
public int getNextDescendant ( int subtreeRootHandle , int nodeHandle ) { subtreeRootHandle &= NODEHANDLE_MASK ; nodeHandle &= NODEHANDLE_MASK ; if ( nodeHandle == 0 ) return NULL ; while ( ! m_isError ) { if ( done && ( nodeHandle > nodes . slotsUsed ( ) ) ) break ; if ( nodeHandle > subtreeRootHandle ) { nodes . readSlot ( nodeHandle + 1 , gotslot ) ; if ( gotslot [ 2 ] != 0 ) { short type = ( short ) ( gotslot [ 0 ] & 0xFFFF ) ; if ( type == ATTRIBUTE_NODE ) { nodeHandle += 2 ; } else { int nextParentPos = gotslot [ 1 ] ; if ( nextParentPos >= subtreeRootHandle ) return ( m_docHandle | ( nodeHandle + 1 ) ) ; else break ; } } else if ( ! done ) { } else break ; } else { nodeHandle ++ ; } } return NULL ; } 
public void Add ( ScreenRectangleEntry entry ) { queue . add ( entry ) ; } 
public final void yyclose ( ) throws java . io . IOException { zzAtEOF = true ; zzEndRead = zzStartRead ; if ( zzReader != null ) zzReader . close ( ) ; } 
public static String toString ( InputStream input ) throws IOException { StringWriter sw = new StringWriter ( ) ; copy ( input , sw ) ; return sw . toString ( ) ; } 
private static List < Class > findClasses ( File directory , String packageName ) throws ClassNotFoundException { List < Class > classes = new ArrayList < Class > ( ) ; if ( ! directory . exists ( ) ) { return classes ; } File [ ] files = directory . listFiles ( ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { assert ! file . getName ( ) . contains ( "." ) ; classes . addAll ( findClasses ( file , packageName + "." + file . getName ( ) ) ) ; } else if ( file . getName ( ) . endsWith ( ".class" ) ) { classes . add ( Class . forName ( packageName + '.' + file . getName ( ) . substring ( 0 , file . getName ( ) . length ( ) - 6 ) ) ) ; } } return classes ; } 
public synchronized void getInstance ( String algorithm , Provider provider , Object param ) throws NoSuchAlgorithmException { Provider . Service serv = null ; if ( algorithm == null ) { throw new NoSuchAlgorithmException ( "algorithm-==-null" ) ; } serv = provider . getService ( serviceName , algorithm ) ; if ( serv == null ) { throw notFound ( serviceName , algorithm ) ; } spi = serv . newInstance ( param ) ; this . provider = provider ; } 
final public float [ ] getScaleFactors ( float scaleFactors [ ] ) { if ( scaleFactors == null ) { return ( float [ ] ) this . scaleFactors . clone ( ) ; } System . arraycopy ( this . scaleFactors , 0 , scaleFactors , 0 , Math . min ( this . scaleFactors . length , scaleFactors . length ) ) ; return scaleFactors ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public static final String toString ( Object [ ] array , String divider ) { return toString ( array , divider , array . length ) ; } 
public byte [ ] digest ( byte [ ] input ) { update ( input ) ; return digest ( ) ; } 
public static void writeProperty ( Property p , DataOutput out ) throws IOException { writeString ( p . getURN ( ) , out ) ; writeBoolean ( p . isDefined ( ) , out ) ; if ( p . isDefined ( ) ) { ByteArrayOutputStream gather = new ByteArrayOutputStream ( ) ; p . write ( gather ) ; byte [ ] bytes = gather . toByteArray ( ) ; writeInt32 ( bytes . length , out ) ; out . write ( bytes ) ; } } 
public static < E > ArrayList < E > newArrayList ( ) { return new ArrayList < E > ( ) ; } 
private void writeBufData ( byte [ ] data , int offset , int len ) throws IOException { if ( count + len > 0 ) { Utils . writeVInt ( out , - ( count + len ) ) ; out . write ( buf , 0 , count ) ; count = 0 ; out . write ( data , offset , len ) ; } } 
static String getCorruptFilesWarning ( FSNamesystem fsn ) { if ( fsn == null ) { return "" ; } long missingBlocks = fsn . getMissingBlocksCount ( ) ; if ( missingBlocks > 0 ) { StringBuilder result = new StringBuilder ( ) ; result . append ( "<div>" ) ; result . append ( "<a-class="warning"-href="/corrupt_files.jsp"-title="List-corrupt-files">-" ) ; result . append ( "<b>WARNING-:-There-are-" + missingBlocks + "-missing-blocks.-Please-check-the-logs-or-run-fsck-in-order-to-identify-the-missing-blocks.</b>" ) ; result . append ( "</a>" ) ; result . append ( "<div-class="small">See-the-Hadoop-FAQ-for-common-causes-and-potential-solutions.</div>" ) ; result . append ( "</div>-" ) ; return result . toString ( ) ; } return "" ; } 
public static ArrayList < Cargo > LoadAll ( String where ) { ArrayList < Cargo > returnList = new ArrayList < Cargo > ( ) ; try { ArrayList < Map < String , Object >> temp ; if ( where . isEmpty ( ) ) temp = executeQuery ( "Select-*-from-CargoShip-where-Deleted-=-false" ) ; else temp = executeQuery ( "Select-*-from-CargoShip-" + where + "-AND-Deleted-=-false" ) ; for ( int i = 0 ; i < temp . size ( ) ; i ++ ) { Cargo c = BuildFromDataRow ( temp . get ( i ) ) ; returnList . add ( c ) ; } } catch ( Exception ex ) { System . out . println ( "Error-" + ex ) ; ex . printStackTrace ( ) ; } return returnList ; } 
@ Override public Enumeration < String > getUsers ( ) { return ( homes . keys ( ) ) ; } 
public static double max ( double d1 , double d2 ) { if ( d1 > d2 ) return d1 ; if ( d1 < d2 ) return d2 ; if ( d1 != d2 ) return Double . NaN ; if ( d1 == 0.0 && ( ( Double . doubleToLongBits ( d1 ) & Double . doubleToLongBits ( d2 ) ) & 0x8000000000000000L ) == 0 ) return 0.0 ; return d1 ; } 
public static View convertButton ( View convertView , String text , int position ) { if ( ( ( String ) convertView . getTag ( ) ) . equals ( "button" ) ) { ( ( Button ) convertView ) . setText ( text ) ; convertView . setId ( position ) ; return convertView ; } else { return null ; } } 
public static String [ ] getStylenames ( String style ) { List < String > result = new ArrayList < String > ( ) ; if ( style != null ) { String [ ] pairs = style . split ( ";" ) ; for ( int i = 0 ; i < pairs . length ; i ++ ) { if ( pairs [ i ] . indexOf ( "=" ) < 0 ) { result . add ( pairs [ i ] ) ; } } } return result . toArray ( new String [ result . size ( ) ] ) ; } 
public static String [ ] getEditorSearchPath ( ) { return ThreadGroupContext . getContext ( ) . getPropertyEditorFinder ( ) . getPackages ( ) ; } 
public String getText ( Object arg0 ) { String text = ( ( File ) arg0 ) . getName ( ) ; if ( text . length ( ) == 0 ) { text = ( ( File ) arg0 ) . getPath ( ) ; } return text ; } 
public static String formatMonth ( int month , Locale locale ) { DateFormatSymbols symbols = new DateFormatSymbols ( locale ) ; String [ ] monthNames = symbols . getMonths ( ) ; return monthNames [ month - 1 ] ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
private static void percDown ( int [ ] a , int i , int n ) { int child ; int tmp ; for ( tmp = a [ i ] ; leftChild ( i ) < n ; i = child ) { child = leftChild ( i ) ; if ( ( child != n - 1 ) && ( a [ child ] < a [ child + 1 ] ) ) { child ++ ; } if ( tmp < a [ child ] ) { a [ i ] = a [ child ] ; } else { break ; } } a [ i ] = tmp ; } 
public long roundTripTime ( ) throws InterruptedException { latch . await ( ) ; return received - sent ; } 
public void addGop ( long _position , Gop gop ) { String str = "7-" + file_index + "-" + _position + "-0-0-" ; fields . add ( str ) ; } 
public Collection < String > search ( String query ) { return Collections . emptyList ( ) ; } 
public void decDfsUsed ( long value ) { used . addAndGet ( - value ) ; } 
public List < FieldComparisonFailure > getFieldMissing ( ) { return Collections . unmodifiableList ( _fieldMissing ) ; } 
private void readProcStatFile ( ) { BufferedReader in = null ; FileReader fReader = null ; try { fReader = new FileReader ( procfsStatFile ) ; in = new BufferedReader ( fReader ) ; } catch ( FileNotFoundException f ) { return ; } Matcher mat = null ; try { String str = in . readLine ( ) ; while ( str != null ) { mat = CPU_TIME_FORMAT . matcher ( str ) ; if ( mat . find ( ) ) { long uTime = Long . parseLong ( mat . group ( 1 ) ) ; long nTime = Long . parseLong ( mat . group ( 2 ) ) ; long sTime = Long . parseLong ( mat . group ( 3 ) ) ; cumulativeCpuTime = uTime + nTime + sTime ; break ; } str = in . readLine ( ) ; } cumulativeCpuTime *= jiffyLengthInMillis ; } catch ( IOException io ) { LOG . warn ( "Error-reading-the-stream-" + io ) ; } finally { try { fReader . close ( ) ; try { in . close ( ) ; } catch ( IOException i ) { LOG . warn ( "Error-closing-the-stream-" + in ) ; } } catch ( IOException i ) { LOG . warn ( "Error-closing-the-stream-" + fReader ) ; } } } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public void setAdditionalInformation ( Map < String , Object > additionalInformation ) { this . additionalInformation = new LinkedHashMap < String , Object > ( additionalInformation ) ; } 
protected void loadInfo ( AudioFileFormat aff ) throws UnsupportedAudioFileException { String ty = aff . getType ( ) . toString ( ) ; if ( ! ty . equalsIgnoreCase ( "flac" ) ) { throw new UnsupportedAudioFileException ( "Not-Flac-audio-format" ) ; } AudioFormat af = aff . getFormat ( ) ; channels = af . getChannels ( ) ; samplerate = ( int ) af . getSampleRate ( ) ; bitspersample = af . getSampleSizeInBits ( ) ; } 
public void write ( Float f ) { writeInteger32ToByteArray ( Float . floatToIntBits ( f . floatValue ( ) ) ) ; } 
public ArrayList < String > getAids ( ) { final ArrayList < String > aids = new ArrayList < String > ( ) ; for ( AidGroup group : getAidGroups ( ) ) { aids . addAll ( group . aids ) ; } return aids ; } 
public double getLastUpdateTime ( ) { return attribute . getLastUpdateTime ( ) ; } 
protected String getCleanPath ( String path ) { if ( path . endsWith ( "/" ) && path . length ( ) > 1 ) path = path . substring ( 0 , path . length ( ) - 1 ) ; return path ; } 
public static Set < String > commaDelimitedListToSet ( String str ) { Set < String > set = new TreeSet < String > ( ) ; String [ ] tokens = commaDelimitedListToStringArray ( str ) ; for ( String token : tokens ) { set . add ( token ) ; } return set ; } 
private Node tryMinimizeNot ( Node n ) { Node parent = n . getParent ( ) ; Node notChild = n . getFirstChild ( ) ; int complementOperator ; switch ( notChild . getType ( ) ) { case Token . EQ : complementOperator = Token . NE ; break ; case Token . NE : complementOperator = Token . EQ ; break ; case Token . SHEQ : complementOperator = Token . SHNE ; break ; case Token . SHNE : complementOperator = Token . SHEQ ; break ; default : return n ; } Node newOperator = n . removeFirstChild ( ) ; newOperator . setType ( complementOperator ) ; parent . replaceChild ( n , newOperator ) ; reportCodeChange ( ) ; return newOperator ; } 
public void reshape ( GLAutoDrawable glAutoDrawable , int x , int y , int w , int h ) { ( ( Component ) glAutoDrawable ) . setMinimumSize ( new Dimension ( 0 , 0 ) ) ; } 
public static String formatFraction ( Fraction f ) { return getImproperInstance ( ) . format ( f ) ; } 
public Point2D scale ( double x , double y ) { return new Point2D ( x * scalex + vx , y * scaley + vy ) ; } 
private static String _indent ( int level ) { return Utilities . indent ( level ) ; } 
public static void getRelativeDrawPosition ( View rootView , View childView , int [ ] outPosition ) { assert outPosition . length == 2 ; outPosition [ 0 ] = 0 ; outPosition [ 1 ] = 0 ; while ( childView != null && childView != rootView ) { outPosition [ 0 ] += childView . getX ( ) ; outPosition [ 1 ] += childView . getY ( ) ; childView = ( View ) childView . getParent ( ) ; } } 
public synchronized E remove ( int index ) { modCount ++ ; if ( index >= elementCount ) throw new ArrayIndexOutOfBoundsException ( index ) ; E oldValue = elementData ( index ) ; int numMoved = elementCount - index - 1 ; if ( numMoved > 0 ) System . arraycopy ( elementData , index + 1 , elementData , index , numMoved ) ; elementData [ -- elementCount ] = null ; return oldValue ; } 
public static String formatTime ( long timeDiff ) { StringBuffer buf = new StringBuffer ( ) ; long hours = timeDiff / ( 60 * 60 * 1000 ) ; long rem = ( timeDiff % ( 60 * 60 * 1000 ) ) ; long minutes = rem / ( 60 * 1000 ) ; rem = rem % ( 60 * 1000 ) ; long seconds = rem / 1000 ; if ( hours != 0 ) { buf . append ( hours ) ; buf . append ( "hrs,-" ) ; } if ( minutes != 0 ) { buf . append ( minutes ) ; buf . append ( "mins,-" ) ; } buf . append ( seconds ) ; buf . append ( "sec" ) ; return buf . toString ( ) ; } 
public String toString ( ) { return type . tsym . name . toString ( ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public Server ( Object instance , Configuration conf , String bindAddress , int port ) throws IOException { this ( instance , conf , bindAddress , port , 1 , false , null ) ; } 
@ edu . umd . cs . findbugs . annotations . SuppressWarnings ( value = "RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE" ) @ VisibleForTesting static void configureCompression ( HTable table , Configuration conf ) throws IOException { StringBuilder compressionConfigValue = new StringBuilder ( ) ; HTableDescriptor tableDescriptor = table . getTableDescriptor ( ) ; if ( tableDescriptor == null ) { return ; } Collection < HColumnDescriptor > families = tableDescriptor . getFamilies ( ) ; int i = 0 ; for ( HColumnDescriptor familyDescriptor : families ) { if ( i ++ > 0 ) { compressionConfigValue . append ( '&' ) ; } compressionConfigValue . append ( URLEncoder . encode ( familyDescriptor . getNameAsString ( ) , "UTF-8" ) ) ; compressionConfigValue . append ( '=' ) ; compressionConfigValue . append ( URLEncoder . encode ( familyDescriptor . getCompression ( ) . getName ( ) , "UTF-8" ) ) ; } conf . set ( COMPRESSION_FAMILIES_CONF_KEY , compressionConfigValue . toString ( ) ) ; } 
public void addInitParam ( org . gridlab . gridsphere . portletcontainer . jsrimpl . descriptor . InitParam vInitParam ) throws java . lang . IndexOutOfBoundsException { _initParamList . add ( vInitParam ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public static Enumeration < Driver > getDrivers ( ) { Vector v = new Vector ( ) ; Enumeration e = drivers . elements ( ) ; ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; while ( e . hasMoreElements ( ) ) { Object obj = e . nextElement ( ) ; ClassLoader loader = obj . getClass ( ) . getClassLoader ( ) ; if ( loader == null ) loader = ClassLoader . getSystemClassLoader ( ) ; if ( ! loader . equals ( cl ) ) continue ; v . addElement ( obj ) ; } return v . elements ( ) ; } 
public static long skipByReading ( InputStream in , long byteCount ) throws IOException { byte [ ] buffer = skipBuffer . getAndSet ( null ) ; if ( buffer == null ) { buffer = new byte [ 4096 ] ; } long skipped = 0 ; while ( skipped < byteCount ) { int toRead = ( int ) Math . min ( byteCount - skipped , buffer . length ) ; int read = in . read ( buffer , 0 , toRead ) ; if ( read == - 1 ) { break ; } skipped += read ; if ( read < toRead ) { break ; } } skipBuffer . set ( buffer ) ; return skipped ; } 
private javax . swing . JLabel getHelpLabel ( ) { if ( ivjHelpLabel == null ) { try { ivjHelpLabel = new javax . swing . JLabel ( ) ; ivjHelpLabel . setName ( "HelpLabel" ) ; ivjHelpLabel . setText ( "(help)" ) ; ivjHelpLabel . setHorizontalAlignment ( javax . swing . SwingConstants . LEFT ) ; ivjHelpLabel . setHorizontalTextPosition ( javax . swing . SwingConstants . CENTER ) ; } catch ( java . lang . Throwable ivjExc ) { handleException ( ivjExc ) ; } } return ivjHelpLabel ; } 
public List < java . lang . Object > getAny ( ) { if ( any == null ) { any = new ArrayList < java . lang . Object > ( ) ; } return this . any ; } 
public static void defaultPrint ( InfExpression e , PrintWriter o ) { if ( e . sign < 0 ) o . print ( "-INF" ) ; else o . print ( "+INF" ) ; } 
protected ByteBuffer ensureAvailable ( int available ) throws IOException { if ( ! blockMode ) { if ( buf . remaining ( ) < available ) { buf . compact ( ) ; buf . limit ( available ) ; in . read ( buf ) ; buf . position ( 0 ) ; } } else { while ( buf . remaining ( ) < available ) { if ( unbufferedBlock > 0 ) { buf . compact ( ) . limit ( Math . min ( unbufferedBlock , buf . capacity ( ) ) ) ; int r = in . read ( buf ) ; buf . flip ( ) ; unbufferedBlock -= r ; continue ; } ByteBuffer b = ByteBuffer . allocateDirect ( 1 ) ; in . read ( b ) ; b . flip ( ) ; if ( b . get ( ) != J_BLOCK_DATA ) throw new StreamCorruptedException ( "Not-at-block-boundary" ) ; int blockSize = readChannelEscapedInt ( ) ; buf . clear ( ) . limit ( Math . min ( blockSize , buf . capacity ( ) ) ) ; in . read ( buf ) ; buf . flip ( ) ; unbufferedBlock = blockSize - buf . limit ( ) ; } } return buf ; } 
public float getHeading ( ) { this . lastAccessTime = System . currentTimeMillis ( ) ; return this . heading ; } 
public PrintStream append ( CharSequence charSequence , int start , int end ) { if ( charSequence == null ) { charSequence = "null" ; } print ( charSequence . subSequence ( start , end ) . toString ( ) ) ; return this ; } 
public boolean removeDataSet ( int index ) { if ( index >= mDataSets . size ( ) || index < 0 ) return false ; T set = mDataSets . get ( index ) ; return removeDataSet ( set ) ; } 
public boolean deregisterServiceProvider ( Object provider ) { Object oprovider = map . get ( provider . getClass ( ) ) ; if ( provider == oprovider ) { map . remove ( provider . getClass ( ) ) ; poset . remove ( provider ) ; if ( provider instanceof RegisterableService ) { RegisterableService rs = ( RegisterableService ) provider ; rs . onDeregistration ( registry , category ) ; } return true ; } return false ; } 
public RBTuple extractBound ( RBTuple goal ) { return extract ( boundPlaces , goal ) ; } 
public synchronized void start ( ) { if ( hasBeenStarted ) { throw new IllegalThreadStateException ( "Thread-already-started." ) ; } hasBeenStarted = true ; VMThread . create ( this , stackSize ) ; } 
public List < String > getAudienceRating ( ) { if ( audienceRating == null ) { audienceRating = new ArrayList < String > ( ) ; } return this . audienceRating ; } 
public String toString ( ) { return ( "" + proxyIP . getHostName ( ) + ":" + proxyPort + "-Version-" + version ) ; } 
public static void readFully ( InputStream in , byte [ ] dst , int offset , int byteCount ) throws IOException { if ( byteCount == 0 ) { return ; } if ( in == null ) { throw new NullPointerException ( "in-==-null" ) ; } if ( dst == null ) { throw new NullPointerException ( "dst-==-null" ) ; } checkOffsetAndCount ( dst . length , offset , byteCount ) ; while ( byteCount > 0 ) { int bytesRead = in . read ( dst , offset , byteCount ) ; if ( bytesRead < 0 ) { throw new EOFException ( ) ; } offset += bytesRead ; byteCount -= bytesRead ; } } 
public static Chromosome getChromosomeFromElement ( Configuration a_activeConfiguration , Element a_xmlElement ) throws ImproperXMLException , InvalidConfigurationException , UnsupportedRepresentationException , GeneCreationException { if ( a_xmlElement == null || ! ( a_xmlElement . getTagName ( ) . equals ( CHROMOSOME_TAG ) ) ) { throw new ImproperXMLException ( "Unable-to-build-Chromosome-instance-from-XML-Element:-" + "given-Element-is-not-a-'chromosome'-element." ) ; } Element genesElement = ( Element ) a_xmlElement . getElementsByTagName ( GENES_TAG ) . item ( 0 ) ; if ( genesElement == null ) { throw new ImproperXMLException ( "Unable-to-build-Chromosome-instance-from-XML-Element:-" + "'genes'-sub-element-not-found." ) ; } Gene [ ] geneAlleles = getGenesFromElement ( a_activeConfiguration , genesElement ) ; return new Chromosome ( a_activeConfiguration , geneAlleles ) ; } 
public void addElement ( E element ) { int index = delegate . size ( ) ; delegate . addElement ( element ) ; fireIntervalAdded ( this , index , index ) ; } 
public static String encodeFromFile ( String filename ) { String encodedData = null ; Base64 . InputStream bis = null ; try { java . io . File file = new java . io . File ( filename ) ; byte [ ] buffer = new byte [ Math . max ( ( int ) ( file . length ( ) * 1.4 ) , 40 ) ] ; int length = 0 ; int numBytes = 0 ; bis = new Base64 . InputStream ( new java . io . BufferedInputStream ( new java . io . FileInputStream ( file ) ) , Base64 . ENCODE ) ; while ( ( numBytes = bis . read ( buffer , length , 4096 ) ) >= 0 ) length += numBytes ; encodedData = new String ( buffer , 0 , length , Base64 . PREFERRED_ENCODING ) ; } catch ( java . io . IOException e ) { System . err . println ( "Error-encoding-from-file-" + filename ) ; } finally { try { bis . close ( ) ; } catch ( Exception e ) { } } return encodedData ; } 
synchronized void addExtendedStyle ( Style attr ) { insertAttributeSetAt ( attr , getAttributes ( ) . length ) ; } 
public synchronized void join ( ) throws InterruptedException { while ( running ) { wait ( ) ; } } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public static boolean equals ( float [ ] a , float [ ] a2 ) { if ( a == a2 ) return true ; if ( a == null || a2 == null ) return false ; int length = a . length ; if ( a2 . length != length ) return false ; for ( int i = 0 ; i < length ; i ++ ) if ( Float . floatToIntBits ( a [ i ] ) != Float . floatToIntBits ( a2 [ i ] ) ) return false ; return true ; } 
public synchronized void close ( ) throws IOException { if ( ! indexClosed ) { index . close ( ) ; } data . close ( ) ; } 
public PduPart getPartByFileName ( String filename ) { return mPartMapByFileName . get ( filename ) ; } 
public void close ( ) { isClosed = true ; impl . close ( ) ; } 
public static String bytesToString ( byte [ ] data , int start , int end ) { StringBuilder buf = new StringBuilder ( ) ; if ( end > data . length ) { end = data . length ; } for ( int i = start ; i < end ; i ++ ) { buf . append ( "-" ) ; buf . append ( Integer . toHexString ( data [ i ] & 0xff ) ) ; } return buf . toString ( ) ; } 
public static InputStream getSystemResourceAsStream ( String resName ) { return SystemClassLoader . loader . getResourceAsStream ( resName ) ; } 
public static BufferedImage magnifyImage ( double f , BufferedImage img ) { if ( img == null ) return null ; AffineTransform at = new AffineTransform ( ) ; at . scale ( f , f ) ; int type = img . getType ( ) ; if ( type == BufferedImage . TYPE_CUSTOM ) type = BufferedImage . TYPE_INT_ARGB ; Rectangle bounds = img . getRaster ( ) . getBounds ( ) ; bounds = at . createTransformedShape ( bounds ) . getBounds ( ) ; BufferedImage rescaleBuff ; rescaleBuff = new BufferedImage ( bounds . width , bounds . height , type ) ; Graphics2D g2 = rescaleBuff . createGraphics ( ) ; g2 . drawImage ( img , at , null ) ; g2 . dispose ( ) ; img . flush ( ) ; return rescaleBuff ; } 
public static boolean hasExternalStorage ( ) { return Environment . MEDIA_MOUNTED . equals ( Environment . getExternalStorageState ( ) ) ; } 
public Object get ( String name ) throws IOException { if ( name . equalsIgnoreCase ( DESCRIPTIONS ) ) { return accessDescriptions ; } else { throw new IOException ( "Attribute-name-[" + name + "]-not-recognized-by-" + "CertAttrSet:AuthorityInfoAccessExtension." ) ; } } 
public int codePointBefore ( int index ) { if ( index < 1 || index > count ) { throw new StringIndexOutOfBoundsException ( index ) ; } return Character . codePointBefore ( value , index ) ; } 
public int read ( byte [ ] b ) throws IOException { return read ( b , 0 , b . length ) ; } 
@ Transient public Rectangle getBounds ( ) { return new Rectangle ( x , y , width , height ) ; } 
public Enumeration listOptions ( ) { Vector result = new Vector ( ) ; result . addElement ( new Option ( "-number-of-clusters.-" + "-(default-2)." , "N" , 1 , "-N-<num>" ) ) ; result . addElement ( new Option ( "-Display-std.-deviations-for-centroids.-" , "V" , 0 , "-V" ) ) ; result . addElement ( new Option ( "-Replace-missing-values-with-mean/mode.-" , "M" , 0 , "-M" ) ) ; result . add ( new Option ( "-Distance-function-to-use.-" + "-(default:-weka.core.EuclideanDistance)" , "A" , 1 , "-A-<classname-and-options>" ) ) ; result . add ( new Option ( "-Maximum-number-of-iterations.-" , "I" , 1 , "-I-<num>" ) ) ; result . addElement ( new Option ( "-Preserve-order-of-instances.-" , "O" , 0 , "-O" ) ) ; Enumeration en = super . listOptions ( ) ; while ( en . hasMoreElements ( ) ) result . addElement ( en . nextElement ( ) ) ; return result . elements ( ) ; } 
public Date getStartDate ( ) { if ( startDate == - 1 ) return null ; return new Date ( startDate ) ; } 
public static < K , V > Tuple < K , V > consumeNext ( final Iterator < K > it , final Iterator < V > it2 ) { K nextK = null ; V nextV = null ; if ( it . hasNext ( ) ) { nextK = it . next ( ) ; } if ( it2 . hasNext ( ) ) { nextV = it2 . next ( ) ; } if ( nextK == null && nextV == null ) { return null ; } else { return new Tuple < > ( nextK , nextV ) ; } } 
public Set < AWTKeyStroke > getFocusTraversalKeys ( int id ) { if ( id != KeyboardFocusManager . FORWARD_TRAVERSAL_KEYS && id != KeyboardFocusManager . BACKWARD_TRAVERSAL_KEYS && id != KeyboardFocusManager . UP_CYCLE_TRAVERSAL_KEYS && id != KeyboardFocusManager . DOWN_CYCLE_TRAVERSAL_KEYS ) throw new IllegalArgumentException ( ) ; Set s = null ; if ( focusTraversalKeys != null ) s = focusTraversalKeys [ id ] ; if ( s == null && parent != null ) s = parent . getFocusTraversalKeys ( id ) ; return s == null ? ( KeyboardFocusManager . getCurrentKeyboardFocusManager ( ) . getDefaultFocusTraversalKeys ( id ) ) : s ; } 
public void removeOnAccountsUpdatedListener ( OnAccountsUpdateListener listener ) { if ( listener == null ) throw new IllegalArgumentException ( "listener-is-null" ) ; synchronized ( mAccountsUpdatedListeners ) { if ( ! mAccountsUpdatedListeners . containsKey ( listener ) ) { Log . e ( TAG , "Listener-was-not-previously-added" ) ; return ; } mAccountsUpdatedListeners . remove ( listener ) ; if ( mAccountsUpdatedListeners . isEmpty ( ) ) { mContext . unregisterReceiver ( mAccountsChangedBroadcastReceiver ) ; } } } 
protected long generateLowThreshold ( ) { return listeners . isEmpty ( ) ? Long . MAX_VALUE : listeners . get ( 0 ) . threshold ; } 
public int length ( ) { return namesAndValues . size ( ) / 2 ; } 
public int getMajorVersion ( ) { byteBuffer . position ( PERFDATA_PROLOG_MAJOR_OFFSET ) ; return ( int ) byteBuffer . get ( ) ; } 
public Element generateElement ( Document document ) { Element key = document . createElement ( mxGraphMlConstants . KEY ) ; if ( ! keyName . equals ( "" ) ) { key . setAttribute ( mxGraphMlConstants . KEY_NAME , keyName ) ; } key . setAttribute ( mxGraphMlConstants . ID , keyId ) ; if ( ! keyName . equals ( "" ) ) { key . setAttribute ( mxGraphMlConstants . KEY_FOR , stringForValue ( keyFor ) ) ; } if ( ! keyName . equals ( "" ) ) { key . setAttribute ( mxGraphMlConstants . KEY_TYPE , stringTypeValue ( keyType ) ) ; } if ( ! keyName . equals ( "" ) ) { key . setTextContent ( keyDefault ) ; } return key ; } 
public static boolean rename ( File source , File destination ) throws IOException { BufferedInputStream bis = null ; BufferedOutputStream bos = null ; try { if ( destination . exists ( ) ) { destination . delete ( ) ; } if ( source . renameTo ( destination ) ) { return true ; } FileUtils . createNewFile ( destination ) ; bis = new BufferedInputStream ( new FileInputStream ( source ) ) ; bos = new BufferedOutputStream ( new FileOutputStream ( destination ) ) ; pipeStreams ( bos , bis ) ; bos . flush ( ) ; bis . close ( ) ; bos . close ( ) ; destination . setLastModified ( source . lastModified ( ) ) ; if ( ! source . canWrite ( ) ) { destination . setReadOnly ( ) ; } source . delete ( ) ; bis = null ; bos = null ; return true ; } finally { try { if ( bis != null ) { bis . close ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } try { if ( bos != null ) { bos . close ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } } 
public void setComposite ( Composite comp ) { this . composite = comp ; if ( comp instanceof AlphaComposite ) { AlphaComposite acomp = ( AlphaComposite ) comp ; int alpha = ( int ) ( acomp . getAlpha ( ) * 0xFF ) ; this . gc . setAlpha ( alpha ) ; } else { System . out . println ( "warning,-can-only-handle-alpha-composite-at-the-moment." ) ; } } 
public String toString ( int indentFactor ) throws JSONException { StringWriter w = new StringWriter ( ) ; synchronized ( w . getBuffer ( ) ) { return this . write ( w , indentFactor , 0 ) . toString ( ) ; } } 
public void putAny ( byte [ ] s ) { putAny ( s , s . length ) ; } 
public Object getChild ( int index ) { return children . elementAt ( index ) ; } 
private void createGroup ( ) { touchScreenTableGroup = new Composite ( this , SWT . NONE ) ; touchScreenTableGroup . setBackground ( new Color ( Display . getCurrent ( ) , 255 , 255 , 255 ) ) ; GridLayout gridLayout = new GridLayout ( ) ; gridLayout . numColumns = 2 ; gridLayout . verticalSpacing = 0 ; gridLayout . makeColumnsEqualWidth = true ; gridLayout . marginWidth = 0 ; gridLayout . marginHeight = 0 ; gridLayout . horizontalSpacing = 0 ; touchScreenTableGroup . setLayout ( gridLayout ) ; GridData gridData = new GridData ( ) ; gridData . grabExcessHorizontalSpace = true ; gridData . grabExcessVerticalSpace = true ; gridData . horizontalAlignment = GridData . CENTER ; gridData . verticalAlignment = GridData . CENTER ; touchScreenTableGroup . setLayoutData ( gridData ) ; } 
public static Object deserialize ( InputStream in ) { Class cls ; Class [ ] paramTypes ; Constructor constr ; Object [ ] arglist ; Object obj ; Object result ; result = null ; try { cls = Class . forName ( CLASS_PYTHONOBJECTINPUTSTREAM ) ; paramTypes = new Class [ ] { InputStream . class } ; constr = cls . getConstructor ( paramTypes ) ; arglist = new Object [ ] { in } ; obj = constr . newInstance ( arglist ) ; result = invoke ( obj , "readObject" , new Class [ ] { } , new Object [ ] { } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return result ; } 
public void autonomousPeriodic ( ) { Scheduler . getInstance ( ) . run ( ) ; } 
public Collection getEntities ( ) { return Collections . unmodifiableCollection ( this . entities ) ; } 
public ListPathAdapter ( List < T > pathList , int frontOffset ) throws NullPointerException { super ( ) ; if ( pathList == null ) throw new NullPointerException ( "Cannot-create-ListPathAdapters-with-a-null-list." ) ; if ( frontOffset < 0 || frontOffset > pathList . size ( ) ) throw new IllegalArgumentException ( "Cannot-create-ListPathAdapter:-frontOffset-out-of-bounds-(" + frontOffset + ")." ) ; this . pathList = pathList ; this . frontOffset = frontOffset ; } 
private void startIfReady ( Animator dependencyAnimation ) { if ( mAnimatorSet . mTerminated ) { return ; } Dependency dependencyToRemove = null ; int numDependencies = mNode . tmpDependencies . size ( ) ; for ( int i = 0 ; i < numDependencies ; ++ i ) { Dependency dependency = mNode . tmpDependencies . get ( i ) ; if ( dependency . rule == mRule && dependency . node . animation == dependencyAnimation ) { dependencyToRemove = dependency ; dependencyAnimation . removeListener ( this ) ; break ; } } mNode . tmpDependencies . remove ( dependencyToRemove ) ; if ( mNode . tmpDependencies . size ( ) == 0 ) { mNode . animation . start ( ) ; mAnimatorSet . mPlayingSet . add ( mNode . animation ) ; } } 
@ NonNull public static Choices createChoices ( @ NonNull String id , @ NonNull String title , @ NonNull IMenuCallback callback , @ Nullable List < URL > iconUrls , @ Nullable String current , @ Nullable URL iconUrl , int sortPriority , boolean supportsMultipleNodes , @ NonNull List < Pair < String , String >> idsAndTitles ) { int itemCount = idsAndTitles . size ( ) ; List < String > titles = new ArrayList < String > ( itemCount ) ; List < String > ids = new ArrayList < String > ( itemCount ) ; for ( Pair < String , String > pair : idsAndTitles ) { ids . add ( pair . getFirst ( ) ) ; titles . add ( pair . getSecond ( ) ) ; } Choices choices = new Choices ( id , title , callback , titles , iconUrls , ids , current , sortPriority , supportsMultipleNodes ) ; choices . setIconUrl ( iconUrl ) ; return choices ; } 
public Object get ( final Object key , final int n ) { final List v = ( List ) this . table . get ( key ) ; if ( v == null ) { return null ; } return v . get ( n ) ; } 
Vector processSIMPLEPATTERNLIST ( StylesheetHandler handler , String uri , String name , String rawName , String value , ElemTemplateElement owner ) throws org . xml . sax . SAXException { try { StringTokenizer tokenizer = new StringTokenizer ( value , "-" ) ; int nPatterns = tokenizer . countTokens ( ) ; Vector patterns = new Vector ( nPatterns ) ; for ( int i = 0 ; i < nPatterns ; i ++ ) { XPath pattern = handler . createMatchPatternXPath ( tokenizer . nextToken ( ) , owner ) ; patterns . addElement ( pattern ) ; } return patterns ; } catch ( TransformerException te ) { throw new org . xml . sax . SAXException ( te ) ; } } 
public ExpressionNode getExpressionOwner ( ) { ExpressionNode parent = exprGetParent ( ) ; while ( ( null != parent ) && ( parent instanceof Expression ) ) parent = parent . exprGetParent ( ) ; return parent ; } 
public void addInnerClass ( InnerClass innerClass ) { innerClasses . add ( innerClass ) ; } 
public static byte [ ] encodeBase64 ( byte [ ] binaryData ) { return encodeBase64 ( binaryData , false ) ; } 
public void goToStartOfWhiteSpace ( boolean select ) { Selection s = getSelectionAtOffset ( caret ) ; int line , offset ; if ( select || s == null ) { line = caretLine ; offset = caret - buffer . getLineStartOffset ( line ) ; } else { line = s . startLine ; offset = s . start - buffer . getLineStartOffset ( line ) ; } int firstIndent = chunkCache . getSubregionStartOffset ( line , offset ) ; if ( firstIndent == getLineStartOffset ( line ) ) { firstIndent = StandardUtilities . getLeadingWhiteSpace ( getLineText ( line ) ) ; if ( firstIndent == getLineLength ( line ) ) firstIndent = 0 ; firstIndent += getLineStartOffset ( line ) ; } if ( select ) extendSelection ( caret , firstIndent ) ; else if ( ! multi ) selectNone ( ) ; moveCaretPosition ( firstIndent ) ; } 
public static String join ( Collection < String > parts , String separator , String lastSeparator ) { StringBuilder sb = new StringBuilder ( ) ; int i = 0 ; int lastIndex = parts . size ( ) - 1 ; for ( String part : parts ) { sb . append ( part ) ; if ( i == lastIndex - 1 ) { sb . append ( lastSeparator ) ; } else if ( i != lastIndex ) { sb . append ( separator ) ; } i ++ ; } return sb . toString ( ) ; } 
private synchronized void removeServiceRegistrations ( BundleContextImpl context ) { publishedServicesByContext . remove ( context ) ; } 
public void initializeBoard ( ) { boardState = new int [ ( BOARD_SIZE * BOARD_SIZE ) ] ; Arrays . fill ( boardState , 0 ) ; } 
private void initializeScheme ( String p_uriSpec ) throws MalformedURIException { int uriSpecLen = p_uriSpec . length ( ) ; int index = 0 ; String scheme = null ; char testChar = '|0' ; while ( index < uriSpecLen ) { testChar = p_uriSpec . charAt ( index ) ; if ( testChar == ':' || testChar == '/' || testChar == '?' || testChar == '#' ) { break ; } index ++ ; } scheme = p_uriSpec . substring ( 0 , index ) ; if ( scheme . length ( ) == 0 ) { throw new MalformedURIException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_NO_SCHEME_INURI , null ) ) ; } else { setScheme ( scheme ) ; } } 
public boolean contains ( Rectangle r ) { return contains ( r . x , r . y , r . width , r . height ) ; } 
public char toCharArray ( ) [ ] { synchronized ( lock ) { return Arrays . copyOf ( buf , count ) ; } } 
private int parsePrecision ( ) { if ( format . charAt ( index ) != '.' ) return - 1 ; advance ( ) ; int precision = parseInt ( ) ; if ( precision == - 1 ) throw new IllegalArgumentException ( ) ; return precision ; } 
public void setSweepInterval ( int interval ) { if ( interval <= 0 ) throw new KNXIllegalArgumentException ( "sweep-interval-has-to-be->-0" ) ; synchronized ( lock ) { sweepInterval = interval ; lock . notify ( ) ; } } 
public String toString ( ) { if ( m_Classifiers == null ) { return "RandomCommittee:-No-model-built-yet." ; } StringBuffer text = new StringBuffer ( ) ; text . append ( "All-the-base-classifiers:-" ) ; for ( int i = 0 ; i < m_Classifiers . length ; i ++ ) text . append ( m_Classifiers [ i ] . toString ( ) + "-" ) ; return text . toString ( ) ; } 
public StrBuilder append ( final char [ ] chars ) { if ( chars == null ) { return appendNull ( ) ; } final int strLen = chars . length ; if ( strLen > 0 ) { final int len = length ( ) ; ensureCapacity ( len + strLen ) ; System . arraycopy ( chars , 0 , buffer , len , strLen ) ; size += strLen ; } return this ; } 
public static Map < String , String > getHardRebindAnswers ( Map < String , String > [ ] rebindAnswers ) { Iterator < Map < String , String >> it = Arrays . asList ( rebindAnswers ) . iterator ( ) ; Map < String , String > toReturn = new HashMap < String , String > ( it . next ( ) ) ; while ( it . hasNext ( ) ) { Map < String , String > next = it . next ( ) ; toReturn . entrySet ( ) . retainAll ( next . entrySet ( ) ) ; } return toReturn ; } 
public static void error ( String msg ) { getLogger ( ) . severe ( msg ) ; handler . flush ( ) ; } 
boolean isSynthetic ( ) { return field . isSynthetic ( ) ; } 
protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( "two" , null ) ) ; } 
public Set < Complex > getMaximalComplex ( ) { HashSet < Complex > result = new HashSet < Complex > ( ) ; if ( this . isMaximal ( ) ) { result . add ( this ) ; } else { for ( Complex c : this . superComplex ) { result . addAll ( c . getMaximalComplex ( ) ) ; } } return result ; } 
public void editingStopped ( ChangeEvent e ) { getHandler ( ) . editingStopped ( e ) ; } 
public static NumericEntityEscaper above ( final int codepoint ) { return outsideOf ( 0 , codepoint ) ; } 
public boolean isHostRestricted ( InetAddress host ) { String ip = host . getHostAddress ( ) ; if ( hosts . containsKey ( ip ) ) return true ; for ( int i = 0 ; i < 3 ; i ++ ) { ip = ip . substring ( 0 , ip . lastIndexOf ( '.' ) + 1 ) ; if ( hosts . containsKey ( ip ) ) return true ; } return false ; } 
public static String joinNiceString ( Object [ ] par0ArrayOfObj ) { StringBuilder var1 = new StringBuilder ( ) ; for ( int var2 = 0 ; var2 < par0ArrayOfObj . length ; ++ var2 ) { String var3 = par0ArrayOfObj [ var2 ] . toString ( ) ; if ( var2 > 0 ) { if ( var2 == par0ArrayOfObj . length - 1 ) { var1 . append ( "-and-" ) ; } else { var1 . append ( ",-" ) ; } } var1 . append ( var3 ) ; } return var1 . toString ( ) ; } 
public int getStateIndex ( String string ) { for ( int i = 0 ; i < possibleValueList . size ( ) ; i ++ ) { if ( ( ( String ) possibleValueList . elementAt ( i ) ) . equals ( string ) ) { return i ; } } return 0 ; } 
public Vertex getVertexByName ( String name ) { for ( Vertex v : vertices ) { if ( v . getName ( ) . equals ( name ) ) { return v ; } } return null ; } 
public static String findStringWithPosition ( String [ ] big , String [ ] small , String token ) { Map < String , WordPosition > map = createMap ( big , small ) ; List < String > s1 = new ArrayList < String > ( ) ; List < String > s2 = new ArrayList < String > ( ) ; String res = "" ; for ( int i = 0 ; i < big . length ; i ++ ) { WordPosition wp = map . get ( big [ i ] ) ; if ( - 1 != wp . pos2 ) { if ( 0 < res . length ( ) ) { res += token ; } res += big [ i ] + i ; } } return res ; } 
public static void decodeToFile ( String dataToDecode , String filename ) throws java . io . IOException { OutputStream bos = null ; try { bos = new OutputStream ( new java . io . FileOutputStream ( filename ) , Base64 . DECODE ) ; bos . write ( dataToDecode . getBytes ( PREFERRED_ENCODING ) ) ; } catch ( java . io . IOException e ) { throw e ; } finally { try { bos . close ( ) ; } catch ( Exception e ) { } } } 
public static boolean elementIsInEncryptionSpace ( Element element , String localName ) { if ( element == null ) { return false ; } return EncryptionConstants . EncryptionSpecNS . equals ( element . getNamespaceURI ( ) ) && element . getLocalName ( ) . equals ( localName ) ; } 
public int getMinLevel ( double value ) { if ( value <= 0 ) { return S2CellId . MAX_LEVEL ; } int exponent = exp ( value / ( ( 1 << dim ) * deriv ) ) ; int level = Math . max ( 0 , Math . min ( S2CellId . MAX_LEVEL , - ( ( exponent - 1 ) >> ( dim - 1 ) ) ) ) ; return level ; } 
public boolean intersectsLine ( double x1 , double y1 , double x2 , double y2 ) { double rx1 = getX ( ) ; double ry1 = getY ( ) ; double rx2 = rx1 + getWidth ( ) ; double ry2 = ry1 + getHeight ( ) ; return ( rx1 <= x1 && x1 <= rx2 && ry1 <= y1 && y1 <= ry2 ) || ( rx1 <= x2 && x2 <= rx2 && ry1 <= y2 && y2 <= ry2 ) || Line2D . linesIntersect ( rx1 , ry1 , rx2 , ry2 , x1 , y1 , x2 , y2 ) || Line2D . linesIntersect ( rx2 , ry1 , rx1 , ry2 , x1 , y1 , x2 , y2 ) ; } 
@ Deprecated public void getMatrix ( Matrix ctm ) { native_getCTM ( mNativeCanvas , ctm . native_instance ) ; } 
private byte [ ] readAllBytes ( InputStream in ) throws IOException { ByteArrayOutputStream tmp = new ByteArrayOutputStream ( ) ; byte [ ] buf = new byte [ 512 ] ; for ( int len ; - 1 != ( len = in . read ( buf ) ) ; ) { tmp . write ( buf , 0 , len ) ; } tmp . close ( ) ; return tmp . toByteArray ( ) ; } 
public void moveFile ( String file ) { File f = new File ( this . tempFile ) ; if ( ! file . startsWith ( "/" ) ) { if ( Environment . getExternalStorageState ( ) . equals ( Environment . MEDIA_MOUNTED ) ) { file = Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) + File . separator + file ; } else { file = "/data/data/" + handler . cordova . getActivity ( ) . getPackageName ( ) + "/cache/" + file ; } } String logMsg = "renaming-" + this . tempFile + "-to-" + file ; Log . d ( LOG_TAG , logMsg ) ; if ( ! f . renameTo ( new File ( file ) ) ) Log . e ( LOG_TAG , "FAILED-" + logMsg ) ; } 
public Byte getAsByte ( String key ) { Object value = mValues . get ( key ) ; try { return value != null ? ( ( Number ) value ) . byteValue ( ) : null ; } catch ( ClassCastException e ) { if ( value instanceof CharSequence ) { try { return Byte . valueOf ( value . toString ( ) ) ; } catch ( NumberFormatException e2 ) { Log . e ( TAG , "Cannot-parse-Byte-value-for-" + value + "-at-key-" + key ) ; return null ; } } else { Log . e ( TAG , "Cannot-cast-value-for-" + key + "-to-a-Byte:-" + value , e ) ; return null ; } } } 
@ XmlElementDecl ( namespace = "http://webservice.webf/" , name = "getAllPersonsResponse" ) public JAXBElement < GetAllPersonsResponse > createGetAllPersonsResponse ( GetAllPersonsResponse value ) { return new JAXBElement < GetAllPersonsResponse > ( _GetAllPersonsResponse_QNAME , GetAllPersonsResponse . class , null , value ) ; } 
@ XmlElementDecl ( namespace = "http://www.nltaxonomie.nl/8.0/basis/bd/items/bd-omzetbelasting" , name = "SuppliesToCountriesWithinTheEC" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < MonetaryNoDecimals10VItemType > createSuppliesToCountriesWithinTheEC ( MonetaryNoDecimals10VItemType value ) { return new JAXBElement < MonetaryNoDecimals10VItemType > ( _SuppliesToCountriesWithinTheEC_QNAME , MonetaryNoDecimals10VItemType . class , null , value ) ; } 
protected void processWindowEvent ( WindowEvent e ) { WindowListener listener = windowListener ; if ( listener != null ) { switch ( e . getID ( ) ) { case WindowEvent . WINDOW_OPENED : listener . windowOpened ( e ) ; break ; case WindowEvent . WINDOW_CLOSING : listener . windowClosing ( e ) ; break ; case WindowEvent . WINDOW_CLOSED : listener . windowClosed ( e ) ; break ; case WindowEvent . WINDOW_ICONIFIED : listener . windowIconified ( e ) ; break ; case WindowEvent . WINDOW_DEICONIFIED : listener . windowDeiconified ( e ) ; break ; case WindowEvent . WINDOW_ACTIVATED : listener . windowActivated ( e ) ; break ; case WindowEvent . WINDOW_DEACTIVATED : listener . windowDeactivated ( e ) ; break ; default : break ; } } } 
static Value cache ( Value v ) { if ( SysProperties . OBJECT_CACHE ) { int hash = v . hashCode ( ) ; if ( softCache == null ) { softCache = new SoftReference < Value [ ] > ( null ) ; } Value [ ] cache = softCache . get ( ) ; if ( cache == null ) { cache = new Value [ SysProperties . OBJECT_CACHE_SIZE ] ; softCache = new SoftReference < Value [ ] > ( cache ) ; } int index = hash & ( SysProperties . OBJECT_CACHE_SIZE - 1 ) ; Value cached = cache [ index ] ; if ( cached != null ) { if ( cached . getType ( ) == v . getType ( ) && v . equals ( cached ) ) { return cached ; } } cache [ index ] = v ; } return v ; } 
void jobCompleted ( JobInProgress job ) { String user = job . getProfile ( ) . getUser ( ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Job-to-be-removed-for-user-" + user ) ; } Integer i = numJobsByUser . get ( job . getProfile ( ) . getUser ( ) ) ; i -- ; if ( 0 == i . intValue ( ) ) { numJobsByUser . remove ( user ) ; mapSlots . numSlotsOccupiedByUser . remove ( user ) ; reduceSlots . numSlotsOccupiedByUser . remove ( user ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "No-more-jobs-for-user,-number-of-users-=-" + numJobsByUser . size ( ) ) ; } } else { numJobsByUser . put ( user , i ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "User-still-has-" + i + "-jobs,-number-of-users-=-" + numJobsByUser . size ( ) ) ; } } } 
public String getFieldSeparator ( ) { return Utils . backQuoteChars ( m_FieldSeparator ) ; } 
public List < PPCell > getPPCell ( ) { if ( ppCell == null ) { ppCell = new ArrayList < PPCell > ( ) ; } return this . ppCell ; } 
static public Properties loadPropertiesFile ( String aFilePath ) throws IOException { try { Properties properties = new Properties ( ) ; properties . load ( new FileInputStream ( aFilePath ) ) ; return properties ; } catch ( Throwable t ) { throw new IOException ( "failed-loading-Properties-file-from-" + aFilePath ) ; } } 
public static OffsetDateTime parse ( CharSequence text ) { return parse ( text , DateTimeFormatter . ISO_OFFSET_DATE_TIME ) ; } 
public String toSummaryString ( boolean printComplexityStatistics ) { return m_delegate . toSummaryString ( printComplexityStatistics ) ; } 
public int getNumberOfThreads ( ) { return threadMap . size ( ) ; } 
private void sendInterrupt ( ) { messageSent . V ( ) ; } 
public double getDouble ( double _default ) { try { return Double . parseDouble ( value ) ; } catch ( NumberFormatException e ) { return _default ; } } 
private void removeGroups ( JMeterVariables vars , String basename ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( basename ) ; buf . append ( "_g" ) ; int pfxlen = buf . length ( ) ; int groups ; try { groups = Integer . parseInt ( vars . get ( buf . toString ( ) ) ) ; } catch ( NumberFormatException e ) { groups = 0 ; } vars . remove ( buf . toString ( ) ) ; for ( int i = 0 ; i <= groups ; i ++ ) { buf . append ( i ) ; vars . remove ( buf . toString ( ) ) ; buf . setLength ( pfxlen ) ; } } 
public Set < String > getConditionallyHiddenPropertyNames ( BusinessObject businessObject ) { return new HashSet < String > ( ) ; } 
public void setAzimuth ( float a ) { float roll = q . taitBryanAngles ( ) . x ; q . fromTaitBryan ( roll , a , 0 ) ; computeCameraPosition ( ) ; } 
@ SuppressWarnings ( "rawtypes" ) private boolean isIntrospectionCandidate ( Class clazz ) { return ( COLLECTION_CLASS . isAssignableFrom ( clazz ) || Map . class . isAssignableFrom ( clazz ) ) ; } 
@ Override public List < Rule > match ( String namespaceURI , String pattern ) { List < Rule > matches = wrappedRules . match ( namespaceURI , pattern ) ; if ( matches == null || matches . isEmpty ( ) ) { return new ArrayList < Rule > ( defaultRules ) ; } return matches ; } 
private String [ ] diff_halfMatchI ( String longtext , String shorttext , int i ) { String seed = longtext . substring ( i , i + longtext . length ( ) / 4 ) ; int j = - 1 ; String best_common = "" ; String best_longtext_a = "" , best_longtext_b = "" ; String best_shorttext_a = "" , best_shorttext_b = "" ; while ( ( j = shorttext . indexOf ( seed , j + 1 ) ) != - 1 ) { int prefixLength = diff_commonPrefix ( longtext . substring ( i ) , shorttext . substring ( j ) ) ; int suffixLength = diff_commonSuffix ( longtext . substring ( 0 , i ) , shorttext . substring ( 0 , j ) ) ; if ( best_common . length ( ) < suffixLength + prefixLength ) { best_common = shorttext . substring ( j - suffixLength , j ) + shorttext . substring ( j , j + prefixLength ) ; best_longtext_a = longtext . substring ( 0 , i - suffixLength ) ; best_longtext_b = longtext . substring ( i + prefixLength ) ; best_shorttext_a = shorttext . substring ( 0 , j - suffixLength ) ; best_shorttext_b = shorttext . substring ( j + prefixLength ) ; } } if ( best_common . length ( ) >= longtext . length ( ) / 2 ) { return new String [ ] { best_longtext_a , best_longtext_b , best_shorttext_a , best_shorttext_b , best_common } ; } else { return null ; } } 
public void putIfNotNull ( String k , Object v ) { if ( v == null ) return ; if ( k == null ) return ; this . put ( k , v ) ; } 
public Long toLong ( ) { return new Long ( value ) ; } 
public static void disableConnectionReuseIfNecessary ( ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . FROYO ) { System . setProperty ( "http.keepAlive" , "false" ) ; } } 
public Object getObject ( ) throws IOException , ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream ( new ByteArrayInputStream ( content ) ) ; try { return ois . readObject ( ) ; } finally { ois . close ( ) ; } } 
synchronized public void removeCursor ( Cursor cursor ) { Preconditions . checkArgument ( cursor != null ) ; if ( thd == null ) { cursors . remove ( cursor ) ; } else { synchronized ( rmCursors ) { rmCursors . add ( cursor ) ; } } } 
public void setSeparatorColor ( int separatorColor ) { Field [ ] pickerFields = NumberPicker . class . getDeclaredFields ( ) ; for ( Field pf : pickerFields ) { if ( pf . getName ( ) . equals ( "mSelectionDivider" ) ) { pf . setAccessible ( true ) ; try { pf . set ( this , new ColorDrawable ( separatorColor ) ) ; } catch ( IllegalAccessException | IllegalArgumentException e ) { e . printStackTrace ( ) ; } break ; } } } 
public Object getPreviousValue ( ) { Calendar prevCal = Calendar . getInstance ( ) ; prevCal . setTime ( date . getTime ( ) ) ; prevCal . roll ( calendarField , false ) ; Date prevDate = prevCal . getTime ( ) ; if ( start != null ) if ( start . compareTo ( prevDate ) > 0 ) return null ; return prevDate ; } 
public static final TreeLogger getWriter ( String filename , Position pos ) { try { TreeLogger log = new TreeLogger ( ) ; log . os = new FileOutputStream ( filename ) ; log . bos = new BufferedOutputStream ( log . os , 65536 ) ; log . writeHeader ( pos ) ; log . nextIndex = 0 ; return log ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( ) ; } } 
public void push ( String string ) { buffer . insert ( 0 , string ) ; cachedHash = 0xdeadbeef ; } 
public List < String > interactions ( ) { List < String > out = super . interactions ( ) ; Location ml = location ( ) ; if ( ml instanceof Container && ( ( Container ) ml ) . owner ( ) instanceof Player ) { out . add ( "drink" ) ; } return out ; } 
public static void tigUpdatePassword ( String userId , String userPw ) throws SQLException { Connection conn = DriverManager . getConnection ( "jdbc:default:connection" ) ; conn . setTransactionIsolation ( Connection . TRANSACTION_READ_COMMITTED ) ; try { PreparedStatement ps = conn . prepareStatement ( "update-tig_users-set-user_pw-=-?-where-lower(user_id)-=-?" ) ; ps . setString ( 1 , userPw ) ; ps . setString ( 2 , userId . toLowerCase ( ) ) ; ps . executeUpdate ( ) ; } catch ( SQLException e ) { throw e ; } finally { conn . close ( ) ; } } 
public void removePropertyChangeListener ( String propertyName , PropertyChangeListener in_pcl ) { pcSupport . removePropertyChangeListener ( propertyName , in_pcl ) ; } 
private static boolean scanArgs ( String [ ] args , String value ) { if ( args != null ) { for ( String arg : args ) { if ( value . equals ( arg ) ) { return true ; } } } return false ; } 
public void addListener ( MotionPathListener listener ) { if ( listeners == null ) { listeners = new ArrayList < MotionPathListener > ( ) ; } listeners . add ( listener ) ; } 
public void add ( String fieldName , String value ) { if ( fieldName == null ) throw new IllegalArgumentException ( "fieldname-==-null" ) ; if ( value == null ) throw new IllegalArgumentException ( "value-==-null" ) ; if ( fieldName . length ( ) == 0 || fieldName . indexOf ( '|0' ) != - 1 || value . indexOf ( '|0' ) != - 1 ) { throw new IllegalArgumentException ( "Unexpected-header:-" + fieldName + ":-" + value ) ; } addLenient ( fieldName , value ) ; } 
public List < TransportHandlingUnitType > getReferencedTransportHandlingUnit ( ) { if ( referencedTransportHandlingUnit == null ) { referencedTransportHandlingUnit = new ArrayList < TransportHandlingUnitType > ( ) ; } return this . referencedTransportHandlingUnit ; } 
static boolean removeAllImpl ( Set < ? > set , Iterator < ? > iterator ) { boolean changed = false ; while ( iterator . hasNext ( ) ) { changed |= set . remove ( iterator . next ( ) ) ; } return changed ; } 
public void createGroupPad ( String groupID , String padName , String text ) { HashMap args = new HashMap ( ) ; args . put ( "groupID" , groupID ) ; args . put ( "padName" , padName ) ; args . put ( "text" , text ) ; this . connection . post ( "createGroupPad" , args ) ; } 
protected void resetChildrenPaths ( TreePath parentPath ) { removeMapping ( this ) ; if ( parentPath == null ) path = new TreePath ( getUserObject ( ) ) ; else path = parentPath . pathByAddingChild ( getUserObject ( ) ) ; addMapping ( this ) ; for ( int counter = getChildCount ( ) - 1 ; counter >= 0 ; counter -- ) ( ( FHTreeStateNode ) getChildAt ( counter ) ) . resetChildrenPaths ( path ) ; } 
public Param createParam ( ) { final Param p = new Param ( ) ; params . add ( p ) ; return p ; } 
public List < RecordInfo > getRecordInfo ( ) { if ( recordInfo == null ) { recordInfo = new ArrayList < RecordInfo > ( ) ; } return this . recordInfo ; } 
public double interceptStdErr ( ) { return Math . sqrt ( svar0 ) ; } 
public Control getControl ( String type ) { Class cls ; try { cls = Class . forName ( type ) ; } catch ( ClassNotFoundException e ) { return null ; } Control cs [ ] = getControls ( ) ; for ( int i = 0 ; i < cs . length ; i ++ ) { if ( cls . isInstance ( cs [ i ] ) ) return cs [ i ] ; } return null ; } 
private int localizedWeekOfWeekBasedYear ( TemporalAccessor temporal ) { int dow = localizedDayOfWeek ( temporal ) ; int doy = temporal . get ( DAY_OF_YEAR ) ; int offset = startOfWeekOffset ( doy , dow ) ; int week = computeWeek ( offset , doy ) ; if ( week == 0 ) { ChronoLocalDate date = Chronology . from ( temporal ) . date ( temporal ) ; date = date . minus ( doy , DAYS ) ; return localizedWeekOfWeekBasedYear ( date ) ; } else if ( week > 50 ) { ValueRange dayRange = temporal . range ( DAY_OF_YEAR ) ; int yearLen = ( int ) dayRange . getMaximum ( ) ; int newYearWeek = computeWeek ( offset , yearLen + weekDef . getMinimalDaysInFirstWeek ( ) ) ; if ( week >= newYearWeek ) { week = week - newYearWeek + 1 ; } } return week ; } 
public void draw ( ) { Canvas . getInstance ( ) . show ( this ) ; } 
public void updateCircle ( int delta , Character self ) { if ( super . isPowerOn ) { power . setCenterX ( self . getPositionX ( ) + 50 ) ; power . setCenterY ( self . getPositionY ( ) + 40 ) ; timer += delta ; if ( powerRadius >= 1 && timer >= 500 ) { powerRadius -= 10 ; timer = 0 ; } power . setRadius ( powerRadius ) ; } else { reset ( ) ; } } 
public void apply2XX ( float [ ] [ ] [ ] x , float [ ] [ ] [ ] y ) { _filter . applyNXX ( 2 , x , y ) ; } 
public static void deleteFileOrDir ( File file ) { if ( file != null && file . exists ( ) ) { if ( file . isFile ( ) ) { file . delete ( ) ; } else { deleteDir ( file ) ; } } } 
public String getRequestProperty ( String field ) { checkNotConnected ( ) ; return null ; } 
public static boolean evalTagForLoop ( Node node ) { NodeList childList = node . getChildNodes ( ) ; for ( int i = 0 ; i < childList . getLength ( ) ; i ++ ) if ( childList . item ( i ) . getNodeName ( ) . equals ( "loop" ) ) return true ; return false ; } 
public void addVetoableChangeListener ( String name , VetoableChangeListener vcl ) { vcSupport . addVetoableChangeListener ( name , vcl ) ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public Rectangle getNodeBounds ( Rectangle placeIn ) { if ( placeIn == null ) placeIn = new Rectangle ( getXOrigin ( ) , getYOrigin ( ) , getPreferredWidth ( ) , getPreferredHeight ( ) ) ; else { placeIn . x = getXOrigin ( ) ; placeIn . y = getYOrigin ( ) ; placeIn . width = getPreferredWidth ( ) ; placeIn . height = getPreferredHeight ( ) ; } return placeIn ; } 
public void persist ( Connection connection ) throws SQLException { PreparedStatement statement = connection . prepareStatement ( "INSERT-INTO-ModelAttributes-(modelName)-VALUES-(?);" ) ; statement . setString ( 1 , this . name ) ; statement . executeUpdate ( ) ; statement . close ( ) ; for ( int i = 0 ; i < this . attributes . size ( ) ; i ++ ) { this . attributes . get ( i ) . persist ( connection ) ; statement = connection . prepareStatement ( "INSERT-INTO-AttributeToModelAttributes-(attributeId,-modelAttributesName)-VALUES-(?,-?);" ) ; statement . setInt ( 1 , this . attributes . get ( i ) . getId ( ) ) ; statement . setString ( 2 , this . name ) ; statement . executeUpdate ( ) ; statement . close ( ) ; } } 
public final int read ( byte ba [ ] ) throws IOException { return raf . read ( ba ) ; } 
public String getName ( ) { return OID_NAME_TABLE . get ( PKCS9_OIDS [ index ] ) ; } 
@ Override public void onClear ( Notification notification ) { notification . clear ( ) ; } 
public long getTimeInMillis ( final Date startInstant ) { Calendar cal = new GregorianCalendar ( ) ; cal . setTime ( startInstant ) ; this . addTo ( cal ) ; return getCalendarTimeInMillis ( cal ) - startInstant . getTime ( ) ; } 
public void setArgValues ( IRubyObject [ ] values , int size ) { System . arraycopy ( values , 0 , variableValues , 2 , size ) ; } 
public XSSimpleTypeDecl newXSSimpleTypeDecl ( ) { return new XSSimpleTypeDecl ( ) ; } 
private String getDescriptionForShiftKey ( Context context , Keyboard keyboard ) { final KeyboardId keyboardId = keyboard . mId ; final int elementId = keyboardId . mElementId ; final int resId ; switch ( elementId ) { case KeyboardId . ELEMENT_ALPHABET_SHIFT_LOCK_SHIFTED : case KeyboardId . ELEMENT_ALPHABET_SHIFT_LOCKED : resId = R . string . spoken_description_caps_lock ; break ; case KeyboardId . ELEMENT_ALPHABET_AUTOMATIC_SHIFTED : case KeyboardId . ELEMENT_ALPHABET_MANUAL_SHIFTED : case KeyboardId . ELEMENT_SYMBOLS_SHIFTED : resId = R . string . spoken_description_shift_shifted ; break ; default : resId = R . string . spoken_description_shift ; } return context . getString ( resId ) ; } 
public static Type < FormSubmitFailedHandler > getType ( ) { if ( TYPE == null ) { TYPE = new Type < FormSubmitFailedHandler > ( ) ; } return TYPE ; } 
public Collection < String > getRelatedServiceDocumentsTitles ( ) { return relatedServiceDocuments . keySet ( ) ; } 
protected void hasProperty ( Properties properties , String name ) { if ( properties . getProperty ( name ) == null ) throw new IllegalArgumentException ( "McastService:Required-property-"" + name + ""-is-missing." ) ; } 
public DTMAxisIterator cloneIterator ( ) { _isRestartable = false ; try { final PrecedingIterator clone = ( PrecedingIterator ) super . clone ( ) ; final int [ ] stackCopy = new int [ _stack . length ] ; System . arraycopy ( _stack , 0 , stackCopy , 0 , _stack . length ) ; clone . _stack = stackCopy ; return clone ; } catch ( CloneNotSupportedException e ) { throw new DTMException ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_ITERATOR_CLONE_NOT_SUPPORTED , null ) ) ; } } 
public FixedsizePriorityQueue ( Comparator comparator , int capacity ) throws IllegalArgumentException { this . comparator = comparator ; if ( capacity <= 0 ) throw new IllegalArgumentException ( ) ; tree = new TreeSet ( ) ; this . capacity = capacity ; } 
public static List < String > split ( String s , char delimiter , boolean trim ) { if ( s == null ) { return new ArrayList < String > ( ) ; } List < String > list = new ArrayList < String > ( ) ; StringBuilder token = new StringBuilder ( ) ; int begin = 0 ; boolean inEscape = false ; while ( begin < s . length ( ) ) { char c = s . charAt ( begin ) ; if ( inEscape ) { if ( c != delimiter && c != LIST_ESC_CHAR ) { token . append ( LIST_ESC_CHAR ) ; } token . append ( c ) ; inEscape = false ; } else { if ( c == delimiter ) { String t = token . toString ( ) ; if ( trim ) { t = t . trim ( ) ; } list . add ( t ) ; token = new StringBuilder ( ) ; } else if ( c == LIST_ESC_CHAR ) { inEscape = true ; } else { token . append ( c ) ; } } begin ++ ; } if ( inEscape ) { token . append ( LIST_ESC_CHAR ) ; } String t = token . toString ( ) ; if ( trim ) { t = t . trim ( ) ; } list . add ( t ) ; return list ; } 
public final double errorEstimate ( ) { calculate ( ) ; QL . require ( ! Double . isNaN ( this . errorEstimate ) , "error-estimate-not-provided" ) ; return errorEstimate ; } 
public static double getFlatness ( double x1 , double y1 , double cx1 , double cy1 , double cx2 , double cy2 , double x2 , double y2 ) { return Math . sqrt ( getFlatnessSq ( x1 , y1 , cx1 , cy1 , cx2 , cy2 , x2 , y2 ) ) ; } 
protected boolean inClosedList ( Node node ) { return closed . contains ( node ) ; } 
public static String toHexString ( int i ) { return toUnsignedString ( i , 4 ) ; } 
public BasicDocument < L > init ( URL textURL ) throws FileNotFoundException , IOException { return init ( textURL , textURL . toExternalForm ( ) , true ) ; } 
@ Override public void zoomRange ( double lowerPercent , double upperPercent ) { double startLog = switchedLog10 ( getRange ( ) . getLowerBound ( ) ) ; double lengthLog = switchedLog10 ( getRange ( ) . getUpperBound ( ) ) - startLog ; Range adjusted ; if ( isInverted ( ) ) { adjusted = new Range ( switchedPow10 ( startLog + ( lengthLog * ( 1 - upperPercent ) ) ) , switchedPow10 ( startLog + ( lengthLog * ( 1 - lowerPercent ) ) ) ) ; } else { adjusted = new Range ( switchedPow10 ( startLog + ( lengthLog * lowerPercent ) ) , switchedPow10 ( startLog + ( lengthLog * upperPercent ) ) ) ; } setRange ( adjusted ) ; } 
public String formatMessage ( LogRecord r ) { String pattern = r . getMessage ( ) ; ResourceBundle rb = null ; if ( ( rb = r . getResourceBundle ( ) ) != null ) { try { pattern = rb . getString ( pattern ) ; } catch ( Exception e ) { pattern = r . getMessage ( ) ; } } if ( pattern != null ) { Object [ ] params = r . getParameters ( ) ; if ( pattern . indexOf ( "{0" ) >= 0 && params != null && params . length > 0 ) { try { pattern = MessageFormat . format ( pattern , params ) ; } catch ( IllegalArgumentException e ) { pattern = r . getMessage ( ) ; } } } return pattern ; } 
public boolean setComment ( final String cmt ) { boolean success = false ; if ( cmt != null && cmt . length ( ) > 0 ) { COMMENT = cmt ; success = true ; } return success ; } 
protected int _exptype ( int identity ) { if ( identity == DTM . NULL ) return NULL ; while ( identity >= m_size ) { if ( ! nextNode ( ) && identity >= m_size ) return NULL ; } return m_exptype . elementAt ( identity ) ; } 
public static Object [ ] sort ( Object [ ] array , boolean decreasing ) throws NotComparableException { Class ct = array . getClass ( ) . getComponentType ( ) ; if ( Comparable . class . isAssignableFrom ( ct ) ) { throw new NotComparableException ( ct ) ; } int n = array . length ; Object [ ] res = copy ( array ) ; Arrays . sort ( res ) ; if ( ! decreasing ) { return res ; } else { Object current ; int top = ( res . length ) / 2 ; for ( int i = 0 ; i < top ; i ++ ) { current = res [ i ] ; res [ i ] = res [ n - i - 1 ] ; res [ n - i - 1 ] = current ; } } return res ; } 
@ XmlElementDecl ( namespace = "http://www.xbrl.org/tw/fr/gaap/tw-gaap-fh-2010-03-31" , name = "OtherNonInterestIncomesLosses-ProvisionDefaultLossReserveAbstract" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < StringItemType > createOtherNonInterestIncomesLossesProvisionDefaultLossReserveAbstract ( StringItemType value ) { return new JAXBElement < StringItemType > ( _OtherNonInterestIncomesLossesProvisionDefaultLossReserveAbstract_QNAME , StringItemType . class , null , value ) ; } 
public String popAndEncode ( boolean fromOnlineEvent ) { synchronized ( this ) { if ( activeBridgeMode == null ) { return null ; } activeBridgeMode . notifyOfFlush ( fromOnlineEvent ) ; if ( queue . isEmpty ( ) ) { return null ; } int totalPayloadLen = 0 ; int numMessagesToSend = 0 ; for ( JsMessage message : queue ) { int messageSize = calculatePackedMessageLength ( message ) ; if ( numMessagesToSend > 0 && totalPayloadLen + messageSize > MAX_PAYLOAD_SIZE && MAX_PAYLOAD_SIZE > 0 ) { break ; } totalPayloadLen += messageSize ; numMessagesToSend += 1 ; } StringBuilder sb = new StringBuilder ( totalPayloadLen ) ; for ( int i = 0 ; i < numMessagesToSend ; ++ i ) { JsMessage message = queue . removeFirst ( ) ; packMessage ( message , sb ) ; } if ( ! queue . isEmpty ( ) ) { sb . append ( '*' ) ; } String ret = sb . toString ( ) ; return ret ; } } 
public static boolean decodeToFile ( String dataToDecode , String filename ) { boolean success = false ; RhBase64 . OutputStream bos = null ; try { bos = new RhBase64 . OutputStream ( new java . io . FileOutputStream ( filename ) , RhBase64 . DECODE ) ; bos . write ( dataToDecode . getBytes ( PREFERRED_ENCODING ) ) ; success = true ; } catch ( java . io . IOException e ) { success = false ; } finally { try { bos . close ( ) ; } catch ( Exception e ) { } } return success ; } 
public String getRawText ( ) { StringBuilder buf = new StringBuilder ( ) ; if ( meText != null ) { buf . append ( meText ) ; } for ( int i = 0 ; i < tokens . size ( ) ; ++ i ) { buf . append ( tokens . get ( i ) . getRawText ( ) ) ; } return buf . toString ( ) ; } 
public static org . openrtk . idl . epp0503 . contact . epp_ContactStatusType from_int ( int value ) { if ( value >= 0 && value < __size ) return __array [ value ] ; else throw new org . omg . CORBA . BAD_PARAM ( ) ; } 
public static long decodeLongBase64 ( final String str ) { if ( str . length ( ) < 11 ) { throw new IllegalArgumentException ( "string-is-less-than-11-characters" ) ; } long v = 0 ; int bit = - 2 ; for ( int i = 0 ; i < 11 ; ++ i ) { byte b = ( byte ) str . charAt ( i ) ; long val = LEXI_BASE64_DECODABET [ b ] ; if ( val < 0 ) { throw new IllegalArgumentException ( "Invalid-character" ) ; } v |= val << ( 58 - bit ) ; bit += 6 ; } return v ; } 
public int getPort ( ) { if ( bind == null ) { return - 1 ; } String [ ] split = bind . split ( "|:" ) ; if ( split . length != 2 ) { throw new IllegalArgumentException ( "invalid-bind-format-(should-be-IP:port)" ) ; } return Integer . parseInt ( split [ 1 ] ) ; } 
@ XmlElementDecl ( namespace = "http://www.i2b2.org/xsd/cell/ont/1.1/" , name = "update_concept_totalnum" ) public JAXBElement < UpdateConceptTotalNumType > createUpdateConceptTotalnum ( UpdateConceptTotalNumType value ) { return new JAXBElement < UpdateConceptTotalNumType > ( _UpdateConceptTotalnum_QNAME , UpdateConceptTotalNumType . class , null , value ) ; } 
public String getTeller ( int n ) { if ( ( n < 0 ) || ( n >= tellers . size ( ) ) ) return null ; return ( String ) tellers . elementAt ( n ) ; } 
public Right [ ] getRights ( ) { Vector v = new Vector ( ) ; for ( int i = 0 ; i < this . rights . length ; i ++ ) if ( this . rights [ i ] ) v . addElement ( Right . getInstance ( ( char ) i ) ) ; Right [ ] rights = new Right [ v . size ( ) ] ; v . copyInto ( rights ) ; return rights ; } 
public Boolean getSymmetricEdges ( ) { return getAttributeAsBoolean ( "symmetricEdges" ) ; } 
public static Character [ ] toObject ( final char [ ] array ) { if ( array == null ) { return null ; } else if ( array . length == 0 ) { return EMPTY_CHARACTER_OBJECT_ARRAY ; } final Character [ ] result = new Character [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { result [ i ] = Character . valueOf ( array [ i ] ) ; } return result ; } 
public String [ ] findMimeMappings ( ) { synchronized ( mimeMappings ) { String results [ ] = new String [ mimeMappings . size ( ) ] ; return ( ( String [ ] ) mimeMappings . keySet ( ) . toArray ( results ) ) ; } } 
public QName getPrefixedQName ( NamespacePrefixResolver resolver ) { Collection < String > prefixes = resolver . getPrefixes ( namespaceURI ) ; if ( prefixes . size ( ) == 0 ) { throw new NamespaceException ( "A-namespace-prefix-is-not-registered-for-uri-" + namespaceURI ) ; } String resolvedPrefix = prefixes . iterator ( ) . next ( ) ; if ( prefix != null && prefix . equals ( resolvedPrefix ) ) { return this ; } return new QName ( namespaceURI , localName , resolvedPrefix ) ; } 
@ Override public String [ ] getOptions ( ) { Vector < String > result = new Vector < String > ( ) ; result . add ( "-C" ) ; result . add ( "" + getCacheSize ( ) ) ; Collections . addAll ( result , super . getOptions ( ) ) ; return result . toArray ( new String [ result . size ( ) ] ) ; } 
public static List seriesNameListFromDataArray ( Object [ ] [ ] data ) { int seriesCount = data . length ; List seriesNameList = new java . util . ArrayList ( seriesCount ) ; for ( int i = 0 ; i < seriesCount ; i ++ ) { seriesNameList . add ( "Series-" + ( i + 1 ) ) ; } return seriesNameList ; } 
public static int getEntityID ( Entity par0Entity ) { Class oclass = par0Entity . getClass ( ) ; return classToIDMapping . containsKey ( oclass ) ? ( ( Integer ) classToIDMapping . get ( oclass ) ) . intValue ( ) : 0 ; } 
public void startElement ( String elementNamespaceURI , String elementLocalName , String elementName ) throws SAXException { startElement ( elementNamespaceURI , elementLocalName , elementName , null ) ; } 
public void loadSFLResult ( ) { String result = "" , result2 = "" ; try { FileInputStream fstream = new FileInputStream ( fileSFLResult ) ; DataInputStream in = new DataInputStream ( fstream ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; String strLine = "" ; String [ ] x ; int s = 0 ; while ( ( strLine = br . readLine ( ) ) != null ) { x = strLine . split ( "-" ) ; for ( int i = 0 ; i < x . length ; i ++ ) { sfl . add ( Integer . parseInt ( x [ i ] ) ) ; } } in . close ( ) ; } catch ( Exception e ) { System . err . println ( "Error:-" + e ) ; } } 
private JLabel createEmptyMessage ( ) { JLabel message = new JLabel ( "No-score-entries-to-show." ) ; message . setAlignmentX ( Component . CENTER_ALIGNMENT ) ; return message ; } 
@ SuppressWarnings ( "unchecked" ) protected void bcsPreDeserializationHook ( ObjectInputStream ois ) throws IOException , ClassNotFoundException { super . bcsPreDeserializationHook ( ois ) ; synchronized ( services ) { serializable = ois . readInt ( ) ; for ( int i = 0 ; i < serializable ; i ++ ) { Object serviceClass = ois . readObject ( ) ; Object bcssProvider = ois . readObject ( ) ; services . put ( ( Class ) serviceClass , ( BCSSServiceProvider ) bcssProvider ) ; } } } 
public static Configuration createConfigurationFromConfDir ( String confDir ) { Configuration conf = new Configuration ( ) ; conf . addResource ( new Path ( confDir + "/core-site.xml" ) ) ; conf . addResource ( new Path ( confDir + "/mapred-site.xml" ) ) ; conf . addResource ( new Path ( confDir + "/hdfs-site.xml" ) ) ; conf . addResource ( new Path ( confDir + "/yarn-site.xml" ) ) ; System . out . println ( "Add-resource:-" + confDir + "/yarn-site.xml" ) ; return conf ; } 
public List < Double > getViewportRatio ( ) { if ( viewportRatio == null ) { viewportRatio = new ArrayList < Double > ( ) ; } return this . viewportRatio ; } 
private float getFloatParameter ( final String param ) { final Float p = ( Float ) getParameter ( param ) ; if ( p == null ) { return 0 ; } return p . floatValue ( ) ; } 
public static boolean stringable ( String name ) { try { Class realDataType = ( Class ) TypeMapping . mapWOXToJava . get ( name ) ; if ( realDataType != null ) { return true ; } else { return false ; } } catch ( Exception e ) { return false ; } } 
public static String comboInput ( String message , String title , String [ ] choices ) { String temp = "" ; if ( choices == null || choices [ 0 ] == null ) return "" ; temp = ( String ) JOptionPane . showInputDialog ( null , message , title , JOptionPane . QUESTION_MESSAGE , null , choices , choices [ 0 ] ) ; if ( temp == null ) return "" ; return temp ; } 
public int next ( ) { ServerSocket serverSocket = null ; while ( ++ currPort < portEnd ) { try { serverSocket = new ServerSocket ( currPort ) ; serverSocket . close ( ) ; serverSocket = new ServerSocket ( ) ; InetSocketAddress sa = new InetSocketAddress ( hostname , currPort ) ; serverSocket . bind ( sa ) ; serverSocket . close ( ) ; return currPort ; } catch ( IOException e ) { continue ; } } throw new IllegalStateException ( "No-more-ports-avaliable-in-the-range:-" + portStart + "---" + portEnd ) ; } 
public void setCookieStore ( CookieStore cookieStore ) { httpContext . setAttribute ( ClientContext . COOKIE_STORE , cookieStore ) ; } 
public Bundle putByteArray ( String key , byte [ ] value ) { _map . put ( key , value ) ; return this ; } 
static String getContentTypeEncoding ( String httpContentType ) { String encoding = null ; if ( httpContentType != null ) { int i = httpContentType . indexOf ( ";" ) ; if ( i > - 1 ) { String postMime = httpContentType . substring ( i + 1 ) ; Matcher m = CHARSET_PATTERN . matcher ( postMime ) ; encoding = m . find ( ) ? m . group ( 1 ) : null ; encoding = encoding != null ? encoding . toUpperCase ( Locale . US ) : null ; } } return encoding ; } 
public final void drawImage ( final Image image , final Bounds bounds ) { drawImage ( image , bounds . x , bounds . y , bounds . x2 ( ) , bounds . y2 ( ) ) ; } 
private void showArrow ( final int whichArrow , final int requestedX ) { final View showArrow = ( whichArrow == R . id . arrow_up ) ? mArrowUp : mArrowDown ; final View hideArrow = ( whichArrow == R . id . arrow_up ) ? mArrowDown : mArrowUp ; final int arrowWidth = mArrowUp . getMeasuredWidth ( ) ; showArrow . setVisibility ( View . VISIBLE ) ; ViewGroup . MarginLayoutParams param = ( ViewGroup . MarginLayoutParams ) showArrow . getLayoutParams ( ) ; param . leftMargin = requestedX - ( arrowWidth / 2 ) ; hideArrow . setVisibility ( View . INVISIBLE ) ; } 
@ Override public boolean equals ( Object obj ) { if ( ! ( obj instanceof Area ) ) { return false ; } Area a = ( Area ) obj ; if ( rect == null ) { if ( a . rect != null ) return false ; } else { if ( ! rect . equals ( a . rect ) ) return false ; } return weight == a . weight ; } 
public static char nextKeyTyped ( ) { synchronized ( keyLock ) { return keysTyped . removeLast ( ) ; } } 
public static int decode ( String data , OutputStream out ) throws IOException { return encoder . decode ( data , out ) ; } 
public boolean isPdfACompliant ( ) { return _content . size ( ) <= 8191 ; } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || this . getClass ( ) != o . getClass ( ) ) { return false ; } return Arrays . equals ( oid , ( ( ObjectIdentifier ) o ) . oid ) ; } 
public void mouseReleased ( MouseEvent evt ) { if ( evt . isPopupTrigger ( ) ) { createPopup ( evt . getPoint ( ) ) ; } } 
public static String convertMacAddressToString ( byte [ ] macAddress ) { return String . format ( "%02x:%02x:%02x:%02x:%02x:%02x" , macAddress [ 0 ] , macAddress [ 1 ] , macAddress [ 2 ] , macAddress [ 3 ] , macAddress [ 4 ] , macAddress [ 5 ] ) ; } 
private void lookupRingtoneName ( ) { new Thread ( mRingtoneLookupRunnable ) . start ( ) ; } 
public boolean isNumberAllowed ( int candidate ) { if ( availableNumbers . isEmpty ( ) ) { throw new IllegalStateException ( "Allowed-Numbers-has-not-been-filled-out-yet" ) ; } else if ( candidate == 0 ) { throw new IllegalArgumentException ( "0-should-not-be-tested-(Field-" + row + ",-" + column + ")" ) ; } return availableNumbers . contains ( candidate ) ; } 
@ Override public String toString ( ) { StringBuffer text = new StringBuffer ( ) ; if ( m_trainInstances == null ) { text . append ( "ReliefF-feature-evaluator-has-not-been-built-yet-" ) ; } else { text . append ( "-ReliefF-Ranking-Filter" ) ; text . append ( "-Instances-sampled:-" ) ; if ( m_sampleM == - 1 ) { text . append ( "all-" ) ; } else { text . append ( m_sampleM + "-" ) ; } text . append ( "-Number-of-nearest-neighbours-(k):-" + m_Knn + "-" ) ; if ( m_weightByDistance ) { text . append ( "-Exponentially-decreasing-(with-distance)-" + "influence-for-" + "-nearest-neighbours.-Sigma:-" + m_sigma + "-" ) ; } else { text . append ( "-Equal-influence-nearest-neighbours-" ) ; } } return text . toString ( ) ; } 
private boolean isCommand ( String response ) { return response . startsWith ( "5910" ) && response . substring ( 8 , 12 ) . equalsIgnoreCase ( "ffff" ) && response . substring ( 16 , 24 ) . equalsIgnoreCase ( "ffffffff" ) ; } 
public void addAll ( ASN1EncodableVector other ) { for ( Enumeration en = other . v . elements ( ) ; en . hasMoreElements ( ) ; ) { v . addElement ( en . nextElement ( ) ) ; } } 
public static Double toDoubleObject ( Object obj ) { if ( obj == null ) { return null ; } if ( obj instanceof Double ) { return ( Double ) obj ; } if ( obj instanceof Number ) { return new Double ( ( ( Number ) obj ) . doubleValue ( ) ) ; } Double result = null ; try { result = Double . parseDouble ( obj . toString ( ) ) ; } catch ( Exception e ) { } return result ; } 
public static Request deleteAppData ( String [ ] keys ) { List < String > keyList = new ArrayList < String > ( keys . length ) ; for ( int i = 0 ; i < keys . length ; i ++ ) { keyList . add ( keys [ i ] ) ; } return deleteAppData ( keyList ) ; } 
public static boolean isNotEmpty ( CharSequence string ) { return string != null && string . length ( ) > 0 ; } 
public final boolean containsResource ( String resourceName ) { return resources . containsKey ( resourceName ) ; } 
public synchronized void close ( ) throws IOException { if ( journalWriter == null ) { return ; } for ( Entry entry : new ArrayList < Entry > ( lruEntries . values ( ) ) ) { if ( entry . currentEditor != null ) { entry . currentEditor . abort ( ) ; } } trimToSize ( ) ; journalWriter . close ( ) ; journalWriter = null ; } 
@ XmlElementDecl ( namespace = "http://www.sdltridion.com/ContentManager/R6" , name = "LinkToMultimediaTypeData" ) public JAXBElement < LinkToMultimediaTypeData > createLinkToMultimediaTypeData ( LinkToMultimediaTypeData value ) { return new JAXBElement < LinkToMultimediaTypeData > ( _LinkToMultimediaTypeData_QNAME , LinkToMultimediaTypeData . class , null , value ) ; } 
protected Parser createParser ( File source ) { if ( source != null ) { String sourceName = source . getName ( ) ; int lastDot = sourceName . lastIndexOf ( '.' ) ; if ( lastDot >= 0 && lastDot + 1 < sourceName . length ( ) ) { char afterDot = sourceName . charAt ( lastDot + 1 ) ; if ( afterDot == 'f' || afterDot == 'F' ) { return new FortranParser ( ) ; } } } return new CParser ( ) ; } 
protected String getClientID ( ) { return Activator . getClientID ( ) ; } 
public static Collection < String > stringToCollection ( String string ) { if ( string == null || string . trim ( ) . length ( ) == 0 ) { return Collections . emptyList ( ) ; } Collection < String > collection = new ArrayList < String > ( ) ; StringTokenizer tokens = new StringTokenizer ( string , "," ) ; while ( tokens . hasMoreTokens ( ) ) { collection . add ( tokens . nextToken ( ) . trim ( ) ) ; } return collection ; } 
@ Override public boolean validateArguments ( String modeName , ParameterBlock args , StringBuffer message ) { if ( ! super . validateArguments ( modeName , args , message ) ) { return false ; } if ( ! modeName . equalsIgnoreCase ( "rendered" ) ) { return true ; } RenderedImage src = args . getRenderedSource ( 0 ) ; int dtype = src . getSampleModel ( ) . getDataType ( ) ; if ( dtype != DataBuffer . TYPE_USHORT ) { return false ; } return true ; } 
@ Override public boolean contains ( Object key ) { return keyToEntry . containsKey ( key ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public final void removeUser ( UserAccount userAcc ) { for ( int i = 0 ; i < m_users . size ( ) ; i ++ ) { UserAccount acc = m_users . get ( i ) ; if ( acc . getUserName ( ) . compareTo ( userAcc . getUserName ( ) ) == 0 ) { m_users . removeElementAt ( i ) ; return ; } } } 
public int callGet_Original ( Object instance , int a , long b ) throws Exception { Method m = instance . getClass ( ) . getMethod ( "get_Original" , new Class < ? > [ ] { int . class , long . class } ) ; Object result = m . invoke ( instance , new Object [ ] { a , b } ) ; return ( ( Integer ) result ) . intValue ( ) ; } 
@ Override public void startBody ( ) { Body body = RenderableTagFactory . createBody ( ) ; tags . peek ( ) . add ( body ) ; tags . push ( body ) ; } 
public String getExtendedHeaders ( ) { if ( mExtendedHeader != null ) { return mExtendedHeader . writeToString ( ) ; } return null ; } 
public static void closeQuietly ( DataSource dataSource ) { try { dataSource . close ( ) ; } catch ( IOException e ) { } } 
public static < T > Collection < T > misleadingSizeCollection ( final int delta ) { return new ArrayList < T > ( ) { @ Override public int size ( ) { return Math . max ( 0 , super . size ( ) + delta ) ; } } ; } 
static Class < ? extends Partitioner > getJavaPartitioner ( JobConf conf ) { return conf . getClass ( "hadoop.pipes.partitioner" , HashPartitioner . class , Partitioner . class ) ; } 
public Component bugSummaryComponent ( String str , BugInstance bug ) { JLabel label = new JLabel ( ) ; label . setFont ( label . getFont ( ) . deriveFont ( Driver . getFontSize ( ) ) ) ; label . setFont ( label . getFont ( ) . deriveFont ( Font . PLAIN ) ) ; label . setForeground ( Color . BLACK ) ; label . setText ( str ) ; SourceLineAnnotation link = bug . getPrimarySourceLineAnnotation ( ) ; if ( link != null ) { label . addMouseListener ( new BugSummaryMouseListener ( bug , label , link ) ) ; } return label ; } 
public void moveToBack ( ) { if ( getParent ( ) != null && getParent ( ) instanceof JLayeredPane ) ( ( JLayeredPane ) getParent ( ) ) . moveToBack ( this ) ; } 
public void addCIDMapping ( int src , String dest ) throws IOException { cid2charMappings . put ( src , dest ) ; char2CIDMappings . put ( dest , src ) ; } 
public static void _main ( String argv [ ] ) { System . out . println ( getVersion ( ) ) ; } 
public void addContextHandlerSetting ( String ctxPath , NameValuePair keyValue ) { Set < NameValuePair > settings = contextHandlerSettings . get ( ctxPath ) ; if ( settings == null ) settings = new HashSet < NameValuePair > ( ) ; settings . remove ( keyValue ) ; settings . add ( keyValue ) ; contextHandlerSettings . put ( ctxPath , settings ) ; } 
public void note ( DiagnosticPosition pos , String key , Object ... args ) { report ( diags . note ( source , pos , key , args ) ) ; } 
public void addOnTouchModeChangeListener ( OnTouchModeChangeListener listener ) { checkIsAlive ( ) ; if ( mOnTouchModeChangeListeners == null ) { mOnTouchModeChangeListeners = new CopyOnWriteArrayList < OnTouchModeChangeListener > ( ) ; } mOnTouchModeChangeListeners . add ( listener ) ; } 
public void setChildren ( List < Tree < T >> children ) { children = new ArrayList < Tree < T >> ( ) ; for ( Tree < T > child : children ) addChild ( child ) ; } 
private BufferInfo getBufferInfo ( Container root ) { for ( int counter = bufferInfos . size ( ) - 1 ; counter >= 0 ; counter -- ) { BufferInfo bufferInfo = bufferInfos . get ( counter ) ; Container biRoot = bufferInfo . getRoot ( ) ; if ( biRoot == null ) { bufferInfos . remove ( counter ) ; if ( LOGGER . isLoggable ( PlatformLogger . FINER ) ) { LOGGER . finer ( "BufferInfo-pruned,-root-null" ) ; } } else if ( biRoot == root ) { return bufferInfo ; } } return null ; } 
@ SuppressWarnings ( "unchecked" ) public List < String > getFields ( ) { Object [ ] o = listModel . toArray ( ) ; return ( List ) java . util . Arrays . asList ( o ) ; } 
private static List < Variable > collectVariables ( ) { List < Variable > variables = new ArrayList < Variable > ( ) ; variables . add ( NSW ) ; variables . add ( WA ) ; variables . add ( NT ) ; variables . add ( Q ) ; variables . add ( SA ) ; variables . add ( V ) ; variables . add ( T ) ; return variables ; } 
public Builder setDescrBytes ( com . google . protobuf . ByteString value ) { if ( value == null ) { throw new NullPointerException ( ) ; } bitField0_ |= 0x00000002 ; descr_ = value ; onChanged ( ) ; return this ; } 
protected Node parentNode ( Node n ) { if ( n == root ) { return null ; } Node result = n ; for ( ; ; ) { result = result . getParentNode ( ) ; if ( result == null ) { return null ; } if ( ( whatToShow & ( 1 << result . getNodeType ( ) - 1 ) ) != 0 ) { if ( filter == null || filter . acceptNode ( result ) == NodeFilter . FILTER_ACCEPT ) { return result ; } } } } 
private boolean checkUser ( String userID , X509Certificate cert ) { Set < BigInteger > numSet = certsMap . get ( userID ) ; if ( numSet == null ) { LOG . info ( "User-" + userID + "-is-not-configured-in-the-user-certs-file" ) ; return false ; } if ( ! numSet . contains ( cert . getSerialNumber ( ) ) ) { LOG . info ( "Cert-with-serial-number-" + cert . getSerialNumber ( ) + "-is-not-listed-for-user-" + userID ) ; return false ; } return true ; } 
private InetSocketAddress nextInetSocketAddress ( ) throws UnknownHostException { InetSocketAddress result = new InetSocketAddress ( socketAddresses [ nextSocketAddressIndex ++ ] , socketPort ) ; if ( nextSocketAddressIndex == socketAddresses . length ) { socketAddresses = null ; nextSocketAddressIndex = 0 ; } return result ; } 
@ Override public final void start ( int options ) throws Exception { final ReentrantLock lock = m_lock ; lock . lock ( ) ; try { m_state . start ( this , options ) ; } finally { lock . unlock ( ) ; } } 
public Duration multiply ( int factor ) { return multiply ( BigDecimal . valueOf ( factor ) ) ; } 
static public int parseHex ( String theHex ) { int myLen = theHex . length ( ) ; int a , r , b , g ; switch ( myLen ) { case ( 8 ) : break ; case ( 6 ) : theHex = "ff" + theHex ; break ; default : theHex = "ff000000" ; break ; } a = ( new Integer ( Integer . parseInt ( theHex . substring ( 0 , 2 ) , 16 ) ) ) . intValue ( ) ; r = ( new Integer ( Integer . parseInt ( theHex . substring ( 2 , 4 ) , 16 ) ) ) . intValue ( ) ; g = ( new Integer ( Integer . parseInt ( theHex . substring ( 4 , 6 ) , 16 ) ) ) . intValue ( ) ; b = ( new Integer ( Integer . parseInt ( theHex . substring ( 6 , 8 ) , 16 ) ) ) . intValue ( ) ; return ( a << 24 | r << 16 | g << 8 | b ) ; } 
void reap ( ) { final WatchersForTemplateClass content [ ] ; synchronized ( holders ) { final Collection values = holders . values ( ) ; content = new WatchersForTemplateClass [ values . size ( ) ] ; values . toArray ( content ) ; } final long now = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < content . length ; i ++ ) { content [ i ] . reap ( now ) ; } } 
private static int drawJustifiedSpaceSeparatedSubstrings ( Font font , final String s , final int x , final int y , final int justifiedSpaceWidth ) { int curpos = 0 ; int endpos = 0 ; int resultingXCoordinate = x ; while ( curpos < s . length ( ) ) { endpos = s . indexOf ( '-' , curpos ) ; if ( endpos == - 1 ) { endpos = s . length ( ) ; } String substring = s . substring ( curpos , endpos ) ; font . drawString ( resultingXCoordinate , y , substring ) ; resultingXCoordinate += font . getWidth ( substring ) + justifiedSpaceWidth ; curpos = endpos + 1 ; } return resultingXCoordinate ; } 
public MaskFilter setMaskFilter ( MaskFilter maskfilter ) { int maskfilterNative = 0 ; if ( maskfilter != null ) { maskfilterNative = maskfilter . native_instance ; } native_setMaskFilter ( mNativePaint , maskfilterNative ) ; mMaskFilter = maskfilter ; return maskfilter ; } 
public void installUI ( JComponent a ) { for ( int i = 0 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . installUI ( a ) ; } } 
public static String copyValueOf ( char [ ] data ) { return new String ( data , 0 , data . length ) ; } 
public E remove ( ) { return removeFirst ( ) ; } 
public synchronized int deleteSensor ( AbstractSensor x ) { int idx = sensors . indexOf ( x ) ; if ( idx >= 0 ) { sensors . remove ( idx ) ; } else { for ( int i = 0 ; i < nodes . size ( ) ; i ++ ) { if ( ( nodes . get ( i ) . getType ( ) & AbstractTypes . MASK_NETWORK ) > 0 ) { idx = ( ( AbstractNodeComplex ) nodes . get ( i ) ) . deleteSensor ( x ) ; if ( idx >= 0 ) break ; } } } if ( idx >= 0 ) { for ( int i = 0 ; i < monitors . size ( ) ; i ++ ) { monitors . get ( i ) . deletePredecessor ( x ) ; monitors . get ( i ) . deleteSuccessor ( x ) ; } } return idx ; } 
private Method getPropertyFunction ( Class targetClass , String prefix , Class valueType ) { Method returnVal = null ; String methodName = getMethodName ( prefix , mPropertyName ) ; Class args [ ] = null ; if ( valueType == null ) { try { returnVal = targetClass . getMethod ( methodName , args ) ; } catch ( NoSuchMethodException e ) { Log . e ( "PropertyValuesHolder" , targetClass . getSimpleName ( ) + "---" + "Couldn't-find-no-arg-method-for-property-" + mPropertyName + ":-" + e ) ; } } else { args = new Class [ 1 ] ; Class typeVariants [ ] ; if ( mValueType . equals ( Float . class ) ) { typeVariants = FLOAT_VARIANTS ; } else if ( mValueType . equals ( Integer . class ) ) { typeVariants = INTEGER_VARIANTS ; } else if ( mValueType . equals ( Double . class ) ) { typeVariants = DOUBLE_VARIANTS ; } else { typeVariants = new Class [ 1 ] ; typeVariants [ 0 ] = mValueType ; } for ( Class typeVariant : typeVariants ) { args [ 0 ] = typeVariant ; try { returnVal = targetClass . getMethod ( methodName , args ) ; mValueType = typeVariant ; return returnVal ; } catch ( NoSuchMethodException e ) { } } Log . e ( "PropertyValuesHolder" , "Couldn't-find-" + prefix + "ter-property-" + mPropertyName + "-for-" + targetClass . getSimpleName ( ) + "-with-value-type-" + mValueType ) ; } return returnVal ; } 
public static Message obtain ( Handler h , Runnable callback ) { Message m = obtain ( ) ; m . target = h ; m . callback = callback ; return m ; } 
public int getCellsVal ( ) { Iterator < Character > i = cells . keySet ( ) . iterator ( ) ; int size = 0 ; for ( ; i . hasNext ( ) ; ) { Character c = i . next ( ) ; Cell e = at ( c ) ; if ( e . cmd >= 0 ) { size ++ ; } } return size ; } 
E getLastDelivered ( ) { if ( lastDelivered == null ) { return null ; } return lastDelivered . getObject ( ) ; } 
private void makeError ( ) { this . href = null ; if ( this . label == null ) { this . label = "" ; } this . label = "ERROR(" + this . label + "/" + text . trim ( ) + ")" ; } 
public static int [ ] filterPublicFormats ( int [ ] formats ) { if ( formats == null ) { return null ; } int [ ] myCopy = Arrays . copyOf ( formats , formats . length ) ; int size = 0 ; for ( int i = 0 ; i < myCopy . length ; i ++ ) { if ( isPublicEncoding ( myCopy [ i ] ) ) { if ( size != i ) { myCopy [ size ] = myCopy [ i ] ; } size ++ ; } } return Arrays . copyOf ( myCopy , size ) ; } 
private String getXMLUrl ( ) { StringBuffer urlBuf = new StringBuffer ( ) ; urlBuf . append ( apiUrlPrefix ) ; urlBuf . append ( BoxConstant . SLASH_STRING ) ; urlBuf . append ( apiVersion ) ; urlBuf . append ( BoxConstant . SLASH_STRING ) ; urlBuf . append ( BoxConstant . CONFIG_API_REQUEST_FORMAT_XML ) ; return urlBuf . toString ( ) ; } 
private int getAmOrPmKeyCode ( int amOrPm ) { if ( mAmKeyCode == - 1 || mPmKeyCode == - 1 ) { KeyCharacterMap kcm = KeyCharacterMap . load ( KeyCharacterMap . VIRTUAL_KEYBOARD ) ; char amChar ; char pmChar ; for ( int i = 0 ; i < Math . max ( mAmText . length ( ) , mPmText . length ( ) ) ; i ++ ) { amChar = mAmText . toLowerCase ( Locale . getDefault ( ) ) . charAt ( i ) ; pmChar = mPmText . toLowerCase ( Locale . getDefault ( ) ) . charAt ( i ) ; if ( amChar != pmChar ) { KeyEvent [ ] events = kcm . getEvents ( new char [ ] { amChar , pmChar } ) ; if ( events != null && events . length == 4 ) { mAmKeyCode = events [ 0 ] . getKeyCode ( ) ; mPmKeyCode = events [ 2 ] . getKeyCode ( ) ; } else { Log . e ( TAG , "Unable-to-find-keycodes-for-AM-and-PM." ) ; } break ; } } } if ( amOrPm == AM ) { return mAmKeyCode ; } else if ( amOrPm == PM ) { return mPmKeyCode ; } return - 1 ; } 
public static Connection enlistConnection ( XAConnection xacon ) throws GenericTransactionException { if ( xacon == null ) { return null ; } try { XAResource resource = xacon . getXAResource ( ) ; TransactionUtil . enlistResource ( resource ) ; return xacon . getConnection ( ) ; } catch ( SQLException e ) { throw new GenericTransactionException ( "SQL-error,-could-not-enlist-connection-in-transaction-even-though-transactions-are-available" , e ) ; } } 
public static void closeQuietly ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } 
public void setGregorianChange ( Date date ) { gregorianCutover = date . getTime ( ) ; GregorianCalendar cal = new GregorianCalendar ( TimeZone . getTimeZone ( "GMT" ) ) ; cal . setTime ( date ) ; changeYear = cal . get ( YEAR ) ; if ( cal . get ( ERA ) == BC ) { changeYear = 1 - changeYear ; } julianSkew = ( ( changeYear - 2000 ) / 400 ) + julianError ( ) - ( ( changeYear - 2000 ) / 100 ) ; int dayOfYear = cal . get ( DAY_OF_YEAR ) ; if ( dayOfYear < julianSkew ) { currentYearSkew = dayOfYear - 1 ; lastYearSkew = julianSkew - dayOfYear + 1 ; } else { lastYearSkew = 0 ; currentYearSkew = julianSkew ; } } 
public static RawHeaders fromMultimap ( Map < String , List < String >> map , boolean response ) throws IOException { if ( ! response ) throw new UnsupportedOperationException ( ) ; RawHeaders result = new RawHeaders ( ) ; for ( Entry < String , List < String >> entry : map . entrySet ( ) ) { String fieldName = entry . getKey ( ) ; List < String > values = entry . getValue ( ) ; if ( fieldName != null ) { for ( String value : values ) { result . addLenient ( fieldName , value ) ; } } else if ( ! values . isEmpty ( ) ) { result . setStatusLine ( values . get ( values . size ( ) - 1 ) ) ; } } return result ; } 
public void addNotify ( ) { synchronized ( getTreeLock ( ) ) { if ( peer == null ) peer = getToolkit ( ) . createLabel ( this ) ; super . addNotify ( ) ; } } 
public void paint ( Graphics g , Shape s ) { synchronized ( locator ) { locator . setAllocation ( s ) ; locator . paintChildren ( g ) ; } } 
public boolean hasBeenInvalidated ( ) { if ( switchPoints == null ) { return false ; } for ( final SwitchPoint sp : switchPoints ) { if ( sp . hasBeenInvalidated ( ) ) { return true ; } } return false ; } 
static boolean equalsImpl ( Set < ? > s , @ Nullable Object object ) { if ( s == object ) { return true ; } if ( object instanceof Set ) { Set < ? > o = ( Set < ? > ) object ; try { return s . size ( ) == o . size ( ) && s . containsAll ( o ) ; } catch ( NullPointerException ignored ) { return false ; } catch ( ClassCastException ignored ) { return false ; } } return false ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public int addMatch ( AbstractPattern pattern ) throws XslParseException { int index = _matchPatterns . size ( ) ; _matchPatterns . add ( pattern ) ; return index ; } 
public static int getCompletionPollInterval ( Configuration conf ) { int completionPollIntervalMillis = conf . getInt ( COMPLETION_POLL_INTERVAL_KEY , DEFAULT_COMPLETION_POLL_INTERVAL ) ; if ( completionPollIntervalMillis < 1 ) { LOG . warn ( COMPLETION_POLL_INTERVAL_KEY + "-has-been-set-to-an-invalid-value;-" + "replacing-with-" + DEFAULT_COMPLETION_POLL_INTERVAL ) ; completionPollIntervalMillis = DEFAULT_COMPLETION_POLL_INTERVAL ; } return completionPollIntervalMillis ; } 
public final boolean weakCompareAndSet ( int i , int expect , int update ) { return compareAndSet ( i , expect , update ) ; } 
private static Set < Character > parseFlags ( String flags ) { Set < Character > flagsSet = new HashSet < Character > ( flags . length ( ) ) ; for ( int flagIndex = 0 ; flagIndex < flags . length ( ) ; flagIndex ++ ) { char flag = flags . charAt ( flagIndex ) ; if ( ! flagsSet . add ( flag ) ) { throw new IllegalArgumentException ( "Flag-cannot-be-specified-twice:-'" + flag + "'" ) ; } } return flagsSet ; } 
public boolean hasPrevious ( ) { boolean has_prev = false ; if ( token_stream != null ) { if ( iterator > 0 && token_stream . get ( iterator - 1 ) != null ) has_prev = true ; } return has_prev ; } 
public void putProperty ( final String name , Object value ) { Object oldValue = null ; synchronized ( this ) { if ( properties == null ) { properties = new HashMap < String , Object > ( 7 ) ; } oldValue = properties . get ( name ) ; properties . put ( name , value ) ; } firePropertyChange ( name , oldValue , value ) ; if ( propListener != null ) { Mutex . EVENT . readAccess ( new Runnable ( ) { public void run ( ) { propListener . propertyChange ( new PropertyChangeEvent ( this , name , null , null ) ) ; } } ) ; } if ( PROP_ERROR_MESSAGE . equals ( name ) ) { WizardPanel wp = wizardPanel ; if ( wp != null ) { wp . setErrorMessage ( ( String ) ( value == null ? "-" : value ) ) ; } } } 
public static Type getElementType ( Type type ) { if ( ! type . isArrayType ( ) ) return type ; return ( ( ArrayType ) type ) . getElementType ( ) ; } 
public final Object getObject ( Cipher c ) throws IOException , ClassNotFoundException , IllegalBlockSizeException , BadPaddingException { if ( c == null ) { throw new NullPointerException ( "c-==-null" ) ; } byte [ ] serialized = c . doFinal ( encryptedContent ) ; ObjectInputStream ois = new ObjectInputStream ( new ByteArrayInputStream ( serialized ) ) ; return ois . readObject ( ) ; } 
public static Policy getInstance ( Node root ) throws ParsingException { if ( ! root . getNodeName ( ) . equals ( "Policy" ) ) { throw new ParsingException ( "Cannot-create-Policy-from-root-of-" + "type-" + root . getNodeName ( ) ) ; } return new Policy ( root ) ; } 
public void moveAllChildrenTo ( final FilePath target ) throws IOException , InterruptedException { if ( this . channel != target . channel ) { throw new IOException ( "pullUpTo-target-must-be-on-the-same-host" ) ; } act ( new FileCallable < Void > ( ) { public Void invoke ( File f , VirtualChannel channel ) throws IOException { File t = new File ( target . getRemote ( ) ) ; for ( File child : f . listFiles ( ) ) { File target = new File ( t , child . getName ( ) ) ; if ( ! child . renameTo ( target ) ) throw new IOException ( "Failed-to-rename-" + child + "-to-" + target ) ; } f . delete ( ) ; return null ; } } ) ; } 
public void reset ( ) throws IOException { int last ; if ( locations . isEmpty ( ) ) { last = 0 ; } else { last = locations . peek ( ) ; } if ( last - pos < 0 ) { throw new IOException ( ) ; } index = last - pos ; } 
public final void beginBufferedOps ( ) { __receiveBuffer = new byte [ PACKET_SIZE ] ; __receiveDatagram = new DatagramPacket ( __receiveBuffer , __receiveBuffer . length ) ; _sendBuffer = new byte [ PACKET_SIZE ] ; __sendDatagram = new DatagramPacket ( _sendBuffer , _sendBuffer . length ) ; } 
public Vector3D multByScalar ( double scalar ) { return new Vector3D ( _x * scalar , _y * scalar , _z * scalar ) ; } 
public String myGetType ( ) { SequenceEncoder se = new SequenceEncoder ( TYPE_DELIMITOR ) ; String red = backgroundColor == null ? "" : Integer . toString ( backgroundColor . getRed ( ) ) ; String green = backgroundColor == null ? "" : Integer . toString ( backgroundColor . getGreen ( ) ) ; String blue = backgroundColor == null ? "" : Integer . toString ( backgroundColor . getBlue ( ) ) ; String commit = Integer . toString ( commitStyle ) ; se . append ( m_definition ) . append ( menuName ) . append ( "" ) . append ( commit ) . append ( red ) . append ( green ) . append ( blue ) . append ( launchKeyStroke ) ; return ID + se . getValue ( ) ; } 
static void terminateBits ( int numDataBytes , BitArray bits ) throws WriterException { int capacity = numDataBytes << 3 ; if ( bits . getSize ( ) > capacity ) { throw new WriterException ( "data-bits-cannot-fit-in-the-QR-Code" + bits . getSize ( ) + "->-" + capacity ) ; } for ( int i = 0 ; i < 4 && bits . getSize ( ) < capacity ; ++ i ) { bits . appendBit ( false ) ; } int numBitsInLastByte = bits . getSize ( ) & 0x07 ; if ( numBitsInLastByte > 0 ) { for ( int i = numBitsInLastByte ; i < 8 ; i ++ ) { bits . appendBit ( false ) ; } } int numPaddingBytes = numDataBytes - bits . getSizeInBytes ( ) ; for ( int i = 0 ; i < numPaddingBytes ; ++ i ) { bits . appendBits ( ( i & 0x01 ) == 0 ? 0xEC : 0x11 , 8 ) ; } if ( bits . getSize ( ) != capacity ) { throw new WriterException ( "Bits-size-does-not-equal-capacity" ) ; } } 
public void clearXTextLabels ( ) { mXTextLabels . clear ( ) ; } 
public synchronized String readLine ( String filename , boolean recycle , boolean firstLineIsNames ) throws IOException { FileEntry fileEntry = files . get ( filename ) ; if ( fileEntry != null ) { if ( fileEntry . inputOutputObject == null ) { fileEntry . inputOutputObject = createBufferedReader ( fileEntry ) ; } else if ( ! ( fileEntry . inputOutputObject instanceof Reader ) ) { throw new IOException ( "File-" + filename + "-already-in-use" ) ; } BufferedReader reader = ( BufferedReader ) fileEntry . inputOutputObject ; String line = reader . readLine ( ) ; if ( line == null && recycle ) { reader . close ( ) ; reader = createBufferedReader ( fileEntry ) ; fileEntry . inputOutputObject = reader ; if ( firstLineIsNames ) { reader . readLine ( ) ; } line = reader . readLine ( ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Read:" + line ) ; } return line ; } throw new IOException ( "File-never-reserved:-" + filename ) ; } 
@ Override public void paint ( Graphics g ) { Rectangle rowBounds = getRowBounds ( visibleRow ) ; g . translate ( 0 , - rowBounds . y ) ; Rectangle oldClip = g . getClipBounds ( ) ; int newY = Math . max ( oldClip . y , rowBounds . y ) ; int newHeight = Math . min ( rowBounds . height - ( rowBounds . y - newY ) , oldClip . height ) ; g . setClip ( oldClip . x , newY , oldClip . width , newHeight ) ; super . paint ( g ) ; } 
void advanceHead ( QNode h , QNode nh ) { if ( h == head && headUpdater . compareAndSet ( this , h , nh ) ) h . next = h ; } 
private JSONObject copyFile ( File srcFile , File destFile ) throws IOException , InvalidModificationException , JSONException { if ( destFile . exists ( ) && destFile . isDirectory ( ) ) { throw new InvalidModificationException ( "Can't-rename-a-file-to-a-directory" ) ; } FileInputStream istream = new FileInputStream ( srcFile ) ; FileOutputStream ostream = new FileOutputStream ( destFile ) ; FileChannel input = istream . getChannel ( ) ; FileChannel output = ostream . getChannel ( ) ; try { input . transferTo ( 0 , input . size ( ) , output ) ; } finally { istream . close ( ) ; ostream . close ( ) ; input . close ( ) ; output . close ( ) ; } return getEntry ( destFile ) ; } 
protected Byte wrapKey ( byte k ) { return new Byte ( k ) ; } 
public final java . net . InetAddress [ ] getClientAddresses ( ) { return ( clientAddresses == null ) ? null : clientAddresses . clone ( ) ; } 
protected void get_from_real ( ) { Symbol stack_sym ; if ( real_next >= real_stack . size ( ) ) return ; stack_sym = ( Symbol ) real_stack . elementAt ( real_stack . size ( ) - 1 - real_next ) ; real_next ++ ; vstack . push ( new Integer ( stack_sym . parse_state ) ) ; } 
private List < String > getTerms ( HashMap < String , Widget > bundle ) { List < String > result = new ArrayList < String > ( ) ; for ( Widget widget : bundle . values ( ) ) { if ( widget instanceof Text ) { result . add ( ( ( Text ) widget ) . getText ( ) . toLowerCase ( ) ) ; } } return result ; } 
public String [ ] toStringArray ( ) { List < String > arguments = new ArrayList < String > ( ) ; for ( String key : _argumentsMap . keySet ( ) ) { if ( _argumentsMap . get ( key ) instanceof Boolean == false || _argumentsMap . get ( key ) . equals ( true ) ) { arguments . add ( key ) ; } if ( _argumentsMap . get ( key ) instanceof Boolean == false ) { arguments . add ( _argumentsMap . get ( key ) . toString ( ) ) ; } } return arguments . toArray ( new String [ arguments . size ( ) ] ) ; } 
public void drawOval ( RectF oval , Paint paint ) { if ( oval == null ) { throw new NullPointerException ( ) ; } native_drawOval ( mNativeCanvas , oval , paint . mNativePaint ) ; } 
public void shutdown ( ) { poolLock . lock ( ) ; try { if ( isShutDown ) return ; Iterator < BasicPoolEntry > iter = leasedConnections . iterator ( ) ; while ( iter . hasNext ( ) ) { BasicPoolEntry entry = iter . next ( ) ; iter . remove ( ) ; closeConnection ( entry . getConnection ( ) ) ; } idleConnHandler . removeAll ( ) ; isShutDown = true ; } finally { poolLock . unlock ( ) ; } } 
private ThreadData getDetails ( String line ) { Pattern pattern = Pattern . compile ( REGEX_THREAD_NAMES ) ; Matcher matcher = pattern . matcher ( line ) ; if ( matcher . find ( ) ) { String title = matcher . group ( 1 ) ; pattern = Pattern . compile ( REGEX_THREAD_URL ) ; matcher = pattern . matcher ( line ) ; if ( matcher . find ( ) ) { String urlLink = matcher . group ( 1 ) ; return new ThreadData ( title , urlLink , getContent ( urlLink ) ) ; } } return null ; } 
public static Object instantiate ( String tag , Class [ ] types , Object [ ] params ) { Class < ? > messageClass ; try { messageClass = Class . forName ( tag ) ; } catch ( ClassNotFoundException e ) { throw new IllegalArgumentException ( "Unable-to-find-class-" + tag , e ) ; } Constructor < ? > constructor ; try { constructor = messageClass . getDeclaredConstructor ( types ) ; } catch ( NoSuchMethodException | SecurityException e ) { String p = "Unable-to-find-constructor-" + tag + "(" ; for ( Class type : types ) p += "-" + type ; p += "-)" ; throw new IllegalArgumentException ( p , e ) ; } Object instance ; try { instance = constructor . newInstance ( params ) ; } catch ( IllegalAccessException | IllegalArgumentException | InstantiationException | InvocationTargetException e ) { throw new IllegalArgumentException ( "Failed-to-construct-" + tag , e ) ; } return instance ; } 
public int nextRawValue ( ValueBytes rawValue ) throws IOException { int valLength = in . nextRawValue ( rawValue ) ; return valLength ; } 
public MBeanServer newMBeanServer ( String defaultDomain , MBeanServer outer , MBeanServerDelegate delegate ) { return JmxMBeanServer . newMBeanServer ( defaultDomain , outer , delegate , false ) ; } 
public GBC setInsets ( int distance ) { this . insets = new Insets ( distance , distance , distance , distance ) ; return this ; } 
public Text evaluate ( String jsonString , String pathString ) { if ( jsonString == null || jsonString == "" || pathString == null || pathString == "" ) { return null ; } try { String [ ] pathExpr = pathExprCache . get ( pathString ) ; if ( pathExpr == null ) { pathExpr = pathString . split ( "|." , - 1 ) ; pathExprCache . put ( pathString , pathExpr ) ; } if ( ! pathExpr [ 0 ] . equalsIgnoreCase ( "$" ) ) { return null ; } Object extractObject = extractObjectCache . get ( jsonString ) ; if ( extractObject == null ) { extractObject = new JSONObject ( jsonString ) ; extractObjectCache . put ( jsonString , extractObject ) ; } for ( int i = 1 ; i < pathExpr . length ; i ++ ) { extractObject = extract ( extractObject , pathExpr [ i ] ) ; } result . set ( extractObject . toString ( ) ) ; return result ; } catch ( Exception e ) { return null ; } } 
public void insertAfterInstruction ( int instructionOffset , Instruction instruction ) { if ( instructionOffset < 0 || instructionOffset >= codeLength ) { throw new IllegalArgumentException ( "Invalid-instruction-offset-[" + instructionOffset + "]-in-code-with-length-[" + codeLength + "]" ) ; } postInsertions [ instructionOffset ] = shrinkInstructions ? instruction . shrink ( ) : instruction ; modified = true ; simple = false ; } 
public void addImplementationArgument ( ImplementationSpecificArgument arg ) { args . add ( arg ) ; } 
public void drawHUD ( ) { mPaint . setColor ( Color . BLACK ) ; mPaint . setTextAlign ( Paint . Align . LEFT ) ; mCanvas . drawText ( mStrings [ TXT_TIME ] + ":-" + ( mTotalTime / 1000 ) , mTextPadding , mHudTextY , mPaint ) ; mPaint . setTextAlign ( Paint . Align . CENTER ) ; mCanvas . drawText ( mStrings [ TXT_LEVEL ] + ":-" + mlevel , mCanvasHalfWidth , mHudTextY , mPaint ) ; mPaint . setTextAlign ( Paint . Align . RIGHT ) ; mCanvas . drawText ( mStrings [ TXT_LIVES ] + ":-" + mMarble . getLives ( ) , mCanvasWidth - mTextPadding , mHudTextY , mPaint ) ; if ( mWarning ) { mPaint . setColor ( Color . BLUE ) ; mCanvas . drawRect ( 0 , mCanvasHalfHeight - 15 , mCanvasWidth , mCanvasHalfHeight + 5 , mPaint ) ; mPaint . setColor ( Color . WHITE ) ; mPaint . setTextAlign ( Paint . Align . CENTER ) ; mCanvas . drawText ( mStrings [ TXT_TAP_SCREEN ] , mCanvasHalfWidth , mCanvasHalfHeight , mPaint ) ; } } 
public int getDelimiterCount ( ) { int count = 0 ; if ( mDelimiters != null ) { count = mDelimiters . size ( ) ; } return count ; } 
public Cursor query ( String tag , int limit ) { String selection = ( tag == null ? null : TrackerEntry . TAG + "=?" ) ; String [ ] selectionArgs = ( tag == null ? null : new String [ ] { tag } ) ; Cursor cursor = mContext . getContentResolver ( ) . query ( TrackerProvider . CONTENT_URI , TrackerEntry . ATTRIBUTES , selection , selectionArgs , null ) ; if ( cursor == null ) { return cursor ; } int pos = ( cursor . getCount ( ) < limit ? 0 : cursor . getCount ( ) - limit ) ; cursor . moveToPosition ( pos ) ; return cursor ; } 
public Object getParameter ( String name ) { return parameters . get ( name ) ; } 
public static Response newInternalServerError ( Exception exception ) { return newInternalServerError ( exception . getMessage ( ) ) . setCause ( exception ) ; } 
public List < ContactInformationType > getOrganizationPrimaryContactInformation ( ) { if ( organizationPrimaryContactInformation == null ) { organizationPrimaryContactInformation = new ArrayList < ContactInformationType > ( ) ; } return this . organizationPrimaryContactInformation ; } 
public boolean isInitialized ( ) { return isOctetStream ( ) || isNodeSet ( ) ; } 
public boolean isLoopbackAddress ( ) { byte [ ] loopback = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 } ; return Arrays . equals ( ipaddress , loopback ) ; } 
public static String getChildText ( Node node ) { if ( node == null ) { return null ; } StringBuffer str = new StringBuffer ( ) ; Node child = node . getFirstChild ( ) ; while ( child != null ) { short type = child . getNodeType ( ) ; if ( type == Node . TEXT_NODE ) { str . append ( child . getNodeValue ( ) ) ; } else if ( type == Node . CDATA_SECTION_NODE ) { str . append ( getChildText ( child ) ) ; } child = child . getNextSibling ( ) ; } return str . toString ( ) ; } 
public Activity startActivitySync ( Intent intent ) { validateNotAppThread ( ) ; synchronized ( mSync ) { intent = new Intent ( intent ) ; ActivityInfo ai = intent . resolveActivityInfo ( getTargetContext ( ) . getPackageManager ( ) , 0 ) ; if ( ai == null ) { throw new RuntimeException ( "Unable-to-resolve-activity-for:-" + intent ) ; } String myProc = mThread . getProcessName ( ) ; if ( ! ai . processName . equals ( myProc ) ) { throw new RuntimeException ( "Intent-in-process-" + myProc + "-resolved-to-different-process-" + ai . processName + ":-" + intent ) ; } intent . setComponent ( new ComponentName ( ai . applicationInfo . packageName , ai . name ) ) ; final ActivityWaiter aw = new ActivityWaiter ( intent ) ; if ( mWaitingActivities == null ) { mWaitingActivities = new ArrayList ( ) ; } mWaitingActivities . add ( aw ) ; getTargetContext ( ) . startActivity ( intent ) ; do { try { mSync . wait ( ) ; } catch ( InterruptedException e ) { } } while ( mWaitingActivities . contains ( aw ) ) ; return aw . activity ; } } 
public Path makeQualified ( Path path ) { checkPath ( path ) ; return path . makeQualified ( this . getUri ( ) , this . getWorkingDirectory ( ) ) ; } 
public static String [ ] getOptionsForHierarchy ( Object target , Class < ? > oldestAncestorClazz ) { ArrayList < String > options = new ArrayList < String > ( ) ; for ( String s : getOptions ( target , target . getClass ( ) ) ) { options . add ( s ) ; } Class < ? > parent = target . getClass ( ) ; do { parent = parent . getSuperclass ( ) ; if ( parent == null ) { break ; } for ( String s : getOptions ( target , parent ) ) { options . add ( s ) ; } } while ( ! parent . equals ( oldestAncestorClazz ) ) ; return options . toArray ( new String [ options . size ( ) ] ) ; } 
public String getTitle ( ) throws IOException { Map < String , String > data = getMetadata ( ) ; if ( data == null || ! data . containsKey ( "StreamTitle" ) ) return "" ; String streamTitle = data . get ( "StreamTitle" ) ; String artist = streamTitle . substring ( streamTitle . indexOf ( "-" ) + 1 ) ; return artist . trim ( ) ; } 
public final void setDefault ( @ Nonnull final String def ) { try { _default = Integer . parseInt ( def ) ; } catch ( final NumberFormatException nfe ) { _default = 0 ; } } 
public String [ ] getClassFileNames ( File dir ) { List < String > names = new ArrayList < String > ( ) ; Stack < String > pathStack = new Stack < String > ( ) ; addClassNames ( dir , pathStack , names ) ; return names . toArray ( new String [ names . size ( ) ] ) ; } 
@ Deprecated int activeDirectoryPages ( ) { int ret = 1 ; final Iterator < AbstractPage > children = childIterator ( ) ; while ( children . hasNext ( ) ) { ret += children . next ( ) . activeDirectoryPages ( ) ; } return ret ; } 
public String popAndEncode ( boolean fromOnlineEvent ) { synchronized ( this ) { if ( activeBridgeMode == null ) { return null ; } activeBridgeMode . notifyOfFlush ( this , fromOnlineEvent ) ; if ( queue . isEmpty ( ) ) { return null ; } int totalPayloadLen = 0 ; int numMessagesToSend = 0 ; for ( JsMessage message : queue ) { int messageSize = calculatePackedMessageLength ( message ) ; if ( numMessagesToSend > 0 && totalPayloadLen + messageSize > MAX_PAYLOAD_SIZE && MAX_PAYLOAD_SIZE > 0 ) { break ; } totalPayloadLen += messageSize ; numMessagesToSend += 1 ; } StringBuilder sb = new StringBuilder ( totalPayloadLen ) ; for ( int i = 0 ; i < numMessagesToSend ; ++ i ) { JsMessage message = queue . removeFirst ( ) ; packMessage ( message , sb ) ; } if ( ! queue . isEmpty ( ) ) { sb . append ( '*' ) ; } String ret = sb . toString ( ) ; return ret ; } } 
static void terminateBits ( int numDataBytes , BitArray bits ) throws WriterException { int capacity = numDataBytes << 3 ; if ( bits . getSize ( ) > capacity ) { throw new WriterException ( "data-bits-cannot-fit-in-the-QR-Code" + bits . getSize ( ) + "->-" + capacity ) ; } for ( int i = 0 ; i < 4 && bits . getSize ( ) < capacity ; ++ i ) { bits . appendBit ( false ) ; } int numBitsInLastByte = bits . getSize ( ) & 0x07 ; if ( numBitsInLastByte > 0 ) { for ( int i = numBitsInLastByte ; i < 8 ; i ++ ) { bits . appendBit ( false ) ; } } int numPaddingBytes = numDataBytes - bits . getSizeInBytes ( ) ; for ( int i = 0 ; i < numPaddingBytes ; ++ i ) { bits . appendBits ( ( i & 0x01 ) == 0 ? 0xEC : 0x11 , 8 ) ; } if ( bits . getSize ( ) != capacity ) { throw new WriterException ( "Bits-size-does-not-equal-capacity" ) ; } } 
public void writeTo ( OutputStream os ) throws IOException { if ( dataSource != null ) { InputStream is = null ; byte data [ ] = new byte [ 8 * 1024 ] ; int bytes_read ; is = dataSource . getInputStream ( ) ; try { while ( ( bytes_read = is . read ( data ) ) > 0 ) { os . write ( data , 0 , bytes_read ) ; } } finally { is . close ( ) ; is = null ; } } else { DataContentHandler dch = getDataContentHandler ( ) ; dch . writeTo ( object , objectMimeType , os ) ; } } 
@ Override public AppEngineUpdate < E > filter ( Filter < ? > ... filters ) { if ( filters == null ) { throw new IllegalArgumentException ( "'filters'-must-not-be-[" + filters + "]" ) ; } this . filters = Arrays . asList ( filters ) ; return this ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
@ Override protected String getLoginFileName ( ) { String loginFile = PAResourceManagerProperties . RM_LOGIN_FILE . getValueAsString ( ) ; if ( ! ( new File ( loginFile ) . isAbsolute ( ) ) ) { loginFile = PAResourceManagerProperties . RM_HOME . getValueAsString ( ) + File . separator + loginFile ; } return loginFile ; } 
public int lookupString ( String str ) { Index index = ( Index ) string_table . get ( str ) ; return ( index != null ) ? index . index : - 1 ; } 
public void writeData ( ) { this . outputPath = this . dataPath + ".clean" ; BufferedWriter writer = null ; try { writer = new BufferedWriter ( new FileWriter ( outputPath ) ) ; for ( int index = 0 ; index < dictionary . size ( ) ; index ++ ) { writer . write ( dictionary . get ( index ) ) ; writer . newLine ( ) ; } writer . close ( ) ; } catch ( IOException e ) { System . err . println ( "Could-not-write-the-cleaned-data-to-:-" + outputPath ) ; System . exit ( - 1 ) ; } } 
private boolean addAll ( int index , List objects ) { if ( index < 0 || index > size ) { throw new IndexOutOfBoundsException ( "Index:-" + index + ",-Size:-" + size ) ; } if ( objects . size ( ) == 0 ) { return false ; } Node successor = ( index == size ? header : entry ( index ) ) ; Node predecessor = successor . getPrevious ( ) ; for ( Object o : objects ) { Node e = new Node ( successor , predecessor , o ) ; predecessor . setNext ( e ) ; predecessor = e ; } successor . setPrevious ( predecessor ) ; size += objects . size ( ) ; return true ; } 
public List < DocumentType > getDocument ( ) { if ( document == null ) { document = new ArrayList < DocumentType > ( ) ; } return this . document ; } 
public int hashCode ( ) { int i , size = size ( ) ; IChromosome s ; int twopower = 1 ; int localHashCode = - 593 ; for ( i = 0 ; i < size ; i ++ , twopower = 2 * twopower ) { s = getChromosome ( i ) ; localHashCode = 31 * localHashCode + s . hashCode ( ) ; } return localHashCode ; } 
public static < T > Transformer < T , T > chainedTransformer ( final Transformer < ? super T , ? extends T > ... transformers ) { FunctorUtils . validate ( transformers ) ; if ( transformers . length == 0 ) { return NOPTransformer . < T > nopTransformer ( ) ; } return new ChainedTransformer < T > ( transformers ) ; } 
public static String getMethodDescriptor ( final Type returnType , final Type [ ] argumentTypes ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( '(' ) ; for ( int i = 0 ; i < argumentTypes . length ; ++ i ) { argumentTypes [ i ] . getDescriptor ( buf ) ; } buf . append ( ')' ) ; returnType . getDescriptor ( buf ) ; return buf . toString ( ) ; } 
public void addValue ( Comparable < ? > v ) { Comparable < ? > obj = v ; if ( v instanceof Integer ) { obj = Long . valueOf ( ( ( Integer ) v ) . longValue ( ) ) ; } try { Long count = freqTable . get ( obj ) ; if ( count == null ) { freqTable . put ( obj , Long . valueOf ( 1 ) ) ; } else { freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { throw new MathIllegalArgumentException ( LocalizedFormats . INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES , v . getClass ( ) . getName ( ) ) ; } } 
public void setDialogTitle ( String dialogTitle ) { String oldValue = this . dialogTitle ; this . dialogTitle = dialogTitle ; if ( dialog != null ) { dialog . setTitle ( dialogTitle ) ; } firePropertyChange ( DIALOG_TITLE_CHANGED_PROPERTY , oldValue , dialogTitle ) ; } 
protected void setGlobalFocusOwner ( Component focusOwner ) throws SecurityException { Component oldFocusOwner = null ; boolean shouldFire = false ; if ( focusOwner == null || focusOwner . isFocusable ( ) ) { synchronized ( KeyboardFocusManager . class ) { checkKFMSecurity ( ) ; oldFocusOwner = getFocusOwner ( ) ; try { fireVetoableChange ( "focusOwner" , oldFocusOwner , focusOwner ) ; } catch ( PropertyVetoException e ) { return ; } KeyboardFocusManager . focusOwner = focusOwner ; if ( focusOwner != null && ( getCurrentFocusCycleRoot ( ) == null || ! focusOwner . isFocusCycleRoot ( getCurrentFocusCycleRoot ( ) ) ) ) { Container rootAncestor = focusOwner . getFocusCycleRootAncestor ( ) ; if ( rootAncestor == null && ( focusOwner instanceof Window ) ) { rootAncestor = ( Container ) focusOwner ; } if ( rootAncestor != null ) { setGlobalCurrentFocusCycleRootPriv ( rootAncestor ) ; } } shouldFire = true ; } } if ( shouldFire ) { firePropertyChange ( "focusOwner" , oldFocusOwner , focusOwner ) ; } } 
public String getSchemeSpecificPart ( ) { return decode ( schemeSpecificPart ) ; } 
public boolean next ( ) throws SQLException { return _rs . next ( ) ; } 
public double getSubmissionTime ( ) { if ( index_ == - 1 ) { return 0.0 ; } return resList_ . get ( index_ ) . submissionTime ; } 
public static byte [ ] toBytes ( ByteBuffer bb ) { int length = bb . remaining ( ) ; byte [ ] result = new byte [ length ] ; System . arraycopy ( bb . array ( ) , bb . arrayOffset ( ) + bb . position ( ) , result , 0 , length ) ; return result ; } 
public static String decodeEntryPointURL ( String entryPointURL ) { String afterDecode = entryPointURL ; try { afterDecode = afterDecode . replace ( "###" , "=" ) ; afterDecode = new String ( Base64 . decodeBase64 ( afterDecode . getBytes ( "UTF-8" ) ) , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { log . error ( "Decode-entryPointURL-:-{}-failed" , e ) ; } return afterDecode ; } 
public < T extends TelegramMessage > Builder register ( MessageType < T > type , MessageHandler < T > handler ) { List < MessageHandler > handlers = this . messageHandlers . get ( type ) ; if ( handlers == null ) { handlers = new LinkedList < > ( ) ; this . messageHandlers . put ( type , handlers ) ; } handlers . add ( handler ) ; return this ; } 
public void update ( Graphics g , JComponent c ) { AbstractButton button = ( AbstractButton ) c ; if ( ( c . getBackground ( ) instanceof UIResource ) && button . isContentAreaFilled ( ) && c . isEnabled ( ) ) { ButtonModel model = button . getModel ( ) ; if ( ! MetalUtils . isToolBarButton ( c ) ) { if ( ! model . isArmed ( ) && ! model . isPressed ( ) && MetalUtils . drawGradient ( c , g , "Button.gradient" , 0 , 0 , c . getWidth ( ) , c . getHeight ( ) , true ) ) { paint ( g , c ) ; return ; } } else if ( model . isRollover ( ) && MetalUtils . drawGradient ( c , g , "Button.gradient" , 0 , 0 , c . getWidth ( ) , c . getHeight ( ) , true ) ) { paint ( g , c ) ; return ; } } super . update ( g , c ) ; } 
@ Override public void setTarget ( Object target ) { if ( mTarget != target ) { final Object oldTarget = mTarget ; mTarget = target ; if ( oldTarget != null && target != null && oldTarget . getClass ( ) == target . getClass ( ) ) { return ; } mInitialized = false ; } } 
public boolean isOpaque ( ) { Color back = getBackground ( ) ; Component p = getParent ( ) ; if ( p != null ) { p = p . getParent ( ) ; } boolean colorMatch = ( back != null ) && ( p != null ) && back . equals ( p . getBackground ( ) ) && p . isOpaque ( ) ; return ! colorMatch && super . isOpaque ( ) ; } 
SocketAddress getLocalSocketAddress ( ) { try { return ( ( SocketChannel ) sendThread . sockKey . channel ( ) ) . socket ( ) . getLocalSocketAddress ( ) ; } catch ( NullPointerException e ) { return null ; } } 
public List getRegions ( boolean splitDisjointRegions ) { List list = new ArrayList ( ) ; Interval currentInterval = null ; Iterator it = map . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; List currentValue = ( List ) entry . getValue ( ) ; int currentKey = ( ( Integer ) entry . getKey ( ) ) . intValue ( ) ; if ( currentValue . size ( ) == 0 ) { Assert . a ( currentInterval != null , "Multiple-0-intervals-in-a-row-were-detected." ) ; currentInterval . stop = currentKey - 1 ; list . add ( currentInterval ) ; currentInterval = null ; } else { if ( currentInterval != null ) { boolean disjoint = true ; for ( Iterator i = currentValue . iterator ( ) ; i . hasNext ( ) ; ) { if ( currentInterval . elements . contains ( i . next ( ) ) ) { disjoint = false ; } } if ( disjoint && splitDisjointRegions ) { currentInterval . stop = currentKey - 1 ; list . add ( currentInterval ) ; currentInterval = null ; } } if ( currentInterval == null ) { currentInterval = new Interval ( ) ; currentInterval . start = currentKey ; currentInterval . elements = new HashSet ( ) ; } currentInterval . elements . addAll ( currentValue ) ; } } Assert . a ( currentInterval == null , "RangeMap-did-not-end-with-a-0-entry." ) ; return list ; } 
private static boolean match ( SeamConversationContext scc , final Class < ? > storeType ) { try { Class < ? > current = scc . getClass ( ) ; while ( current != Object . class ) { final Class < ? > clazz = current ; Method doAssociate = AccessController . doPrivileged ( new PrivilegedExceptionAction < Method > ( ) { public Method run ( ) throws Exception { try { return clazz . getDeclaredMethod ( "doAssociate" , storeType ) ; } catch ( NoSuchMethodException nsme ) { return null ; } } } ) ; if ( doAssociate != null ) return true ; current = current . getSuperclass ( ) ; } } catch ( Throwable ignored ) { } return false ; } 
@ Override public String toString ( ) { return map . toString ( ) ; } 
public void characters ( char ch [ ] , int start , int length ) throws SAXException { if ( contentHandler != null ) { contentHandler . characters ( ch , start , length ) ; } } 
public boolean apply ( ObjectName name ) throws BadStringOperationException , BadBinaryOpValueExpException , BadAttributeValueExpException , InvalidApplicationException { return exp1 . apply ( name ) || exp2 . apply ( name ) ; } 
public List < String > getBridge ( ) { if ( bridge == null ) { bridge = new ArrayList < String > ( ) ; } return this . bridge ; } 
private static Set getReportSectionDataFromReportMap ( Map < String , Set > reportMap , String key ) { final Set tempSet = reportMap . get ( key ) ; return tempSet ; } 
public void cancelConnect ( ) { if ( rbnbThread != null ) { rbnbThread . interrupt ( ) ; } } 
public boolean accept ( File file ) { String name = file . getName ( ) ; for ( int i = 0 ; i < this . names . length ; i ++ ) { if ( caseSensitivity . checkEquals ( name , names [ i ] ) ) { return true ; } } return false ; } 
public static void copyStream ( InputStream is , OutputStream os ) throws IOException { ParamChecker . notNull ( is , "is" ) ; ParamChecker . notNull ( os , "os" ) ; byte [ ] buffer = new byte [ 4096 ] ; int read ; while ( ( read = is . read ( buffer ) ) > - 1 ) { os . write ( buffer , 0 , read ) ; } os . close ( ) ; is . close ( ) ; } 
public void write ( byte b [ ] , int off , int len ) throws IOException { if ( ( off | len | ( b . length - ( len + off ) ) | ( off + len ) ) < 0 ) throw new IndexOutOfBoundsException ( ) ; for ( int i = 0 ; i < len ; i ++ ) { write ( b [ off + i ] ) ; } } 
public void close ( ) throws IOException { synchronized ( in ) { if ( buf != null ) { buf = null ; in . close ( ) ; } } } 
public List < Descriptor > getNestedTypes ( ) { return Collections . unmodifiableList ( Arrays . asList ( nestedTypes ) ) ; } 
public void testSerialization ( ) { TimeSeriesDataItem item1 = new TimeSeriesDataItem ( new Day ( 23 , 9 , 2001 ) , 99.7 ) ; TimeSeriesDataItem item2 = null ; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; ObjectOutput out = new ObjectOutputStream ( buffer ) ; out . writeObject ( item1 ) ; out . close ( ) ; ObjectInput in = new ObjectInputStream ( new ByteArrayInputStream ( buffer . toByteArray ( ) ) ) ; item2 = ( TimeSeriesDataItem ) in . readObject ( ) ; in . close ( ) ; } catch ( Exception e ) { System . out . println ( e . toString ( ) ) ; } assertEquals ( item1 , item2 ) ; } 
public void setSelectedItem ( Object anObject ) { if ( ( selectedObject != null && ! selectedObject . equals ( anObject ) ) || selectedObject == null && anObject != null ) { selectedObject = anObject ; fireContentsChanged ( this , - 1 , - 1 ) ; } } 
public static Builder newBuilder ( Message prototype ) { return new Builder ( prototype . getDescriptorForType ( ) ) . mergeFrom ( prototype ) ; } 
private Criteria buildCriteria ( Map fieldValues ) { Criteria criteria = new Criteria ( ) ; for ( Iterator i = fieldValues . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; String key = ( String ) e . getKey ( ) ; Object value = e . getValue ( ) ; if ( value instanceof Collection ) { criteria . addIn ( key , ( Collection ) value ) ; } else { criteria . addEqualTo ( key , value ) ; } } return criteria ; } 
public static String toSafeFileName ( String name ) { int size = name . length ( ) ; StringBuilder builder = new StringBuilder ( size * 2 ) ; for ( int i = 0 ; i < size ; i ++ ) { char c = name . charAt ( i ) ; boolean valid = c >= 'a' && c <= 'z' ; valid = valid || ( c >= 'A' && c <= 'Z' ) ; valid = valid || ( c >= '0' && c <= '9' ) ; valid = valid || ( c == '_' ) || ( c == '-' ) || ( c == '.' ) ; if ( valid ) { builder . append ( c ) ; } else { builder . append ( 'x' ) ; builder . append ( Integer . toHexString ( i ) ) ; } } return builder . toString ( ) ; } 
public String getValue ( int i ) { if ( i < 0 ) { return null ; } try { return ( String ) values . elementAt ( i ) ; } catch ( ArrayIndexOutOfBoundsException e ) { return null ; } } 
public static Spec spec ( int start ) { return spec ( start , 1 ) ; } 
@ Override public CharSequence getPreview ( ) { CharSequence preview = "" ; if ( boundaries == null || boundaries . size ( ) == 0 ) { return spannableStringBuilder . toString ( ) ; } else { try { int verseToPreview = Utils . getVerse ( key ) ; Log . e ( "SwordBibleText" , key . toString ( ) + "-Verse-to-preview-" + verseToPreview ) ; preview = spannableStringBuilder . subSequence ( boundaries . get ( verseToPreview - 1 ) , boundaries . get ( verseToPreview ) ) ; } catch ( Exception e ) { } } return preview ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public com . google . protobuf . ByteString getLongFieldNameIsLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong496Bytes ( ) { java . lang . Object ref = longFieldNameIsLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong496_ ; if ( ref instanceof java . lang . String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; longFieldNameIsLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong496_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public void writeUTF ( String str ) throws IOException { bout . writeUTF ( str ) ; } 
public static String getUserDomain ( String invitedUser ) { return invitedUser . substring ( invitedUser . lastIndexOf ( "@" ) + 1 , invitedUser . length ( ) ) ; } 
public final float getFloat ( ) { return Float . intBitsToFloat ( data ) ; } 
@ Override public void destroySubcontext ( Name name ) throws NamingException { if ( ! checkWritable ( ) ) { return ; } while ( ( ! name . isEmpty ( ) ) && ( name . get ( 0 ) . length ( ) == 0 ) ) name = name . getSuffix ( 1 ) ; if ( name . isEmpty ( ) ) throw new NamingException ( sm . getString ( "namingContext.invalidName" ) ) ; NamingEntry entry = bindings . get ( name . get ( 0 ) ) ; if ( entry == null ) { throw new NameNotFoundException ( sm . getString ( "namingContext.nameNotBound" , name , name . get ( 0 ) ) ) ; } if ( name . size ( ) > 1 ) { if ( entry . type == NamingEntry . CONTEXT ) { ( ( Context ) entry . value ) . destroySubcontext ( name . getSuffix ( 1 ) ) ; } else { throw new NamingException ( sm . getString ( "namingContext.contextExpected" ) ) ; } } else { if ( entry . type == NamingEntry . CONTEXT ) { ( ( Context ) entry . value ) . close ( ) ; bindings . remove ( name . get ( 0 ) ) ; } else { throw new NotContextException ( sm . getString ( "namingContext.contextExpected" ) ) ; } } } 
public void add ( double sample ) { sampleMeasurements . add ( sample ) ; } 
public boolean isPopupTrigger ( MouseEvent e ) { return getUI ( ) . isPopupTrigger ( e ) ; } 
public BigInteger toBigIntegerExact ( ) { if ( ( scale == 0 ) || ( isZero ( ) ) ) { return getUnscaledValue ( ) ; } else if ( scale < 0 ) { return getUnscaledValue ( ) . multiply ( Multiplication . powerOf10 ( - ( long ) scale ) ) ; } else { BigInteger [ ] integerAndFraction ; if ( ( scale > approxPrecision ( ) ) || ( scale > getUnscaledValue ( ) . getLowestSetBit ( ) ) ) { throw new ArithmeticException ( "Rounding-necessary" ) ; } integerAndFraction = getUnscaledValue ( ) . divideAndRemainder ( Multiplication . powerOf10 ( scale ) ) ; if ( integerAndFraction [ 1 ] . signum ( ) != 0 ) { throw new ArithmeticException ( "Rounding-necessary" ) ; } return integerAndFraction [ 0 ] ; } } 
protected URL getDefinitionsURL ( ) { String cust_proj_file = System . getProperty ( SYSTEM_DEFAULT_USER_PROJ_FILE ) ; if ( cust_proj_file == null ) { GeoServerResourceLoader loader = GeoServerExtensions . bean ( GeoServerResourceLoader . class ) ; if ( loader != null ) { Resource custom_proj = loader . get ( "user_projections/netcdf.projections.properties" ) ; if ( custom_proj . getType ( ) == Type . RESOURCE ) { cust_proj_file = custom_proj . file ( ) . getAbsolutePath ( ) ; } } } if ( cust_proj_file != null ) { File proj_file = new File ( cust_proj_file ) ; if ( proj_file . exists ( ) ) { URL url = DataUtilities . fileToURL ( proj_file ) ; if ( url != null ) { return url ; } else { LOGGER . log ( Level . SEVERE , "Had-troubles-converting-" + cust_proj_file + "-to-URL" ) ; } } } cust_proj_file = "override_epsg.netcdf.properties" ; return NetCDFCRSOverridingAuthorityFactory . class . getResource ( cust_proj_file ) ; } 
public void addHeaderClickListener ( final TableHeaderClickListener listener ) { listeners . add ( listener ) ; } 
public final int getConnectionCount ( ) { return m_connections != null ? m_connections . size ( ) : 0 ; } 
public static Controller getController ( int index ) { return controllers . get ( index ) ; } 
@ SuppressWarnings ( "unchecked" ) public Class < ? extends OutputFormat < ? , ? >> getOutputFormatClass ( ) throws ClassNotFoundException { return ( Class < ? extends OutputFormat < ? , ? >> ) conf . getClass ( OUTPUT_FORMAT_CLASS_ATTR , TextOutputFormat . class ) ; } 
@ Parameters public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { "Elias" , "Nogueira" , "PayPal" , "Envio-por-Sedex-10" } , { "Fulano" , "da-Silva" , "PagSeguro" , "Envio-por-encom.-normal" } , { "Deltrano" , "Santos" , "Cartao-de-Credito" , "Envio-por-Sedex" } } ) ; } 
static ICC_Profile getDeferredInstance ( ProfileDeferralInfo pdi ) { if ( ! ProfileDeferralMgr . deferring ) { return getStandardProfile ( pdi . filename ) ; } if ( pdi . colorSpaceType == ColorSpace . TYPE_RGB ) { return new ICC_ProfileRGB ( pdi ) ; } else if ( pdi . colorSpaceType == ColorSpace . TYPE_GRAY ) { return new ICC_ProfileGray ( pdi ) ; } else { return new ICC_Profile ( pdi ) ; } } 
public void changeBackgroundResource ( Drawable drawableResource ) { if ( drawableResource != null ) { if ( mInternalMainCardLayout != null ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN ) mInternalMainCardLayout . setBackground ( drawableResource ) ; else mInternalMainCardLayout . setBackgroundDrawable ( drawableResource ) ; } } } 
public void process ( String aType , int aLevel , Object aData ) { process ( aType , aLevel , "" , aData ) ; } 
public boolean removeAccessibilityStateChangeListener ( AccessibilityStateChangeListener listener ) { return mAccessibilityStateChangeListeners . remove ( listener ) ; } 
public Comparator < ? > getComparator ( int column ) { checkColumn ( column ) ; if ( comparators != null ) { return comparators [ column ] ; } return null ; } 
@ Override protected void disableUnusablePreferences ( final int quality , MutableBoolean allowBiometric ) { final int newQuality = Math . max ( quality , DevicePolicyManager . PASSWORD_QUALITY_SOMETHING ) ; super . disableUnusablePreferencesImpl ( newQuality , allowBiometric , true ) ; } 
private final void loadPattern ( String pattern ) { if ( ! TextUtils . isEmpty ( pattern ) ) { final int hashCode = pattern . hashCode ( ) ; if ( hashCode != mProfilePatternLastHash ) { mProfilePatternLastHash = hashCode ; mMatcher = Pattern . compile ( pattern ) ; mVeiledMatchingEnabled = true ; } } } 
public void addTitle ( Title title ) { titles . addElement ( title ) ; } 
public void removeSubscriptionStateHeader ( ) { removeHeader ( SipHeaders . Subscription_State ) ; } 
public String getSigAlgOID ( ) { return c . getSignatureAlgorithm ( ) . getAlgorithm ( ) . getId ( ) ; } 
@ Override public double java2DToValue ( double java2DValue , Rectangle2D area , RectangleEdge edge ) { Range range = getRange ( ) ; double axisMin = calculateLog ( Math . max ( this . smallestValue , range . getLowerBound ( ) ) ) ; double axisMax = calculateLog ( range . getUpperBound ( ) ) ; double min = 0.0 ; double max = 0.0 ; if ( RectangleEdge . isTopOrBottom ( edge ) ) { min = area . getX ( ) ; max = area . getMaxX ( ) ; } else if ( RectangleEdge . isLeftOrRight ( edge ) ) { min = area . getMaxY ( ) ; max = area . getY ( ) ; } double log ; if ( isInverted ( ) ) { log = axisMax - ( java2DValue - min ) / ( max - min ) * ( axisMax - axisMin ) ; } else { log = axisMin + ( java2DValue - min ) / ( max - min ) * ( axisMax - axisMin ) ; } return calculateValue ( log ) ; } 
private int [ ] getForeignKeyActions ( String commentString ) { int [ ] actions = new int [ ] { java . sql . DatabaseMetaData . importedKeyNoAction , java . sql . DatabaseMetaData . importedKeyNoAction } ; int lastParenIndex = commentString . lastIndexOf ( ")" ) ; if ( lastParenIndex != ( commentString . length ( ) - 1 ) ) { String cascadeOptions = commentString . substring ( lastParenIndex + 1 ) . trim ( ) . toUpperCase ( Locale . ENGLISH ) ; actions [ 0 ] = getCascadeDeleteOption ( cascadeOptions ) ; actions [ 1 ] = getCascadeUpdateOption ( cascadeOptions ) ; } return actions ; } 
public boolean isValid ( ) { BigInteger allbits = new BigInteger ( "0" ) ; allbits = allbits . setBit ( map_size ) ; allbits = allbits . subtract ( new BigInteger ( "1" ) ) ; return allbits . equals ( validBits ) ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
static public Sort instance ( ) { if ( instance == null ) instance = new Sort ( ) ; return instance ; } 
public String checkMatching ( Map < Integer , ArrayList < Integer >> cardMap ) { twoOfAKind = false ; for ( Map . Entry < Integer , ArrayList < Integer >> entry : cardMap . entrySet ( ) ) { switch ( entry . getValue ( ) . size ( ) ) { case 4 : topRankingValue = entry . getKey ( ) ; matchingCards = "four-of-a-Kind" ; break ; case 3 : topRankingValue = entry . getKey ( ) ; matchingCards = "three-of-a-Kind" ; break ; case 2 : if ( twoOfAKind ) { topRankingValue2 = entry . getKey ( ) ; matchingCards = "two-pair" ; } else { topRankingValue = entry . getKey ( ) ; twoOfAKind = true ; matchingCards = "a-pair" ; } } } return matchingCards ; } 
public String toString ( int digits , boolean trailing ) { if ( isEmpty ( ) ) return "null-vector" ; StringBuffer text = new StringBuffer ( ) ; FlexibleDecimalFormat nf = new FlexibleDecimalFormat ( digits , trailing ) ; nf . grouping ( true ) ; for ( int i = 0 ; i < size ( ) ; i ++ ) nf . update ( get ( i ) ) ; int count = 0 ; int width = 80 ; String number ; for ( int i = 0 ; i < size ( ) ; i ++ ) { number = nf . format ( get ( i ) ) ; count += 1 + number . length ( ) ; if ( count > width - 1 ) { text . append ( '|n' ) ; count = 1 + number . length ( ) ; } text . append ( "-" + number ) ; } return text . toString ( ) ; } 
public boolean startsWith ( XMLString prefix ) { return startsWith ( prefix , 0 ) ; } 
public boolean isCustomization ( ) { Object oo = get_Value ( COLUMNNAME_IsCustomization ) ; if ( oo != null ) { if ( oo instanceof Boolean ) return ( ( Boolean ) oo ) . booleanValue ( ) ; return "Y" . equals ( oo ) ; } return false ; } 
static public byte [ ] imageToPNG ( Image image ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { BufferedImage buffer = new BufferedImage ( image . getWidth ( null ) , image . getHeight ( null ) , BufferedImage . TYPE_INT_ARGB ) ; buffer . createGraphics ( ) . drawImage ( image , 0 , 0 , null ) ; ImageIO . write ( buffer , "PNG" , baos ) ; baos . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return baos . toByteArray ( ) ; } 
public final int [ ] getDoublingHistogram ( ) { return Arrays . copyOf ( histogram , histogram . length ) ; } 
public static File [ ] getCachedWordLists ( final String locale , final Context context ) { final File [ ] directoryList = DictionaryInfoUtils . getCachedDirectoryList ( context ) ; if ( null == directoryList ) return EMPTY_FILE_ARRAY ; final HashMap < String , FileAndMatchLevel > cacheFiles = new HashMap < > ( ) ; for ( File directory : directoryList ) { if ( ! directory . isDirectory ( ) ) continue ; final String dirLocale = DictionaryInfoUtils . getWordListIdFromFileName ( directory . getName ( ) ) ; final int matchLevel = LocaleUtils . getMatchLevel ( dirLocale , locale ) ; if ( LocaleUtils . isMatch ( matchLevel ) ) { final File [ ] wordLists = directory . listFiles ( ) ; if ( null != wordLists ) { for ( File wordList : wordLists ) { final String category = DictionaryInfoUtils . getCategoryFromFileName ( wordList . getName ( ) ) ; final FileAndMatchLevel currentBestMatch = cacheFiles . get ( category ) ; if ( null == currentBestMatch || currentBestMatch . mMatchLevel < matchLevel ) { cacheFiles . put ( category , new FileAndMatchLevel ( wordList , matchLevel ) ) ; } } } } } if ( cacheFiles . isEmpty ( ) ) return EMPTY_FILE_ARRAY ; final File [ ] result = new File [ cacheFiles . size ( ) ] ; int index = 0 ; for ( final FileAndMatchLevel entry : cacheFiles . values ( ) ) { result [ index ++ ] = entry . mFile ; } return result ; } 
public Enumeration listOptions ( ) { Vector newVector = new Vector ( 3 ) ; newVector . addElement ( new Option ( "-Sets-the-attribute-index-(default-last)." , "C" , 1 , "-C-<col>" ) ) ; newVector . addElement ( new Option ( "-Sets-the-first-value's-index-(default-first)." , "F" , 1 , "-F-<value-index>" ) ) ; newVector . addElement ( new Option ( "-Sets-the-second-value's-index-(default-last)." , "S" , 1 , "-S-<value-index>" ) ) ; return newVector . elements ( ) ; } 
private void check ( InetAddress address , int prefixLength ) { if ( address . isLoopbackAddress ( ) ) { throw new IllegalArgumentException ( "Bad-address" ) ; } if ( address instanceof Inet4Address ) { if ( prefixLength < 0 || prefixLength > 32 ) { throw new IllegalArgumentException ( "Bad-prefixLength" ) ; } } else if ( address instanceof Inet6Address ) { if ( prefixLength < 0 || prefixLength > 128 ) { throw new IllegalArgumentException ( "Bad-prefixLength" ) ; } } else { throw new IllegalArgumentException ( "Unsupported-family" ) ; } } 
public int getPixel ( int x , int y ) { if ( x >= 0 && x < width && y >= 0 && y < height ) return Float . floatToIntBits ( pixels [ y * width + x ] ) ; else return 0 ; } 
public static void incrementCount ( Map < String , Float > counts , String eventString , float count ) { Float currentCount = counts . get ( eventString ) ; if ( currentCount == null ) currentCount = 0.0f ; counts . put ( eventString , currentCount + count ) ; } 
public String toLocalizedPattern ( ) { return convertPattern ( pattern , PATTERN_CHARS , formatData . getLocalPatternChars ( ) , false ) ; } 
public FacesConfigOrderingType < T > removeAfter ( ) { childNode . removeChildren ( "after" ) ; return this ; } 
public String getNamespaceFromExpandedNameID ( int expandedNameID ) { return m_expandedNameTable . getNamespace ( expandedNameID ) ; } 
public static gov . nasa . jpl . xdata . nba . impoexpo . structs . GamePlayer . Builder newBuilder ( ) { return new gov . nasa . jpl . xdata . nba . impoexpo . structs . GamePlayer . Builder ( ) ; } 
protected void handleErrors ( XMLErrorHandler handler ) throws UseCaseDocumentXMLException { if ( handler . isFatalError ( ) ) { throw handler . getFatalErrors ( ) . iterator ( ) . next ( ) ; } if ( handler . isError ( ) ) { throw handler . getErrors ( ) . iterator ( ) . next ( ) ; } if ( handler . isWarning ( ) ) { throw handler . getWarnings ( ) . iterator ( ) . next ( ) ; } } 
public static boolean writeToFile ( String filename , String message , boolean append ) { boolean result ; BufferedWriter writer ; try { writer = new BufferedWriter ( new FileWriter ( filename , append ) ) ; writer . write ( message ) ; writer . newLine ( ) ; writer . flush ( ) ; writer . close ( ) ; result = true ; } catch ( Exception e ) { result = false ; } return result ; } 
public boolean detectAmazonSilk ( ) { if ( userAgent . indexOf ( engineSilk ) != - 1 ) { return true ; } return false ; } 
public static byte [ ] copyOfRange ( byte [ ] original , int start , int end ) throws ArrayIndexOutOfBoundsException , IllegalArgumentException , NullPointerException { if ( start > end ) { throw new IllegalArgumentException ( ) ; } int originalLength = original . length ; if ( start < 0 || start > originalLength ) { throw new ArrayIndexOutOfBoundsException ( ) ; } int resultLength = end - start ; int copyLength = Math . min ( resultLength , originalLength - start ) ; byte [ ] result = new byte [ resultLength ] ; System . arraycopy ( original , start , result , 0 , copyLength ) ; return result ; } 
protected void setField ( Object o , String name , Object value ) { Field f ; try { f = o . getClass ( ) . getField ( name ) ; f . set ( o , value ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } 
public static boolean isLinkable ( ClassDoc classDoc , Configuration configuration ) { return ( ( classDoc . isIncluded ( ) && configuration . isGeneratedDoc ( classDoc ) ) ) || ( configuration . extern . isExternal ( classDoc ) && ( classDoc . isPublic ( ) || classDoc . isProtected ( ) ) ) ; } 
public void endElement ( String qName ) throws SAXException { if ( ! namespaces ) { if ( contentHandler != null ) { contentHandler . endElement ( "" , "" , qName . intern ( ) ) ; } return ; } String names [ ] = processName ( qName , false , false ) ; if ( contentHandler != null ) { contentHandler . endElement ( names [ 0 ] , names [ 1 ] , names [ 2 ] ) ; Enumeration prefixes = nsSupport . getDeclaredPrefixes ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = ( String ) prefixes . nextElement ( ) ; contentHandler . endPrefixMapping ( prefix ) ; } } nsSupport . popContext ( ) ; } 
public V setValue ( V value ) { if ( value == null ) throw new NullPointerException ( ) ; V v = super . setValue ( value ) ; ConcurrentHashMap . this . put ( getKey ( ) , value ) ; return v ; } 
protected static void dispatchNodeData ( Node node , org . xml . sax . ContentHandler ch , int depth ) throws org . xml . sax . SAXException { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_FRAGMENT_NODE : case Node . DOCUMENT_NODE : case Node . ELEMENT_NODE : { for ( Node child = node . getFirstChild ( ) ; null != child ; child = child . getNextSibling ( ) ) { dispatchNodeData ( child , ch , depth + 1 ) ; } } break ; case Node . PROCESSING_INSTRUCTION_NODE : case Node . COMMENT_NODE : if ( 0 != depth ) break ; case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : case Node . ATTRIBUTE_NODE : String str = node . getNodeValue ( ) ; if ( ch instanceof CharacterNodeHandler ) { ( ( CharacterNodeHandler ) ch ) . characters ( node ) ; } else { ch . characters ( str . toCharArray ( ) , 0 , str . length ( ) ) ; } break ; default : break ; } } 
public static char [ ] toCharArray ( Reader input ) throws IOException { CharArrayWriter sw = new CharArrayWriter ( ) ; copy ( input , sw ) ; return sw . toCharArray ( ) ; } 
public static int readSingleByte ( InputStream in ) throws IOException { byte [ ] buffer = new byte [ 1 ] ; int result = in . read ( buffer , 0 , 1 ) ; return ( result != - 1 ) ? buffer [ 0 ] & 0xff : - 1 ; } 
public static SequenceFile . Reader [ ] getReaders ( Configuration conf , Path dir ) throws IOException { FileSystem fs = dir . getFileSystem ( conf ) ; Path [ ] names = FileUtil . stat2Paths ( fs . listStatus ( dir ) ) ; Arrays . sort ( names ) ; SequenceFile . Reader [ ] parts = new SequenceFile . Reader [ names . length ] ; for ( int i = 0 ; i < names . length ; i ++ ) { parts [ i ] = new SequenceFile . Reader ( fs , names [ i ] , conf ) ; } return parts ; } 
public void sendKeys ( String keysSequence ) { final String [ ] keys = keysSequence . split ( "-" ) ; final int count = keys . length ; final Instrumentation instrumentation = getInstrumentation ( ) ; for ( int i = 0 ; i < count ; i ++ ) { String key = keys [ i ] ; int repeater = key . indexOf ( '*' ) ; int keyCount ; try { keyCount = repeater == - 1 ? 1 : Integer . parseInt ( key . substring ( 0 , repeater ) ) ; } catch ( NumberFormatException e ) { Log . w ( "ActivityTestCase" , "Invalid-repeat-count:-" + key ) ; continue ; } if ( repeater != - 1 ) { key = key . substring ( repeater + 1 ) ; } for ( int j = 0 ; j < keyCount ; j ++ ) { try { final Field keyCodeField = KeyEvent . class . getField ( "KEYCODE_" + key ) ; final int keyCode = keyCodeField . getInt ( null ) ; try { instrumentation . sendKeyDownUpSync ( keyCode ) ; } catch ( SecurityException e ) { } } catch ( NoSuchFieldException e ) { Log . w ( "ActivityTestCase" , "Unknown-keycode:-KEYCODE_" + key ) ; break ; } catch ( IllegalAccessException e ) { Log . w ( "ActivityTestCase" , "Unknown-keycode:-KEYCODE_" + key ) ; break ; } } } instrumentation . waitForIdleSync ( ) ; } 
private void writeSuffix ( ) throws IOException { PrintStream ps = new PrintStream ( out ) ; ps . println ( "-end" ) ; ps . flush ( ) ; } 
public List < PremiseNumber > getPremiseNumber ( ) { if ( premiseNumber == null ) { premiseNumber = new ArrayList < > ( ) ; } return this . premiseNumber ; } 
static long getFlags ( ClassSymbol clazz ) { while ( true ) { try { return clazz . flags ( ) ; } catch ( CompletionFailure ex ) { } } } 
public int saveLayer ( RectF bounds , Paint paint , int saveFlags ) { return native_saveLayer ( mNativeCanvas , bounds , paint != null ? paint . mNativePaint : 0 , saveFlags ) ; } 
public void add ( int index , E element ) { delegate . insertElementAt ( element , index ) ; fireIntervalAdded ( this , index , index ) ; } 
public ObjectStreamField [ ] getFields ( ) { return getFields ( true ) ; } 
public void setShowGrid ( boolean showGrid ) { setShowHorizontalLines ( showGrid ) ; setShowVerticalLines ( showGrid ) ; repaint ( ) ; } 
private static void printVersionAndExit ( ) { System . out . println ( getVersionNumber ( ) . toString ( ) ) ; System . exit ( 0 ) ; } 
public Object getDefaultValue ( ) { return getDefaultValue ( declaringClass , slot ) ; } 
public long getPosition ( ) { if ( currentBlock == null ) { return 0 ; } else { return blocks . size ( ) * blockSize + upto ; } } 
private static Node getLeftChild ( final Node node , final int index ) { return ( node == null ) ? null : node . getLeft ( index ) ; } 
public LockableFileWriter ( String fileName ) throws IOException { this ( fileName , false , null ) ; } 
public void removeLineNumber ( LineNumberGen l ) { line_number_vec . remove ( l ) ; } 
public void addMessageListener ( MessageListener listener ) { messageListenerList . add ( listener ) ; } 
public static long getPlayerEnterGame ( ) { return _playerEnterGameCounter . get ( ) ; } 
void invalidateGeneratedFiles ( ) { if ( mFilename != null ) { new File ( mFilename ) . delete ( ) ; mFilename = null ; } if ( mBitmapFileName != null ) { new File ( mBitmapFileName ) . delete ( ) ; mBitmapFileName = null ; } } 
@ Override public void setEnabled ( boolean enabled ) { super . setEnabled ( enabled ) ; if ( m_HasCustomPanel ) { m_CustomPanel . setEnabled ( enabled ) ; } } 
private Node findDeleteNode ( Node current , int val ) { if ( current == null ) { System . out . println ( "Node-not-found." ) ; return current ; } else if ( current . data == val ) { return deleteCurrentNode ( current ) ; } else if ( current . data > val ) { current . left = findDeleteNode ( current . left , val ) ; } else if ( current . data < val ) { current . right = findDeleteNode ( current . right , val ) ; } current . height = updateHeight ( current ) ; return current = checkBalance ( current ) ; } 
public Object head ( ) { Object ret = ( val == null ? null : ( Object ) val ) ; return ret ; } 
public void addProduct ( Product item ) { stock . add ( item ) ; } 
public static BitmapRegionDecoder newInstance ( String pathName , boolean isShareable ) throws IOException { BitmapRegionDecoder decoder = null ; InputStream stream = null ; try { stream = new FileInputStream ( pathName ) ; decoder = newInstance ( stream , isShareable ) ; } finally { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { } } } return decoder ; } 
public void delete ( ) { event_OnDelete ( ) ; for ( int C = 0 ; C <= vctListeners . size ( ) - 1 ; C ++ ) { EventListener lNext = ( EventListener ) ( vctListeners . get ( C ) ) ; this . removeListener ( lNext ) ; } vctListeners . removeAllElements ( ) ; java . awt . Container contParent = this . getParent ( ) ; if ( contParent != null ) { contParent . remove ( this ) ; } } 
public int lastIndexOf ( String subString , int start ) { int subCount = subString . count ; if ( subCount <= count && start >= 0 ) { if ( subCount > 0 ) { if ( start > count - subCount ) { start = count - subCount ; } char [ ] target = subString . value ; int subOffset = subString . offset ; char firstChar = target [ subOffset ] ; int end = subOffset + subCount ; while ( true ) { int i = lastIndexOf ( firstChar , start ) ; if ( i == - 1 ) { return - 1 ; } int o1 = offset + i , o2 = subOffset ; while ( ++ o2 < end && value [ ++ o1 ] == target [ o2 ] ) { } if ( o2 == end ) { return i ; } start = i - 1 ; } } return start < count ? start : count ; } return - 1 ; } 
protected final int findViewBlock ( int indx ) { int i = blocks . size ( ) / 2 ; int imin = 0 ; int imax = blocks . size ( ) - 1 ; Block b ; do { b = blocks . get ( i ) ; if ( b . viewStart <= indx && b . viewEnd >= indx ) { return i ; } else { if ( b . viewStart < indx ) { imin = i + 1 ; i = imin + ( imax - imin ) / 2 ; } else { imax = i - 1 ; i = imin + ( imax - imin ) / 2 ; } } } while ( imin <= imax ) ; if ( i >= blocks . size ( ) ) { return - blocks . size ( ) - 1 ; } if ( blocks . get ( i ) != b ) { if ( blocks . get ( i - 1 ) == b ) { -- i ; } else if ( blocks . get ( i + 1 ) == b ) { ++ i ; } } if ( indx > b . viewStart ) { i ++ ; if ( i < blocks . size ( ) ) { } } return - i - 1 ; } 
protected void setGeneralWarningWithSpecialInfo ( Properties props , String resultInfo ) { try { resultInfo = resultInfo != null ? resultInfo : SoloMessage . NULL_VALUE ; props . setProperty ( SoloMessage . KEY_ISREMOTERESULT , String . valueOf ( true ) ) ; props . setProperty ( SoloMessage . KEY_REMOTERESULTCODE , SoloMessage . STATUS_REMOTERESULT_WARN_STRING ) ; props . setProperty ( SoloMessage . KEY_REMOTERESULTINFO , resultInfo ) ; } catch ( Exception e ) { String debugmsg = TAG + ".setGeneralWarningWithSpecialInfo()-" ; debug ( debugmsg + "-Met-Exception=" + e . getMessage ( ) ) ; } } 
public void start ( ) { if ( m_thread == null || ! m_thread . isAlive ( ) ) { m_thread = new Thread ( this ) ; m_isRunning = true ; m_thread . start ( ) ; } } 
public void removeCritters ( Panel panel ) { for ( int k = 0 ; k < panel . getComponentCount ( ) ; k ++ ) { try { Object sd1 = ( ( JPanel ) panel . getComponent ( k ) ) . getComponents ( ) [ 1 ] ; if ( ( ( JLabel ) sd1 ) . getName ( ) . equalsIgnoreCase ( "critter" ) ) { ( ( JPanel ) panel . getComponent ( k ) ) . remove ( 1 ) ; } } catch ( Exception e ) { continue ; } } } 
public String getLocalName ( ) { if ( _state == START_ELEMENT || _state == END_ELEMENT ) { String localName = _current . getLocalName ( ) ; return localName != null ? localName : QName . valueOf ( _current . getNodeName ( ) ) . getLocalPart ( ) ; } else if ( _state == ENTITY_REFERENCE ) { return _current . getNodeName ( ) ; } throw new IllegalStateException ( "DOMStreamReader:-getAttributeValue()-called-in-illegal-state" ) ; } 
protected float getLeftFadingEdgeStrength ( ) { return computeHorizontalScrollOffset ( ) > 0 ? 1.0f : 0.0f ; } 
public BigDecimal negate ( MathContext mc ) { BigDecimal result = negate ( ) ; result . inplaceRound ( mc ) ; return result ; } 
static public MethodHandle invoker ( MethodType type ) { return type . invokers ( ) . generalInvoker ( ) ; } 
public void removeAllChildren ( ) { for ( int i = getChildCount ( ) - 1 ; i >= 0 ; i -- ) remove ( i ) ; } 
public InputStreamReader ( InputStream in , final String enc ) throws UnsupportedEncodingException { super ( in ) ; if ( enc == null ) { throw new NullPointerException ( ) ; } this . in = in ; try { decoder = Charset . forName ( enc ) . newDecoder ( ) . onMalformedInput ( CodingErrorAction . REPLACE ) . onUnmappableCharacter ( CodingErrorAction . REPLACE ) ; } catch ( IllegalArgumentException e ) { throw ( UnsupportedEncodingException ) new UnsupportedEncodingException ( enc ) . initCause ( e ) ; } bytes . limit ( 0 ) ; } 
public List < UndInstrmtGrpBlockT > getUndly ( ) { if ( undly == null ) { undly = new ArrayList < UndInstrmtGrpBlockT > ( ) ; } return this . undly ; } 
static private boolean matchingExitNode ( Node n , int type , String labelName ) { if ( n . getType ( ) == type ) { if ( type == Token . RETURN ) { return ! n . hasChildren ( ) ; } else { if ( labelName == null ) { return ! n . hasChildren ( ) ; } else { return n . hasChildren ( ) && labelName . equals ( n . getFirstChild ( ) . getString ( ) ) ; } } } return false ; } 
public void _read ( InputStream input ) { value = input . read_boolean ( ) ; } 
private ArrayList < HashMap < String , String >> createTestList ( int colCount , int rowCount , String prefix ) { ArrayList < HashMap < String , String >> list = new ArrayList < HashMap < String , String >> ( ) ; String [ ] columns = new String [ colCount ] ; for ( int i = 0 ; i < colCount ; i ++ ) { columns [ i ] = "column" + i ; } for ( int i = 0 ; i < rowCount ; i ++ ) { HashMap < String , String > row = new HashMap < String , String > ( ) ; for ( int j = 0 ; j < colCount ; j ++ ) { row . put ( columns [ j ] , prefix + i + "" + j ) ; } list . add ( row ) ; } return list ; } 
private boolean isIdentifierChar ( ) { if ( _len >= 0 && _pos >= _len ) { return false ; } char ch = _working [ _pos ] ; return Character . isUnicodeIdentifierStart ( ch ) || Character . isDigit ( ch ) || Utils . isIdentifierHelperChar ( ch ) ; } 
public long getInputFiles ( long minSize , Collection < FileStatus > files ) throws IOException { updateLock . readLock ( ) . lock ( ) ; try { return root . selectFiles ( minSize , files ) ; } finally { updateLock . readLock ( ) . unlock ( ) ; } } 
private List < Element > getListOfBooksSplitByDate ( Breadcrumbs pBreadcrumbs , Map < DateRange , List < Book >> mapOfBooksByDate , boolean inSubDir , String baseTitle , String baseUrn , String baseFilename , String icon , Option ... options ) throws IOException { if ( Helper . isNullOrEmpty ( mapOfBooksByDate ) ) return null ; String sTitle = baseTitle ; if ( Helper . isNotNullOrEmpty ( sTitle ) ) sTitle = sTitle + ",-" ; if ( pBreadcrumbs . size ( ) > 1 ) inSubDir = true ; List < Element > result = new LinkedList < Element > ( ) ; SortedSet < DateRange > ranges = new TreeSet < DateRange > ( mapOfBooksByDate . keySet ( ) ) ; for ( DateRange range : ranges ) { String rangeFilename = baseFilename + Constants . TYPE_SEPARATOR + range ; String rangeUrn = Helper . getSplitString ( baseUrn , range . toString ( ) , Constants . URN_SEPARATOR ) ; String rangeTitle = LocalizationHelper . getEnumConstantHumanName ( range ) ; List < Book > booksInThisRange = mapOfBooksByDate . get ( range ) ; String summary = Summarizer . summarizeBooks ( booksInThisRange ) ; Element element = null ; if ( booksInThisRange . size ( ) > 0 ) { element = getListOfBooks ( pBreadcrumbs , booksInThisRange , true , 0 , rangeTitle , summary , rangeUrn , rangeFilename , SplitOption . Paginate , icon , null , options ) ; } if ( element != null ) result . add ( element ) ; } return result ; } 
private Method findMethod ( Class clazz , String name ) { Method [ ] methods = clazz . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { if ( methods [ i ] . getName ( ) . equalsIgnoreCase ( name ) ) { Method method = methods [ i ] ; Class [ ] params = method . getParameterTypes ( ) ; if ( params . length == 1 ) { return method ; } } } return null ; } 
public static < P extends TestedProduct < ? >> P create ( Class < P > testedProductClass , ProductInstance productInstance , TesterFactory < ? > testerFactory ) { try { Constructor < P > c = testedProductClass . getConstructor ( TesterFactory . class , ProductInstance . class ) ; return c . newInstance ( testerFactory , productInstance ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException ( e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( e ) ; } catch ( InstantiationException e ) { throw new RuntimeException ( e ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } } 
public static Element create ( ) { com . google . gwt . user . client . Element span = DOM . createSpan ( ) ; span . setAttribute ( "type" , "docketNumber" ) ; span . setAttribute ( "ns" , "http://docs.oasis-open.org/legaldocml/ns/akn/3.0/CSD02" ) ; span . setClassName ( "widget-docketNumber" ) ; return span ; } 
public static Stroke readStroke ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { if ( stream == null ) { throw new IllegalArgumentException ( "Null-'stream'-argument." ) ; } Stroke result = null ; boolean isNull = stream . readBoolean ( ) ; if ( ! isNull ) { Class c = ( Class ) stream . readObject ( ) ; if ( c . equals ( BasicStroke . class ) ) { float width = stream . readFloat ( ) ; int cap = stream . readInt ( ) ; int join = stream . readInt ( ) ; float miterLimit = stream . readFloat ( ) ; float [ ] dash = ( float [ ] ) stream . readObject ( ) ; float dashPhase = stream . readFloat ( ) ; result = new BasicStroke ( width , cap , join , miterLimit , dash , dashPhase ) ; } else { result = ( Stroke ) stream . readObject ( ) ; } } return result ; } 
public List < String > findRelationsOfType ( String relationTypeName ) throws IllegalArgumentException , RelationTypeNotFoundException { if ( relationTypeName == null ) { String excMsg = "Invalid-parameter." ; throw new IllegalArgumentException ( excMsg ) ; } RELATION_LOGGER . entering ( RelationService . class . getName ( ) , "findRelationsOfType" ) ; RelationType relType = getRelationType ( relationTypeName ) ; List < String > result ; synchronized ( myRelType2RelIdsMap ) { List < String > result1 = myRelType2RelIdsMap . get ( relationTypeName ) ; if ( result1 == null ) result = new ArrayList < String > ( ) ; else result = new ArrayList < String > ( result1 ) ; } RELATION_LOGGER . exiting ( RelationService . class . getName ( ) , "findRelationsOfType" ) ; return result ; } 
public void refresh ( int opt ) { if ( opt == ALL_VIEWS ) { JInternalFrame frames [ ] = getAllFrames ( ) ; if ( frames != null ) { for ( JInternalFrame frame : frames ) { frame . repaint ( ) ; } } } else if ( opt == TOP_VIEW ) { JInternalFrame frame = getTopFrame ( ) ; if ( frame != null ) { frame . repaint ( ) ; } } } 
protected Map getSource ( ) { try { Method getmap = ServletRequest . class . getMethod ( "getParameterMap" , null ) ; return ( Map ) getmap . invoke ( getRequest ( ) , null ) ; } catch ( NoSuchMethodException nsme ) { throw new UnsupportedOperationException ( "This-method-is-only-supported-with-Servlet-2.3-and-higher." ) ; } catch ( IllegalAccessException iae ) { throw new UnsupportedOperationException ( "ServletRequest.getParameterMap()-is-restricted---" + iae ) ; } catch ( InvocationTargetException ite ) { throw new UnsupportedOperationException ( "ServletRequest.getParameterMap()-threw-an-exception---" + ite ) ; } } 
public static Collection < String > getPluginBlacklist ( ) { String pluginlist = getString ( "PLUGIN_BLACKLIST" ) . replace ( "-" , "" ) . toLowerCase ( ) ; StringTokenizer tokenizer = new StringTokenizer ( pluginlist , "," ) ; ArrayList < String > list = new ArrayList < String > ( ) ; while ( tokenizer . hasMoreTokens ( ) ) { list . add ( tokenizer . nextToken ( ) ) ; } StringTokenizer clazztokenz = new StringTokenizer ( getString ( "PLUGIN_BLACKLIST_CLASS" ) . replace ( "-" , "" ) , "," ) ; while ( clazztokenz . hasMoreTokens ( ) ) { list . add ( clazztokenz . nextToken ( ) ) ; } return list ; } 
public static List < double [ ] > sampleSliceHistory ( int numSliceIter , final double [ ] counts , final double [ ] etaMean , final double etaVar [ ] ) { final int K = etaMean . length ; Function < double [ ] , Double > lDensity = new Function < double [ ] , Double > ( ) { @ Override public Double apply ( double [ ] eta ) { return calcUnnormLogprob ( eta , counts , etaMean , etaVar ) ; } } ; double [ ] widths = new double [ K ] ; Arrays . fill ( widths , 10 ) ; double [ ] init = new double [ K ] ; return MCMC . slice_sample ( lDensity , init , widths , numSliceIter ) ; } 
List < Purchase > getAllPurchases ( ) { return new ArrayList < Purchase > ( mPurchaseMap . values ( ) ) ; } 
public static String readAsciiLine ( InputStream in ) throws IOException { StringBuilder result = new StringBuilder ( 80 ) ; while ( true ) { int c = in . read ( ) ; if ( c == - 1 ) { throw new EOFException ( ) ; } else if ( c == '|n' ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > 0 && result . charAt ( length - 1 ) == '|r' ) { result . setLength ( length - 1 ) ; } return result . toString ( ) ; } 
@ VisibleForTesting void writeDistance ( double distance , StringBuilder builder , int resId , String lineBreak ) { double distanceInKm = distance * UnitConversions . M_TO_KM ; double distanceInMi = distanceInKm * UnitConversions . KM_TO_MI ; builder . append ( context . getString ( resId , distanceInKm , distanceInMi ) ) ; builder . append ( lineBreak ) ; } 
public String getType ( int index ) { ListNode node = getListNodeAt ( index ) ; return ( node != null ) ? node . type : null ; } 
public int getC_Currency_ID ( ) { Integer ii = ( Integer ) get_Value ( COLUMNNAME_C_Currency_ID ) ; if ( ii == null ) return 0 ; return ii . intValue ( ) ; } 
static private String getTemporaryFilename ( final String url ) { return Base64 . encodeToString ( url . getBytes ( ) , Base64 . NO_WRAP ) ; } 
public synchronized DatagramPacket removePacket ( ) { DatagramPacket packet ; if ( ( packet = queue . poll ( ) ) != null ) { decreaseSize ( packet . getLength ( ) ) ; return packet ; } else { return null ; } } 
public static no . mesan . miniprosjekt . kommunikasjon . domain . AvroOs . Builder newBuilder ( ) { return new no . mesan . miniprosjekt . kommunikasjon . domain . AvroOs . Builder ( ) ; } 
public void clearAccessibleSelection ( ) { clearSelection ( ) ; } 
public void addLast ( E e ) { if ( e == null ) throw new NullPointerException ( ) ; elements [ tail ] = e ; if ( ( tail = ( tail + 1 ) & ( elements . length - 1 ) ) == head ) doubleCapacity ( ) ; } 
public ThreadGroup getThreadGroup ( ) { return Thread . currentThread ( ) . getThreadGroup ( ) ; } 
public static int getThreadsAllocatedCount ( ) { return VMThread . getThreadsAllocatedCount ( ) ; } 
public BigDecimal divide ( BigDecimal divisor ) { if ( divisor . signum ( ) == 0 ) { if ( this . signum ( ) == 0 ) throw new ArithmeticException ( "Division-undefined" ) ; throw new ArithmeticException ( "Division-by-zero" ) ; } int preferredScale = ( int ) Math . max ( Math . min ( ( long ) this . scale ( ) - divisor . scale ( ) , Integer . MAX_VALUE ) , Integer . MIN_VALUE ) ; if ( this . signum ( ) == 0 ) return new BigDecimal ( 0 , preferredScale ) ; else { this . inflate ( ) ; divisor . inflate ( ) ; MathContext mc = new MathContext ( ( int ) Math . min ( this . precision ( ) + ( long ) Math . ceil ( 10.0 * divisor . precision ( ) / 3.0 ) , Integer . MAX_VALUE ) , RoundingMode . UNNECESSARY ) ; BigDecimal quotient ; try { quotient = this . divide ( divisor , mc ) ; } catch ( ArithmeticException e ) { throw new ArithmeticException ( "Non-terminating-decimal-expansion;-" + "no-exact-representable-decimal-result." ) ; } int quotientScale = quotient . scale ( ) ; if ( preferredScale > quotientScale ) return quotient . setScale ( preferredScale ) ; return quotient ; } } 
public JPTOps transverse ( ) { String oper ; StringBuffer buf = new StringBuffer ( ) ; iCmdArgs . add ( "-transverse" ) ; if ( buf . length ( ) > 0 ) { iCmdArgs . add ( buf . toString ( ) ) ; } return this ; } 
public String toString ( ) { return toList ( ) . toString ( ) ; } 
private int findNext ( BitSet bits , int value , Calendar calendar , int field , int nextField , List < Integer > lowerOrders ) { int nextValue = bits . nextSetBit ( value ) ; if ( nextValue == - 1 ) { calendar . add ( nextField , 1 ) ; reset ( calendar , Arrays . asList ( field ) ) ; nextValue = bits . nextSetBit ( 0 ) ; } if ( nextValue != value ) { calendar . set ( field , nextValue ) ; reset ( calendar , lowerOrders ) ; } return nextValue ; } 
public String getQName ( int i ) { return qAtts . getName ( i ) . intern ( ) ; } 
public long getSmallestSelectionIndex ( ) { long index = Math . min ( leadSelectionIndex , anchorSelectionIndex ) ; return index < 0 ? 0 : index ; } 
public void removeClickingListener ( OnWheelClickedListener listener ) { clickingListeners . remove ( listener ) ; } 
private void processPendingText ( boolean ignorable ) throws SAXException { if ( ignorable && text . toString ( ) . trim ( ) . length ( ) == 0 ) ; else currentHandler . text ( text . toString ( ) ) ; if ( text . length ( ) > 1024 ) text = new StringBuffer ( ) ; else text . setLength ( 0 ) ; } 
@ Override public SnmpInformRequest snmpInformRequest ( InetAddress addr , String cs , SnmpInformHandler cb , SnmpOid trapOid , SnmpVarBindList varBindList ) throws IllegalStateException , IOException , SnmpStatusException { return snmpInformRequest ( addr , getInformPort ( ) , cs , cb , trapOid , varBindList ) ; } 
public Set < String > getReferenceSystems ( ) { Set < String > rVal = Sets . newHashSet ( ) ; for ( File refFolder : baseFolder . listFiles ( ) ) { String refSysName = refFolder . getName ( ) ; if ( hasReferenceSystem ( refSysName ) ) { rVal . add ( refSysName ) ; } } return rVal ; } 
public void setEndRule ( int month , int dayOfMonth , int time ) { endMonth = month ; endDay = dayOfMonth ; endDayOfWeek = 0 ; endTime = time ; setEndMode ( ) ; } 
public static void slurDown ( Part part , int numberOfNotes ) { if ( part == null ) { return ; } Enumeration enum1 = part . getPhraseList ( ) . elements ( ) ; while ( enum1 . hasMoreElements ( ) ) { Phrase phr = ( Phrase ) enum1 . nextElement ( ) ; slurDown ( phr , numberOfNotes ) ; } } 
@ XmlElementDecl ( namespace = "http://www.w3.org/1998/Math/MathML" , name = "geq" ) public JAXBElement < RelationsType > createGeq ( RelationsType value ) { return new JAXBElement < RelationsType > ( _Geq_QNAME , RelationsType . class , null , value ) ; } 
public String replaceFirst ( String regex , String replacement ) { return Pattern . compile ( regex ) . matcher ( this ) . replaceFirst ( replacement ) ; } 
static Point convertScreenLocationToParent ( Container parent , int x , int y ) { for ( Container p = parent ; p != null ; p = p . getParent ( ) ) { if ( p instanceof Window ) { Point point = new Point ( x , y ) ; SwingUtilities . convertPointFromScreen ( point , parent ) ; return point ; } } throw new Error ( "convertScreenLocationToParent:-no-window-ancestor" ) ; } 
public final void filter ( CharSequence constraint ) { filter ( constraint , null ) ; } 
@ Override public void setReloadable ( boolean reloadable ) { boolean oldReloadable = this . reloadable ; this . reloadable = reloadable ; support . firePropertyChange ( "reloadable" , Boolean . valueOf ( oldReloadable ) , Boolean . valueOf ( this . reloadable ) ) ; } 
public int hashCode ( ) { int result = 0 ; int increment = Math . min ( 3 , values . length / 16 ) ; for ( int i = 0 ; i < values . length ; i += increment ) { result = result * 37 + values [ i ] ; } return result ; } 
public int getValueCount ( final Object key ) { if ( key == null ) { throw new NullPointerException ( "Key-must-not-be-null." ) ; } final List list = ( List ) this . table . get ( key ) ; if ( list != null ) { return list . size ( ) ; } return 0 ; } 
public void setTitle ( String title ) { if ( _title == null ) _title = new Content ( ) ; _title . setValue ( title ) ; } 
public void removeGuide ( final AbstractWidgetModel model , final boolean horizontal ) { if ( horizontal ) { _horizontalGuides . remove ( model ) ; } else { _verticalGuides . remove ( model ) ; } } 
public void waitFor ( long timeout ) throws InterruptedException { m_latch . await ( timeout , TimeUnit . MILLISECONDS ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
@ Requires ( "type-!=-null" ) @ Ensures ( "result-!=-null" ) protected static String getDefaultValue ( TypeName type ) { String name = type . getDeclaredName ( ) ; if ( name . equals ( "boolean" ) ) { return "false" ; } else if ( numericTypes . contains ( name ) ) { return "(" + name + ")0" ; } else { return "(" + name + ")null" ; } } 
public void setNavigationBarTintEnabled ( boolean enabled ) { mNavBarTintEnabled = enabled ; if ( mNavBarAvailable ) { mNavBarTintView . setVisibility ( enabled ? View . VISIBLE : View . GONE ) ; } } 
public List getContent ( ) { return new NodeList ( super . getContent ( ) , false ) ; } 
public static Element create ( ) { com . google . gwt . user . client . Element span = DOM . createSpan ( ) ; span . setAttribute ( "type" , "subdivision" ) ; span . setAttribute ( "ns" , "http://docs.oasis-open.org/legaldocml/ns/akn/3.0/CSD02" ) ; span . setClassName ( "widget-subdivision" ) ; return span ; } 
public DefaultMutableTreeNode addObject ( Object child ) { DefaultMutableTreeNode parentNode = null ; TreePath parentPath = tree . getSelectionPath ( ) ; if ( parentPath == null ) { parentNode = radice ; } else { parentNode = ( DefaultMutableTreeNode ) ( parentPath . getLastPathComponent ( ) ) ; } return addObject ( parentNode , child , true ) ; } 
public synchronized int getItemCount ( ) { return mCategories . size ( ) ; } 
private InetSocketAddress nextInetSocketAddress ( ) throws UnknownHostException { InetSocketAddress result = new InetSocketAddress ( socketAddresses [ nextSocketAddressIndex ++ ] , socketPort ) ; if ( nextSocketAddressIndex == socketAddresses . length ) { socketAddresses = null ; nextSocketAddressIndex = 0 ; } return result ; } 
private final ActivityRecord moveActivityToFrontLocked ( int where ) { ActivityRecord newTop = mHistory . remove ( where ) ; int top = mHistory . size ( ) ; ActivityRecord oldTop = mHistory . get ( top - 1 ) ; if ( DEBUG_ADD_REMOVE ) { RuntimeException here = new RuntimeException ( "here" ) ; here . fillInStackTrace ( ) ; Slog . i ( TAG , "Removing-and-adding-activity-" + newTop + "-to-stack-at-" + top , here ) ; } mHistory . add ( top , newTop ) ; oldTop . frontOfTask = false ; newTop . frontOfTask = true ; return newTop ; } 
private void assignTileVariablesFromServer ( ) { ArrayList < String > listOfTileTypes = Network . serverListOfTypes ; ArrayList < Integer > listOfYieldNumbers = Network . serverListOfYieldNumbers ; for ( Tile tile : map ) { if ( Math . abs ( tile . q ) == 3 || Math . abs ( tile . r ) == 3 || Math . abs ( tile . s ) == 3 ) { tile . setTileType ( "Water" ) ; } else { String type ; if ( tile . getTileType ( ) . equalsIgnoreCase ( "Default" ) ) { if ( ! listOfTileTypes . isEmpty ( ) ) { type = listOfTileTypes . remove ( listOfTileTypes . size ( ) - 1 ) ; tile . setTileType ( type ) ; } } if ( ! listOfYieldNumbers . isEmpty ( ) ) { if ( ! tile . getTileType ( ) . equalsIgnoreCase ( "desert" ) ) { int yieldNum = listOfYieldNumbers . remove ( listOfYieldNumbers . size ( ) - 1 ) ; tile . setYieldNumber ( yieldNum ) ; } } } } } 
public void startStatementLeakTracing ( Statement stmt , StatementLeakListener listener ) { synchronized ( statementLeakLock ) { if ( ! statementLeakThreadStackHashMap . containsKey ( stmt ) ) { statementLeakThreadStackHashMap . put ( stmt , Thread . currentThread ( ) . getStackTrace ( ) ) ; StatementLeakTask statementLeakTask = new StatementLeakTask ( stmt ) ; statementLeakTimerTaskHashMap . put ( stmt , statementLeakTask ) ; registerListener ( stmt , listener ) ; if ( timer != null ) { timer . schedule ( statementLeakTask , statementLeakTimeoutInMillis ) ; if ( _logger . isLoggable ( Level . FINEST ) ) { _logger . finest ( "Scheduled-Statement-leak-tracing-timer-task" ) ; } } } } } 
@ SuppressWarnings ( "unchecked" ) public static < T , U > T [ ] copyOfRange ( U [ ] original , int start , int end , Class < ? extends T [ ] > newType ) { if ( start > end ) { throw new IllegalArgumentException ( ) ; } int originalLength = original . length ; if ( start < 0 || start > originalLength ) { throw new ArrayIndexOutOfBoundsException ( ) ; } int resultLength = end - start ; int copyLength = Math . min ( resultLength , originalLength - start ) ; T [ ] result = ( T [ ] ) Array . newInstance ( newType . getComponentType ( ) , resultLength ) ; System . arraycopy ( original , start , result , 0 , copyLength ) ; return result ; } 
public void saveSystem ( ) { int resp = chooser . showSaveDialog ( this ) ; if ( resp == JFileChooser . APPROVE_OPTION ) { File file = chooser . getSelectedFile ( ) ; if ( ! file . getName ( ) . endsWith ( ".xml" ) ) { file = new File ( file . getAbsolutePath ( ) + ".xml" ) ; } try { ParticleIO . saveConfiguredSystem ( file , game . getSystem ( ) ) ; } catch ( IOException e ) { Log . error ( e ) ; JOptionPane . showMessageDialog ( this , e . getMessage ( ) ) ; } } } 
public static void dragViewToTop ( InstrumentationTestCase test , View v , int stepCount ) { int [ ] xy = new int [ 2 ] ; v . getLocationOnScreen ( xy ) ; final int viewWidth = v . getWidth ( ) ; final int viewHeight = v . getHeight ( ) ; final float x = xy [ 0 ] + ( viewWidth / 2.0f ) ; float fromY = xy [ 1 ] + ( viewHeight / 2.0f ) ; float toY = 0 ; drag ( test , x , x , fromY , toY , stepCount ) ; } 
final void close ( boolean allMenusAreClosing ) { if ( mIsClosing ) return ; mIsClosing = true ; for ( WeakReference < MenuPresenter > ref : mPresenters ) { final MenuPresenter presenter = ref . get ( ) ; if ( presenter == null ) { mPresenters . remove ( ref ) ; } else { presenter . onCloseMenu ( this , allMenusAreClosing ) ; } } mIsClosing = false ; } 
private void splitRequest ( SnmpPduRequest req ) { int nbAgents = mibs . size ( ) ; SnmpMibAgent agent = mibs . firstElement ( ) ; if ( nbAgents == 1 ) { subs . put ( agent , new SnmpSubRequestHandler ( agent , req , true ) ) ; return ; } if ( req . type == pduGetNextRequestPdu ) { for ( Enumeration < SnmpMibAgent > e = mibs . elements ( ) ; e . hasMoreElements ( ) ; ) { final SnmpMibAgent ag = e . nextElement ( ) ; subs . put ( ag , new SnmpSubNextRequestHandler ( adaptor , ag , req ) ) ; } return ; } int nbReqs = req . varBindList . length ; SnmpVarBind [ ] vars = req . varBindList ; SnmpSubRequestHandler sub ; for ( int i = 0 ; i < nbReqs ; i ++ ) { agent = root . getAgentMib ( vars [ i ] . oid ) ; sub = subs . get ( agent ) ; if ( sub == null ) { sub = new SnmpSubRequestHandler ( agent , req ) ; subs . put ( agent , sub ) ; } sub . updateRequest ( vars [ i ] , i ) ; } } 
public static int wtf ( String tag , Throwable tr ) { return wtf ( LOG_ID_MAIN , tag , tr . getMessage ( ) , tr , false ) ; } 
public synchronized void addComponentListener ( ComponentListener l ) { if ( l == null ) { return ; } componentListener = AWTEventMulticaster . add ( componentListener , l ) ; newEventsOnly = true ; } 
public void setOutput ( java . io . Writer writer ) { fOut = writer instanceof PrintWriter ? ( PrintWriter ) writer : new PrintWriter ( writer ) ; } 
public XfdfReader ( String filename ) throws IOException { FileInputStream fin = null ; try { fin = new FileInputStream ( filename ) ; SimpleXMLParser . parse ( this , fin ) ; } finally { try { fin . close ( ) ; } catch ( Exception e ) { } } } 
public static void readLocalisation ( String fileName , Map < String , String > map ) throws IOException { BufferedReader in = getReader ( fileName ) ; String line = in . readLine ( ) ; while ( line != null ) { line = line . replaceAll ( "#[^"]*$" , "" ) ; line = line . trim ( ) ; line = line . replaceFirst ( ":|d*-" , ":" ) ; int index = line . indexOf ( ":" ) ; if ( index == - 1 ) { line = in . readLine ( ) ; continue ; } String key = line . substring ( 0 , index ) . toLowerCase ( ) ; String value = line . substring ( index + 1 ) ; value = value . replaceAll ( "^"(.*)"$" , "$1" ) ; map . put ( key , value ) ; line = in . readLine ( ) ; } } 
public Object construct ( ProgressMonitor pmw ) { Thread currentThread = Thread . currentThread ( ) ; currentThread . setPriority ( currentThread . getPriority ( ) - 1 ) ; result = ProjectBrowser . getInstance ( ) . trySave ( overwrite , file , pmw ) ; return null ; } 
public static void w ( String tag , String s , Object ... args ) { if ( LOG . WARN >= LOGLEVEL ) Log . w ( tag , String . format ( s , args ) ) ; } 
public void outputNodePush ( ) { nameSpaces ++ ; push ( ) ; } 
public float getFloat ( String property , float def ) { Object value = super . get ( property ) ; if ( value == null ) { return def ; } if ( value instanceof Float ) { return ( ( Float ) value ) . floatValue ( ) ; } throw new TypeException ( property , value , "float" ) ; } 
public void setOptions ( String [ ] options ) throws Exception { resetOptions ( ) ; String optionString ; optionString = Utils . getOption ( 'R' , options ) ; if ( optionString . length ( ) != 0 ) { double temp ; temp = Double . valueOf ( optionString ) . doubleValue ( ) ; setRank ( temp ) ; } optionString = Utils . getOption ( 'A' , options ) ; if ( optionString . length ( ) != 0 ) { setMaximumAttributeNames ( Integer . parseInt ( optionString ) ) ; } setNormalize ( Utils . getFlag ( 'N' , options ) ) ; } 
public void refresh ( ) { this . frameCount = 0 ; this . lastCount = System . currentTimeMillis ( ) ; } 
public String getNamespaceForPrefix ( String prefix , Element namespaceContext ) { int type ; Node parent = namespaceContext ; String namespace = null ; if ( prefix . equals ( "xml" ) ) { namespace = QName . S_XMLNAMESPACEURI ; } else if ( prefix . equals ( "xmlns" ) ) { namespace = "http://www.w3.org/2000/xmlns/" ; } else { String declname = ( prefix == "" ) ? "xmlns" : "xmlns:" + prefix ; while ( ( null != parent ) && ( null == namespace ) && ( ( ( type = parent . getNodeType ( ) ) == Node . ELEMENT_NODE ) || ( type == Node . ENTITY_REFERENCE_NODE ) ) ) { if ( type == Node . ELEMENT_NODE ) { Attr attr = ( ( Element ) parent ) . getAttributeNode ( declname ) ; if ( attr != null ) { namespace = attr . getNodeValue ( ) ; break ; } } parent = getParentOfNode ( parent ) ; } } return namespace ; } 
protected static void suspend ( Node node ) { node . setFailState ( Fallible . DOWN ) ; } 
public void clearDomainMarkers ( int index ) { Integer key = new Integer ( index ) ; if ( this . backgroundDomainMarkers != null ) { Collection markers = ( Collection ) this . backgroundDomainMarkers . get ( key ) ; if ( markers != null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . hasNext ( ) ) { Marker m = ( Marker ) iterator . next ( ) ; m . removeChangeListener ( this ) ; } markers . clear ( ) ; } } if ( this . foregroundRangeMarkers != null ) { Collection markers = ( Collection ) this . foregroundDomainMarkers . get ( key ) ; if ( markers != null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . hasNext ( ) ) { Marker m = ( Marker ) iterator . next ( ) ; m . removeChangeListener ( this ) ; } markers . clear ( ) ; } } fireChangeEvent ( ) ; } 
public boolean getBoolean ( String key ) throws JSONException { Object o = get ( key ) ; if ( o . equals ( Boolean . FALSE ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( o . equals ( Boolean . TRUE ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "]-is-not-a-Boolean." ) ; } 
private boolean isLevelOfGray ( Color color ) { return color . getRed ( ) == color . getBlue ( ) && color . getRed ( ) == color . getGreen ( ) ; } 
private static String joinPackages ( String [ ] packages ) { boolean first = true ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < packages . length ; i ++ ) { String pkg = packages [ i ] ; if ( sb . length ( ) + pkg . length ( ) + 1 < LOG_PACKAGES_MAX_LENGTH ) { if ( ! first ) { sb . append ( ',' ) ; } else { first = false ; } sb . append ( pkg ) ; } else if ( sb . length ( ) >= LOG_PACKAGES_SUFFICIENT_LENGTH ) { return sb . toString ( ) ; } } if ( sb . length ( ) == 0 && packages . length > 0 ) { String pkg = packages [ 0 ] ; return pkg . substring ( pkg . length ( ) - LOG_PACKAGES_MAX_LENGTH + 1 ) + '-' ; } return null ; } 
private void showErrorIconHax ( Drawable icon ) { if ( icon == null ) return ; if ( Build . VERSION . SDK_INT != Build . VERSION_CODES . JELLY_BEAN && Build . VERSION . SDK_INT != Build . VERSION_CODES . JELLY_BEAN_MR1 ) return ; try { Class < ? > textview = Class . forName ( "android.widget.TextView" ) ; Field tEditor = textview . getDeclaredField ( "mEditor" ) ; tEditor . setAccessible ( true ) ; Class < ? > editor = Class . forName ( "android.widget.Editor" ) ; Method privateShowError = editor . getDeclaredMethod ( "setErrorIcon" , Drawable . class ) ; privateShowError . setAccessible ( true ) ; privateShowError . invoke ( tEditor . get ( this ) , icon ) ; } catch ( Exception e ) { } } 
public static int binarySearch ( short [ ] array , short value ) { return binarySearch ( array , 0 , array . length , value ) ; } 
public ImmutableSet < ClassInfo > getTopLevelClasses ( String packageName ) { checkNotNull ( packageName ) ; ImmutableSet . Builder < ClassInfo > builder = ImmutableSet . builder ( ) ; for ( ClassInfo classInfo : getTopLevelClasses ( ) ) { if ( classInfo . getPackageName ( ) . equals ( packageName ) ) { builder . add ( classInfo ) ; } } return builder . build ( ) ; } 
public void flip ( int from , int to ) { if ( from < 0 || from > to ) throw new IndexOutOfBoundsException ( ) ; if ( from == to ) return ; int lo_offset = from >>> 6 ; int hi_offset = to >>> 6 ; ensure ( hi_offset ) ; if ( lo_offset == hi_offset ) { bits [ hi_offset ] ^= ( - 1L << from ) & ( ( 1L << to ) - 1 ) ; return ; } bits [ lo_offset ] ^= - 1L << from ; bits [ hi_offset ] ^= ( 1L << to ) - 1 ; for ( int i = lo_offset + 1 ; i < hi_offset ; i ++ ) bits [ i ] ^= - 1 ; } 
private JTextField getHostField ( ) { if ( hostField == null ) { hostField = new JTextField ( ) ; hostField . setSize ( 150 , 20 ) ; hostField . setText ( host ) ; hostField . setEditable ( true ) ; hostField . setPreferredSize ( new Dimension ( 150 , 20 ) ) ; hostField . setLocation ( 132 , 15 ) ; hostField . setSelectionStart ( 0 ) ; hostField . setSelectionEnd ( hostField . getText ( ) . length ( ) ) ; } return hostField ; } 
private static Character parseNumber ( PushbackString input ) { StringBuilder sb = new StringBuilder ( ) ; Character c ; while ( ( c = input . next ( ) ) != null ) { if ( c == ';' ) break ; if ( ! Character . isDigit ( c . charValue ( ) ) ) return null ; sb . append ( c ) ; } if ( c == null ) return null ; if ( sb . length ( ) <= 0 ) return null ; try { return int2char ( Integer . parseInt ( sb . toString ( ) ) ) ; } catch ( NumberFormatException e ) { return null ; } } 
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( 5 ) ; newVector . addElement ( new Option ( "-The-full-class-name-of-the-classifier.-" + "-eg:-weka.classifiers.bayes.NaiveBayes" , "W" , 1 , "-W-<class-name>" ) ) ; newVector . addElement ( new Option ( "-The-index-of-the-class-for-which-IR-statistics-" + "-are-to-be-output.-(default-1)" , "C" , 1 , "-C-<index>" ) ) ; newVector . addElement ( new Option ( "-The-index-of-an-attribute-to-output-in-the-" + "-results.-This-attribute-should-identify-an-" + "-instance-in-order-to-know-which-instances-are-" + "-in-the-test-set-of-a-cross-validation.-if-0-" + "-no-output-(default-0)." , "I" , 1 , "-I-<index>" ) ) ; newVector . addElement ( new Option ( "-Add-target-and-prediction-columns-to-the-result-" + "-for-each-fold." , "P" , 0 , "-P" ) ) ; newVector . addElement ( new Option ( "-Skips-the-determination-of-sizes-(train/test/classifier)-" + "-(default:-sizes-are-determined)" , "no-size" , 0 , "-no-size" ) ) ; if ( ( m_Template != null ) && ( m_Template instanceof OptionHandler ) ) { newVector . addElement ( new Option ( "" , "" , 0 , "-Options-specific-to-classifier-" + m_Template . getClass ( ) . getName ( ) + ":" ) ) ; newVector . addAll ( Collections . list ( ( ( OptionHandler ) m_Template ) . listOptions ( ) ) ) ; } return newVector . elements ( ) ; } 
public static boolean upper ( double [ ] T , int indexT , int n ) { double el_ii ; double div_el_ii = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { double sum = T [ indexT + i * n + j ] ; for ( int k = 0 ; k < i ; k ++ ) { sum -= T [ indexT + k * n + i ] * T [ indexT + k * n + j ] ; } if ( i == j ) { if ( sum <= 0.0 ) return false ; el_ii = Math . sqrt ( sum ) ; T [ indexT + i * n + i ] = el_ii ; div_el_ii = 1.0 / el_ii ; } else { T [ indexT + i * n + j ] = sum * div_el_ii ; } } } return true ; } 
public void pennPrint ( PrintStream ps ) { pennPrint ( new PrintWriter ( new OutputStreamWriter ( ps ) , true ) ) ; } 
public static Typeface createFromAsset ( AssetManager mgr , String path ) { if ( sFallbackFonts != null ) { FontFamily fontFamily = new FontFamily ( ) ; if ( fontFamily . addFontFromAsset ( mgr , path ) ) { FontFamily [ ] families = { fontFamily } ; return createFromFamiliesWithDefault ( families ) ; } } throw new RuntimeException ( "Font-asset-not-found-" + path ) ; } 
protected void validateTree ( ) { if ( ! valid ) { ContainerPeer cPeer = null ; if ( peer instanceof ContainerPeer ) { cPeer = ( ContainerPeer ) peer ; cPeer . beginLayout ( ) ; } doLayout ( ) ; for ( int i = 0 ; i < ncomponents ; ++ i ) { Component comp = component [ i ] ; if ( comp instanceof Container && ! ( comp instanceof Window ) && ! comp . valid ) { ( ( Container ) comp ) . validateTree ( ) ; } else { comp . validate ( ) ; } } if ( cPeer != null ) { cPeer = ( ContainerPeer ) peer ; cPeer . endLayout ( ) ; } } valid = true ; } 
private void removeTakenColors ( ) { ActionListener al ; int numPairs = nameFields . length ; for ( int i = 0 ; i < numPairs ; i ++ ) { JComboBox < String > cb = colorsLists [ i ] ; for ( int j = 0 ; j < colorStrings . length ; j ++ ) { String color = colorStrings [ j ] ; if ( takenColors . containsValue ( color ) && takenColors . get ( i ) != color ) { al = cb . getActionListeners ( ) [ cb . getActionListeners ( ) . length - 1 ] ; cb . removeItem ( color ) ; cb . addActionListener ( al ) ; } } } } 
private void decodeRules ( ) { decodeStartRule ( ) ; decodeEndRule ( ) ; } 
@ SuppressWarnings ( "unchecked" ) Map < String , List < Integer >> getLineNumbers ( Object instrumented ) { try { Method method = instrumented . getClass ( ) . getMethod ( TestInstrumenter . GET_INSTRUMENTATION ) ; Map < String , List < Integer >> result = ( Map < String , List < Integer >> ) method . invoke ( null ) ; if ( result == null ) { throw new IllegalArgumentException ( "No-line-number-data-for-" + instrumented ) ; } return result ; } catch ( NoSuchMethodException nsme ) { throw new IllegalArgumentException ( "No-instrumented-method-in-" + instrumented ) ; } catch ( IllegalAccessException iae ) { throw new IllegalArgumentException ( "Cannot-call-instrumented-method-in-" + instrumented ) ; } catch ( InvocationTargetException ite ) { throw new IllegalArgumentException ( "Cannot-call-instrumented-method-in-" + instrumented ) ; } } 
MobileServiceQuery ( MobileServiceQuery < ? > query ) { internalValues . add ( query ) ; } 
public Segment [ ] rankSegmentsByConfidence ( InstanceList ilist , Object [ ] startTags , Object [ ] continueTags ) { ArrayList segmentList = new ArrayList ( ) ; SegmentIterator iter = new SegmentIterator ( this . model , ilist , startTags , continueTags ) ; if ( this . segmentConfidences == null ) segmentConfidences = new java . util . Vector ( ) ; while ( iter . hasNext ( ) ) { Segment segment = ( Segment ) iter . nextSegment ( ) ; double confidence = estimateConfidenceFor ( segment ) ; segment . setConfidence ( confidence ) ; logger . fine ( "confidence=" + segment . getConfidence ( ) + "-for-segment-" + segment . sequenceToString ( ) + "-" ) ; segmentList . add ( segment ) ; } Collections . sort ( segmentList ) ; Segment [ ] ret = new Segment [ 1 ] ; ret = ( Segment [ ] ) segmentList . toArray ( ret ) ; return ret ; } 
void showGoogleShopperButton ( View . OnClickListener listener ) { View shopperButton = activity . findViewById ( R . id . shopper_button ) ; shopperButton . setVisibility ( View . VISIBLE ) ; shopperButton . setOnClickListener ( listener ) ; } 
public final int getCurrentNode ( ) { return m_currentNodes . peek ( ) ; } 
private Set < Account > getAllowableAccountSet ( final Intent intent ) { Set < Account > setOfAllowableAccounts = null ; final ArrayList < Parcelable > validAccounts = intent . getParcelableArrayListExtra ( EXTRA_ALLOWABLE_ACCOUNTS_ARRAYLIST ) ; if ( validAccounts != null ) { setOfAllowableAccounts = new HashSet < Account > ( validAccounts . size ( ) ) ; for ( Parcelable parcelable : validAccounts ) { setOfAllowableAccounts . add ( ( Account ) parcelable ) ; } } return setOfAllowableAccounts ; } 
public Attributes getAttributes ( String name ) { return getEntries ( ) . get ( name ) ; } 
public String build ( ) { final StringBuilder name = new StringBuilder ( ) ; name . append ( prefix ) . append ( '.' ) . append ( startMillis ) . append ( '-' ) ; if ( endMillis != Long . MAX_VALUE ) { name . append ( endMillis ) ; } return name . toString ( ) ; } 
private static String [ ] getSubjectAlts ( final X509Certificate cert , final String hostname ) { int subjectType ; if ( isIPAddress ( hostname ) ) { subjectType = 7 ; } else { subjectType = 2 ; } LinkedList < String > subjectAltList = new LinkedList < String > ( ) ; Collection < List < ? >> c = null ; try { c = cert . getSubjectAlternativeNames ( ) ; } catch ( CertificateParsingException cpe ) { Logger . getLogger ( AbstractVerifier . class . getName ( ) ) . log ( Level . FINE , "Error-parsing-certificate." , cpe ) ; } if ( c != null ) { for ( List < ? > aC : c ) { List < ? > list = aC ; int type = ( ( Integer ) list . get ( 0 ) ) . intValue ( ) ; if ( type == subjectType ) { String s = ( String ) list . get ( 1 ) ; subjectAltList . add ( s ) ; } } } if ( ! subjectAltList . isEmpty ( ) ) { String [ ] subjectAlts = new String [ subjectAltList . size ( ) ] ; subjectAltList . toArray ( subjectAlts ) ; return subjectAlts ; } else { return null ; } } 
public void debug_stack ( ) { StringBuffer sb = new StringBuffer ( "##-STACK:" ) ; for ( int i = 0 ; i < stack . size ( ) ; i ++ ) { Symbol s = ( Symbol ) stack . elementAt ( i ) ; sb . append ( "-<state-" + s . parse_state + ",-sym-" + s . sym + ">" ) ; if ( ( i % 3 ) == 2 || ( i == ( stack . size ( ) - 1 ) ) ) { debug_message ( sb . toString ( ) ) ; sb = new StringBuffer ( "-" ) ; } } } 
private void parseURI ( String str ) throws URISyntaxException { Matcher matcher = URI_PATTERN . matcher ( str ) ; if ( matcher . matches ( ) ) { scheme = getURIGroup ( matcher , SCHEME_GROUP ) ; rawSchemeSpecificPart = matcher . group ( SCHEME_SPEC_PART_GROUP ) ; schemeSpecificPart = unquote ( rawSchemeSpecificPart ) ; if ( ! isOpaque ( ) ) { rawAuthority = getURIGroup ( matcher , AUTHORITY_GROUP ) ; rawPath = matcher . group ( PATH_GROUP ) ; rawQuery = getURIGroup ( matcher , QUERY_GROUP ) ; } rawFragment = getURIGroup ( matcher , FRAGMENT_GROUP ) ; } else throw new URISyntaxException ( str , "doesn't-match-URI-regular-expression" ) ; parseServerAuthority ( ) ; authority = unquote ( rawAuthority ) ; userInfo = unquote ( rawUserInfo ) ; host = unquote ( rawHost ) ; path = unquote ( rawPath ) ; query = unquote ( rawQuery ) ; fragment = unquote ( rawFragment ) ; } 
private static byte [ ] encode3to4 ( byte [ ] b4 , byte [ ] threeBytes , int numSigBytes ) { encode3to4 ( threeBytes , 0 , numSigBytes , b4 , 0 ) ; return b4 ; } 
public void accept ( Token token ) { if ( S . token ( ) == token ) { S . nextToken ( ) ; } else { setErrorEndPos ( S . pos ( ) ) ; reportSyntaxError ( S . prevEndPos ( ) , "expected" , token ) ; } } 
void output ( Method method ) throws Exception { Class < ? > cls = method . getDeclaringClass ( ) ; String mname = method . getName ( ) ; boolean isStatic = Modifier . isStatic ( method . getModifiers ( ) ) ; Class < ? > [ ] parms = method . getParameterTypes ( ) ; Class < ? > ret = method . getReturnType ( ) ; output ( cls , mname , isStatic , parms , ret ) ; } 
private void initdata ( ) { Thread t = new Thread ( new Runnable ( ) { public void run ( ) { pref = Preferences . userRoot ( ) . node ( "/com/cititoolkit" ) ; String picstore = pref . get ( "picpath" , "C:/brucexx/picstore/" ) ; String dbstore = pref . get ( "dbpath" , "C:/brucexx/xmldb/" ) ; dbfolder . setText ( dbstore ) ; picfolder . setText ( picstore ) ; ServerContext . setServerLogger ( serverlog ) ; ServerContext . setDBLogger ( dblog ) ; ServerContext . instance ( ) ; ServerContext . setSystemFileFolder ( picstore ) ; ServerContext . getDB ( ) . setDbpath ( dbstore ) ; File f = new File ( AppContext . getSystemFolderPath ( ) ) ; if ( ! f . exists ( ) ) { f . mkdirs ( ) ; } ServerXMLLoad ( ) ; } } ) ; t . start ( ) ; } 
public static String decode ( String s ) { if ( s == null ) { return null ; } return UriCodec . decode ( s , false , Charset . forName ( "UTF-8" ) ) ; } 
private boolean yy_refill ( ) throws java . io . IOException { if ( yy_startRead > 0 ) { System . arraycopy ( yy_buffer , yy_startRead , yy_buffer , 0 , yy_endRead - yy_startRead ) ; yy_endRead -= yy_startRead ; yy_currentPos -= yy_startRead ; yy_markedPos -= yy_startRead ; yy_pushbackPos -= yy_startRead ; yy_startRead = 0 ; } if ( yy_currentPos >= yy_buffer . length ) { char newBuffer [ ] = new char [ yy_currentPos * 2 ] ; System . arraycopy ( yy_buffer , 0 , newBuffer , 0 , yy_buffer . length ) ; yy_buffer = newBuffer ; } int numRead = yy_reader . read ( yy_buffer , yy_endRead , yy_buffer . length - yy_endRead ) ; if ( numRead < 0 ) { return true ; } else { yy_endRead += numRead ; return false ; } } 
public List < TrustAnchor > getTrustAnchor ( ) { if ( trustAnchor == null ) { trustAnchor = new ArrayList < TrustAnchor > ( ) ; } return this . trustAnchor ; } 
public int onStartCommand ( Intent intent , int flags , int startId ) { onStart ( intent , startId ) ; return mStartCompatibility ? START_STICKY_COMPATIBILITY : START_STICKY ; } 
public String toString ( int indentFactor ) throws JSONException { StringWriter sw = new StringWriter ( ) ; synchronized ( sw . getBuffer ( ) ) { return this . write ( sw , indentFactor , 0 ) . toString ( ) ; } } 
private InetSocketAddress nextInetSocketAddress ( ) throws UnknownHostException { InetSocketAddress result = new InetSocketAddress ( socketAddresses [ nextSocketAddressIndex ++ ] , socketPort ) ; if ( nextSocketAddressIndex == socketAddresses . length ) { socketAddresses = null ; nextSocketAddressIndex = 0 ; } return result ; } 
private static List < String > readFile ( String fileName ) { List < String > result = Lists . newArrayList ( ) ; try { BufferedReader bufRead = new BufferedReader ( new FileReader ( fileName ) ) ; String line ; while ( ( line = bufRead . readLine ( ) ) != null ) { if ( line . length ( ) > 0 ) result . add ( line ) ; } bufRead . close ( ) ; } catch ( IOException e ) { throw new ParameterException ( "Could-not-read-file-" + fileName + ":-" + e ) ; } return result ; } 
public final boolean isDither ( ) { return ( getFlags ( ) & DITHER_FLAG ) != 0 ; } 
protected Iterator < Element > createIterator ( ExecutionContext context ) { return getExecutionElement ( ) . getChildren ( ) . iterator ( ) ; } 
public void visitChildren ( final TreeVisitor visitor ) { if ( tree != null ) { tree . visit ( visitor ) ; } } 
private void installKeyboardActions ( ) { ActionMap actions = getActionMap ( ) ; InputMap inputMap = getInputMap ( WHEN_ANCESTOR_OF_FOCUSED_COMPONENT ) ; inputMap . put ( ( KeyStroke ) actions . get ( ActionType . SHOW_PREVIOUS ) . getValue ( Action . ACCELERATOR_KEY ) , ActionType . SHOW_PREVIOUS ) ; inputMap . put ( ( KeyStroke ) actions . get ( ActionType . SHOW_NEXT ) . getValue ( Action . ACCELERATOR_KEY ) , ActionType . SHOW_NEXT ) ; inputMap . put ( ( KeyStroke ) actions . get ( ActionType . CLOSE ) . getValue ( Action . ACCELERATOR_KEY ) , ActionType . CLOSE ) ; inputMap . put ( ( KeyStroke ) actions . get ( ActionType . SEARCH ) . getValue ( Action . ACCELERATOR_KEY ) , ActionType . SEARCH ) ; } 
public static void setThreadPoolSize ( int threads ) { setThreadPool ( new ThreadPoolExecutor ( threads , threads , 0L , TimeUnit . MILLISECONDS , new LinkedBlockingQueue < Runnable > ( ) ) ) ; } 
public boolean fill ( final MediaObjectList mediaObjList , final Node mediaObjListNode , final File relatePathsTo ) { if ( mediaObjListNode == null || mediaObjListNode . getNodeType ( ) != Node . ELEMENT_NODE || ! mediaObjListNode . getNodeName ( ) . equals ( "mediaObjectList" ) ) { return false ; } mediaObjList . clear ( ) ; Element mediaObjListElem = ( Element ) mediaObjListNode ; NodeList mediaObjects = mediaObjListElem . getElementsByTagName ( "mediaObject" ) ; for ( int i = 0 ; i < mediaObjects . getLength ( ) ; i ++ ) { MediaObject mediaObj = null ; try { mediaObj = buildMediaObjFrom ( mediaObjects . item ( i ) , relatePathsTo ) ; } catch ( final NullPointerException e ) { mediaObj = null ; } if ( mediaObj != null ) { mediaObjList . add ( mediaObj , false ) ; } } mediaObjList . add ( new LinkedList < MediaObject > ( ) ) ; return true ; } 
final synchronized void defaultReadObjectDelegate ( ) { try { if ( currentObject == null || currentClassDesc == null ) throw new NotActiveException ( "defaultReadObjectDelegate" ) ; if ( defaultReadObjectFVDMembers != null && defaultReadObjectFVDMembers . length > 0 ) { inputClassFields ( currentObject , currentClass , currentClassDesc , defaultReadObjectFVDMembers , cbSender ) ; } else { ObjectStreamField [ ] fields = currentClassDesc . getFieldsNoCopy ( ) ; if ( fields . length > 0 ) { inputClassFields ( currentObject , currentClass , fields , cbSender ) ; } } } catch ( NotActiveException nae ) { bridge . throwException ( nae ) ; } catch ( IOException ioe ) { bridge . throwException ( ioe ) ; } catch ( ClassNotFoundException cnfe ) { bridge . throwException ( cnfe ) ; } } 
public void setFilter ( Filter filter ) { mFilter = filter ; if ( filter != null ) { mFilterMap = new HashMap < String , Boolean > ( ) ; } } 
public void addErrorListener ( ActionListener e ) { if ( errorListeners == null ) { errorListeners = new EventDispatcher ( ) ; errorListeners . setBlocking ( true ) ; } errorListeners . addListener ( e ) ; } 
public static boolean typesAreCompatible ( Class cls1 , Class cls2 ) { if ( cls1 . isAssignableFrom ( cls2 ) ) { return true ; } if ( cls1 . isPrimitive ( ) ) { return ClassUtils . getWrapperTypeForPrimitiveType ( cls1 ) . isAssignableFrom ( cls2 ) ; } return false ; } 
public List < String > values ( String name ) { List < String > result = null ; for ( int i = 0 ; i < length ( ) ; i ++ ) { if ( name . equalsIgnoreCase ( getFieldName ( i ) ) ) { if ( result == null ) result = new ArrayList < String > ( 2 ) ; result . add ( getValue ( i ) ) ; } } return result != null ? Collections . unmodifiableList ( result ) : Collections . < String > emptyList ( ) ; } 
public static String trim ( String str ) { String s = ( str != null ) ? str . trim ( ) : "" ; return s ; } 
public String toStringOfHalfWords ( ) { String s = new String ( ) ; for ( int i = 0 ; i < bits . length ; i ++ ) { if ( i != 0 ) s += ",-" ; long tmp = bits [ i ] ; tmp &= 0xFFFFFFFFL ; s += ( tmp + "UL" ) ; s += ",-" ; tmp = bits [ i ] >>> 32 ; tmp &= 0xFFFFFFFFL ; s += ( tmp + "UL" ) ; } return s ; } 
public String getCategory ( int index ) { return mCategories . get ( index ) ; } 
public void writeTo ( OutputStream os ) throws TransformerConfigurationException , FileNotFoundException , TransformerException , IOException , Exception { if ( type . isXMLType ( ) ) { if ( writer == null ) writer = new MaryNormalisedWriter ( ) ; if ( logger . getEffectiveLevel ( ) . equals ( Level . DEBUG ) ) { ByteArrayOutputStream debugOut = new ByteArrayOutputStream ( ) ; writer . output ( xmlDocument , debugOut ) ; logger . debug ( debugOut . toString ( ) ) ; } writer . output ( xmlDocument , new BufferedOutputStream ( os ) ) ; } else if ( type . isTextType ( ) ) { writeTo ( new OutputStreamWriter ( os , "UTF-8" ) ) ; } else { logger . debug ( "Writing-audio-output,-frame-length-" + audio . getFrameLength ( ) ) ; AudioSystem . write ( audio , audioFileFormat . getType ( ) , os ) ; os . flush ( ) ; os . close ( ) ; } } 
private void paintBackground ( Graphics2D g , JComponent c , int width , int height , ButtonColors colors ) { g . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_OFF ) ; g . setColor ( colors . top ) ; g . drawLine ( 1 , 0 , width - 2 , 0 ) ; g . setColor ( colors . leftOuter ) ; g . drawLine ( 0 , 0 , 0 , height - 4 ) ; g . drawLine ( 1 , height - 3 , 1 , height - 3 ) ; g . setColor ( colors . leftInner ) ; g . drawLine ( 1 , 1 , 1 , height - 4 ) ; g . drawLine ( 2 , height - 3 , 2 , height - 3 ) ; g . setColor ( colors . edge ) ; g . drawLine ( width - 1 , 0 , width - 1 , height - 2 ) ; g . drawLine ( 3 , height - 2 , width - 2 , height - 2 ) ; g . setColor ( colors . edgeShade ) ; g . drawLine ( 2 , height - 2 , 2 , height - 2 ) ; g . setColor ( colors . shadow ) ; g . drawLine ( 4 , height - 1 , width - 1 , height - 1 ) ; g . setColor ( colors . interior ) ; g . fillRect ( 1 , 1 , width - 1 , height - 3 ) ; g . drawLine ( 3 , height - 3 , width - 2 , height - 3 ) ; } 
public static EventBean [ ] flatten ( ArrayDeque < EventBean [ ] > eventVector ) { if ( eventVector . isEmpty ( ) ) { return null ; } if ( eventVector . size ( ) == 1 ) { return eventVector . getFirst ( ) ; } int totalElements = 0 ; for ( EventBean [ ] arr : eventVector ) { if ( arr != null ) { totalElements += arr . length ; } } if ( totalElements == 0 ) { return null ; } EventBean [ ] result = new EventBean [ totalElements ] ; int destPos = 0 ; for ( EventBean [ ] arr : eventVector ) { if ( arr != null ) { System . arraycopy ( arr , 0 , result , destPos , arr . length ) ; destPos += arr . length ; } } return result ; } 
public int getAD_Image_ID ( ) { Integer ii = ( Integer ) get_Value ( COLUMNNAME_AD_Image_ID ) ; if ( ii == null ) return 0 ; return ii . intValue ( ) ; } 
long freeSpaceUnix ( String path , boolean kb , boolean posix ) throws IOException { if ( path . length ( ) == 0 ) { throw new IllegalArgumentException ( "Path-must-not-be-empty" ) ; } path = FilenameUtils . normalize ( path ) ; String flags = "-" ; if ( kb ) { flags += "k" ; } if ( posix ) { flags += "P" ; } String [ ] cmdAttribs = ( flags . length ( ) > 1 ? new String [ ] { "df" , flags , path } : new String [ ] { "df" , path } ) ; List < String > lines = performCommand ( cmdAttribs , 3 ) ; if ( lines . size ( ) < 2 ) { throw new IOException ( "Command-line-'df'-did-not-return-info-as-expected-" + "for-path-'" + path + "'--response-was-" + lines ) ; } String line2 = lines . get ( 1 ) ; StringTokenizer tok = new StringTokenizer ( line2 , "-" ) ; if ( tok . countTokens ( ) < 4 ) { if ( tok . countTokens ( ) == 1 && lines . size ( ) >= 3 ) { String line3 = lines . get ( 2 ) ; tok = new StringTokenizer ( line3 , "-" ) ; } else { throw new IOException ( "Command-line-'df'-did-not-return-data-as-expected-" + "for-path-'" + path + "'--check-path-is-valid" ) ; } } else { tok . nextToken ( ) ; } tok . nextToken ( ) ; tok . nextToken ( ) ; String freeSpace = tok . nextToken ( ) ; return parseBytes ( freeSpace , path ) ; } 
public static < U > CompletableFuture < U > completedFuture ( U value ) { CompletableFuture < U > f = new CompletableFuture < U > ( ) ; f . result = ( value == null ) ? NIL : value ; return f ; } 
public static long readHexLong ( Map < String , ? extends Object > map , String key , long defaultValue ) { Object v = map . get ( key ) ; if ( v == null ) { return defaultValue ; } else if ( v instanceof Long ) { return ( Long ) v ; } try { return parseHexLong ( ( String ) v ) ; } catch ( NumberFormatException e ) { throw newIllegalStateException ( ERROR_FILE_CORRUPT , "Error-parsing-the-value-{0}" , v , e ) ; } } 
public List < Double > getFloat4 ( ) { if ( float4 == null ) { float4 = new ArrayList < Double > ( ) ; } return this . float4 ; } 
private void startIfReady ( Animator dependencyAnimation ) { if ( mAnimatorSet . mTerminated ) { return ; } Dependency dependencyToRemove = null ; int numDependencies = mNode . tmpDependencies . size ( ) ; for ( int i = 0 ; i < numDependencies ; ++ i ) { Dependency dependency = mNode . tmpDependencies . get ( i ) ; if ( dependency . rule == mRule && dependency . node . animation == dependencyAnimation ) { dependencyToRemove = dependency ; dependencyAnimation . removeListener ( this ) ; break ; } } mNode . tmpDependencies . remove ( dependencyToRemove ) ; if ( mNode . tmpDependencies . size ( ) == 0 ) { mNode . animation . start ( ) ; mAnimatorSet . mPlayingSet . add ( mNode . animation ) ; } } 
void save ( ) { if ( kSave == null ) { kSave = new byte [ blockSize ] ; } System . arraycopy ( k , 0 , kSave , 0 , blockSize ) ; } 
public void print ( boolean x ) { out . print ( x ) ; out . flush ( ) ; } 
public double distanceTo ( Point2D that ) { double dx = this . x - that . x ; double dy = this . y - that . y ; return Math . sqrt ( dx * dx + dy * dy ) ; } 
public enableTable_args setTableName ( byte [ ] tableName ) { setTableName ( tableName == null ? ( ByteBuffer ) null : ByteBuffer . wrap ( tableName ) ) ; return this ; } 
public void setProxyHost ( String proxyHost ) { this . proxyHost = Configuration . getProxyHost ( proxyHost ) ; } 
private static final String coerceToString ( final Object obj ) { if ( obj == null ) { return "" ; } else if ( obj instanceof String ) { return ( String ) obj ; } else if ( obj instanceof Enum < ? > ) { return ( ( Enum < ? > ) obj ) . name ( ) ; } else { return obj . toString ( ) ; } } 
protected int getRowsOccupied ( View v ) { AttributeSet a = v . getElement ( ) . getAttributes ( ) ; if ( a . isDefined ( HTML . Attribute . ROWSPAN ) ) { String s = ( String ) a . getAttribute ( HTML . Attribute . ROWSPAN ) ; if ( s != null ) { try { return Integer . parseInt ( s ) ; } catch ( NumberFormatException nfe ) { } } } return 1 ; } 
public void setDragOffsetX ( float offset ) { mTransOffsetX = Utils . convertDpToPixel ( offset ) ; } 
private JTextPane getJTextPane ( ) { if ( jTextPane == null ) { jTextPane = new JTextPane ( ) ; jTextPane . addKeyListener ( this ) ; } return jTextPane ; } 
public MarkupContainer removeAll ( ) { if ( children != null ) { addStateChange ( ) ; for ( Component child : this ) { child . internalOnRemove ( ) ; child . detach ( ) ; child . setParent ( null ) ; } children = null ; removals_add ( null , null ) ; } return this ; } 
public Method getMethod ( java . lang . reflect . Method method ) { String name = method . getName ( ) ; Class [ ] parameterClasses = method . getParameterTypes ( ) ; Type [ ] parameterTypes = new Type [ parameterClasses . length ] ; for ( int i = parameterClasses . length ; -- i >= 0 ; ) parameterTypes [ i ] = Type . make ( parameterClasses [ i ] ) ; return addMethod ( name , method . getModifiers ( ) , parameterTypes , Type . make ( method . getReturnType ( ) ) ) ; } 
public LinkedList get ( String fileName ) { LinkedList jarFiles = null ; if ( ( jarFiles = ( LinkedList ) indexMap . get ( fileName ) ) == null ) { int pos ; if ( ( pos = fileName . lastIndexOf ( "/" ) ) != - 1 ) { jarFiles = ( LinkedList ) indexMap . get ( fileName . substring ( 0 , pos ) ) ; } } return jarFiles ; } 
public void clear ( ) { removeAllElements ( ) ; } 
public static String formatThreadInfo ( ThreadInfo threadInfo , String indent ) { StringBuilder sb = new StringBuilder ( ) ; appendThreadInfo ( sb , threadInfo , indent ) ; return sb . toString ( ) ; } 
public void installUI ( JComponent c ) { list = ( JList ) c ; layoutOrientation = list . getLayoutOrientation ( ) ; rendererPane = new CellRendererPane ( ) ; list . add ( rendererPane ) ; columnCount = 1 ; updateLayoutStateNeeded = modelChanged ; isLeftToRight = list . getComponentOrientation ( ) . isLeftToRight ( ) ; installDefaults ( ) ; installListeners ( ) ; installKeyboardActions ( ) ; } 
public void unregisterServiceHandler ( String name ) { Map < String , Object > serviceHandlers = getServiceHandlers ( false ) ; if ( serviceHandlers == null ) { return ; } serviceHandlers . remove ( name ) ; } 
private static void formatNames ( Iterable < List < String >> names ) { if ( names != null ) { for ( List < String > list : names ) { String name = list . get ( 0 ) ; String [ ] components = new String [ 5 ] ; int start = 0 ; int end ; int componentIndex = 0 ; while ( componentIndex < components . length - 1 && ( end = name . indexOf ( ';' , start ) ) > 0 ) { components [ componentIndex ] = name . substring ( start , end ) ; componentIndex ++ ; start = end + 1 ; } components [ componentIndex ] = name . substring ( start ) ; StringBuilder newName = new StringBuilder ( 100 ) ; maybeAppendComponent ( components , 3 , newName ) ; maybeAppendComponent ( components , 1 , newName ) ; maybeAppendComponent ( components , 2 , newName ) ; maybeAppendComponent ( components , 0 , newName ) ; maybeAppendComponent ( components , 4 , newName ) ; list . set ( 0 , newName . toString ( ) . trim ( ) ) ; } } } 
public int getItemCount ( ) { return mItems . size ( ) ; } 
public RealVector add ( RealVector v ) throws DimensionMismatchException { checkVectorDimensions ( v ) ; RealVector result = v . copy ( ) ; Iterator < Entry > it = iterator ( ) ; while ( it . hasNext ( ) ) { final Entry e = it . next ( ) ; final int index = e . getIndex ( ) ; result . setEntry ( index , e . getValue ( ) + result . getEntry ( index ) ) ; } return result ; } 
public PropertyResourceBundle ( Reader reader ) throws IOException { Properties properties = new Properties ( ) ; properties . load ( reader ) ; lookup = new HashMap ( properties ) ; } 
public E removeLast ( ) { final Node < E > l = last ; if ( l == null ) throw new NoSuchElementException ( ) ; return unlinkLast ( l ) ; } 
public Attributes getMainAttributes ( ) throws java . io . IOException { Manifest m = getJarFile ( ) . getManifest ( ) ; return ( m == null ) ? null : m . getMainAttributes ( ) ; } 
@ Override protected Point getInitialSize ( ) { return new Point ( 540 , 411 ) ; } 
public void testSerialization ( ) { Minute m1 = new Minute ( ) ; Minute m2 = null ; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; ObjectOutput out = new ObjectOutputStream ( buffer ) ; out . writeObject ( m1 ) ; out . close ( ) ; ObjectInput in = new ObjectInputStream ( new ByteArrayInputStream ( buffer . toByteArray ( ) ) ) ; m2 = ( Minute ) in . readObject ( ) ; in . close ( ) ; } catch ( Exception e ) { System . out . println ( e . toString ( ) ) ; } assertEquals ( m1 , m2 ) ; } 
private static void updateAllUIs ( ) { Class uiClass = UIManager . getLookAndFeel ( ) . getClass ( ) ; if ( uiClass . getPackage ( ) . equals ( DesktopProperty . class . getPackage ( ) ) ) { XPStyle . invalidateStyle ( ) ; } Frame appFrames [ ] = Frame . getFrames ( ) ; for ( Frame appFrame : appFrames ) { updateWindowUI ( appFrame ) ; } } 
private void writeEntry ( InputStream input , JarEntry entry ) throws IOException { mOutputJar . putNextEntry ( entry ) ; int count ; while ( ( count = input . read ( mBuffer ) ) != - 1 ) { mOutputJar . write ( mBuffer , 0 , count ) ; if ( mMessageDigest != null ) { mMessageDigest . update ( mBuffer , 0 , count ) ; } } mOutputJar . closeEntry ( ) ; if ( mManifest != null ) { Attributes attr = mManifest . getAttributes ( entry . getName ( ) ) ; if ( attr == null ) { attr = new Attributes ( ) ; mManifest . getEntries ( ) . put ( entry . getName ( ) , attr ) ; } attr . putValue ( DIGEST_ATTR , mBase64Encoder . encode ( mMessageDigest . digest ( ) ) ) ; } } 
public static Builder builder ( UnregisterRequest request ) { return new Builder ( request ) ; } 
private void doAcquireSharedInterruptibly ( int arg ) throws InterruptedException { final Node node = addWaiter ( Node . SHARED ) ; boolean failed = true ; try { for ( ; ; ) { final Node p = node . predecessor ( ) ; if ( p == head ) { int r = tryAcquireShared ( arg ) ; if ( r >= 0 ) { setHeadAndPropagate ( node , r ) ; p . next = null ; failed = false ; return ; } } if ( shouldParkAfterFailedAcquire ( p , node ) && parkAndCheckInterrupt ( ) ) throw new InterruptedException ( ) ; } } finally { if ( failed ) cancelAcquire ( node ) ; } } 
public static void forceDelete ( File file ) throws IOException { if ( file . isDirectory ( ) ) { deleteDirectory ( file ) ; } else { boolean filePresent = file . exists ( ) ; if ( ! file . delete ( ) ) { if ( ! filePresent ) { throw new FileNotFoundException ( "File-does-not-exist:-" + file ) ; } String message = "Unable-to-delete-file:-" + file ; throw new IOException ( message ) ; } } } 
public int getInt ( String key ) throws JSONException { Object object = this . get ( key ) ; try { return object instanceof Number ? ( ( Number ) object ) . intValue ( ) : Integer . parseInt ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONObject[" + quote ( key ) + "]-is-not-an-int." ) ; } } 
protected static int readIgnoreWhitespace ( Reader reader ) throws IOException { int next ; do { next = reader . read ( ) ; if ( next < 0 ) { throw new RuntimeException ( "Invalid-json-data" ) ; } } while ( next == '-' || next == '|n' || next == '|r' || next == '|t' ) ; return next ; } 
private Calendar createAtDate ( ) { Calendar cal = Calendar . getInstance ( ) ; cal . set ( 0 , 0 , 0 , 0 , 0 , 0 ) ; return cal ; } 
public MenuItem setOnMenuItemClickListener ( OnMenuItemClickListener menuItemClickListener ) { mMenuItem . setOnMenuItemClickListener ( menuItemClickListener ) ; return this ; } 
public boolean isNodeSibling ( TreeNode anotherNode ) { boolean retval ; if ( anotherNode == null ) { retval = false ; } else if ( anotherNode == this ) { retval = true ; } else { TreeNode myParent = getParent ( ) ; retval = ( myParent != null && myParent == anotherNode . getParent ( ) ) ; if ( retval && ! ( ( DefaultMutableTreeNode ) getParent ( ) ) . isNodeChild ( anotherNode ) ) { throw new Error ( "sibling-has-different-parent" ) ; } } return retval ; } 
public List < ValueSetContains > getContains ( ) { if ( contains == null ) { contains = new ArrayList < ValueSetContains > ( ) ; } return this . contains ; } 
public Builder mergeFrom ( final Field other ) { if ( ! other . varint . isEmpty ( ) ) { if ( result . varint == null ) { result . varint = new ArrayList < Long > ( ) ; } result . varint . addAll ( other . varint ) ; } if ( ! other . fixed32 . isEmpty ( ) ) { if ( result . fixed32 == null ) { result . fixed32 = new ArrayList < Integer > ( ) ; } result . fixed32 . addAll ( other . fixed32 ) ; } if ( ! other . fixed64 . isEmpty ( ) ) { if ( result . fixed64 == null ) { result . fixed64 = new ArrayList < Long > ( ) ; } result . fixed64 . addAll ( other . fixed64 ) ; } if ( ! other . lengthDelimited . isEmpty ( ) ) { if ( result . lengthDelimited == null ) { result . lengthDelimited = new ArrayList < ByteString > ( ) ; } result . lengthDelimited . addAll ( other . lengthDelimited ) ; } if ( ! other . group . isEmpty ( ) ) { if ( result . group == null ) { result . group = new ArrayList < UnknownFieldSet > ( ) ; } result . group . addAll ( other . group ) ; } return this ; } 
public synchronized void addObservedObject ( ObjectName object ) throws IllegalArgumentException { if ( object == null ) { throw new IllegalArgumentException ( "Null-observed-object" ) ; } if ( containsObservedObject ( object ) ) return ; ObservedObject o = createObservedObject ( object ) ; o . setAlreadyNotified ( RESET_FLAGS_ALREADY_NOTIFIED ) ; o . setDerivedGauge ( INTEGER_ZERO ) ; o . setDerivedGaugeTimeStamp ( System . currentTimeMillis ( ) ) ; observedObjects . add ( o ) ; createAlreadyNotified ( ) ; } 
public float getValueAsFloat ( ) { try { return Float . parseFloat ( entry ) ; } catch ( NumberFormatException e ) { return - 1 ; } } 
public Image ( InputStream in , String ref , boolean flipped ) throws SlickException { this ( in , ref , flipped , FILTER_LINEAR ) ; } 
public NetworkInterface getNetworkInterface ( ) throws SocketException { NetworkInterface ni = ( NetworkInterface ) getImpl ( ) . getOption ( SocketOptions . IP_MULTICAST_IF2 ) ; if ( ni . getIndex ( ) == 0 ) { InetAddress [ ] addrs = new InetAddress [ 1 ] ; addrs [ 0 ] = InetAddress . anyLocalAddress ( ) ; return new NetworkInterface ( addrs [ 0 ] . getHostName ( ) , 0 , addrs ) ; } else { return ni ; } } 
public boolean isGoalState ( final GameStateAnyFoodSearchProblem state ) { final Position pos = state . getPacmanPosition ( ) ; final double x = pos . getX ( ) ; final double y = pos . getY ( ) ; throw new UnsupportedOperationException ( ) ; } 
protected SizeRequirements calculateMajorAxisRequirements ( int axis , SizeRequirements r ) { if ( r == null ) { r = new SizeRequirements ( ) ; } if ( ! spanSetFromAttributes ( axis , r , cssWidth , cssHeight ) ) { r = super . calculateMajorAxisRequirements ( axis , r ) ; } else { SizeRequirements parentR = super . calculateMajorAxisRequirements ( axis , null ) ; int margin = ( axis == X_AXIS ) ? getLeftInset ( ) + getRightInset ( ) : getTopInset ( ) + getBottomInset ( ) ; r . minimum -= margin ; r . preferred -= margin ; r . maximum -= margin ; constrainSize ( axis , r , parentR ) ; } return r ; } 
private int getlen ( String str ) { if ( str == null ) return 0 ; return str . length ( ) ; } 
public void write ( String fileName ) throws IOException { FileOutputStream outputFile ; byte profileData [ ] ; profileData = getData ( ) ; outputFile = new FileOutputStream ( fileName ) ; outputFile . write ( profileData ) ; outputFile . close ( ) ; } 
public boolean binaryOverrides ( Symbol _other , TypeSymbol origin , Types types ) { if ( isConstructor ( ) || _other . kind != MTH ) return false ; if ( this == _other ) return true ; MethodSymbol other = ( MethodSymbol ) _other ; if ( other . isOverridableIn ( ( TypeSymbol ) owner ) && types . asSuper ( owner . type , other . owner ) != null && types . isSameType ( erasure ( types ) , other . erasure ( types ) ) ) return true ; return ( flags ( ) & ABSTRACT ) == 0 && other . isOverridableIn ( origin ) && this . isMemberOf ( origin , types ) && types . isSameType ( erasure ( types ) , other . erasure ( types ) ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public void printFitness ( final EvolutionState state , final PrintWriter writer ) { writer . println ( fitnessToString ( ) ) ; } 
private boolean set ( int i ) { Iterator it = ( Iterator ) ( iterators . get ( i ) ) ; if ( it . hasNext ( ) ) { values . set ( i , it . next ( ) ) ; valueSet . set ( i ) ; return true ; } else { values . set ( i , null ) ; valueSet . clear ( i ) ; return false ; } } 
public static String ajustaValorArredondado ( String str ) { String var = str . substring ( 3 ) ; return var ; } 
void union ( PurityGraph arg ) { nodes . addAll ( arg . nodes ) ; paramNodes . addAll ( arg . paramNodes ) ; edges . putAll ( arg . edges ) ; locals . putAll ( arg . locals ) ; ret . addAll ( arg . ret ) ; globEscape . addAll ( arg . globEscape ) ; backEdges . putAll ( arg . backEdges ) ; backLocals . putAll ( arg . backLocals ) ; mutated . putAll ( arg . mutated ) ; if ( doCheck ) sanityCheck ( ) ; } 
Date delayedDate ( long delayMillis ) { return new Date ( System . currentTimeMillis ( ) + delayMillis ) ; } 
public void setVisible ( boolean visible ) { mFloatingActionButtonContainer . setVisibility ( visible ? View . VISIBLE : View . GONE ) ; } 
protected java . io . Reader getNativeCharacterStream ( int columnIndex ) throws SQLException { String asString = null ; asString = getStringForClob ( columnIndex ) ; if ( asString == null ) { return null ; } return getCharacterStreamFromString ( asString , columnIndex ) ; } 
public static ViewsSoap getViewsPort ( URL webUrl ) throws NoSuchAlgorithmException , KeyManagementException , MalformedURLException { URL wsURL = new URL ( webUrl . toString ( ) + "/_vti_bin/Views.asmx" ) ; URL wsdlURL = new URL ( WsContext . class . getResource ( "/wsdl/views.wsdl" ) . toExternalForm ( ) ) ; Views service = new Views ( wsdlURL ) ; ViewsSoap websPort = service . getViewsSoap ( ) ; ( ( BindingProvider ) websPort ) . getRequestContext ( ) . put ( BindingProvider . ENDPOINT_ADDRESS_PROPERTY , wsURL . toString ( ) ) ; return websPort ; } 
public boolean getBoolean ( boolean _default ) { if ( isBooleanValue ( ) ) { return Boolean . parseBoolean ( value ) ; } else { return _default ; } } 
private void zzScanError ( int errorCode ) { String message ; try { message = ZZ_ERROR_MSG [ errorCode ] ; } catch ( ArrayIndexOutOfBoundsException e ) { message = ZZ_ERROR_MSG [ ZZ_UNKNOWN_ERROR ] ; } throw new Error ( message ) ; } 
protected void rememberObjectReference ( Object obj ) { serializedObjects . put ( obj , new Integer ( serializedObjectCount ++ ) ) ; } 
public List < String > getExtendedKeyUsage ( ) throws IOException { if ( keys == null ) { keys = ( List < String > ) ASN1 . decode ( getEncoded ( ) ) ; } return keys ; } 
public boolean hasOneByteMappings ( ) { return ! singleByteMappings . isEmpty ( ) ; } 
public PipedInputStream ( PipedOutputStream src , int pipeSize ) throws IOException { initPipe ( pipeSize ) ; connect ( src ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public void fireTableRowsDeleted ( int firstRow , int lastRow ) { fireTableChanged ( new TableModelEvent ( this , firstRow , lastRow , TableModelEvent . ALL_COLUMNS , TableModelEvent . DELETE ) ) ; } 
public static String htmlEscape ( String s ) { StringBuilder sb = null ; String replacement ; int start = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { switch ( s . charAt ( i ) ) { case '"' : replacement = "&quot;" ; break ; case '&' : replacement = "&amp;" ; break ; case '<' : replacement = "&lt;" ; break ; case '>' : replacement = "&gt;" ; break ; default : replacement = null ; } if ( replacement != null ) { if ( sb == null ) { sb = new StringBuilder ( s . length ( ) + replacement . length ( ) - 1 ) ; } if ( i > start ) { sb . append ( s . substring ( start , i ) ) ; } sb . append ( replacement ) ; start = i + 1 ; } } if ( start > 0 ) { sb . append ( s . substring ( start ) ) ; } if ( sb != null ) { return sb . toString ( ) ; } return s ; } 
public static String numberToString ( Number number ) throws JSONException { if ( number == null ) { throw new JSONException ( "Null-pointer" ) ; } testValidity ( number ) ; String string = number . toString ( ) ; if ( string . indexOf ( '.' ) > 0 && string . indexOf ( 'e' ) < 0 && string . indexOf ( 'E' ) < 0 ) { while ( string . endsWith ( "0" ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . endsWith ( "." ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; } 
public Track createTrack ( ) { Track track = new Track ( ) ; tracks . addElement ( track ) ; return track ; } 
public int search ( Object object ) { int i = size ( ) - 1 ; int n = 1 ; while ( i >= 0 ) { Object current = get ( i ) ; if ( ( object == null && current == null ) || ( object != null && object . equals ( current ) ) ) { return n ; } i -- ; n ++ ; } return - 1 ; } 
public static String string ( int i ) { String s = opcodes . getString ( i ) ; return ( s != null ) ? s : new Integer ( i ) . toString ( ) ; } 
public boolean getIndent ( ) { return m_handler . getIndent ( ) ; } 
private void addTransform ( Transform transform ) { if ( true ) if ( log . isLoggable ( java . util . logging . Level . FINE ) ) log . log ( java . util . logging . Level . FINE , "Transforms.addTransform(" + transform . getURI ( ) + ")" ) ; Element transformElement = transform . getElement ( ) ; this . _constructionElement . appendChild ( transformElement ) ; XMLUtils . addReturnToElement ( this . _constructionElement ) ; } 
public final void addReference ( Object ref ) { refSet . add ( ref ) ; } 
public static void writeChaco ( Graph g , PrintStream out ) { if ( g . directed ( ) ) System . err . println ( "warning:-you're-saving-a-directed-graph-in-Chaco-format" ) ; long edges = 0 ; for ( int i = 0 ; i < g . size ( ) ; ++ i ) edges += g . getNeighbours ( i ) . size ( ) ; out . println ( g . size ( ) + "-" + edges / 2 ) ; for ( int i = 0 ; i < g . size ( ) ; ++ i ) { Iterator it = g . getNeighbours ( i ) . iterator ( ) ; while ( it . hasNext ( ) ) { out . print ( ( ( ( Integer ) it . next ( ) ) . intValue ( ) + 1 ) + "-" ) ; } out . println ( ) ; } out . println ( ) ; } 
protected boolean requestFocus ( boolean temporary ) { toolkit . lockAWT ( ) ; try { } finally { toolkit . unlockAWT ( ) ; } return false ; } 
private void drawDays ( Canvas canvas ) { int y = ( ( ( mRowHeight + mMiniDayNumberTextSize ) / 2 ) - DAY_SEPARATOR_WIDTH ) + mMonthHeaderSize ; int dayWidthHalf = ( mWidth - mPadding * 2 ) / ( mNumDays * 2 ) ; int j = findDayOffset ( ) ; for ( int day = 1 ; day <= mNumCells ; day ++ ) { int x = ( 2 * j + 1 ) * dayWidthHalf + mPadding ; if ( mSelectedDay == day ) { canvas . drawCircle ( x , y - ( mMiniDayNumberTextSize / 3 ) , mDaySelectedCircleSize , mDayNumberSelectedPaint ) ; } if ( mHasToday && mToday == day ) { mDayNumberPaint . setColor ( mSelectedDayColor ) ; } else { mDayNumberPaint . setColor ( mNormalTextColor ) ; } final Paint paint = ( day < mEnabledDayStart || day > mEnabledDayEnd ) ? mDayNumberDisabledPaint : mDayNumberPaint ; canvas . drawText ( String . format ( "%d" , day ) , x , y , paint ) ; j ++ ; if ( j == mNumDays ) { j = 0 ; y += mRowHeight ; } } } 
public static String pad ( String source , String padChar , int length , boolean leftPad ) { StringBuffer temp = new StringBuffer ( ) ; if ( leftPad ) { for ( int i = 0 ; i < length ; i ++ ) { temp . append ( padChar ) ; } temp . append ( source ) ; } else { temp . append ( source ) ; for ( int i = 0 ; i < length ; i ++ ) { temp . append ( padChar ) ; } } return temp . toString ( ) ; } 
public BufferedReader sendQuery ( String xmlQuery ) throws IOException { System . out . println ( "Generated-Query:-" + xmlQuery ) ; URL url = new URL ( baseURL ) ; URLConnection uc = URLUtil . getURLConnection ( url ) ; uc . setDoOutput ( true ) ; uc . setRequestProperty ( "User-Agent" , "Java-URLConnection" ) ; OutputStream os = uc . getOutputStream ( ) ; final String postStr = "query=" + xmlQuery ; PrintStream ps = new PrintStream ( os ) ; ps . print ( postStr ) ; os . close ( ) ; ps . close ( ) ; ps = null ; os = null ; return new BufferedReader ( new InputStreamReader ( uc . getInputStream ( ) ) , BUFFER_SIZE ) ; } 
public Object [ ] getCreatedElements ( ) { return fCreations . values ( ) . toArray ( ) ; } 
private static int findBestMotZoomX10 ( CharSequence motZoomValuesString , int desiredZoomX10 ) { int bestMotZoomX10 = 0 ; for ( String motZoomValueString : COMMA_PATTERN . split ( motZoomValuesString ) ) { motZoomValueString = motZoomValueString . trim ( ) ; double motZoomValue ; try { motZoomValue = Double . parseDouble ( motZoomValueString ) ; } catch ( NumberFormatException e ) { return desiredZoomX10 ; } int motZoomValueX10 = ( int ) ( 10.0 * motZoomValue ) ; if ( Math . abs ( desiredZoomX10 - motZoomValueX10 ) < Math . abs ( desiredZoomX10 - bestMotZoomX10 ) ) { bestMotZoomX10 = motZoomValueX10 ; } } return bestMotZoomX10 ; } 
public static void writeObjectsInListToStream ( List par0List , DataOutputStream par1DataOutputStream ) throws IOException { if ( par0List != null ) { Iterator var2 = par0List . iterator ( ) ; while ( var2 . hasNext ( ) ) { WatchableObject var3 = ( WatchableObject ) var2 . next ( ) ; writeWatchableObject ( par1DataOutputStream , var3 ) ; } } par1DataOutputStream . writeByte ( 127 ) ; } 
public String getDatabaseProductVersion ( ) throws SQLException { return this . conn . getServerVersion ( ) ; } 
LimeXMLReplyCollection ( String URI , File path , Provider < Library > library , LimeXMLDocumentFactory limeXMLDocumentFactory , MetaDataReader metaDataReader , MetaDataFactory metaDataFactory ) { this . schemaURI = URI ; this . library = library ; this . limeXMLDocumentFactory = limeXMLDocumentFactory ; this . metaDataReader = metaDataReader ; this . metaDataFactory = metaDataFactory ; this . trieMap = new HashMap < String , StringTrie < List < LimeXMLDocument >>> ( ) ; this . mainMap = new HashMap < FileAndUrn , LimeXMLDocument > ( ) ; this . savedDocsDir = path ; this . oldMap = readMapFromDisk ( ) ; } 
public double getFlatness ( ) { return Line2D . ptSegDist ( getX1 ( ) , getY1 ( ) , getX2 ( ) , getY2 ( ) , getCtrlX ( ) , getCtrlY ( ) ) ; } 
private Signal feedCharU0 ( char c ) { switch ( Character . getType ( c ) ) { case Character . LINE_SEPARATOR : case Character . PARAGRAPH_SEPARATOR : case Character . SPACE_SEPARATOR : theCurrentState = States . O0 ; return Signal . end_word ; case Character . DECIMAL_DIGIT_NUMBER : case Character . LETTER_NUMBER : case Character . OTHER_NUMBER : theCurrentState = States . N0 ; return Signal . switch_word ; case Character . LOWERCASE_LETTER : case Character . UPPERCASE_LETTER : case Character . MODIFIER_LETTER : case Character . OTHER_LETTER : case Character . TITLECASE_LETTER : theCurrentState = States . L0 ; return Signal . switch_word ; default : return Signal . nop ; } } 
public void insert_double ( double d ) { typeCode = orb . get_primitive_tc ( TCKind . _tk_double ) ; value = Double . doubleToLongBits ( d ) ; isInitialized = true ; } 
public Color gray2RBG ( final double g ) { if ( g < 0 || g > 1 ) throw new IllegalArgumentException ( String . valueOf ( g ) ) ; return new Color ( ( float ) g , ( float ) g , ( float ) g ) ; } 
public List < String > getClazzs ( ) { if ( clazzs == null ) { clazzs = new ArrayList < String > ( ) ; } return this . clazzs ; } 
public synchronized < T > T unwrap ( java . lang . Class < T > iface ) throws java . sql . SQLException { try { if ( "java.sql.Statement" . equals ( iface . getName ( ) ) || "java.sql.PreparedStatement" . equals ( iface . getName ( ) ) || "java.sql.Wrapper.class" . equals ( iface . getName ( ) ) ) { return iface . cast ( this ) ; } if ( unwrappedInterfaces == null ) { unwrappedInterfaces = new HashMap ( ) ; } Object cachedUnwrapped = unwrappedInterfaces . get ( iface ) ; if ( cachedUnwrapped == null ) { if ( cachedUnwrapped == null ) { cachedUnwrapped = Proxy . newProxyInstance ( this . wrappedStmt . getClass ( ) . getClassLoader ( ) , new Class [ ] { iface } , new ConnectionErrorFiringInvocationHandler ( this . wrappedStmt ) ) ; unwrappedInterfaces . put ( iface , cachedUnwrapped ) ; } unwrappedInterfaces . put ( iface , cachedUnwrapped ) ; } return iface . cast ( cachedUnwrapped ) ; } catch ( ClassCastException cce ) { throw SQLError . createSQLException ( "Unable-to-unwrap-to-" + iface . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , this . exceptionInterceptor ) ; } } 
public void addLine ( String line ) { int index = line . indexOf ( ":" , 1 ) ; if ( index != - 1 ) { addLenient ( line . substring ( 0 , index ) , line . substring ( index + 1 ) ) ; } else if ( line . startsWith ( ":" ) ) { addLenient ( "" , line . substring ( 1 ) ) ; } else { addLenient ( "" , line ) ; } } 
private void checkNegativeNumberExpression ( ) { if ( ( numberFormat instanceof DecimalFormat ) && ! numberFormat . equals ( originalNumberFormat ) ) { String numberPattern = ( ( DecimalFormat ) numberFormat ) . toPattern ( ) ; if ( ! numberPattern . equals ( originalNumberPattern ) ) { hasFollowingMinusSign = false ; int separatorIndex = numberPattern . indexOf ( ';' ) ; if ( separatorIndex > - 1 ) { int minusIndex = numberPattern . indexOf ( '-' , separatorIndex ) ; if ( ( minusIndex > numberPattern . lastIndexOf ( '0' ) ) && ( minusIndex > numberPattern . lastIndexOf ( '#' ) ) ) { hasFollowingMinusSign = true ; minusSign = ( ( DecimalFormat ) numberFormat ) . getDecimalFormatSymbols ( ) . getMinusSign ( ) ; } } originalNumberPattern = numberPattern ; } originalNumberFormat = numberFormat ; } } 
public void setPrimaryPhoneId ( JAXBElement < Long > value ) { this . primaryPhoneId = ( ( JAXBElement < Long > ) value ) ; } 
public URI relativize ( URI uri ) { return relativize ( this , uri ) ; } 
public void getChars ( int start , int end , char [ ] buffer , int index ) { if ( 0 <= start && start <= end && end <= count ) { System . arraycopy ( value , start + offset , buffer , index , end - start ) ; } else { throw new StringIndexOutOfBoundsException ( ) ; } } 
protected void fireColumnMarginChanged ( ) { EventListener [ ] listeners = getListeners ( TableColumnModelListener . class ) ; if ( changeEvent == null && listeners . length > 0 ) changeEvent = new ChangeEvent ( this ) ; for ( int i = 0 ; i < listeners . length ; ++ i ) ( ( TableColumnModelListener ) listeners [ i ] ) . columnMarginChanged ( changeEvent ) ; } 
protected short getNativeShort ( int columnIndex ) throws SQLException { return getNativeShort ( columnIndex , true ) ; } 
public String toString ( ) { return "Basic-Nearest-Neighbor-with-IG-numfeatures:-" + String . valueOf ( num_features_to_select ) + "-with-epsilon-" + String . valueOf ( this . eps ) + "-average-distance-:-" + String . valueOf ( this . distsum / this . numpred ) ; } 
public static QueuePlacementPolicy fromXml ( Element el , Map < FSQueueType , Set < String >> configuredQueues , Configuration conf ) throws AllocationConfigurationException { List < QueuePlacementRule > rules = new ArrayList < QueuePlacementRule > ( ) ; NodeList elements = el . getChildNodes ( ) ; for ( int i = 0 ; i < elements . getLength ( ) ; i ++ ) { Node node = elements . item ( i ) ; if ( node instanceof Element ) { QueuePlacementRule rule = createAndInitializeRule ( node ) ; rules . add ( rule ) ; } } return new QueuePlacementPolicy ( rules , configuredQueues , conf ) ; } 
public GenericApplicationContext remove ( String aKey ) { GenericApplicationContext context = mContextMap . remove ( aKey ) ; Set < QName > names = mNameMap . get ( aKey ) ; if ( names != null ) { for ( QName name : names ) { mQNameContextMap . remove ( name ) ; } } mNameMap . remove ( aKey ) ; if ( context != null ) { context . stop ( ) ; } return context ; } 
private int endCheck ( ) { switch ( type ) { case Token . BREAK : return endCheckBreak ( ) ; case Token . EXPR_VOID : if ( this . first != null ) return first . endCheck ( ) ; return END_DROPS_OFF ; case Token . YIELD : return END_YIELDS ; case Token . CONTINUE : case Token . THROW : return END_UNREACHED ; case Token . RETURN : if ( this . first != null ) return END_RETURNS_VALUE ; else return END_RETURNS ; case Token . TARGET : if ( next != null ) return next . endCheck ( ) ; else return END_DROPS_OFF ; case Token . LOOP : return endCheckLoop ( ) ; case Token . LOCAL_BLOCK : case Token . BLOCK : if ( first == null ) return END_DROPS_OFF ; switch ( first . type ) { case Token . LABEL : return first . endCheckLabel ( ) ; case Token . IFNE : return first . endCheckIf ( ) ; case Token . SWITCH : return first . endCheckSwitch ( ) ; case Token . TRY : return first . endCheckTry ( ) ; default : return endCheckBlock ( ) ; } default : return END_DROPS_OFF ; } } 
public boolean isFileIgnored ( String filePath ) { for ( String path : ignorePaths ) { if ( path . equals ( filePath ) ) { return true ; } } for ( String pattern : ignorePatterns ) { if ( filePath . matches ( pattern ) ) { return true ; } } return false ; } 
public void add ( DBusEntry entry ) { entries . add ( entry ) ; } 
public void lockIds ( Iterable < Integer > ids ) { try { lock . lock ( ) ; for ( int id : ids ) { boolean status = idList . get ( id ) ; if ( status ) { throw new IDFactoryError ( "ID-" + id + "-is-already-taken,-fatal-error!!!" ) ; } idList . set ( id ) ; } } finally { lock . unlock ( ) ; } } 
Reaper ( ) { super ( "File-Reaper" ) ; setPriority ( Thread . MAX_PRIORITY ) ; setDaemon ( true ) ; } 
public String getBaseURI ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } if ( attributes != null ) { Attr attrNode = ( Attr ) attributes . getNamedItem ( "xml:base" ) ; if ( attrNode != null ) { String uri = attrNode . getNodeValue ( ) ; if ( uri . length ( ) != 0 ) { try { uri = new URI ( uri ) . toString ( ) ; } catch ( org . apache . xerces . util . URI . MalformedURIException e ) { String parentBaseURI = ( this . ownerNode != null ) ? this . ownerNode . getBaseURI ( ) : null ; if ( parentBaseURI != null ) { try { uri = new URI ( new URI ( parentBaseURI ) , uri ) . toString ( ) ; } catch ( org . apache . xerces . util . URI . MalformedURIException ex ) { return null ; } return uri ; } return null ; } return uri ; } } } String baseURI = ( this . ownerNode != null ) ? this . ownerNode . getBaseURI ( ) : null ; if ( baseURI != null ) { try { return new URI ( baseURI ) . toString ( ) ; } catch ( org . apache . xerces . util . URI . MalformedURIException e ) { return null ; } } return null ; } 
public boolean isExpired ( ) { return expires != - 1 && System . currentTimeMillis ( ) > expires ; } 
@ Override public Object getAttribute ( String name ) { synchronized ( attributes ) { return ( attributes . get ( name ) ) ; } } 
public static File getContainerLogFile ( ContainerId containerId , String fileName , String remoteUser , Context context ) throws YarnException { Container container = context . getContainers ( ) . get ( containerId ) ; Application application = getApplicationForContainer ( containerId , context ) ; checkAccess ( remoteUser , application , context ) ; if ( container != null ) { checkState ( container . getContainerState ( ) ) ; } try { LocalDirsHandlerService dirsHandler = context . getLocalDirsHandler ( ) ; String relativeContainerLogDir = ContainerLaunch . getRelativeContainerLogDir ( application . getAppId ( ) . toString ( ) , containerId . toString ( ) ) ; Path logPath = dirsHandler . getLogPathToRead ( relativeContainerLogDir + Path . SEPARATOR + fileName ) ; URI logPathURI = new URI ( logPath . toString ( ) ) ; File logFile = new File ( logPathURI . getPath ( ) ) ; return logFile ; } catch ( URISyntaxException e ) { throw new YarnException ( "Internal-error" , e ) ; } catch ( IOException e ) { LOG . warn ( "Failed-to-find-log-file" , e ) ; throw new NotFoundException ( "Cannot-find-this-log-on-the-local-disk." ) ; } } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public static ScheduledExecutorService newScheduledThreadPool ( int corePoolSize , ThreadFactory threadFactory ) { return new ScheduledThreadPoolExecutor ( corePoolSize , threadFactory ) ; } 
public MasterTxn getAckTxn ( long txnId ) { TxnInfo txnInfo = txnMap . get ( txnId ) ; return ( txnInfo == null ) ? null : txnInfo . txn ; } 
public void addContentView ( View view , ViewGroup . LayoutParams params ) { mWindow . addContentView ( view , params ) ; } 
public static String encodeObject ( java . io . Serializable serializableObject ) throws java . io . IOException { return encodeObject ( serializableObject , NO_OPTIONS ) ; } 
public static int remove ( Connection pCon , int pHistoryId , boolean pLogFl ) throws SQLException { if ( pLogFl ) { long millis = System . currentTimeMillis ( ) ; java . util . Date rmDate = new java . util . Date ( millis ) ; java . text . SimpleDateFormat smf = new java . text . SimpleDateFormat ( "yyyy-MM-dd-HH:mm:ss" ) ; String oracleDate = "to_date('" + smf . format ( rmDate ) + "','YYYY-MM-DD-HH24:MI:SS')" ; String sqlLog = "INSERT-INTO-LCLW_HISTORY-SELECT-" + millis + "," + oracleDate + ",'D','O',d.*-FROM-CLW_HISTORY-d-WHERE-HISTORY_ID-=-" + pHistoryId ; Statement stmt = pCon . createStatement ( ) ; stmt . executeUpdate ( sqlLog ) ; stmt . close ( ) ; } int n = remove ( pCon , pHistoryId ) ; return n ; } 
public void intervalAdded ( ListDataEvent e ) { updateLayoutStateNeeded |= modelChanged ; list . revalidate ( ) ; } 
public static void main ( String [ ] args ) { Stack < String > s = new Stack < String > ( ) ; while ( ! StdIn . isEmpty ( ) ) { String item = StdIn . readString ( ) ; if ( ! item . equals ( "-" ) ) s . push ( item ) ; else if ( ! s . isEmpty ( ) ) StdOut . print ( s . pop ( ) + "-" ) ; } StdOut . println ( "(" + s . size ( ) + "-left-on-stack)" ) ; } 
public Entry toCacheEntry ( byte [ ] data ) { Entry e = new Entry ( ) ; e . data = data ; e . etag = etag ; e . serverDate = serverDate ; e . ttl = ttl ; e . softTtl = softTtl ; e . responseHeaders = responseHeaders ; return e ; } 
@ SuppressWarnings ( "unchecked" ) public Class < ? extends OutputFormat < ? , ? >> getOutputFormatClass ( ) throws ClassNotFoundException { return ( Class < ? extends OutputFormat < ? , ? >> ) conf . getClass ( OUTPUT_FORMAT_CLASS_ATTR , TextOutputFormat . class ) ; } 
public static void encodeToFile ( byte [ ] dataToEncode , String filename ) throws java . io . IOException { if ( dataToEncode == null ) { throw new NullPointerException ( "Data-to-encode-was-null." ) ; } Base64 . OutputStream bos = null ; try { bos = new Base64 . OutputStream ( new java . io . FileOutputStream ( filename ) , Base64 . ENCODE ) ; bos . write ( dataToEncode ) ; } catch ( java . io . IOException e ) { throw e ; } finally { try { bos . close ( ) ; } catch ( Exception e ) { } } } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public static boolean addFacility ( String name ) { if ( ! logFacilities . containsKey ( name ) ) { logFacilities . put ( name , new FileLogFacility ( name , new File ( "Logs" ) ) ) ; return true ; } return false ; } 
public boolean isViewUnder ( View view , int x , int y ) { if ( view == null ) { return false ; } return x >= view . getLeft ( ) && x < view . getRight ( ) && y >= view . getTop ( ) && y < view . getBottom ( ) ; } 
public static void execute ( Runnable runnable ) { sDefaultExecutor . execute ( runnable ) ; } 
private static String getRequestURL ( String baseURL ) { StringBuffer requestURL = new StringBuffer ( baseURL ) ; requestURL . append ( "?verb=Identify" ) ; return requestURL . toString ( ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
protected final int getNumberOfFormatRecords ( ) { return formatsList . size ( ) ; } 
public static int copy ( InputStream in , OutputStream out ) throws IOException { int total = 0 ; byte [ ] buffer = new byte [ 8192 ] ; int c ; while ( ( c = in . read ( buffer ) ) != - 1 ) { total += c ; out . write ( buffer , 0 , c ) ; } return total ; } 
public String getCurrentSongId ( ) { if ( ! mMusicAvailable ) { return "" ; } return mMusicCursor . getString ( TRACK_ID ) ; } 
protected void forwardUpdate ( DocumentEvent . ElementChange ec , DocumentEvent e , Shape a , ViewFactory f ) { calculateUpdateIndexes ( e ) ; int hole0 = lastUpdateIndex + 1 ; int hole1 = hole0 ; Element [ ] addedElems = ( ec != null ) ? ec . getChildrenAdded ( ) : null ; if ( ( addedElems != null ) && ( addedElems . length > 0 ) ) { hole0 = ec . getIndex ( ) ; hole1 = hole0 + addedElems . length - 1 ; } for ( int i = firstUpdateIndex ; i <= lastUpdateIndex ; i ++ ) { if ( ! ( ( i >= hole0 ) && ( i <= hole1 ) ) ) { View v = getView ( i ) ; if ( v != null ) { Shape childAlloc = getChildAllocation ( i , a ) ; forwardUpdateToView ( v , e , childAlloc , f ) ; } } } } 
public static int getClosestDataSetIndex ( List < SelectionDetail > valsAtIndex , float val , AxisDependency axis ) { int index = - Integer . MAX_VALUE ; float distance = Float . MAX_VALUE ; for ( int i = 0 ; i < valsAtIndex . size ( ) ; i ++ ) { SelectionDetail sel = valsAtIndex . get ( i ) ; if ( axis == null || sel . dataSet . getAxisDependency ( ) == axis ) { float cdistance = Math . abs ( ( float ) sel . val - val ) ; if ( cdistance < distance ) { index = valsAtIndex . get ( i ) . dataSetIndex ; distance = cdistance ; } } } return index ; } 
public void quadTo ( float x1 , float y1 , float x2 , float y2 ) { isSimplePath = false ; native_quadTo ( mNativePath , x1 , y1 , x2 , y2 ) ; } 
public static Map < Integer , List < Integer >> edgelist2adjlist ( Set < Edge > edges , Integer exit ) { Map < Integer , List < Integer >> adjList = new HashMap < Integer , List < Integer >> ( ) ; for ( Edge e : edges ) { List < Integer > list = adjList . get ( e . getSource ( ) ) ; if ( list == null ) { list = new LinkedList < Integer > ( ) ; adjList . put ( e . getSource ( ) , list ) ; } list . add ( e . getTarget ( ) ) ; } if ( exit != null && adjList . get ( exit ) == null ) adjList . put ( exit , new LinkedList < Integer > ( ) ) ; return adjList ; } 
public static JComboBox createComboBox ( Object [ ] model , boolean sort ) { JComboBox comboBox = CayenneWidgetFactory . createComboBox ( ) ; if ( sort ) { Arrays . sort ( model ) ; } comboBox . setModel ( new DefaultComboBoxModel ( model ) ) ; return comboBox ; } 
private static Class < ? > getClassFromSerializedName ( String serializedName , ClassLoader classLoader ) throws ClassNotFoundException { Class < ? > value = TYPE_NAMES . get ( serializedName ) ; if ( value != null ) { return value ; } return Class . forName ( serializedName , false , classLoader ) ; } 
private BigDecimal stripTrailingZeros ( BigDecimal value ) { if ( value . scale ( ) <= 0 ) { return value ; } String valueAsString = String . valueOf ( value ) ; int idx = valueAsString . indexOf ( "." ) ; if ( idx == - 1 ) { return value ; } for ( int i = valueAsString . length ( ) - 1 ; i > idx ; i -- ) { if ( valueAsString . charAt ( i ) == '0' ) { valueAsString = valueAsString . substring ( 0 , i ) ; } else if ( valueAsString . charAt ( i ) == '.' ) { valueAsString = valueAsString . substring ( 0 , i ) ; break ; } else { break ; } } BigDecimal result = new BigDecimal ( valueAsString ) ; return result ; } 
protected void updateTree ( DocumentEvent event ) { updatingSelection = true ; try { TreeModel model = getTreeModel ( ) ; Object root = model . getRoot ( ) ; for ( int counter = model . getChildCount ( root ) - 1 ; counter >= 0 ; counter -- ) { updateTree ( event , ( Element ) model . getChild ( root , counter ) ) ; } } finally { updatingSelection = false ; } } 
@ XmlElementDecl ( namespace = "" , name = "UcPsi" , scope = DocTitleType . class ) public JAXBElement < DocEmptyType > createDocTitleTypeUcPsi ( DocEmptyType value ) { return new JAXBElement < DocEmptyType > ( _DocURLLinkUcPsi_QNAME , DocEmptyType . class , DocTitleType . class , value ) ; } 
public int getLength ( ) { return qAtts . getLength ( ) ; } 
public static void writeXmlDocument ( Document doc , String filename ) throws TransformerConfigurationException , TransformerException { Source source = new DOMSource ( doc ) ; File file = new File ( filename ) ; Result result = new StreamResult ( file ) ; Transformer xformer = TransformerFactory . newInstance ( ) . newTransformer ( ) ; xformer . transform ( source , result ) ; } 
public boolean isSplitTouchEnabled ( ) { if ( mSplitTouchEnabled < 0 && mContext != null ) { return mContext . getApplicationInfo ( ) . targetSdkVersion >= Build . VERSION_CODES . HONEYCOMB ; } return mSplitTouchEnabled == 1 ; } 
public String terminate ( ) { Collections . sort ( data ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < data . size ( ) ; i ++ ) { sb . append ( data . get ( i ) ) ; } return sb . toString ( ) ; } 
private void addReference ( final int sourcePosition , final int referencePosition ) { if ( srcAndRefPositions == null ) { srcAndRefPositions = new int [ 6 ] ; } if ( referenceCount >= srcAndRefPositions . length ) { int [ ] a = new int [ srcAndRefPositions . length + 6 ] ; System . arraycopy ( srcAndRefPositions , 0 , a , 0 , srcAndRefPositions . length ) ; srcAndRefPositions = a ; } srcAndRefPositions [ referenceCount ++ ] = sourcePosition ; srcAndRefPositions [ referenceCount ++ ] = referencePosition ; } 
public static URI makeFileLoggerURL ( File dataDir , File dataLogDir ) { return URI . create ( makeURIString ( dataDir . getPath ( ) , dataLogDir . getPath ( ) , null ) ) ; } 
public void dispatchWindowVisibilityChanged ( int visibility ) { onWindowVisibilityChanged ( visibility ) ; } 
public int getJobCount ( ) { return jobs . size ( ) ; } 
@ Override protected void buildInnerString ( StringBuilder sb ) { sb . append ( getNamespaceReferenceAsString ( ) ) ; sb . append ( '-' ) ; sb . append ( IASKeywordConstants . CLASS ) ; sb . append ( '-' ) ; sb . append ( getBaseName ( ) ) ; sb . append ( '-' ) ; if ( baseClassReference != null ) { sb . append ( IASKeywordConstants . EXTENDS ) ; sb . append ( '-' ) ; String baseClassName = getBaseClassAsDisplayString ( ) ; sb . append ( baseClassName . isEmpty ( ) ? IASLanguageConstants . Object : baseClassName ) ; } String [ ] implementedInterfaces = getImplementedInterfacesAsDisplayStrings ( ) ; int n = implementedInterfaces . length ; if ( n > 0 ) { sb . append ( '-' ) ; sb . append ( IASKeywordConstants . IMPLEMENTS ) ; sb . append ( '-' ) ; for ( int i = 0 ; i < n ; i ++ ) { sb . append ( implementedInterfaces [ i ] ) ; if ( i < n - 1 ) { sb . append ( ',' ) ; sb . append ( '-' ) ; } } } } 
public float getAspectRatio ( int imageIndex ) throws IOException { return ( float ) getWidth ( imageIndex ) / getHeight ( imageIndex ) ; } 
@ Deprecated public static void disableSwingFocusManager ( ) { if ( enabled ) { enabled = false ; KeyboardFocusManager . getCurrentKeyboardFocusManager ( ) . setDefaultFocusTraversalPolicy ( new DefaultFocusTraversalPolicy ( ) ) ; } } 
static public Class loadClass ( String clazz ) throws ClassNotFoundException { if ( java1 || ignoreTCL ) { return Class . forName ( clazz ) ; } else { try { return getTCL ( ) . loadClass ( clazz ) ; } catch ( InvocationTargetException e ) { if ( e . getTargetException ( ) instanceof InterruptedException || e . getTargetException ( ) instanceof InterruptedIOException ) { Thread . currentThread ( ) . interrupt ( ) ; } } catch ( Throwable t ) { } } return Class . forName ( clazz ) ; } 
public boolean remove ( Object o ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { int i = indexOf ( o ) ; if ( i == - 1 ) return false ; removeAt ( i ) ; return true ; } finally { lock . unlock ( ) ; } } 
public static Point convertPoint ( Component source , int x , int y , Component destination ) { Point point = new Point ( x , y ) ; return convertPoint ( source , point , destination ) ; } 
public void setStatusLine ( String statusLine ) throws IOException { if ( this . responseMessage != null ) { throw new IllegalStateException ( "statusLine-is-already-set" ) ; } boolean hasMessage = statusLine . length ( ) > 13 ; if ( ! statusLine . startsWith ( "HTTP/1." ) || statusLine . length ( ) < 12 || statusLine . charAt ( 8 ) != '-' || ( hasMessage && statusLine . charAt ( 12 ) != '-' ) ) { throw new ProtocolException ( "Unexpected-status-line:-" + statusLine ) ; } int httpMinorVersion = statusLine . charAt ( 7 ) - '0' ; if ( httpMinorVersion < 0 || httpMinorVersion > 9 ) { throw new ProtocolException ( "Unexpected-status-line:-" + statusLine ) ; } int responseCode ; try { responseCode = Integer . parseInt ( statusLine . substring ( 9 , 12 ) ) ; } catch ( NumberFormatException e ) { throw new ProtocolException ( "Unexpected-status-line:-" + statusLine ) ; } this . responseMessage = hasMessage ? statusLine . substring ( 13 ) : "" ; this . responseCode = responseCode ; this . statusLine = statusLine ; this . httpMinorVersion = httpMinorVersion ; } 
private void readOpsCfg ( ) { try { BufferedReader reader = new BufferedReader ( new FileReader ( new File ( "config/ops.cfg" ) ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . startsWith ( "#" ) ) { continue ; } if ( ! isOpped ( line ) ) { addPlayer ( line ) ; } } } catch ( FileNotFoundException e ) { Canary . logInfo ( "Could-not-find-config/ops.cfg.-Creating-one-for-you..." ) ; File f = new File ( "config/ops.cfg" ) ; try { if ( f . createNewFile ( ) ) { PrintWriter pwriter = new PrintWriter ( new FileWriter ( f ) ) ; pwriter . println ( "#-Note:-This-file-is-not-guaranteed-to-be-synchronous-with-the-actual-ops-list-in-database." ) ; pwriter . println ( "#-However,-you-may-use-it-to-quickly-add-new-operators-as-you-please." ) ; pwriter . println ( "#-Any-duplicate-entries-will-be-taken-care-of-so-don't-worry." ) ; pwriter . println ( "#-Lines-starting-with-#-are-comments-;)" ) ; pwriter . println ( "#-Add-one-name-to-each-line." ) ; pwriter . close ( ) ; Canary . logInfo ( "You-can-now-add-ops-to-config/ops.cfg-(one-per-line!).-We-left-you-a-note." ) ; } } catch ( IOException e1 ) { Canary . logSevere ( "Failed-to-write-config/ops.cfg!-(Probably-no-write-access!)" , e ) ; } } catch ( IOException e ) { Canary . logSevere ( "Failed-to-read-from-config/ops.cfg!" , e ) ; } } 
public static ScriptIntrinsicConvolve5x5 create ( RenderScript rs , Element e ) { if ( ! e . isCompatible ( Element . U8 ( rs ) ) && ! e . isCompatible ( Element . U8_2 ( rs ) ) && ! e . isCompatible ( Element . U8_3 ( rs ) ) && ! e . isCompatible ( Element . U8_4 ( rs ) ) && ! e . isCompatible ( Element . F32 ( rs ) ) && ! e . isCompatible ( Element . F32_2 ( rs ) ) && ! e . isCompatible ( Element . F32_3 ( rs ) ) && ! e . isCompatible ( Element . F32_4 ( rs ) ) ) { throw new RSIllegalArgumentException ( "Unsuported-element-type." ) ; } int id = rs . nScriptIntrinsicCreate ( 4 , e . getID ( rs ) ) ; return new ScriptIntrinsicConvolve5x5 ( id , rs ) ; } 
public static Date convertStringToDate ( String date , String format ) { try { SimpleDateFormat reqformat = new SimpleDateFormat ( format ) ; Date dateResult = reqformat . parse ( date ) ; return dateResult ; } catch ( Exception e ) { log . error ( "DateUtil.convertStringToDate-error|-ErrMsg:" + e . getMessage ( ) , e ) ; } return null ; } 
public String getBeforeIndex ( int part , int index ) { AccessibleText at = getEditorAccessibleText ( ) ; if ( at != null ) { return at . getBeforeIndex ( part , index ) ; } return null ; } 
public static Request newGraphPathRequest ( Session session , String graphPath , Callback callback ) { return new Request ( session , graphPath , null , null , callback ) ; } 
@ Override public Collection < Clct > getCompleteCollectables ( Collection < Clct > collclct , String customUsage ) throws CommonBusinessException { if ( collclct == null ) { throw new NullArgumentException ( "collclct" ) ; } final Collection < Clct > result = new ArrayList < Clct > ( ) ; for ( Clct clct : collclct ) { final Clct clctComplete = this . isComplete ( clct ) ? clct : cc . readCollectable ( clct ) ; result . add ( clctComplete ) ; } assert result != null ; assert result . size ( ) == collclct . size ( ) ; return result ; } 
protected static Element makeXmlBitstream ( Bitstream bitstream , DAVResource resource ) throws AuthorizeException , SQLException , IOException { Element b = new Element ( "bitstream" , DAV . NS_DSPACE ) ; long length = bitstream . getSize ( ) ; BitstreamFormat bf = bitstream . getFormat ( ) ; if ( length > BITSTREAM_INLINE_THRESHOLD ) { Element e = new Element ( "link" , DAV . NS_DSPACE ) ; e . setAttribute ( "href" , resource . hrefPrefix ( ) + "retrieve_" + String . valueOf ( bitstream . getID ( ) ) ) ; b . addContent ( e ) ; } else { Element e = new Element ( "content" , DAV . NS_DSPACE ) ; if ( bf != null ) { e . setAttribute ( "contenttype" , bf . getMIMEType ( ) ) ; } e . setAttribute ( "contentlength" , String . valueOf ( length ) ) ; e . setAttribute ( "contentencoding" , "base64" ) ; b . addContent ( e ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ( int ) length ) ; Utils . copy ( bitstream . retrieve ( ) , baos ) ; e . setText ( new String ( Base64 . encodeBase64 ( baos . toByteArray ( ) ) ) ) ; } return b ; } 
public void addCdataSectionElements ( String URI_and_localNames ) { if ( URI_and_localNames != null ) initCdataElems ( URI_and_localNames ) ; if ( m_StringOfCDATASections == null ) m_StringOfCDATASections = URI_and_localNames ; else m_StringOfCDATASections += ( "-" + URI_and_localNames ) ; } 
protected static NamingContext resolveFirstAsContext ( NamingContextDataStore impl , NameComponent [ ] n ) throws org . omg . CosNaming . NamingContextPackage . NotFound { org . omg . CORBA . Object topRef = null ; BindingTypeHolder bth = new BindingTypeHolder ( ) ; NamingContext context = null ; synchronized ( impl ) { topRef = impl . Resolve ( n [ 0 ] , bth ) ; if ( topRef == null ) { throw new org . omg . CosNaming . NamingContextPackage . NotFound ( NotFoundReason . missing_node , n ) ; } } if ( bth . value != BindingType . ncontext ) { throw new org . omg . CosNaming . NamingContextPackage . NotFound ( NotFoundReason . not_context , n ) ; } try { context = NamingContextHelper . narrow ( topRef ) ; } catch ( org . omg . CORBA . BAD_PARAM ex ) { throw new org . omg . CosNaming . NamingContextPackage . NotFound ( NotFoundReason . not_context , n ) ; } return context ; } 
public static long readLongNumber ( String longVal ) { if ( longVal . startsWith ( "0x" ) ) { return Long . parseLong ( longVal . substring ( 2 ) , 16 ) ; } else { return Long . parseLong ( longVal ) ; } } 
public void write ( OutputStream out ) throws IOException { out . write ( getData ( ) ) ; } 
public static String fileContentsToString ( File errFile ) throws IOException { String errFileString = null ; BufferedReader br = null ; StringBuffer sb = new StringBuffer ( ) ; br = new BufferedReader ( new FileReader ( errFile ) ) ; String errLine = br . readLine ( ) ; while ( errLine != null ) { sb . append ( errLine ) ; errLine = br . readLine ( ) ; } errFileString = sb . toString ( ) ; return errFileString ; } 
@ XmlElementDecl ( namespace = "http://ecircle.com/developer/ecmapi" , name = "systemGetEcmVersion" ) public JAXBElement < SystemGetEcmVersion > createSystemGetEcmVersion ( SystemGetEcmVersion value ) { return new JAXBElement < SystemGetEcmVersion > ( _SystemGetEcmVersion_QNAME , SystemGetEcmVersion . class , null , value ) ; } 
public void addBOSHClientRequestListener ( final BOSHClientRequestListener listener ) { if ( listener == null ) { throw ( new IllegalArgumentException ( NULL_LISTENER ) ) ; } requestListeners . add ( listener ) ; } 
@ Provides @ Singleton Utils provideUtilities ( ) { return Utils . getInstance ( ) ; } 
private boolean findAndRemove ( Object e ) { if ( e != null ) { for ( Node pred = null , p = head ; p != null ; ) { Object item = p . item ; if ( p . isData ) { if ( item != null && item != p && e . equals ( item ) && p . tryMatchData ( ) ) { unsplice ( pred , p ) ; return true ; } } else if ( item == null ) break ; pred = p ; if ( ( p = p . next ) == pred ) { pred = null ; p = head ; } } } return false ; } 
public void setBackground ( Drawable background ) { setBackgroundDrawable ( background ) ; } 
private Vector < String > makeOriginalSentencesPrefixes ( ) { Vector < String > comboBoxItems = new Vector < String > ( pairData . getMapTreesToSentences ( ) . values ( ) . size ( ) ) ; int i = 1 ; for ( String textSentence : pairData . getMapTreesToSentences ( ) . values ( ) ) { String prefix = textSentence . length ( ) >= TEXT_COMBOBOX_ITEM_LENGTH ? textSentence . substring ( 0 , TEXT_COMBOBOX_ITEM_LENGTH ) + "..." : textSentence ; comboBoxItems . add ( i ++ + ":-" + prefix ) ; } return comboBoxItems ; } 
private boolean timeAuthorisedBook ( Player player ) { if ( player . hasPermission ( "achievement.*" ) ) return true ; long currentTime = System . currentTimeMillis ( ) ; long lastBookTime = 0 ; if ( players . containsKey ( player ) ) lastBookTime = players . get ( player ) ; if ( currentTime - lastBookTime < bookTime ) return false ; players . put ( player , currentTime ) ; return true ; } 
public void refreshTimestamp ( ) { timestampInSeconds = System . currentTimeMillis ( ) / 1000 ; } 
private static Object min ( Object [ ] x , boolean narm ) { int n = x . length ; Object smallest = null ; Object current ; boolean found_min = false ; for ( int i = 0 ; i < n ; i ++ ) { current = x [ i ] ; if ( current == null ) { if ( ! narm ) return null ; } else { if ( ! found_min ) { smallest = current ; found_min = true ; } else if ( ( ( Comparable ) smallest ) . compareTo ( current ) > 0 ) { smallest = current ; } } } return smallest ; } 
public static ImageIcon listRightIcon ( ) { BufferedImage image = new BufferedImage ( 16 , 16 , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g2 = image . createGraphics ( ) ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setPaint ( Color . DARK_GRAY ) ; for ( int i = 3 ; i <= 12 ; i = i + 2 ) { g2 . drawLine ( 1 , i , 6 , i ) ; } g2 . setPaint ( Color . GRAY ) ; g2 . drawLine ( 10 , 5 , 10 , 9 ) ; g2 . drawLine ( 9 , 5 , 9 , 9 ) ; g2 . drawLine ( 8 , 5 , 8 , 9 ) ; for ( int i = 0 ; i <= 4 ; i ++ ) { g2 . drawLine ( 11 + i , 3 + i , 11 + i , 11 - i ) ; } ImageIcon ic = new ImageIcon ( image ) ; return ic ; } 
public static synchronized boolean isSupported ( ) { return getSTclient ( ) != null ; } 
public synchronized void close ( ) throws IOException { if ( journalWriter == null ) { return ; } for ( Entry entry : new ArrayList < Entry > ( lruEntries . values ( ) ) ) { if ( entry . currentEditor != null ) { entry . currentEditor . abort ( ) ; } } trimToSize ( ) ; journalWriter . close ( ) ; journalWriter = null ; } 
public void setUid ( String uid ) { this . uid = uid == null ? null : uid . trim ( ) ; } 
public static int couponCount ( Date settlement , Date maturity , int frequency , DayCountBasis basis ) { if ( 12 % frequency != 0 ) { throw new UnsupportedOperationException ( "Frequency-of-" + Integer . toString ( frequency ) + "-not-supported." ) ; } int nmonths = 12 / frequency , coupCount = 0 ; Date pcd = maturity ; while ( pcd . compareTo ( settlement ) > 0 ) { coupCount ++ ; pcd = DateUtil . addMonths ( pcd , - nmonths , basis ) ; } return coupCount ; } 
public static < T extends Number > T parseNumber ( String text , Class < T > targetClass , NumberFormat numberFormat ) { if ( numberFormat != null ) { org . springframework . util . Assert . notNull ( text , "Text-must-not-be-null" ) ; org . springframework . util . Assert . notNull ( targetClass , "Target-class-must-not-be-null" ) ; DecimalFormat decimalFormat = null ; boolean resetBigDecimal = false ; if ( numberFormat instanceof DecimalFormat ) { decimalFormat = ( DecimalFormat ) numberFormat ; if ( BigDecimal . class == targetClass && ! decimalFormat . isParseBigDecimal ( ) ) { decimalFormat . setParseBigDecimal ( true ) ; resetBigDecimal = true ; } } try { Number number = numberFormat . parse ( StringUtils . trimAllWhitespace ( text ) ) ; return convertNumberToTargetClass ( number , targetClass ) ; } catch ( ParseException ex ) { throw new IllegalArgumentException ( "Could-not-parse-number:-" + ex . getMessage ( ) ) ; } finally { if ( resetBigDecimal ) { decimalFormat . setParseBigDecimal ( false ) ; } } } else { return parseNumber ( text , targetClass ) ; } } 
public String getSelectedInterconnectionServer ( ) { for ( Map . Entry < String , IocConnectionState > entry : _icsConnections . entrySet ( ) ) { if ( entry . getValue ( ) == IocConnectionState . CONNECTED_SELECTED ) { return entry . getKey ( ) ; } } return null ; } 
public static Date parse ( String value ) { try { return STANDARD_DATE_FORMAT . get ( ) . parse ( value ) ; } catch ( ParseException ignored ) { } synchronized ( BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS ) { for ( int i = 0 , count = BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS . length ; i < count ; i ++ ) { DateFormat format = BROWSER_COMPATIBLE_DATE_FORMATS [ i ] ; if ( format == null ) { format = new SimpleDateFormat ( BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS [ i ] , Locale . US ) ; BROWSER_COMPATIBLE_DATE_FORMATS [ i ] = format ; } try { return format . parse ( value ) ; } catch ( ParseException ignored ) { } } } return null ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
private synchronized static long getNumberOfDaysPassed ( long date1 , long date2 ) { if ( sThenTime == null ) { sThenTime = new Time ( ) ; } sThenTime . set ( date1 ) ; int day1 = Time . getJulianDay ( date1 , sThenTime . gmtoff ) ; sThenTime . set ( date2 ) ; int day2 = Time . getJulianDay ( date2 , sThenTime . gmtoff ) ; return Math . abs ( day2 - day1 ) ; } 
public boolean isCookieSecure ( ) { if ( _isSecure ) return true ; else return ! _cookieName . equals ( _sslCookieName ) ; } 
public void restore ( Checkpoint redoCheckpoint ) { for ( Entry < OsmElement , UndoElement > entry : elements . entrySet ( ) ) { if ( redoCheckpoint != null ) redoCheckpoint . add ( entry . getKey ( ) ) ; entry . getValue ( ) . restore ( ) ; } } 
public byte [ ] toBytes ( ) throws UnsupportedEncodingException { StringBuilder result = new StringBuilder ( 256 ) ; result . append ( requestLine ) . append ( "-" ) ; for ( int i = 0 ; i < namesAndValues . size ( ) ; i += 2 ) { result . append ( namesAndValues . get ( i ) ) . append ( ":-" ) . append ( namesAndValues . get ( i + 1 ) ) . append ( "-" ) ; } result . append ( "-" ) ; return result . toString ( ) . getBytes ( "ISO-8859-1" ) ; } 
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof ServicePermission ) ) { return false ; } ServicePermission sp = ( ServicePermission ) obj ; return ( action_mask == sp . action_mask ) && getName ( ) . equals ( sp . getName ( ) ) && ( ( service == sp . service ) || ( ( service != null ) && ( service . compareTo ( sp . service ) == 0 ) ) ) ; } 
public double getDouble ( int index ) throws JSONException { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . doubleValue ( ) : Double . parseDouble ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONArray[" + index + "]-is-not-a-number." ) ; } } 
public static String [ ] splitKerberosName ( String fullName ) { return fullName . split ( "[/@]" ) ; } 
public synchronized void setAttribute ( final String name , final String value ) { final AttributeEntry entry = new AttributeEntry ( name , value ) ; final int pos = this . entryList . indexOf ( entry ) ; if ( pos != - 1 ) { this . entryList . remove ( pos ) ; } this . entryList . add ( entry ) ; } 
public boolean canTraverseOutsideSubtree ( ) { if ( null != m_right && m_right . canTraverseOutsideSubtree ( ) ) return true ; return false ; } 
private String getLookaheadBuffer ( int count ) { if ( count > lookaheadBuffer . length ( ) ) { count = lookaheadBuffer . length ( ) ; } return count > 0 ? lookaheadBuffer . substring ( 0 , count ) : "" ; } 
public double [ ] distributionForInstance ( Instance instance ) throws Exception { if ( instance . classAttribute ( ) . isNumeric ( ) ) { throw new UnsupportedClassTypeException ( "Decorate-can't-handle-a-numeric-class!" ) ; } double [ ] sums = new double [ instance . numClasses ( ) ] , newProbs ; Classifier curr ; for ( int i = 0 ; i < m_Committee . size ( ) ; i ++ ) { curr = ( Classifier ) m_Committee . get ( i ) ; newProbs = curr . distributionForInstance ( instance ) ; for ( int j = 0 ; j < newProbs . length ; j ++ ) sums [ j ] += newProbs [ j ] ; } if ( Utils . eq ( Utils . sum ( sums ) , 0 ) ) { return sums ; } else { Utils . normalize ( sums ) ; return sums ; } } 
public static String GetTypeNames ( long type ) { String sep = "," ; StringBuffer sb = new StringBuffer ( ) ; if ( ( type & TYPE_GPRMC ) != 0 ) { if ( sb . length ( ) > 0 ) { sb . append ( sep ) ; } sb . append ( NAME_GPRMC ) ; } if ( ( type & TYPE_GPGGA ) != 0 ) { if ( sb . length ( ) > 0 ) { sb . append ( sep ) ; } sb . append ( NAME_GPGGA ) ; } if ( ( type & TYPE_GPVTG ) != 0 ) { if ( sb . length ( ) > 0 ) { sb . append ( sep ) ; } sb . append ( NAME_GPVTG ) ; } if ( ( type & TYPE_GPZDA ) != 0 ) { if ( sb . length ( ) > 0 ) { sb . append ( sep ) ; } sb . append ( NAME_GPZDA ) ; } return ( sb . length ( ) > 0 ) ? sb . toString ( ) : NAME_NONE ; } 
Item load ( ) { throw new AssertionError ( ) ; } 
public int getHourOfDay ( ) { return getChronology ( ) . hourOfDay ( ) . get ( getLocalMillis ( ) ) ; } 
protected void makeVisible ( ) { FHTreeStateNode parent = ( FHTreeStateNode ) getParent ( ) ; if ( parent != null ) parent . expandParentAndReceiver ( ) ; } 
@ Override public ClassLoader getParentClassLoader ( ) { if ( parentClassLoader != null ) return ( parentClassLoader ) ; if ( parent != null ) { return ( parent . getParentClassLoader ( ) ) ; } return ( ClassLoader . getSystemClassLoader ( ) ) ; } 
public long longValue ( ) { return ( ( Long ) value ) . longValue ( ) ; } 
private void appendToAlignment ( String poLine ) { StringTokenizer oSt = new StringTokenizer ( poLine , "-" ) ; oSeqName = oSt . nextToken ( ) ; oSeq . setLength ( 0 ) ; while ( oSt . hasMoreTokens ( ) ) { oSeq . append ( oSt . nextToken ( ) ) ; } if ( oAlignment . get ( oSeqName ) == null ) { oAlignment . put ( oSeqName , oSeq . substring ( 0 ) ) ; oSeqNameList . add ( oSeqName ) ; } else { oTmpSeq = ( String ) oAlignment . get ( oSeqName ) ; oAlignment . put ( oSeqName , oTmpSeq . concat ( oSeq . substring ( 0 ) ) ) ; } } 
private boolean waitExpire ( long timeout ) throws InterruptedException { final int count = renewalsLeft . waitOnZero ( timeout ) ; if ( count != 0 ) return false ; final long now = System . currentTimeMillis ( ) ; synchronized ( this ) { if ( setExpiration > now ) { logger . log ( Level . INFO , "Waiting-for-" + ( setExpiration - now ) + "-ms-for-set-lease-to-expire" ) ; wait ( setExpiration - now ) ; } } return true ; } 
public static List < FactObject > parse ( String xmlString ) { FactSaxHandler saxHandler = new FactSaxHandler ( ) ; if ( xmlString . length ( ) != 0 ) { InputSource source = new InputSource ( new StringReader ( xmlString . toString ( ) ) ) ; XMLReader reader ; try { reader = XMLReaderFactory . createXMLReader ( ) ; reader . setContentHandler ( saxHandler ) ; reader . setErrorHandler ( saxHandler ) ; reader . parse ( source ) ; } catch ( SAXException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return saxHandler . getFactObjectList ( ) ; } 
public static DTD getDTD ( String name ) throws IOException { DTD d = dtdHash . get ( name ) ; if ( d == null ) { d = new DTD ( name ) ; dtdHash . put ( d . name , d ) ; } return d ; } 
public void addPathToName ( int type , byte [ ] name ) throws IOException { GeneralName path_name = new GeneralName ( type , name ) ; if ( pathToNames == null ) { pathToNames = new ArrayList ( ) ; } pathToNames . add ( path_name ) ; } 
public void send ( byte [ ] message ) throws IOException { _outServer . write ( message ) ; _outServer . flush ( ) ; } 
public static CertStore getInstance ( String type , CertStoreParameters params , String provider ) throws InvalidAlgorithmParameterException , NoSuchAlgorithmException , NoSuchProviderException { if ( provider == null || provider . isEmpty ( ) ) { throw new IllegalArgumentException ( "provider-==-null-||-provider.isEmpty()" ) ; } Provider impProvider = Security . getProvider ( provider ) ; if ( impProvider == null ) { throw new NoSuchProviderException ( provider ) ; } return getInstance ( type , params , impProvider ) ; } 
public synchronized void ensureCapacity ( int minimumCapacity ) { if ( minimumCapacity > value . length ) { expandCapacity ( minimumCapacity ) ; } } 
public void setRecipient ( RecipientType type , Address address ) throws MessagingException { Address [ ] a = new Address [ 1 ] ; a [ 0 ] = address ; setRecipients ( type , a ) ; } 
protected SecureRandom ( SecureRandomSpi secureRandomSpi , Provider provider ) { this ( secureRandomSpi , provider , "unknown" ) ; } 
private void writeStartElement ( java . lang . String prefix , java . lang . String namespace , java . lang . String localPart , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String writerPrefix = xmlWriter . getPrefix ( namespace ) ; if ( writerPrefix != null ) { xmlWriter . writeStartElement ( namespace , localPart ) ; } else { if ( namespace . length ( ) == 0 ) { prefix = "" ; } else if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; } xmlWriter . writeStartElement ( prefix , localPart , namespace ) ; xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } } 
public PointerBuffer put ( long l ) { if ( is64Bit ) view64 . put ( l ) ; else view32 . put ( ( int ) l ) ; return this ; } 
private AlertDialog . Builder CustomViewDialog ( ) { if ( builder == null ) { Log . e ( "DialogUtil" , "context-is-null" ) ; return null ; } if ( customView != null ) { builder . setView ( customView ) ; } else if ( customView != null && message != null ) { Log . e ( "DialogUtil" , "message-has-no-effect-when-using-custom-dialogView" ) ; } else if ( message != null && message . length ( ) > 0 ) { builder . setMessage ( message ) ; } if ( dialog_title != null && dialog_title . length ( ) > 0 ) builder . setTitle ( dialog_title ) ; if ( callBack != null && titlePositiveButton != null && titlePositiveButton . length ( ) > 0 ) builder . setPositiveButton ( titlePositiveButton , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { if ( callBack != null ) callBack . onPositiveButton ( ) ; } } ) ; if ( callBack != null && titleNegativeButton != null && titleNegativeButton . length ( ) > 0 ) builder . setNegativeButton ( titleNegativeButton , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialogInterface , int i ) { if ( callBack != null ) callBack . onNegativeButton ( ) ; } } ) ; return builder ; } 
public synchronized void print ( char c ) { Character ch = new Character ( c ) ; print ( ch . toString ( ) ) ; } 
private String findPerClause ( Class < ? > aspectClass ) { String str = aspectClass . getAnnotation ( Aspect . class ) . value ( ) ; str = str . substring ( str . indexOf ( "(" ) + 1 ) ; str = str . substring ( 0 , str . length ( ) - 1 ) ; return str ; } 
private int collectCandidates ( Map < Long , Score > candidates , List < Bucket > buckets , int threshold ) { int ix ; for ( ix = 0 ; ix < threshold && candidates . size ( ) < ( CUTOFF_FACTOR_1 * max_search_hits ) ; ix ++ ) { Bucket b = buckets . get ( ix ) ; long [ ] ids = b . records ; double score = b . getScore ( ) ; for ( int ix2 = 0 ; ix2 < b . nextfree ; ix2 ++ ) { Score s = candidates . get ( ids [ ix2 ] ) ; if ( s == null ) { s = new Score ( ids [ ix2 ] ) ; candidates . put ( ids [ ix2 ] , s ) ; } s . score += score ; } if ( DEBUG ) System . out . println ( "Bucket-" + b . nextfree + "-->-" + candidates . size ( ) ) ; } return ix ; } 
public void setOffset ( WorldPt offset ) { for ( PlotInfo pInfo : _plotMap . values ( ) ) { pInfo . _offset = offset ; } } 
static void closeStream ( Closeable stream ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { Log . e ( LOG_TAG , "Could-not-close-stream" , e ) ; } } } 
public boolean start ( String file ) { boolean ok = true ; try { out = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; ok = start ( out ) ; closeStream = true ; } catch ( IOException e ) { ok = false ; } return started = ok ; } 
public void shutdown ( ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { checkShutdownAccess ( ) ; advanceRunState ( SHUTDOWN ) ; interruptIdleWorkers ( ) ; onShutdown ( ) ; } finally { mainLock . unlock ( ) ; } tryTerminate ( ) ; } 
public void init ( File fromFile ) throws IOException { InputStream is = new FileInputStream ( fromFile ) ; init ( is ) ; is . close ( ) ; } 
private void fillRect ( Image imageIn , int a_x , int a_y , int squareSize , int a_rgb ) { for ( int x = a_x ; x < a_x + squareSize ; x ++ ) { for ( int y = a_y ; y < a_y + squareSize ; y ++ ) { if ( x < imageIn . getWidth ( ) && y < imageIn . getHeight ( ) ) { imageIn . setPixelColor ( x , y , a_rgb ) ; } } } } 
private Label createSeparator ( final Composite parent ) { final Label separator = new Label ( parent , SWT . NONE ) ; separator . setVisible ( false ) ; final GridData gd = new GridData ( ) ; gd . horizontalAlignment = GridData . FILL ; gd . verticalAlignment = GridData . BEGINNING ; gd . heightHint = 4 ; separator . setLayoutData ( gd ) ; return separator ; } 
@ Override public void onGeolocationPermissionsShowPrompt ( String origin , Callback callback ) { super . onGeolocationPermissionsShowPrompt ( origin , callback ) ; callback . invoke ( origin , true , false ) ; } 
protected boolean removeDescendantSelectedPaths ( TreePath path , boolean includePath ) { TreePath [ ] toRemove = getDescendantSelectedPaths ( path , includePath ) ; if ( toRemove != null ) { getSelectionModel ( ) . removeSelectionPaths ( toRemove ) ; return true ; } return false ; } 
@ Override public String toString ( ) { StringBuilder result = new StringBuilder ( Modifier . toString ( getModifiers ( ) ) ) ; if ( result . length ( ) != 0 ) { result . append ( '-' ) ; } Types . appendTypeName ( result , getType ( ) ) ; result . append ( '-' ) ; result . append ( getDeclaringClass ( ) . getName ( ) ) ; result . append ( '.' ) ; result . append ( getName ( ) ) ; return result . toString ( ) ; } 
private String removeStringDelimiters ( String key ) { String k = key . trim ( ) ; if ( k . charAt ( 0 ) == this . textDelimiter ) { k = k . substring ( 1 ) ; } if ( k . charAt ( k . length ( ) - 1 ) == this . textDelimiter ) { k = k . substring ( 0 , k . length ( ) - 1 ) ; } return k ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
@ Override public View onCreateFloatView ( int position ) { View v = mListView . getChildAt ( position + mListView . getHeaderViewsCount ( ) - mListView . getFirstVisiblePosition ( ) ) ; if ( v == null ) { return null ; } v . setPressed ( false ) ; v . setDrawingCacheEnabled ( true ) ; mFloatBitmap = Bitmap . createBitmap ( v . getDrawingCache ( ) ) ; v . setDrawingCacheEnabled ( false ) ; if ( mImageView == null ) { mImageView = new ImageView ( mListView . getContext ( ) ) ; } mImageView . setBackgroundColor ( mFloatBGColor ) ; mImageView . setPadding ( 0 , 0 , 0 , 0 ) ; mImageView . setImageBitmap ( mFloatBitmap ) ; mImageView . setLayoutParams ( new ViewGroup . LayoutParams ( v . getWidth ( ) , v . getHeight ( ) ) ) ; return mImageView ; } 
public void endElement ( String namespaceURI , String localName , String name ) throws org . xml . sax . SAXException { if ( m_inEntityRef ) return ; m_prefixMap . popNamespaces ( m_elemContext . m_currentElemDepth , null ) ; try { final java . io . Writer writer = m_writer ; if ( m_elemContext . m_startTagOpen ) { if ( m_tracer != null ) super . fireStartElem ( m_elemContext . m_elementName ) ; int nAttrs = m_attributes . getLength ( ) ; if ( nAttrs > 0 ) { processAttributes ( m_writer , nAttrs ) ; m_attributes . clear ( ) ; } if ( m_spaceBeforeClose ) writer . write ( "-/>" ) ; else writer . write ( "/>" ) ; } else { if ( m_cdataTagOpen ) closeCDATA ( ) ; if ( shouldIndent ( ) ) indent ( m_elemContext . m_currentElemDepth - 1 ) ; writer . write ( '<' ) ; writer . write ( '/' ) ; writer . write ( name ) ; writer . write ( '>' ) ; } } catch ( IOException e ) { throw new SAXException ( e ) ; } if ( ! m_elemContext . m_startTagOpen && m_doIndent ) { m_ispreserve = m_preserves . isEmpty ( ) ? false : m_preserves . pop ( ) ; } m_isprevtext = false ; if ( m_tracer != null ) super . fireEndElem ( name ) ; m_elemContext = m_elemContext . m_prev ; } 
public int getMetaDataPagesUsed ( ) { return metaDataSpace . reservedPages ( ) ; } 
@ PostConstruct public void startConsumerThread ( ) { final int numConsumerThreads = 3 ; LOGGER . info ( "Received-container-start-event,-creating-executor-service-with-threadpool-for-{}-threads" , numConsumerThreads ) ; execService = Executors . newFixedThreadPool ( numConsumerThreads ) ; for ( int i = 0 ; i < numConsumerThreads ; i ++ ) { execService . submit ( new FetchAndSendEmailFromQueueTask ( ) ) ; } this . allowMessagesOnQueue = true ; } 
public void setDateFormatSymbols ( DateFormatSymbols value ) { formatData = ( DateFormatSymbols ) value . clone ( ) ; } 
public static Element getSimFromArchiveDocument ( Document archive ) { return ( ( Element ) archive . getElementsByTagName ( XMLConstantNames . XML_DOCUMENT_ROOT ) . item ( 0 ) ) ; } 
public synchronized void setInput ( byte [ ] buf , int off , int nbytes ) { if ( streamHandle == - 1 ) { throw new IllegalStateException ( ) ; } if ( off <= buf . length && nbytes >= 0 && off >= 0 && buf . length - off >= nbytes ) { inLength = nbytes ; inRead = 0 ; if ( inputBuffer == null ) { setLevelsImpl ( compressLevel , strategy , streamHandle ) ; } inputBuffer = buf ; setInputImpl ( buf , off , nbytes , streamHandle ) ; } else { throw new ArrayIndexOutOfBoundsException ( ) ; } } 
private Node locateNodeWithSameNameSiblings ( Node node ) throws RepositoryException { NodeIterator nodes = node . getNodes ( ) ; while ( nodes . hasNext ( ) ) { Node n = nodes . nextNode ( ) ; NodeIterator nodes2 = node . getNodes ( n . getName ( ) ) ; int i = 0 ; while ( nodes2 . hasNext ( ) ) { nodes2 . next ( ) ; i ++ ; } if ( i > 1 ) { return n ; } else { Node returnedNode = locateNodeWithSameNameSiblings ( n ) ; if ( returnedNode != null ) { return returnedNode ; } } } return null ; } 
boolean checkUnique ( DiagnosticPosition pos , Symbol sym , Scope s ) { if ( sym . type . isErroneous ( ) ) return true ; if ( sym . owner . name == names . any ) return false ; for ( Scope . Entry e = s . lookup ( sym . name ) ; e . scope == s ; e = e . next ( ) ) { if ( sym != e . sym && ( e . sym . flags ( ) & CLASH ) == 0 && sym . kind == e . sym . kind && sym . name != names . error && ( sym . kind != MTH || types . hasSameArgs ( types . erasure ( sym . type ) , types . erasure ( e . sym . type ) ) ) ) { if ( ( sym . flags ( ) & VARARGS ) != ( e . sym . flags ( ) & VARARGS ) ) { varargsDuplicateError ( pos , sym , e . sym ) ; return true ; } else if ( sym . kind == MTH && ! types . hasSameArgs ( sym . type , e . sym . type , false ) ) { duplicateErasureError ( pos , sym , e . sym ) ; sym . flags_field |= CLASH ; return true ; } else { duplicateError ( pos , e . sym ) ; return false ; } } } return true ; } 
public void open ( String jndiName ) { checkExistingConnection ( dbName ) ; try { Context ctx = new InitialContext ( ) ; DataSource ds = ( DataSource ) ctx . lookup ( jndiName ) ; Connection connection = ds . getConnection ( ) ; ConnectionsAccess . attach ( dbName , connection ) ; } catch ( Exception e ) { throw new InitException ( "Failed-to-connect-to-JNDI-name:-" + jndiName , e ) ; } } 
private static String createMessage ( String detail , Throwable cause ) { String message = "Bootstrap-failed" ; if ( detail != null ) { message += ":-"" + detail + '"' ; } if ( cause != null ) { message += ".-Caught-" + cause . getClass ( ) . getName ( ) ; String causeMessage = TextUtils . trim ( cause . getMessage ( ) , null ) ; if ( causeMessage != null ) { message += "-with-message-"" + causeMessage + '"' ; } } message += '.' ; return message ; } 
private void checkLocalityRelaxationConflict ( Priority priority , Collection < String > locations , boolean relaxLocality ) { Map < String , TreeMap < Resource , ResourceRequestInfo >> remoteRequests = this . remoteRequestsTable . get ( priority ) ; if ( remoteRequests == null ) { return ; } for ( String location : locations ) { TreeMap < Resource , ResourceRequestInfo > reqs = remoteRequests . get ( location ) ; if ( reqs != null && ! reqs . isEmpty ( ) ) { boolean existingRelaxLocality = reqs . values ( ) . iterator ( ) . next ( ) . remoteRequest . getRelaxLocality ( ) ; if ( relaxLocality != existingRelaxLocality ) { throw new InvalidContainerRequestException ( "Cannot-submit-a-" + "ContainerRequest-asking-for-location-" + location + "-with-locality-relaxation-" + relaxLocality + "-when-it-has-" + "already-been-requested-with-locality-relaxation-" + existingRelaxLocality ) ; } } } } 
public boolean containsValue ( Object value ) { if ( value == null ) throw new NullPointerException ( ) ; for ( Node < K , V > n = findFirst ( ) ; n != null ; n = n . next ) { V v = n . getValidValue ( ) ; if ( v != null && value . equals ( v ) ) return true ; } return false ; } 
public static boolean checkColumnExists ( String ctx , Connection c , String table , String column ) throws SQLException { PreparedStatement ps = null ; ResultSet rs = null ; ResultSetMetaData rsmd ; String checkColumnSql = "SELECT-*-FROM-" + table + "-WHERE-1=0" ; try { ps = c . prepareStatement ( checkColumnSql ) ; rs = ps . executeQuery ( ) ; rsmd = rs . getMetaData ( ) ; int numCols = rsmd . getColumnCount ( ) ; for ( int i = 0 ; i < numCols ; i ++ ) { if ( rsmd . getColumnName ( i + 1 ) . equalsIgnoreCase ( column ) ) { return true ; } } return false ; } finally { closeJDBCObjects ( ctx , null , ps , rs ) ; } } 
public Rectangle copy ( ) { return new Rectangle ( min , max ) ; } 
private void cleanup ( Throwable whyCleanedUp ) { try { if ( ( this . io != null ) && ! isClosed ( ) ) { realClose ( false , false , false , whyCleanedUp ) ; } else if ( this . io != null ) { this . io . forceClose ( ) ; } } catch ( SQLException sqlEx ) { ; } this . isClosed = true ; } 
private Set < String > findAndFilterExpectedColumns ( final Set < String > actualCols , final Set < String > expectedCols ) { final Set < String > missingColumns = new HashSet < String > ( expectedCols ) ; missingColumns . removeAll ( actualCols ) ; if ( ! missingColumns . isEmpty ( ) ) { throw new PicardException ( String . format ( "LIBRARY_PARAMS-file-%s-is-missing-the-following-columns:-%s." , LIBRARY_PARAMS . getAbsolutePath ( ) , StringUtil . join ( ",-" , missingColumns ) ) ) ; } final Set < String > remainingColumns = new HashSet < String > ( actualCols ) ; remainingColumns . removeAll ( expectedCols ) ; return remainingColumns ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
protected String [ ] getPhones ( String phones ) { ArrayList phoneList = new ArrayList ( ) ; StringTokenizer tokenizer = new StringTokenizer ( phones , "-" ) ; while ( tokenizer . hasMoreTokens ( ) ) { phoneList . add ( tokenizer . nextToken ( ) ) ; } return ( String [ ] ) phoneList . toArray ( new String [ 0 ] ) ; } 
@ Override public boolean messageIsAssociatedWithMember ( int idMessage , String id_member ) throws SQLException { String request = "SELECT-count(*)-as-nbGMess-FROM-APP.T_EnvoiMessageMembre-" + "WHERE-idPersonneDestination-=-'" + id_member . trim ( ) + "'-" + "AND-idMessage-=-" + idMessage + "-" ; ResultSet donnees = this . doRequest ( request , java . sql . ResultSet . TYPE_SCROLL_INSENSITIVE , java . sql . ResultSet . CONCUR_READ_ONLY ) ; donnees . first ( ) ; return ( donnees . getString ( "nbGMess" ) != null && Integer . parseInt ( donnees . getString ( "nbGMess" ) . trim ( ) ) >= 1 ) ; } 
boolean inHalfOpenRange ( K key , K least , K fence ) { if ( key == null ) throw new NullPointerException ( ) ; return ( ( least == null || compare ( key , least ) >= 0 ) && ( fence == null || compare ( key , fence ) < 0 ) ) ; } 
public Object getRaw ( String name ) { return rawProps . get ( name ) ; } 
void internalInsertData ( int offset , String data , boolean replace ) throws DOMException { CoreDocumentImpl ownerDocument = ownerDocument ( ) ; if ( ownerDocument . errorChecking && isReadOnly ( ) ) { String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . DOM_DOMAIN , "NO_MODIFICATION_ALLOWED_ERR" , null ) ; throw new DOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR , msg ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } try { String value = new StringBuffer ( this . data ) . insert ( offset , data ) . toString ( ) ; setNodeValueInternal ( value , replace ) ; ownerDocument . insertedText ( this , offset , data . length ( ) ) ; } catch ( StringIndexOutOfBoundsException e ) { String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . DOM_DOMAIN , "INDEX_SIZE_ERR" , null ) ; throw new DOMException ( DOMException . INDEX_SIZE_ERR , msg ) ; } } 
public int match ( Uri uri ) { final List < String > pathSegments = uri . getPathSegments ( ) ; final int li = pathSegments . size ( ) ; UriMatcher node = this ; if ( li == 0 && uri . getAuthority ( ) == null ) { return this . mCode ; } for ( int i = - 1 ; i < li ; i ++ ) { String u = i < 0 ? uri . getAuthority ( ) : pathSegments . get ( i ) ; ArrayList < UriMatcher > list = node . mChildren ; if ( list == null ) { break ; } node = null ; int lj = list . size ( ) ; for ( int j = 0 ; j < lj ; j ++ ) { UriMatcher n = list . get ( j ) ; which_switch : switch ( n . mWhich ) { case EXACT : if ( n . mText . equals ( u ) ) { node = n ; } break ; case NUMBER : int lk = u . length ( ) ; for ( int k = 0 ; k < lk ; k ++ ) { char c = u . charAt ( k ) ; if ( c < '0' || c > '9' ) { break which_switch ; } } node = n ; break ; case TEXT : node = n ; break ; } if ( node != null ) { break ; } } if ( node == null ) { return NO_MATCH ; } } return node . mCode ; } 
public SocketInputStream ( Socket socket ) throws IOException { this ( socket . getChannel ( ) , socket . getSoTimeout ( ) ) ; } 
public Dimension preferredLayoutSize ( Container parent ) { GridBagLayoutInfo info = getLayoutInfo ( parent , PREFERREDSIZE ) ; return getMinSize ( parent , info ) ; } 
public List < Boolean > getBool4X2 ( ) { if ( bool4X2 == null ) { bool4X2 = new ArrayList < Boolean > ( ) ; } return this . bool4X2 ; } 
private void ensureSupportedKeysInitialized ( ) { if ( supportedKeysInitialized ) { return ; } final String supportedClassesString = getAttribute ( ATTR_SUPPORTED_KEY_CLASSES ) ; if ( supportedClassesString != null ) { String [ ] keyClassNames = supportedClassesString . split ( "||" ) ; ArrayList < Class < ? >> supportedClassList = new ArrayList < Class < ? >> ( keyClassNames . length ) ; final ClassLoader classLoader = getProvider ( ) . getClass ( ) . getClassLoader ( ) ; for ( String keyClassName : keyClassNames ) { try { Class < ? > keyClass = classLoader . loadClass ( keyClassName ) ; if ( Key . class . isAssignableFrom ( keyClass ) ) { supportedClassList . add ( keyClass ) ; } } catch ( ClassNotFoundException ignored ) { } } keyClasses = supportedClassList . toArray ( new Class < ? > [ supportedClassList . size ( ) ] ) ; } final String supportedFormatString = getAttribute ( ATTR_SUPPORTED_KEY_FORMATS ) ; if ( supportedFormatString != null ) { keyFormats = supportedFormatString . split ( "||" ) ; } supportedKeysInitialized = true ; } 
public int getID ( int index ) { return ( ( Integer ) ids . elementAt ( index ) ) . intValue ( ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public void init ( ) { filePath = Messager . getMessage ( "server.file.path" ) ; } 
public void setEntityResolver ( XMLEntityResolver entityResolver ) { fUserEntityResolver = entityResolver ; fLoaderConfig . setProperty ( ENTITY_RESOLVER , entityResolver ) ; fEntityManager . setProperty ( ENTITY_RESOLVER , entityResolver ) ; } 
public String getOutputDelimiter ( ) { return conf . get ( OUTPUT_DELIMITER_PROP , DELIMITER ) ; } 
public List < City > loadCities ( int provinceId ) { List < City > list = new ArrayList < City > ( ) ; Cursor cursor = db . query ( "City" , null , "province_id=?" , new String [ ] { String . valueOf ( provinceId ) } , null , null , null ) ; if ( cursor . moveToFirst ( ) ) { do { City city = new City ( ) ; city . setId ( cursor . getInt ( cursor . getColumnIndex ( "id" ) ) ) ; city . setCityName ( cursor . getString ( cursor . getColumnIndex ( "city_name" ) ) ) ; city . setCityCode ( cursor . getString ( cursor . getColumnIndex ( "city_code" ) ) ) ; city . setProvinceId ( cursor . getInt ( cursor . getColumnIndex ( "province_id" ) ) ) ; list . add ( city ) ; } while ( cursor . moveToNext ( ) ) ; } return list ; } 
public static String stringify ( Serializable aSerializableObject ) throws JSONException { if ( aSerializableObject == null ) { return null ; } ByteArrayOutputStream theByteStream = new ByteArrayOutputStream ( ) ; JSONOutputStream theStream = new JSONOutputStream ( theByteStream ) ; theStream . writeObject ( aSerializableObject ) ; return new String ( theByteStream . toByteArray ( ) ) ; } 
public DOM getResultTreeFrag ( int initSize , int rtfType , boolean addToManager ) { if ( rtfType == DOM . SIMPLE_RTF ) { if ( addToManager ) { int dtmPos = _dtmManager . getFirstFreeDTMID ( ) ; SimpleResultTreeImpl rtf = new SimpleResultTreeImpl ( _dtmManager , dtmPos << DTMManager . IDENT_DTM_NODE_BITS ) ; _dtmManager . addDTM ( rtf , dtmPos , 0 ) ; return rtf ; } else { return new SimpleResultTreeImpl ( _dtmManager , 0 ) ; } } else if ( rtfType == DOM . ADAPTIVE_RTF ) { if ( addToManager ) { int dtmPos = _dtmManager . getFirstFreeDTMID ( ) ; AdaptiveResultTreeImpl rtf = new AdaptiveResultTreeImpl ( _dtmManager , dtmPos << DTMManager . IDENT_DTM_NODE_BITS , m_wsfilter , initSize , m_buildIdIndex ) ; _dtmManager . addDTM ( rtf , dtmPos , 0 ) ; return rtf ; } else { return new AdaptiveResultTreeImpl ( _dtmManager , 0 , m_wsfilter , initSize , m_buildIdIndex ) ; } } else { return ( DOM ) _dtmManager . getDTM ( null , true , m_wsfilter , true , false , false , initSize , m_buildIdIndex ) ; } } 
private String readTo ( InputStream is , char delim ) throws IOException { if ( delim == 10 ) { throw new IOException ( "Not-implemented" ) ; } CharArrayWriter caw = new CharArrayWriter ( 100 ) ; boolean inNewline = false ; while ( true ) { int c = is . read ( ) ; if ( c == - 1 ) return null ; if ( c > 126 ) return null ; if ( c == 10 || c == 13 ) { if ( inNewline ) { continue ; } else { inNewline = true ; c = 10 ; } } else if ( c < 32 && c != 9 ) { return null ; } else { inNewline = false ; } if ( c == delim ) { return caw . toString ( ) ; } else { caw . write ( c ) ; } } } 
public List < PublishConnectFailuresResult > getPublishConnectFailuresResult ( ) { if ( publishConnectFailuresResult == null ) { publishConnectFailuresResult = new ArrayList < PublishConnectFailuresResult > ( ) ; } return this . publishConnectFailuresResult ; } 
public static int readSingleByte ( InputStream in ) throws IOException { byte [ ] buffer = new byte [ 1 ] ; int result = in . read ( buffer , 0 , 1 ) ; return ( result != - 1 ) ? buffer [ 0 ] & 0xff : - 1 ; } 
public long getMonthStart ( ) { return this . getMonthStart ( null , 0 ) ; } 
public synchronized void addContentHandler ( String trigger , ContentHandler observer ) { if ( _observerMap == null ) _observerMap = new HashMap ( ) ; _observerMap . put ( trigger , observer ) ; } 
public void writeNull ( ) throws IOException { os . write ( 'N' ) ; } 
public void setCC040ReferenceIdentifier ( JAXBElement < CC040ReferenceIdentifier > value ) { this . cc040ReferenceIdentifier = ( ( JAXBElement < CC040ReferenceIdentifier > ) value ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public Bindings createBindings ( ) { return new SimpleBindings ( ) ; } 
public void exit ( int exitCode ) { exitStream . println ( exitCode ) ; } 
private static void drawVArrow ( Path path , float cx , float cy , float width , float height ) { path . moveTo ( cx - width / 2.0f , cy ) ; path . lineTo ( cx , cy + height ) ; path . lineTo ( cx + width / 2.0f , cy ) ; path . close ( ) ; } 
public static String toString ( List < String > arguments , String separator , boolean quote ) { StringBuilder builder = new StringBuilder ( ) ; boolean first = true ; for ( String arg : arguments ) { if ( first ) first = false ; else builder . append ( separator ) ; if ( quote && ( arg . contains ( """ ) || arg . contains ( separator ) ) && ( IS_WIN32 || ( ! arg . matches ( "'.*'" ) && ! arg . matches ( "`.*`" ) ) ) ) { builder . append ( '"' ) ; arg = arg . replaceAll ( "||" , "||||" ) ; builder . append ( arg . replaceAll ( """ , "||"" ) ) ; builder . append ( '"' ) ; } else { builder . append ( arg ) ; } } return builder . toString ( ) ; } 
public static Timestamp stringToTimeStamp ( String dateTimeString , String dateTimeFormat , TimeZone tz , Locale locale ) throws ParseException { DateFormat dateFormat = toDateTimeFormat ( dateTimeFormat , tz , locale ) ; Date parsedDate = dateFormat . parse ( dateTimeString ) ; return new Timestamp ( parsedDate . getTime ( ) ) ; } 
public void characters ( char [ ] text , int begin , int length ) { elementText . append ( text , begin , length ) ; } 
public ServiceContext makeServiceContext ( InputStream is , GIOPVersion gv ) { Object [ ] args = new Object [ 2 ] ; args [ 0 ] = is ; args [ 1 ] = gv ; ServiceContext sc = null ; try { sc = ( ServiceContext ) ( scConstructor . newInstance ( args ) ) ; } catch ( IllegalArgumentException iae ) { throwBadParam ( "InputStream-constructor-argument-error" , iae ) ; } catch ( IllegalAccessException iae2 ) { throwBadParam ( "InputStream-constructor-argument-error" , iae2 ) ; } catch ( InstantiationException ie ) { throwBadParam ( "InputStream-constructor-called-for-abstract-class" , ie ) ; } catch ( InvocationTargetException ite ) { throwBadParam ( "InputStream-constructor-threw-exception-" + ite . getTargetException ( ) , ite ) ; } return sc ; } 
public void setDictionary ( Map < String , Double > dictionary ) { this . dictionary = dictionary ; setMissingValueWeight ( Collections . min ( dictionary . values ( ) ) / 2 ) ; } 
protected void updateNextObject ( ) { if ( ! updateNextIndex ( ) ) { findNextValidParent ( ) ; } } 
boolean isEqualTo ( final Item i ) { if ( i . type == type ) { switch ( type ) { case ClassWriter . INT : return i . intVal == intVal ; case ClassWriter . LONG : return i . longVal == longVal ; case ClassWriter . FLOAT : return i . floatVal == floatVal ; case ClassWriter . DOUBLE : return i . doubleVal == doubleVal ; case ClassWriter . UTF8 : case ClassWriter . STR : case ClassWriter . CLASS : return i . strVal1 . equals ( strVal1 ) ; case ClassWriter . NAME_TYPE : return i . strVal1 . equals ( strVal1 ) && i . strVal2 . equals ( strVal2 ) ; default : return i . strVal1 . equals ( strVal1 ) && i . strVal2 . equals ( strVal2 ) && i . strVal3 . equals ( strVal3 ) ; } } return false ; } 
public String getLocalNameOfNode ( Node n ) { String name = n . getLocalName ( ) ; return ( null == name ) ? super . getLocalNameOfNode ( n ) : name ; } 
public static boolean equal ( Object a , Object b ) { return a == b || ( a != null && a . equals ( b ) ) ; } 
private URL getDiffLinkRegardlessOfEditType ( Path path ) throws IOException { final GitChangeSet changeSet = path . getChangeSet ( ) ; final ArrayList < String > affectedPaths = new ArrayList < String > ( changeSet . getAffectedPaths ( ) ) ; Collections . sort ( affectedPaths ) ; final String pathAsString = path . getPath ( ) ; final int i = Collections . binarySearch ( affectedPaths , pathAsString ) ; assert i >= 0 ; return new URL ( getChangeSetLink ( changeSet ) , "#diff-" + String . valueOf ( i ) ) ; } 
public boolean intersects ( Rectangle r ) { return ! intersection ( r ) . isEmpty ( ) ; } 
@ Override protected void dumpLogAdditional ( StringBuilder sb ) { super . dumpLogAdditional ( sb ) ; sb . append ( Key . dumpString ( dupKey , 0 ) ) ; if ( dupCountLNRef != null ) { dupCountLNRef . dumpLog ( sb , true ) ; } } 
public static String removeSuffix ( String s ) { int index = s . lastIndexOf ( '.' ) ; return index == - 1 ? s : s . substring ( 0 , index ) ; } 
public synchronized void reset ( ) { if ( streamHandle == - 1 ) { throw new NullPointerException ( ) ; } flushParm = NO_FLUSH ; finished = false ; resetImpl ( streamHandle ) ; inputBuffer = null ; } 
public String getOutputProperty ( String name ) throws IllegalArgumentException { if ( ! validOutputProperty ( name ) ) { ErrorMsg err = new ErrorMsg ( ErrorMsg . JAXP_UNKNOWN_PROP_ERR , name ) ; throw new IllegalArgumentException ( err . toString ( ) ) ; } return _properties . getProperty ( name ) ; } 
public static Properties getAllProperties ( ) { if ( manager == null ) { synchronized ( managerLock ) { if ( manager == null ) { manager = new PropertyManager ( propsName ) ; } } } return manager . properties ; } 
public void startPrefixMapping ( String prefix , String uri ) throws SAXException { if ( contentHandler != null ) { contentHandler . startPrefixMapping ( prefix , uri ) ; } } 
public Vector getElements ( ) { Vector elements = new Vector ( ) ; Parser par = new Parser ( value ) ; char [ ] delim = { ',' } ; while ( par . hasMore ( ) ) { String elem = par . getWord ( delim ) . trim ( ) ; if ( elem != null && elem . length ( ) > 0 ) elements . addElement ( elem ) ; par . skipChar ( ) ; } return elements ; } 
public static final String getStr ( String tag ) throws ResourceException { try { ResourceBundle msgs = ResourceBundle . getBundle ( RB_CAPTIONS ) ; return msgs . getString ( tag ) ; } catch ( MissingResourceException ex ) { log . log ( Level . WARNING , "no-string-for-tag-"" + tag + """ , ex ) ; throw new ResourceException ( Errors . NO_STRING_FOR_TAG , new Object [ ] { tag } , ex ) ; } } 
public static String escapeXMLTags ( String input ) { if ( ( input == null ) || ( input . length ( ) == 0 ) ) { return input ; } StringBuffer buf = new StringBuffer ( ) ; char ch = '-' ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { ch = input . charAt ( i ) ; if ( ch == '<' ) { buf . append ( "&lt;" ) ; } else if ( ch == '>' ) { buf . append ( "&gt;" ) ; } else if ( ch == '&' ) { buf . append ( "&amp;" ) ; } else if ( ch == '"' ) { buf . append ( "&quot;" ) ; } else { buf . append ( ch ) ; } } return buf . toString ( ) ; } 
public static List < Element > children ( Element parent ) { List < Node > nodes = nodeList ( parent . getChildNodes ( ) ) ; ArrayList < Element > elements = new ArrayList < > ( nodes . size ( ) ) ; for ( Node node : nodes ) { if ( node instanceof Element ) { elements . add ( ( Element ) node ) ; } } elements . trimToSize ( ) ; return elements ; } 
public Interval withStartMillis ( long startInstant ) { if ( startInstant == getStartMillis ( ) ) { return this ; } return new Interval ( startInstant , getEndMillis ( ) , getChronology ( ) ) ; } 
public synchronized long getBytesWritten ( ) { if ( streamHandle == - 1 ) { throw new NullPointerException ( ) ; } return getTotalOutImpl ( streamHandle ) ; } 
public static String toString ( String signature ) throws IllegalArgumentException { return new String ( toCharArray ( signature . toCharArray ( ) ) ) ; } 
public int nextSetBit ( int index ) { checkIndex ( index ) ; int arrayIndex = index / 64 ; if ( arrayIndex >= longCount ) { return - 1 ; } long mask = ALL_ONES << index ; if ( ( bits [ arrayIndex ] & mask ) != 0 ) { return 64 * arrayIndex + Long . numberOfTrailingZeros ( bits [ arrayIndex ] & mask ) ; } while ( ++ arrayIndex < longCount && bits [ arrayIndex ] == 0 ) { } if ( arrayIndex == longCount ) { return - 1 ; } return 64 * arrayIndex + Long . numberOfTrailingZeros ( bits [ arrayIndex ] ) ; } 
protected JLabel makeLabel ( String s ) { if ( s == null ) return null ; JLabel label = new JLabel ( s , JLabel . LEFT ) ; return label ; } 
public static boolean mergeAttributeValues ( Map map1 , Map map2 , boolean bAdd ) { boolean modified = false ; for ( Iterator i = map2 . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; Set orig = ( Set ) map1 . get ( key ) ; if ( ( orig != null ) && ! orig . isEmpty ( ) ) { modified = ( bAdd ) ? orig . addAll ( ( Set ) map2 . get ( key ) ) : orig . removeAll ( ( Set ) map2 . get ( key ) ) ; } else if ( bAdd ) { map1 . put ( key , ( Set ) map2 . get ( key ) ) ; modified = true ; } } return modified ; } 
public byte [ ] getTargetHardwareAddress ( ) { return ( fieldValues . get ( TARGETHWADDR ) ) ; } 
public String getTextFieldGameName ( ) { return textFieldGameName . getText ( ) ; } 
public void registerResultSet ( String regex , MockJDBCResultSet rs ) { resultSets . put ( regex , rs ) ; } 
public BlockSet create ( ) throws BlockCreateException { final double sumRate = sumRate ( ) ; final double rate = Math . random ( ) * sumRate ; double accumulatedRate = 0.0 ; for ( PatternDefinition pd : blockPatterns . keySet ( ) ) { final double patternRate = blockPatterns . get ( pd ) ; if ( accumulatedRate <= rate && rate < accumulatedRate + patternRate ) { return create ( pd ) ; } accumulatedRate += patternRate ; } throw new BlockCreateException ( ) ; } 
public static Messages getInstance ( ) { if ( instance == null ) { instance = new Messages ( ) ; } return instance ; } 
public void setDef4 ( String def4 ) { this . def4 = def4 == null ? null : def4 . trim ( ) ; } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; if ( localStringTracker ) { elementList . add ( new javax . xml . namespace . QName ( "http//axis2.apache.org/sample/spring/types" , "string" ) ) ; elementList . add ( localString == null ? null : org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( localString ) ) ; } return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
public void assertInvokeInterfaceEquals ( int value , Class target , Interface iface ) { Compiler compiler = compilerLocal . get ( ) ; compiler . setFlags ( compilerFlags ( ) ) ; assertInvokeInterfaceEquals ( new Integer ( value ) , target , new Extends ( iface ) , stdAM ) ; compiler . cleanup ( ) ; } 
public static void close ( Gui close ) { removedGui . offer ( close ) ; } 
private List < Poll > getListOfPolls ( String rawQuery , String [ ] params ) { SQLiteDatabase db = getReadableDatabase ( ) ; Cursor c1 = db . rawQuery ( rawQuery , params ) ; List < Poll > polls = new ArrayList < Poll > ( ) ; c1 . moveToFirst ( ) ; while ( ! c1 . isAfterLast ( ) ) { polls . add ( this . extractPoll ( c1 , db ) ) ; c1 . moveToNext ( ) ; } c1 . close ( ) ; db . close ( ) ; return polls ; } 
public boolean errorsFound ( ) { return _errors . size ( ) > 0 ; } 
private final boolean isLegalPath ( final String str ) { if ( str . length ( ) == 0 ) { return true ; } for ( int i = 0 ; i < LEGAL_PATH . length ; i ++ ) { if ( str . equals ( LEGAL_PATH [ i ] ) ) { return true ; } } return false ; } 
public static String getRuntime ( long startTime , long endTime ) { long milliseconds = endTime - startTime ; long hours = milliseconds / ( 1000 * 60 * 60 ) ; long minutes = ( milliseconds % ( 1000 * 60 * 60 ) ) / ( 1000 * 60 ) ; long seconds = ( ( milliseconds % ( 1000 * 60 * 60 ) ) % ( 1000 * 60 ) ) / 1000 ; return String . format ( "%02d:%02d:%02d" , hours , minutes , seconds ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public String getErrorString ( ) { checkDone ( ) ; if ( error != null ) return error ; switch ( result ) { case SUCCESSFUL : return "successful" ; case UNRECOVERABLE : return "unrecoverable-error" ; case TRY_AGAIN : return "try-again" ; case HOST_NOT_FOUND : return "host-not-found" ; case TYPE_NOT_FOUND : return "type-not-found" ; } throw new IllegalStateException ( "unknown-result" ) ; } 
public String getRadiusVectorOfSun ( ) { sb . setLength ( 0 ) ; sb . append ( AngleFormatter . angle2Decimal ( peng . getRadiusVectorOfSun ( ) , 4 ) ) ; sb . append ( "-" ) ; sb . append ( AU ) ; return sb . toString ( ) ; } 
private IntBitMaskedEnum ( final Class < E > enumType ) { super ( enumType ) ; if ( members . length > MAX_MEMBERS ) { throw new IllegalArgumentException ( "The-enum-type-[" + enumType . getName ( ) + "]-has-[" + members . length + "]-but-IntBitMaskedEnums-can-only-support-[" + MAX_MEMBERS + "]" ) ; } EnumMap < E , Integer > _maskMap = new EnumMap < E , Integer > ( enumType ) ; for ( int i = 0 ; i < members . length ; i ++ ) { _maskMap . put ( members [ i ] , POW2 [ i ] ) ; } maskMap = Collections . unmodifiableMap ( _maskMap ) ; } 
public synchronized void addXTick ( String label , double position ) { if ( _xticks == null ) { _xticks = new Vector ( ) ; _xticklabels = new Vector ( ) ; } _xticks . addElement ( new Double ( position ) ) ; _xticklabels . addElement ( label ) ; } 
public static Class tryLoadClass ( String className ) { try { return ClassLoader . getSystemClassLoader ( ) . loadClass ( className ) ; } catch ( Throwable e ) { return null ; } } 
private void startDisambiguationQuery ( String contactDisplayName ) { final Builder builder = Contacts . CONTENT_URI . buildUpon ( ) ; builder . appendQueryParameter ( "limit" , String . valueOf ( 1 ) ) ; final Uri uri = builder . build ( ) ; final String displayNameSelection ; final String [ ] selectionArgs ; if ( TextUtils . isEmpty ( contactDisplayName ) ) { displayNameSelection = Contacts . DISPLAY_NAME_PRIMARY + "-IS-NULL" ; selectionArgs = new String [ ] { String . valueOf ( mContactId ) } ; } else { displayNameSelection = Contacts . DISPLAY_NAME_PRIMARY + "-=-?" ; selectionArgs = new String [ ] { contactDisplayName , String . valueOf ( mContactId ) } ; } mQueryHandler . startQuery ( TOKEN_DISAMBIGUATION_QUERY , null , uri , new String [ ] { Contacts . _ID } , displayNameSelection + "-AND-" + Contacts . PHOTO_ID + "-IS-NULL-AND-" + Contacts . _ID + "-<>-?" , selectionArgs , null ) ; } 
public String [ ] split ( CharSequence input , int limit ) { int index = 0 ; boolean matchLimited = limit > 0 ; ArrayList < String > matchList = new ArrayList < > ( ) ; Matcher m = matcher ( input ) ; while ( m . find ( ) ) { if ( ! matchLimited || matchList . size ( ) < limit - 1 ) { String match = input . subSequence ( index , m . start ( ) ) . toString ( ) ; matchList . add ( match ) ; index = m . end ( ) ; } else if ( matchList . size ( ) == limit - 1 ) { String match = input . subSequence ( index , input . length ( ) ) . toString ( ) ; matchList . add ( match ) ; index = m . end ( ) ; } } if ( index == 0 ) return new String [ ] { input . toString ( ) } ; if ( ! matchLimited || matchList . size ( ) < limit ) matchList . add ( input . subSequence ( index , input . length ( ) ) . toString ( ) ) ; int resultSize = matchList . size ( ) ; if ( limit == 0 ) while ( resultSize > 0 && matchList . get ( resultSize - 1 ) . equals ( "" ) ) resultSize -- ; String [ ] result = new String [ resultSize ] ; return matchList . subList ( 0 , resultSize ) . toArray ( result ) ; } 
protected void refreshPolicy ( ) { try { Policy policy = Policy . getPolicy ( ) ; policy . refresh ( ) ; } catch ( AccessControlException e ) { } } 
public double controlY ( double lateralOffset ) { final double opp = p2y - p0y ; final double adj = p2x - p0x ; final double h = Math . sqrt ( opp * opp + adj * adj ) ; return p1y + lateralOffset * adj / h ; } 
public String toString ( ) { String properties = "-source=" + getSource ( ) + "-firstIndex=-" + firstIndex + "-lastIndex=-" + lastIndex + "-isAdjusting=-" + isAdjusting + "-" ; return getClass ( ) . getName ( ) + "[" + properties + "]" ; } 
public ArrayList < Tag > getTags ( Book book ) throws SQLException { ArrayList < Tag > tags = new ArrayList < Tag > ( getEntryCount ( "tag" ) ) ; PreparedStatement ps = connection . prepareStatement ( "SELECT-tag.*-FROM-" + "tag-INNER-JOIN-tagbook-ON-tagbook.tag_id-=-tag.id-" + "INNER-JOIN-book-ON-tagbook.book_id-=-book.id-" + "where-book.id=?" ) ; ps . setInt ( 1 , book . getID ( ) ) ; ResultSet set = ps . executeQuery ( ) ; ps . close ( ) ; while ( set . next ( ) ) { tags . add ( getTag ( set ) ) ; } return tags ; } 
private static Class < ? > toClass ( String inTypeName ) { if ( sPrimitiveTypeMap . containsKey ( inTypeName ) ) { return sPrimitiveTypeMap . get ( inTypeName ) ; } try { return Class . forName ( inTypeName ) ; } catch ( ClassNotFoundException e ) { throw new IllegalArgumentException ( inTypeName , e ) ; } } 
public void clear ( ) { if ( elementData != null ) { for ( int i = 0 ; i < size ; i ++ ) { Attribute attribute = elementData [ i ] ; attribute . setParent ( null ) ; } elementData = null ; size = 0 ; } modCount ++ ; } 
@ Override public boolean contains ( Object object ) { return backingMap . containsKey ( object ) ; } 
public void setBorderPainted ( boolean b ) { boolean oldValue = paintBorder ; paintBorder = b ; firePropertyChange ( "borderPainted" , oldValue , paintBorder ) ; if ( paintBorder != oldValue ) { repaint ( ) ; } } 
@ Forced public void setContext ( Context context ) { this . rng = context . getRng ( ) ; } 
public void setDouble ( int parameterIndex , double x ) throws SQLException { if ( ! this . connection . getAllowNanAndInf ( ) && ( x == Double . POSITIVE_INFINITY || x == Double . NEGATIVE_INFINITY || Double . isNaN ( x ) ) ) { throw SQLError . createSQLException ( "'" + x + "'-is-not-a-valid-numeric-or-approximate-numeric-value" , SQLError . SQL_STATE_ILLEGAL_ARGUMENT ) ; } setInternal ( parameterIndex , StringUtils . fixDecimalExponent ( String . valueOf ( x ) ) ) ; } 
public int getDefaultKeyboardBrightness ( ) { return mContext . getResources ( ) . getInteger ( com . android . internal . R . integer . config_keyboardBrightnessSettingDefault ) ; } 
@ SuppressWarnings ( "unchecked" ) final public Key < UJO , ? > [ ] getOrderAsArray ( ) { return orderBy . toArray ( new Key [ orderBy . size ( ) ] ) ; } 
void setTypeParameters ( List variables ) { typeParameters = ( TypeVariable [ ] ) variables . toArray ( new TypeVariable [ variables . size ( ) ] ) ; } 
public String description ( ) { if ( description . length ( ) == 0 && matchingField != null ) { Comment comment = matchingField . comment ( ) ; if ( comment != null ) { return comment . commentText ( ) ; } } return description ; } 
public static < E > Set < E > symmetricDiff ( Set < E > s1 , Set < E > s2 ) { Set < E > s = new HashSet < E > ( ) ; for ( E o : s1 ) { if ( ! s2 . contains ( o ) ) { s . add ( o ) ; } } for ( E o : s2 ) { if ( ! s1 . contains ( o ) ) { s . add ( o ) ; } } return s ; } 
public boolean equals ( Object o ) { if ( o == this ) return true ; if ( ! ( o instanceof Set ) ) return false ; Collection < ? > c = ( Collection < ? > ) o ; try { return containsAll ( c ) && c . containsAll ( this ) ; } catch ( ClassCastException unused ) { return false ; } catch ( NullPointerException unused ) { return false ; } } 
@ Override public synchronized int read ( ) throws IOException { if ( ! isConnected ) { throw new IOException ( "Not-connected" ) ; } if ( buffer == null ) { throw new IOException ( "InputStream-is-closed" ) ; } lastReader = Thread . currentThread ( ) ; try { int attempts = 3 ; while ( in == - 1 ) { if ( isClosed ) { return - 1 ; } if ( ( attempts -- <= 0 ) && lastWriter != null && ! lastWriter . isAlive ( ) ) { throw new IOException ( "Pipe-broken" ) ; } notifyAll ( ) ; wait ( 1000 ) ; } } catch ( InterruptedException e ) { throw new InterruptedIOException ( ) ; } int result = buffer [ out ++ ] & 0xff ; if ( out == buffer . length ) { out = 0 ; } if ( out == in ) { in = - 1 ; out = 0 ; } notifyAll ( ) ; return result ; } 
static final int hashCode ( Object o ) { return o == null ? 0 : o . hashCode ( ) ; } 
@ SuppressWarnings ( "unchecked" ) public < T extends Vm > List < T > getVmList ( ) { return ( List < T > ) vmList ; } 
private void writeString ( String str , boolean unshared ) throws IOException { handles . assign ( unshared ? null : str ) ; long utflen = bout . getUTFLength ( str ) ; if ( utflen <= 0xFFFF ) { bout . writeByte ( TC_STRING ) ; bout . writeUTF ( str , utflen ) ; } else { bout . writeByte ( TC_LONGSTRING ) ; bout . writeLongUTF ( str , utflen ) ; } } 
public long getRecordNum ( ) throws IOException { return reader . getRecordNumByLocation ( currentLocation ) ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public void endDocument ( ) throws org . xml . sax . SAXException { flushPending ( ) ; flushWriter ( ) ; if ( m_tracer != null ) super . fireEndDoc ( ) ; } 
public synchronized void addInstance ( String inst ) throws SnmpStatusException { int max = size ( ) ; for ( int i = 0 ; i < max ; i ++ ) { ( ( SnmpVarBind ) elementData [ i ] ) . addInstance ( inst ) ; } } 
public float trimInput ( final float input ) { if ( this . repeating ) { float trimmed = this . minInput + mod ( ( input - this . minInput ) , ( this . maxInput - this . minInput ) ) ; if ( trimmed < this . minInput ) trimmed += this . minInput ; return trimmed ; } else return Math . min ( this . maxInput , Math . max ( this . minInput , input ) ) ; } 
public boolean removeBody ( String language ) { language = determineLanguage ( language ) ; for ( Body body : bodies ) { if ( language . equals ( body . language ) ) { return bodies . remove ( body ) ; } } return false ; } 
public void retoreDC ( ) { if ( ! dcStack . empty ( ) ) { DC dc = ( DC ) dcStack . pop ( ) ; meterLimit = dc . meterLimit ; windingRule = dc . windingRule ; path = dc . path ; bkMode = dc . bkMode ; useCreatePen = dc . useCreatePen ; scaleMode = dc . scaleMode ; pathTransform = dc . pathTransform ; g2 . setPaint ( dc . paint ) ; g2 . setStroke ( dc . stroke ) ; g2 . setTransform ( dc . transform ) ; g2 . setClip ( dc . clip ) ; } else { } } 
static void handleThrowable ( Throwable t ) { t . printStackTrace ( ) ; } 
public Iterator sortedKeys ( ) { return new TreeSet ( this . map . keySet ( ) ) . iterator ( ) ; } 
public String getText ( Object object ) { String label = ( ( Group ) object ) . getName ( ) ; return label == null || label . length ( ) == 0 ? getString ( "_UI_Group_type" ) : getString ( "_UI_Group_type" ) + "-" + label ; } 
public String getOrientation ( ) { return getAttributeAsString ( "orientation" ) ; } 
@ XmlElementDecl ( namespace = "urn:zimbraMail" , name = "DeleteDataSourceResponse" ) public JAXBElement < testDeleteDataSourceResponse > createDeleteDataSourceResponse ( testDeleteDataSourceResponse value ) { return new JAXBElement < testDeleteDataSourceResponse > ( _DeleteDataSourceResponse_QNAME , testDeleteDataSourceResponse . class , null , value ) ; } 
public static void setLocale ( ULocale locale ) { ResourceHandle resourceHandle = null ; if ( locale != null ) { synchronized ( resourceMap ) { resourceHandle = ( ResourceHandle ) resourceMap . get ( locale ) ; if ( resourceHandle == null ) { resourceHandle = new ResourceHandle ( locale ) ; resourceMap . put ( locale , resourceHandle ) ; } } } resources . set ( resourceHandle ) ; } 
public Cursor getSuggestions ( SearchableInfo searchable , String query , int limit ) { if ( searchable == null ) { return null ; } String authority = searchable . getSuggestAuthority ( ) ; if ( authority == null ) { return null ; } Uri . Builder uriBuilder = new Uri . Builder ( ) . scheme ( ContentResolver . SCHEME_CONTENT ) . authority ( authority ) . query ( "" ) . fragment ( "" ) ; final String contentPath = searchable . getSuggestPath ( ) ; if ( contentPath != null ) { uriBuilder . appendEncodedPath ( contentPath ) ; } uriBuilder . appendPath ( SearchManager . SUGGEST_URI_PATH_QUERY ) ; String selection = searchable . getSuggestSelection ( ) ; String [ ] selArgs = null ; if ( selection != null ) { selArgs = new String [ ] { query } ; } else { uriBuilder . appendPath ( query ) ; } if ( limit > 0 ) { uriBuilder . appendQueryParameter ( SUGGEST_PARAMETER_LIMIT , String . valueOf ( limit ) ) ; } Uri uri = uriBuilder . build ( ) ; return mContext . getContentResolver ( ) . query ( uri , null , selection , selArgs , null ) ; } 
public final boolean equals ( Object anObject ) { if ( anObject instanceof AWTKeyStroke ) { AWTKeyStroke ks = ( AWTKeyStroke ) anObject ; return ( ks . keyChar == keyChar && ks . keyCode == keyCode && ks . onKeyRelease == onKeyRelease && ks . modifiers == modifiers ) ; } return false ; } 
public String toString ( ) { String tmp = "-PNI:-" + title + "-" ; for ( int i = 0 ; i < data . size ( ) ; i ++ ) { int [ ] tt = ( int [ ] ) data . get ( i ) ; for ( int j = 0 ; j < tt . length ; j ++ ) { tmp += Double . toString ( tt [ j ] ) ; tmp += "-" ; } tmp += "-" ; } return tmp ; } 
public String getFontName ( ) { if ( fRequestedAttributes != null ) { fRequestedAttributes . get ( TextAttribute . FAMILY ) ; } return null ; } 
public String getRequestHeader ( String name ) { if ( requestHeaderFields == null ) return null ; for ( int i = 0 ; i < requestHeaderFields . size ( ) ; i ++ ) { NameValue nv = ( NameValue ) requestHeaderFields . elementAt ( i ) ; if ( nv . name . equalsIgnoreCase ( name ) ) return nv . value ; } return null ; } 
static final void helpExpungeStaleExceptions ( ) { final ReentrantLock lock = exceptionTableLock ; if ( lock . tryLock ( ) ) { try { expungeStaleExceptions ( ) ; } finally { lock . unlock ( ) ; } } } 
public Shape createSliderThumbDiscrete ( final int x , final int y , final int w , final int h , final CornerSize size ) { final double topArc = size . getRadius ( w , h ) ; final double bottomArcH = size == CornerSize . INTERIOR ? 0 : 1 ; final double bottomArcW = 3 ; path . reset ( ) ; path . moveTo ( x , y + topArc ) ; path . quadTo ( x , y , x + topArc , y ) ; path . lineTo ( x + w - topArc , y ) ; path . quadTo ( x + w , y , x + w , y + topArc ) ; path . lineTo ( x + w , y + h / 2.0 ) ; path . quadTo ( x + w - bottomArcW , y + h - bottomArcH , x + w / 2.0 , y + h ) ; path . quadTo ( x + bottomArcW , y + h - bottomArcH , x , y + h / 2.0 ) ; path . closePath ( ) ; return path ; } 
public static DateTimeFormatter basicWeekDateTime ( ) { if ( bwdt == null ) { bwdt = new DateTimeFormatterBuilder ( ) . append ( basicWeekDate ( ) ) . append ( basicTTime ( ) ) . toFormatter ( ) ; } return bwdt ; } 
private static String longToString ( long number , String digits , boolean reverse ) { int base = digits . length ( ) ; String result = number == 0 ? "0" : "" ; while ( number != 0 ) { int mod = ( int ) number % base ; if ( reverse ) { result += digits . charAt ( mod ) ; } else { result = digits . charAt ( mod ) + result ; } number = number / base ; } return result ; } 
void addFill ( int row , int col ) { TableRow rv = getRow ( row ) ; if ( rv != null ) { rv . fillColumn ( col ) ; } } 
@ Deprecated public String readLine ( ) throws IOException { return primitiveTypes . readLine ( ) ; } 
public void addHeader ( Header header ) { if ( header == null ) { return ; } headers . add ( header ) ; } 
public final double compute ( final double [ ] x ) { return ( Kernel . shiftedPermSchwefel12 ( x , this . m_o , this . m_p , 0 , this . m_m ) * 1e6 ) + Kernel . shiftedPermSphere ( x , this . m_o , this . m_p , this . m_m , this . m_dimension - this . m_m ) ; } 
public final XSTypeDefinition getGlobalTypeDecl ( String declName ) { return ( XSTypeDefinition ) fGlobalTypeDecls . get ( declName ) ; } 
public ShortBuffer put ( short [ ] src , int off , int len ) { int length = src . length ; if ( off < 0 || len < 0 || ( long ) off + ( long ) len > length ) { throw new IndexOutOfBoundsException ( ) ; } if ( len > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = off ; i < off + len ; i ++ ) { put ( src [ i ] ) ; } return this ; } 
public static Calendar getTimeNow ( ) { Calendar now = Calendar . getInstance ( ) ; now . setTime ( new Date ( ) ) ; return now ; } 
protected int getNeededLocation ( int x , int y ) { int newY ; newY = Math . min ( maxX , Math . max ( minX , y - offset ) ) ; return newY ; } 
public int getSpawnFuzz ( ) { return Math . max ( 5 , net . minecraft . server . MinecraftServer . getServer ( ) . getSpawnProtectionSize ( ) - 6 ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public static SOAPFactory newInstance ( String protocol ) throws SOAPException { return SAAJMetaFactory . getInstance ( ) . newSOAPFactory ( protocol ) ; } 
public StringBuilder toStringBuilder ( ) { return new StringBuilder ( size ) . append ( buffer , 0 , size ) ; } 
public boolean canCreate ( String username ) { return groupContains ( username , "cancreate" ) ; } 
private static void createFile ( String fileName , String fileText ) { File f = new File ( fileName ) ; if ( ! f . exists ( ) ) { try { f . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } writeFile ( fileName , fileText ) ; } 
public Iterator getChildAxisIterator ( Object contextNode , String localName , String namespacePrefix , String namespaceURI ) { if ( contextNode instanceof Element ) { Element node = ( Element ) contextNode ; return node . elementIterator ( QName . get ( localName , namespacePrefix , namespaceURI ) ) ; } if ( contextNode instanceof Document ) { Document node = ( Document ) contextNode ; Element el = node . getRootElement ( ) ; if ( el == null || el . getName ( ) . equals ( localName ) == false ) { return JaxenConstants . EMPTY_ITERATOR ; } if ( namespaceURI != null ) { if ( namespaceURI . equals ( el . getNamespaceURI ( ) ) == false ) { return JaxenConstants . EMPTY_ITERATOR ; } } return new SingleObjectIterator ( el ) ; } return JaxenConstants . EMPTY_ITERATOR ; } 
public void onCraftMatrixChanged ( IInventory par1IInventory ) { this . updateCraftingResults ( ) ; } 
public void trimToSize ( ) { int oldCapacity = elementData . length ; if ( elementCount < oldCapacity ) { byte oldData [ ] = elementData ; elementData = new byte [ elementCount ] ; System . arraycopy ( oldData , 0 , elementData , 0 , elementCount ) ; } } 
void flush ( ) throws IOException { if ( VDBG ) Log . d ( TAG , "flush:-" + mSocketOS ) ; mSocketOS . flush ( ) ; } 
private void checkFinishReceiver ( ServiceContext callerContext , ListenerID receiver , ListenerWrapper listenerWrapper ) { if ( listenerWrapper . isOneShot ( ) ) { finish ( listenerWrapper . getContext ( ) , receiver ) ; } } 
protected String readContentFromInputStream ( InputStream is , int length ) { char [ ] buffer = new char [ 0 ] ; try { InputStreamReader inputStreamReader = new InputStreamReader ( is , UTF8 ) ; BufferedReader bufferedReader = new BufferedReader ( inputStreamReader ) ; buffer = new char [ length ] ; bufferedReader . read ( buffer , 0 , length ) ; bufferedReader . close ( ) ; } catch ( IOException e ) { _logger . error ( e ) ; return null ; } return new String ( buffer ) ; } 
public Object createObject ( ) { final String o = ( String ) getParameter ( "value" ) ; if ( o == null ) { return null ; } if ( o . length ( ) > 0 ) { return new Character ( o . charAt ( 0 ) ) ; } else { return null ; } } 
public void writeRef ( int value ) throws IOException { os . write ( 'R' ) ; os . write ( value >> 24 ) ; os . write ( value >> 16 ) ; os . write ( value >> 8 ) ; os . write ( value ) ; } 
public int size ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } } 
public long skip ( long n ) throws IOException { if ( n < 0L ) throw new IllegalArgumentException ( "skip-value-is-negative" ) ; synchronized ( lock ) { ensureOpen ( ) ; int avail = buf . length - pos ; if ( avail > 0 ) { if ( n <= avail ) { pos += n ; return n ; } else { pos = buf . length ; n -= avail ; } } return avail + super . skip ( n ) ; } } 
public int hashCode ( ) { StringBuilder r = new StringBuilder ( ) ; r . append ( ( postfix ? 'P' : 'N' ) ) ; r . append ( item ) ; return r . toString ( ) . hashCode ( ) ; } 
public void removeAllChildren ( ) { for ( int i = getChildCount ( ) - 1 ; i >= 0 ; i -- ) { remove ( i ) ; } } 
private Uri whichContentStore ( ) { if ( Environment . getExternalStorageState ( ) . equals ( Environment . MEDIA_MOUNTED ) ) { return android . provider . MediaStore . Images . Media . EXTERNAL_CONTENT_URI ; } else { return android . provider . MediaStore . Images . Media . INTERNAL_CONTENT_URI ; } } 
public static IntFunction random ( ) { return new cern . jet . random . engine . MersenneTwister ( new java . util . Date ( ) ) ; } 
@ Override public void close ( ) throws IOException { fInputStream . close ( ) ; } 
public double getMinY ( ) { return getY ( ) ; } 
protected void notifyModified ( ) { log . debug ( "notifyModified---modified:-{}-update-counter:-{}" , modified . get ( ) , updateCounter . get ( ) ) ; if ( updateCounter . get ( ) == 0 ) { if ( modified . get ( ) ) { updateVersion ( ) ; lastModified = System . currentTimeMillis ( ) ; if ( storage == null || ! storage . save ( this ) ) { log . warn ( "Could-not-store-shared-object" ) ; } } sendUpdates ( ) ; modified . compareAndSet ( true , false ) ; } } 
@ Override public void run ( ) { System . out . printf ( "VideoConference:-Initialization:-%d-participants.-" , controller . getCount ( ) ) ; try { controller . await ( ) ; System . out . printf ( "VideoConference:-All-the-participants-have-come-" ) ; System . out . printf ( "VideoConference:-Let's-start...-" ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } 
@ Override public void onDetach ( ) { synchronized ( mThread ) { mProgressBar = null ; mReady = false ; mThread . notify ( ) ; } super . onDetach ( ) ; } 
private void saveMatrix ( ) { int returnVal = m_fileChooser . showSaveDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { File selectedFile = m_fileChooser . getSelectedFile ( ) ; if ( ! selectedFile . getName ( ) . toLowerCase ( ) . endsWith ( CostMatrix . FILE_EXTENSION ) ) { selectedFile = new File ( selectedFile . getParent ( ) , selectedFile . getName ( ) + CostMatrix . FILE_EXTENSION ) ; } Writer writer = null ; try { writer = new BufferedWriter ( new FileWriter ( selectedFile ) ) ; m_matrix . write ( writer ) ; writer . close ( ) ; } catch ( Exception ex ) { JOptionPane . showMessageDialog ( this , "Error-writing-file-'" + selectedFile . getName ( ) + "':-" + ex . getMessage ( ) , "Save-failed" , JOptionPane . ERROR_MESSAGE ) ; System . out . println ( ex . getMessage ( ) ) ; } } } 
public static int depth ( Node node ) { int maxDepth = 0 ; NodeList list = node . getChildNodes ( ) ; int count = list . getLength ( ) ; for ( int i = 0 ; i < count ; i ++ ) { maxDepth = Math . max ( maxDepth , depth ( list . item ( i ) ) ) ; } return maxDepth + 1 ; } 
void reportError ( String message ) throws SAXException { if ( errorHandler != null ) errorHandler . error ( makeException ( message ) ) ; } 
public String toString ( ) { int c = sync . getCount ( ) ; int w = Sync . exclusiveCount ( c ) ; int r = Sync . sharedCount ( c ) ; return super . toString ( ) + "[Write-locks-=-" + w + ",-Read-locks-=-" + r + "]" ; } 
public static Builder create ( String dbName , String tableName , String location , Map < String , String > partSpec ) throws HCatException { return new Builder ( dbName , tableName , location , partSpec ) ; } 
private static void usage ( ) { System . err . println ( "Usage:-java-org.apache.pdfbox.PDFSplit-[OPTIONS]-<PDF-file>-" + "--password-<password>-Password-to-decrypt-document-" + "--split-<integer>-split-after-this-many-pages-" + "-<PDF-file>-The-PDF-document-to-use-" ) ; System . exit ( 1 ) ; } 
private long getMostReferencedContactId ( ArrayList < LookupKeySegment > segments ) { Collections . sort ( segments ) ; long bestContactId = - 1 ; int bestRefCount = 0 ; long contactId = - 1 ; int count = 0 ; int segmentCount = segments . size ( ) ; for ( int i = 0 ; i < segmentCount ; i ++ ) { LookupKeySegment segment = segments . get ( i ) ; if ( segment . contactId != - 1 ) { if ( segment . contactId == contactId ) { count ++ ; } else { if ( count > bestRefCount ) { bestContactId = contactId ; bestRefCount = count ; } contactId = segment . contactId ; count = 1 ; } } } if ( count > bestRefCount ) { return contactId ; } else { return bestContactId ; } } 
protected Collection < String > getTablesRenamingScripts ( ) { return new ArrayList < String > ( ) ; } 
public final void tunnelProxy ( HttpHost proxy , boolean secure ) { if ( proxy == null ) { throw new IllegalArgumentException ( "Proxy-host-may-not-be-null." ) ; } if ( ! this . connected ) { throw new IllegalStateException ( "No-tunnel-unless-connected." ) ; } if ( this . proxyChain == null ) { throw new IllegalStateException ( "No-proxy-tunnel-without-proxy." ) ; } HttpHost [ ] proxies = new HttpHost [ this . proxyChain . length + 1 ] ; System . arraycopy ( this . proxyChain , 0 , proxies , 0 , this . proxyChain . length ) ; proxies [ proxies . length - 1 ] = proxy ; this . proxyChain = proxies ; this . secure = secure ; } 
public Enumeration getSectionNames ( ) { return sectionIndex . elements ( ) ; } 
public static String getterName ( Class < ? > componentClass ) { if ( componentClass == null ) return null ; StringBuilder sb = new StringBuilder ( "get" ) ; sb . append ( componentClass . getSimpleName ( ) ) ; return sb . toString ( ) ; } 
public Map < String , String > getHeaders ( ) { return new HashMap < String , String > ( this . customHeaders ) ; } 
public String camelCase ( String lowerCaseAndUnderscoredWord , boolean uppercaseFirstLetter , char ... delimiterChars ) { if ( lowerCaseAndUnderscoredWord == null ) return null ; lowerCaseAndUnderscoredWord = lowerCaseAndUnderscoredWord . trim ( ) ; if ( lowerCaseAndUnderscoredWord . length ( ) == 0 ) return "" ; if ( uppercaseFirstLetter ) { String result = lowerCaseAndUnderscoredWord ; if ( delimiterChars != null ) { for ( char delimiterChar : delimiterChars ) { result = result . replace ( delimiterChar , '_' ) ; } } return replaceAllWithUppercase ( result , "(^|_)(.)" , 2 ) ; } if ( lowerCaseAndUnderscoredWord . length ( ) < 2 ) return lowerCaseAndUnderscoredWord ; return "" + Character . toLowerCase ( lowerCaseAndUnderscoredWord . charAt ( 0 ) ) + camelCase ( lowerCaseAndUnderscoredWord , true , delimiterChars ) . substring ( 1 ) ; } 
public File initializeFile ( String fPath ) { filePath = fPath ; dir = new File ( filePath ) ; try { in = new FileInputStream ( dir ) ; reader = new BufferedReader ( new InputStreamReader ( in ) ) ; if ( dir . isFile ( ) ) { return dir ; } reader . close ( ) ; in . close ( ) ; reader = null ; in = null ; } catch ( FileNotFoundException ex ) { System . out . println ( "File-not-found-error-:-" + ex . getMessage ( ) ) ; return null ; } catch ( IOException ex ) { System . out . println ( "Error-closing-reader-object-:" + ex . getMessage ( ) ) ; return null ; } return null ; } 
private static StringBuilder dump ( StringBuilder _cbuffer , byte value ) { for ( int j = 0 ; j < 2 ; j ++ ) { _cbuffer . append ( _hexcodes [ value >> _shifts [ j + 6 ] & 15 ] ) ; } return _cbuffer ; } 
public boolean remove ( final URI uri ) { boolean removed = this . unique . remove ( uri ) ; if ( removed ) { Iterator < URI > it = this . all . iterator ( ) ; while ( it . hasNext ( ) ) { URI current = it . next ( ) ; if ( current . equals ( uri ) ) { it . remove ( ) ; } } } return removed ; } 
public static Transform createTranslateTransform ( float xOffset , float yOffset ) { return new Transform ( 1 , 0 , xOffset , 0 , 1 , yOffset ) ; } 
public String group ( int group ) { if ( first < 0 ) throw new IllegalStateException ( "No-match-found" ) ; if ( group < 0 || group > groupCount ( ) ) throw new IndexOutOfBoundsException ( "No-group-" + group ) ; if ( ( groups [ group * 2 ] == - 1 ) || ( groups [ group * 2 + 1 ] == - 1 ) ) return null ; return getSubSequence ( groups [ group * 2 ] , groups [ group * 2 + 1 ] ) . toString ( ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
protected void togglePopup ( ) { if ( isVisible ( ) ) { hide ( ) ; } else { show ( ) ; } } 
public FSDataOutputStream create ( Path f , boolean overwrite ) throws IOException { return create ( f , overwrite , getConf ( ) . getInt ( "io.file.buffer.size" , 4096 ) , getDefaultReplication ( ) , getDefaultBlockSize ( ) ) ; } 
public static void err ( String cname , String str , String extra , Exception e ) { if ( _err != null ) { _err . println ( cname + ":" + str ) ; _err . println ( "--Info:-" + extra ) ; _err . println ( "--Reason:-" + e . getMessage ( ) ) ; } } 
static ClassLoader findClassLoader ( ) throws ConfigurationError { ClassLoader context = SecuritySupport . getContextClassLoader ( ) ; ClassLoader system = SecuritySupport . getSystemClassLoader ( ) ; ClassLoader chain = system ; while ( true ) { if ( context == chain ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; chain = system ; while ( true ) { if ( current == chain ) { return system ; } if ( chain == null ) { break ; } chain = SecuritySupport . getParentClassLoader ( chain ) ; } return current ; } if ( chain == null ) { break ; } chain = SecuritySupport . getParentClassLoader ( chain ) ; } ; return context ; } 
@ XmlElementDecl ( namespace = "http://xmlns.oracle.com/apps/cdm/foundation/parties/personService/" , name = "RequestId" , scope = Person . class ) public JAXBElement < Long > createPersonRequestId ( Long value ) { return new JAXBElement < Long > ( _PersonProfileRequestId_QNAME , Long . class , Person . class , value ) ; } 
public static List < Request > getAllRequests ( ) { return Request . findAll ( ) ; } 
@ SuppressWarnings ( "IOResourceOpenedButNotSafelyClosed" ) public SwiftNativeOutputStream ( Configuration conf , SwiftNativeFileSystemStore nativeStore , String key , long partSizeKB ) throws IOException { this . conf = conf ; this . key = key ; this . backupFile = newBackupFile ( ) ; this . nativeStore = nativeStore ; this . backupStream = new BufferedOutputStream ( new FileOutputStream ( backupFile ) ) ; this . partNumber = 1 ; this . blockOffset = 0 ; this . filePartSize = 1024L * partSizeKB ; } 
public HandleLength . Value createHandleLengthValue ( ) { return new HandleLength . Value ( ) ; } 
public void setClockListener ( Clock . Listener listener ) { m_clock . setListener ( listener ) ; } 
private static boolean applicable ( Func f , List < Expr > args ) { if ( f . count ( ) > args . size ( ) ) return false ; int i = 0 ; for ( ExprVar d : f . params ( ) ) { Type param = d . type ( ) , arg = args . get ( i ) . type ( ) ; i ++ ; if ( ! arg . hasCommonArity ( param ) ) return false ; if ( arg . hasTuple ( ) && param . hasTuple ( ) && ! arg . intersects ( param ) ) return false ; } return true ; } 
public static String removeInitialSlash ( String input ) { if ( input == null ) { return null ; } if ( ! input . startsWith ( "/" ) ) { return input ; } else { return input . substring ( 1 ) ; } } 
public Item createItem ( GrammarPattern grammar ) throws RelaxException { if ( _patterns . size ( ) == 0 ) return null ; Item tail = _patterns . get ( _patterns . size ( ) - 1 ) . createItem ( grammar ) ; for ( int i = _patterns . size ( ) - 2 ; i >= 0 ; i -- ) tail = GroupItem . create ( _patterns . get ( i ) . createItem ( grammar ) , tail ) ; return tail ; } 
public String popAndEncode ( boolean fromOnlineEvent ) { synchronized ( this ) { registeredListeners [ activeListenerIndex ] . notifyOfFlush ( fromOnlineEvent ) ; if ( queue . isEmpty ( ) ) { return null ; } int totalPayloadLen = 0 ; int numMessagesToSend = 0 ; for ( JsMessage message : queue ) { int messageSize = calculatePackedMessageLength ( message ) ; if ( numMessagesToSend > 0 && totalPayloadLen + messageSize > MAX_PAYLOAD_SIZE && MAX_PAYLOAD_SIZE > 0 ) { break ; } totalPayloadLen += messageSize ; numMessagesToSend += 1 ; } StringBuilder sb = new StringBuilder ( totalPayloadLen ) ; for ( int i = 0 ; i < numMessagesToSend ; ++ i ) { JsMessage message = queue . removeFirst ( ) ; packMessage ( message , sb ) ; } if ( ! queue . isEmpty ( ) ) { sb . append ( '*' ) ; } String ret = sb . toString ( ) ; return ret ; } } 
public void put ( String key , long value ) { if ( key != null ) { urlParams . put ( key , String . valueOf ( value ) ) ; } } 
public static String escapeNewlines ( String s ) { return s . replaceAll ( "-" , "||n" ) ; } 
public boolean isReachable ( int timeout ) throws IOException { return isReachable ( null , 0 , timeout ) ; } 
public Hashtable parse ( Reader i ) throws IOException { state = new Hashtable ( ) ; parseStack = new Vector ( ) ; currentKey = null ; parse ( i , this ) ; return state ; } 
protected Float parseFloat ( NamedNodeMap attrs , String name , Float defaultValue ) { return parseFloat ( attrs . getNamedItem ( name ) , defaultValue ) ; } 
public void rewind ( ) { isSimplePath = true ; if ( mDetectSimplePaths ) { mLastDirection = null ; if ( rects != null ) rects . setEmpty ( ) ; } native_rewind ( mNativePath ) ; } 
public void addDeletedPrivateOwnedObjects ( DatabaseMapping mapping , Object object ) { if ( deletedPrivateOwnedObjects == null ) { deletedPrivateOwnedObjects = new IdentityHashMap ( ) ; } List < Object > list = deletedPrivateOwnedObjects . get ( mapping ) ; if ( list == null ) { list = new ArrayList < Object > ( ) ; deletedPrivateOwnedObjects . put ( mapping , list ) ; } list . add ( object ) ; } 
public final static float clamp ( final float a , final float low , final float high ) { return Math . max ( low , Math . min ( a , high ) ) ; } 
@ Deprecated public static RequestAsyncTask executeUploadPhotoRequestAsync ( Session session , Bitmap image , Callback callback ) { return newUploadPhotoRequest ( session , image , callback ) . executeAsync ( ) ; } 
public byte [ ] readFully ( ) throws IOException { FileInputStream stream = openRead ( ) ; try { int pos = 0 ; int avail = stream . available ( ) ; byte [ ] data = new byte [ avail ] ; while ( true ) { int amt = stream . read ( data , pos , data . length - pos ) ; if ( amt <= 0 ) { return data ; } pos += amt ; avail = stream . available ( ) ; if ( avail > data . length - pos ) { byte [ ] newData = new byte [ pos + avail ] ; System . arraycopy ( data , 0 , newData , 0 , pos ) ; data = newData ; } } } finally { stream . close ( ) ; } } 
private void addLoadOption ( java . util . Map < Object , Object > options , Object key , Object value ) { if ( options . containsKey ( key ) ) { Object currentValue = options . get ( key ) ; if ( currentValue instanceof java . util . List < ? > ) { java . util . List < ? > currentValueAsList = ( java . util . List < ? > ) currentValue ; java . util . List < Object > currentValueAsObjectList = SOS . resource . SOS . util . SOSListUtil . copySafelyToObjectList ( currentValueAsList ) ; if ( value instanceof java . util . Collection < ? > ) { currentValueAsObjectList . addAll ( ( java . util . Collection < ? > ) value ) ; } else { currentValueAsObjectList . add ( value ) ; } options . put ( key , currentValueAsObjectList ) ; } else { java . util . List < Object > newValueList = new java . util . ArrayList < Object > ( ) ; newValueList . add ( currentValue ) ; if ( value instanceof java . util . Collection < ? > ) { newValueList . addAll ( ( java . util . Collection < ? > ) value ) ; } else { newValueList . add ( value ) ; } options . put ( key , newValueList ) ; } } else { options . put ( key , value ) ; } } 
public final boolean hasAction ( String action ) { return action != null && mActions . contains ( action ) ; } 
public boolean addAll ( Collection < ? extends E > c ) { return al . addAllAbsent ( c ) > 0 ; } 
public Float evaluate ( float fraction , Number startValue , Number endValue ) { float startFloat = startValue . floatValue ( ) ; return startFloat + fraction * ( endValue . floatValue ( ) - startFloat ) ; } 
@ Override public void flush ( ) throws IOException { PipedInputStream stream = target ; if ( stream == null ) { return ; } synchronized ( stream ) { stream . notifyAll ( ) ; } } 
public static void finalizeAllEnqueued ( ) throws InterruptedException { Sentinel sentinel ; do { sentinel = new Sentinel ( ) ; } while ( ! enqueueSentinelReference ( sentinel ) ) ; sentinel . awaitFinalization ( ) ; } 
public final Iterator < String > schemesIterator ( ) { return mDataSchemes != null ? mDataSchemes . iterator ( ) : null ; } 
@ Override public boolean accept ( File file ) { return file . isDirectory ( ) ; } 
public Vector getDirection ( ) { Vector vector = new Vector ( ) ; double rotX = this . getYaw ( ) ; double rotY = this . getPitch ( ) ; vector . setY ( - Math . sin ( Math . toRadians ( rotY ) ) ) ; double xz = Math . cos ( Math . toRadians ( rotY ) ) ; vector . setX ( - xz * Math . sin ( Math . toRadians ( rotX ) ) ) ; vector . setZ ( xz * Math . cos ( Math . toRadians ( rotX ) ) ) ; return vector ; } 
public Object next ( ) { return _nodesIter . next ( ) ; } 
@ XmlElementDecl ( namespace = "" , name = "external_tag_attribute" ) public JAXBElement < ExternalTagAttribute > createExternalTagAttribute ( ExternalTagAttribute value ) { return new JAXBElement < ExternalTagAttribute > ( _ExternalTagAttribute_QNAME , ExternalTagAttribute . class , null , value ) ; } 
public static byte [ ] readAll ( InputStream in ) throws IOException { byte [ ] buf = new byte [ 1024 ] ; int nread , ntotal = 0 ; while ( ( nread = in . read ( buf , ntotal , buf . length - ntotal ) ) > - 1 ) { ntotal += nread ; if ( ntotal == buf . length ) { byte [ ] newbuf = new byte [ buf . length * 2 ] ; System . arraycopy ( buf , 0 , newbuf , 0 , buf . length ) ; buf = newbuf ; } } if ( ntotal < buf . length ) { byte [ ] newbuf = new byte [ ntotal ] ; System . arraycopy ( buf , 0 , newbuf , 0 , ntotal ) ; buf = newbuf ; } return buf ; } 
@ Override public final void run ( ) { boolean deadlock = false ; while ( ! deadlock ) try { long [ ] ids = tmx . findDeadlockedThreads ( ) ; if ( ids != null ) { deadlock = true ; ThreadInfo [ ] tis = tmx . getThreadInfo ( ids , true , true ) ; String info = "DeadLock-Found!-" ; for ( ThreadInfo ti : tis ) info += ti . toString ( ) ; for ( ThreadInfo ti : tis ) { LockInfo [ ] locks = ti . getLockedSynchronizers ( ) ; MonitorInfo [ ] monitors = ti . getLockedMonitors ( ) ; if ( locks . length == 0 && monitors . length == 0 ) continue ; ThreadInfo dl = ti ; info += "Java-level-deadlock:-" ; info += createShortLockInfo ( dl ) ; while ( ( dl = tmx . getThreadInfo ( new long [ ] { dl . getLockOwnerId ( ) } , true , true ) [ 0 ] ) . getThreadId ( ) != ti . getThreadId ( ) ) info += createShortLockInfo ( dl ) ; info += "-Dumping-all-threads:-" ; for ( ThreadInfo dumpedTI : tmx . dumpAllThreads ( true , true ) ) { info += printDumpedThreadInfo ( dumpedTI ) ; } } log . warn ( info ) ; if ( doWhenDL == RESTART ) System . exit ( ExitCode . CODE_RESTART ) ; } Thread . sleep ( sleepTime ) ; } catch ( Exception e ) { log . warn ( "DeadLockDetector:-" + e , e ) ; } } 
public boolean isExpired ( ) { return this . ttl < System . currentTimeMillis ( ) ; } 
public Paint getLeftShadowGradient ( Shape s ) { Rectangle2D bounds = s . getBounds2D ( ) ; float minX = ( float ) bounds . getMinX ( ) ; float maxX = ( float ) bounds . getMaxX ( ) ; float midY = ( float ) bounds . getCenterY ( ) ; return new LinearGradientPaint ( minX , midY , maxX , midY , ( new float [ ] { 0f , 1f } ) , new Color [ ] { innerShadow . bottom , transparentColor } ) ; } 
private void startAnimation ( ) { initAnimation ( ) ; sAnimations . get ( ) . add ( this ) ; if ( mStartDelay > 0 && mListeners != null ) { ArrayList < AnimatorListener > tmpListeners = ( ArrayList < AnimatorListener > ) mListeners . clone ( ) ; int numListeners = tmpListeners . size ( ) ; for ( int i = 0 ; i < numListeners ; ++ i ) { tmpListeners . get ( i ) . onAnimationStart ( this ) ; } } } 
@ Override public void close ( ) throws IOException { synchronized ( lock ) { if ( ! isClosed ( ) ) { in . close ( ) ; buf = null ; } } } 
public Control getControlInstance ( Control ctl ) throws NamingException { String id = ctl . getID ( ) ; try { if ( id . equals ( SortResponseControl . OID ) ) { return new SortResponseControl ( id , ctl . isCritical ( ) , ctl . getEncodedValue ( ) ) ; } else if ( id . equals ( PagedResultsResponseControl . OID ) ) { return new PagedResultsResponseControl ( id , ctl . isCritical ( ) , ctl . getEncodedValue ( ) ) ; } else if ( id . equals ( EntryChangeResponseControl . OID ) ) { return new EntryChangeResponseControl ( id , ctl . isCritical ( ) , ctl . getEncodedValue ( ) ) ; } } catch ( IOException e ) { NamingException ne = new NamingException ( ) ; ne . setRootCause ( e ) ; throw ne ; } return null ; } 
public int getRunLimit ( int run ) { if ( icuBidi . getRunCount ( ) == 0 ) { return icuBidi . getLength ( ) ; } else { return icuBidi . getRunLimit ( run ) ; } } 
protected void startUpdate ( ) { mConfigList . clear ( ) ; } 
protected Collection < Thread > getQueuedWriterThreads ( ) { return sync . getExclusiveQueuedThreads ( ) ; } 
public static Binding getBinding ( Map < String , ? extends Object > context ) { Map < String , Object > vars = FastMap . newInstance ( ) ; if ( context != null ) { vars . putAll ( context ) ; vars . put ( "context" , context ) ; } return new Binding ( vars ) ; } 
public boolean offer ( E e ) { return add ( e ) ; } 
public void accept ( Visitor v ) { v . visitVariableLengthInstruction ( this ) ; v . visitStackProducer ( this ) ; v . visitBranchInstruction ( this ) ; v . visitSelect ( this ) ; v . visitTABLESWITCH ( this ) ; } 
XPathFactory createInstance ( String className ) { try { if ( debug ) debugPrintln ( "instantiating-" + className ) ; Class clazz ; if ( classLoader != null ) clazz = classLoader . loadClass ( className ) ; else clazz = Class . forName ( className ) ; if ( debug ) debugPrintln ( "loaded-it-from-" + which ( clazz ) ) ; Object o = clazz . newInstance ( ) ; if ( o instanceof XPathFactory ) return ( XPathFactory ) o ; if ( debug ) debugPrintln ( className + "-is-not-assignable-to-" + SERVICE_CLASS . getName ( ) ) ; } catch ( VirtualMachineError vme ) { throw vme ; } catch ( ThreadDeath td ) { throw td ; } catch ( Throwable t ) { if ( debug ) { debugPrintln ( "failed-to-instantiate-" + className ) ; t . printStackTrace ( ) ; } } return null ; } 
public int getTrafficClass ( ) throws SocketException { return ( ( Integer ) ( getImpl ( ) . getOption ( SocketOptions . IP_TOS ) ) ) . intValue ( ) ; } 
public DataItem getDataItem ( final int id ) { return data . get ( id ) ; } 
public static void write ( OutputStream stream , Object o ) throws Exception { ObjectOutputStream oos ; if ( ! ( stream instanceof BufferedOutputStream ) ) stream = new BufferedOutputStream ( stream ) ; oos = new ObjectOutputStream ( stream ) ; oos . writeObject ( o ) ; oos . flush ( ) ; oos . close ( ) ; } 
public void removeLevelItem ( Item item ) { level_items . remove ( item ) ; item_count -- ; } 
public Set < MediaTypeExpression > getExpressions ( ) { return new LinkedHashSet < MediaTypeExpression > ( this . expressions ) ; } 
private boolean isCursorInLastPosition ( ) { return ( text . getSelection ( ) . y >= getText ( ) . length ( ) ) ; } 
public void runApplication ( String arg ) throws IOException { List < String > appDef = getComandElements ( ) ; String [ ] cmd = new String [ appDef . size ( ) + 1 ] ; for ( int i = 0 ; i < appDef . size ( ) ; i ++ ) { cmd [ i ] = appDef . get ( i ) ; } cmd [ appDef . size ( ) ] = arg ; Runtime . getRuntime ( ) . exec ( cmd , null ) ; } 
public XMLBuilder add ( String element , Iterable < Attribute > attributes , boolean close ) throws IOException { indent ( ) ; elementStack . push ( element ) ; writer . write ( '<' ) ; writer . write ( element ) ; Iterator < Attribute > iterator = attributes . iterator ( ) ; if ( iterator . hasNext ( ) ) { writer . write ( '-' ) ; } while ( iterator . hasNext ( ) ) { Attribute attribute = iterator . next ( ) ; attribute . append ( writer ) ; if ( iterator . hasNext ( ) ) { writer . write ( '-' ) ; } } if ( close ) { elementStack . pop ( ) ; writer . write ( "/>" ) ; } else { writer . write ( '>' ) ; } newline ( ) ; return this ; } 
public Collection < Target > getTargets ( ) { return targets . values ( ) ; } 
public Image getImage ( GraphicsConfiguration config , int w , int h , Object ... args ) { lock . readLock ( ) . lock ( ) ; try { PixelCountSoftReference ref = map . get ( hash ( config , w , h , args ) ) ; if ( ref != null && ref . equals ( config , w , h , args ) ) { return ref . get ( ) ; } else { return null ; } } finally { lock . readLock ( ) . unlock ( ) ; } } 
public Map getAttributes ( ) { return reorderedACI . getAttributes ( ) ; } 
@ Override public double getFalsePositiveRate ( ) { if ( _entryBytes <= 8 ) return 0d ; return 1d / Math . pow ( 2d , 64d ) ; } 
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( 4 ) ; newVector . addElement ( new Option ( "-Specify-list-of-columns-to-transform.-First-and-last-are-" + "-valid-indexes-(default-none).-Non-numeric-columns-are-" + "-skipped." , "R" , 1 , "-R-<index1,index2-index4,...>" ) ) ; newVector . addElement ( new Option ( "-Invert-matching-sense." , "V" , 0 , "-V" ) ) ; newVector . addElement ( new Option ( "-Sets-the-class-containing-transformation-method.-" + "-(default-java.lang.Math)" , "C" , 1 , "-C-<string>" ) ) ; newVector . addElement ( new Option ( "-Sets-the-method.-(default-abs)" , "M" , 1 , "-M-<string>" ) ) ; return newVector . elements ( ) ; } 
private List < Class < ? >> findEventTypes ( Class < ? > eventClass ) { synchronized ( eventTypesCache ) { List < Class < ? >> eventTypes = eventTypesCache . get ( eventClass ) ; if ( eventTypes == null ) { eventTypes = new ArrayList < Class < ? >> ( ) ; Class < ? > clazz = eventClass ; while ( clazz != null ) { eventTypes . add ( clazz ) ; addInterfaces ( eventTypes , clazz . getInterfaces ( ) ) ; clazz = clazz . getSuperclass ( ) ; } eventTypesCache . put ( eventClass , eventTypes ) ; } return eventTypes ; } } 
static public long getProtocolVersion ( Class < ? > protocol ) { if ( protocol == null ) { throw new IllegalArgumentException ( "Null-protocol" ) ; } long version ; ProtocolInfo anno = protocol . getAnnotation ( ProtocolInfo . class ) ; if ( anno != null ) { version = anno . protocolVersion ( ) ; if ( version != - 1 ) return version ; } try { Field versionField = protocol . getField ( "versionID" ) ; versionField . setAccessible ( true ) ; return versionField . getLong ( protocol ) ; } catch ( NoSuchFieldException ex ) { throw new RuntimeException ( ex ) ; } catch ( IllegalAccessException ex ) { throw new RuntimeException ( ex ) ; } } 
public static void putPerfLong ( long value , String name ) { ByteBuffer b = counters . get ( name ) ; synchronized ( b ) { b . putLong ( value ) ; b . rewind ( ) ; } } 
public Principal toPrincipal ( X509Certificate [ ] certs ) { Principal cn = null ; LdapName dn = null ; Principal subject = certs [ 0 ] . getSubjectDN ( ) ; try { dn = new LdapName ( subject . getName ( ) ) ; for ( Rdn rdn : dn . getRdns ( ) ) { if ( rdn . getType ( ) . compareToIgnoreCase ( "cn" ) == 0 ) { cn = new SimplePrincipal ( rdn . getValue ( ) . toString ( ) ) ; } } } catch ( InvalidNameException e ) { } if ( cn == null ) { cn = subject ; } return cn ; } 
private void addWorker ( ) { Throwable ex = null ; ForkJoinWorkerThread t = null ; try { t = factory . newThread ( this ) ; } catch ( Throwable e ) { ex = e ; } if ( t == null ) { long c ; do { } while ( ! UNSAFE . compareAndSwapLong ( this , ctlOffset , c = ctl , ( ( ( c - AC_UNIT ) & AC_MASK ) | ( ( c - TC_UNIT ) & TC_MASK ) | ( c & ~ ( AC_MASK | TC_MASK ) ) ) ) ) ; if ( ! tryTerminate ( false ) && ex != null && ! ( Thread . currentThread ( ) instanceof ForkJoinWorkerThread ) ) UNSAFE . throwException ( ex ) ; } else t . start ( ) ; } 
private JTextPane getTpOutputPane ( ) { if ( tpOutputPane == null ) { tpOutputPane = new JTextPane ( ) ; tpOutputPane . setContentType ( "text/plain" ) ; } return tpOutputPane ; } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; if ( localProcessResultTracker ) { elementList . add ( new javax . xml . namespace . QName ( "http://com.xyzmo.server.inputinterface.webserviceNativePrototype.Sign/" , "ProcessResult" ) ) ; if ( localProcessResult == null ) { throw new org . apache . axis2 . databinding . ADBException ( "ProcessResult-cannot-be-null!!" ) ; } elementList . add ( localProcessResult ) ; } return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
@ Deprecated public synchronized void removePlugin ( Plugin plugin ) { int location = mPlugins . indexOf ( plugin ) ; if ( location != - 1 ) { mPlugins . remove ( location ) ; } } 
public void setCursor ( Cursor cursor ) { if ( cursor == null ) { cursor = Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ; } super . setCursor ( cursor ) ; } 
public static int optionLength ( String option ) { if ( option . equals ( OUTPUT_PATH_OPTION ) ) { return 2 ; } return 0 ; } 
@ SuppressWarnings ( "unchecked" ) protected StdSerializer ( Class < ? > t , boolean dummy ) { _handledType = ( Class < T > ) t ; } 
public void setStopwords ( File value ) { if ( value == null ) { value = new File ( System . getProperty ( "user.dir" ) ) ; } m_Stopwords = value ; reset ( ) ; } 
private static final String printWakeLockCheckin ( StringBuilder sb , Timer timer , long now , String name , int which , String linePrefix ) { long totalTimeMicros = 0 ; int count = 0 ; if ( timer != null ) { totalTimeMicros = timer . getTotalTimeLocked ( now , which ) ; count = timer . getCountLocked ( which ) ; } sb . append ( linePrefix ) ; sb . append ( ( totalTimeMicros + 500 ) / 1000 ) ; sb . append ( ',' ) ; sb . append ( name != null ? name + "," : "" ) ; sb . append ( count ) ; return "," ; } 
public static boolean contains ( String self , String text ) { int idx = self . indexOf ( text ) ; return idx >= 0 ; } 
int groupFromChildId ( long childId ) { if ( ! mDataValid ) return - 1 ; int group = - 1 ; for ( mCursor . moveToFirst ( ) ; ! mCursor . isAfterLast ( ) ; mCursor . moveToNext ( ) ) { if ( getLong ( mIdIndex ) == childId ) { int bin = mDateSorter . getIndex ( getLong ( mDateIndex ) ) ; if ( DateSorter . DAY_COUNT == mNumberOfBins ) { return bin ; } group = 0 ; for ( int i = 0 ; i < bin ; i ++ ) { if ( mItemMap [ i ] != 0 ) { group ++ ; } } break ; } } return group ; } 
public int getPaymentDateIndex ( LocalDate date ) { return Arrays . binarySearch ( _paymentDates , date , null ) ; } 
@ SuppressWarnings ( "rawtypes" ) public static String vector2String ( Vector v , String delimiter ) { if ( v == null || delimiter == null ) { return null ; } return enumeration2String ( v . elements ( ) , delimiter ) ; } 
public String getExtProperty ( String propName ) { return m_extProperties . get ( propName ) ; } 
public static void main ( String [ ] args ) { JFrame window = new JFrame ( "Multiprocessing-Demo-1" ) ; MultiprocessingDemo1 content = new MultiprocessingDemo1 ( ) ; window . setContentPane ( content ) ; window . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; window . pack ( ) ; window . setResizable ( false ) ; Dimension screenSize = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; window . setLocation ( ( screenSize . width - window . getWidth ( ) ) / 2 , ( screenSize . height - window . getHeight ( ) ) / 2 ) ; window . setVisible ( true ) ; } 
public static double max ( final double a , final double b ) { if ( a > b ) { return a ; } if ( a < b ) { return b ; } if ( a != b ) { return Double . NaN ; } long bits = Double . doubleToRawLongBits ( a ) ; if ( bits == 0x8000000000000000L ) { return b ; } return a ; } 
public Set < X > getValuesForCount ( int count ) { Set < X > ret = new HashSet < X > ( ) ; for ( Entry < X , Integer > e : this . histogram . entrySet ( ) ) { if ( e . getValue ( ) . intValue ( ) == count ) ret . add ( e . getKey ( ) ) ; } return ( ret ) ; } 
public String getRoleSelection ( ) { return Validator . check ( roleSelection , "N/A" ) ; } 
static public Image getLibImage ( String name , Component who ) { Image image = null ; Toolkit tk = Toolkit . getDefaultToolkit ( ) ; File imageLocation = new File ( getContentFile ( "lib" ) , name ) ; image = tk . getImage ( imageLocation . getAbsolutePath ( ) ) ; MediaTracker tracker = new MediaTracker ( who ) ; tracker . addImage ( image , 0 ) ; try { tracker . waitForAll ( ) ; } catch ( InterruptedException e ) { } return image ; } 
public ProgressData getProgressData ( String serviceId ) { return progressDataHashMap . get ( serviceId ) ; } 
public static JsDate toJs ( Date java ) { return java == null ? null : create ( java . getTime ( ) ) ; } 
protected void Argument ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; appendOp ( 2 , OpCodes . OP_ARGUMENT ) ; Expr ( ) ; m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } 
@ Override public Object clone ( ) throws CloneNotSupportedException { Task clone = ( Task ) super . clone ( ) ; return clone ; } 
public boolean remove ( Object o ) { return _list . remove ( o ) ; } 
protected void log ( final String level , final String message ) { try { writer . write ( BasicLogFormatter . format ( level , message , name ) ) ; writer . flush ( ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } } 
public String readLine ( ) throws IOException { synchronized ( in ) { if ( buf == null ) { throw new IOException ( "LineReader-is-closed" ) ; } if ( pos >= end ) { fillBuf ( ) ; } for ( int i = pos ; i != end ; ++ i ) { if ( buf [ i ] == LF ) { int lineEnd = ( i != pos && buf [ i - 1 ] == CR ) ? i - 1 : i ; String res = new String ( buf , pos , lineEnd - pos , charset . name ( ) ) ; pos = i + 1 ; return res ; } } ByteArrayOutputStream out = new ByteArrayOutputStream ( end - pos + 80 ) { @ Override public String toString ( ) { int length = ( count > 0 && buf [ count - 1 ] == CR ) ? count - 1 : count ; try { return new String ( buf , 0 , length , charset . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( e ) ; } } } ; while ( true ) { out . write ( buf , pos , end - pos ) ; end = - 1 ; fillBuf ( ) ; for ( int i = pos ; i != end ; ++ i ) { if ( buf [ i ] == LF ) { if ( i != pos ) { out . write ( buf , pos , i - pos ) ; } pos = i + 1 ; return out . toString ( ) ; } } } } } 
private synchronized void rebuildJournal ( ) throws IOException { if ( journalWriter != null ) { journalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new FileWriter ( journalFileTmp ) ) ; writer . write ( MAGIC ) ; writer . write ( "-" ) ; writer . write ( VERSION_1 ) ; writer . write ( "-" ) ; writer . write ( Integer . toString ( appVersion ) ) ; writer . write ( "-" ) ; writer . write ( Integer . toString ( valueCount ) ) ; writer . write ( "-" ) ; writer . write ( "-" ) ; for ( Entry entry : lruEntries . values ( ) ) { if ( entry . currentEditor != null ) { writer . write ( DIRTY + '-' + entry . key + '|n' ) ; } else { writer . write ( CLEAN + '-' + entry . key + entry . getLengths ( ) + '|n' ) ; } } writer . close ( ) ; journalFileTmp . renameTo ( journalFile ) ; journalWriter = new BufferedWriter ( new FileWriter ( journalFile , true ) ) ; } 
public List < II > getId ( ) { if ( id == null ) { id = new ArrayList < II > ( ) ; } return this . id ; } 
private void failNotAllowed ( String name , String prefix , AttributeSet attrs ) { throw new InflateException ( attrs . getPositionDescription ( ) + ":-Class-not-allowed-to-be-inflated-" + ( prefix != null ? ( prefix + name ) : name ) ) ; } 
public boolean loadModel ( Model model ) { String [ ] wKeys = new String [ model . weights . size ( ) ] ; float [ ] wValues = new float [ model . weights . size ( ) ] ; int i = 0 ; for ( Map . Entry < String , Float > e : model . weights . entrySet ( ) ) { wKeys [ i ] = e . getKey ( ) ; wValues [ i ] = e . getValue ( ) ; i ++ ; } boolean res = setModelWeights ( wKeys , wValues , model . weightNormalizer ) ; if ( ! res ) return false ; for ( Map . Entry < String , String > e : model . parameters . entrySet ( ) ) { res = setModelParameter ( e . getKey ( ) , e . getValue ( ) ) ; if ( ! res ) return false ; } return res ; } 
public TreePath getPathClosestTo ( int x , int y ) { if ( getRowCount ( ) == 0 ) return null ; int row = getRowContainingYLocation ( y ) ; return getPathForRow ( row ) ; } 
public void defaultWriteObject ( ) throws IOException { if ( currentObject == null ) { throw new NotActiveException ( ) ; } writeFieldValues ( currentObject , currentClass ) ; } 
private void doWaitForDownloadsOrTimeout ( Query query , long poll , long timeoutMillis ) throws TimeoutException { int currentWaitTime = 0 ; while ( true ) { query . setFilterByStatus ( DownloadManager . STATUS_PENDING | DownloadManager . STATUS_PAUSED | DownloadManager . STATUS_RUNNING ) ; Cursor cursor = mDownloadManager . query ( query ) ; try { if ( cursor . getCount ( ) == 0 ) { Log . i ( LOG_TAG , "All-downloads-should-be-done..." ) ; break ; } currentWaitTime = timeoutWait ( currentWaitTime , poll , timeoutMillis , "Timed-out-waiting-for-all-downloads-to-finish" ) ; } finally { cursor . close ( ) ; } } } 
public double ptSegDistSq ( Point2D pt ) { return ptSegDistSq ( getX1 ( ) , getY1 ( ) , getX2 ( ) , getY2 ( ) , pt . getX ( ) , pt . getY ( ) ) ; } 
public final String toString ( ) { ConstantUtf8 c ; String name , signature , access ; StringBuffer buf ; access = Utility . accessToString ( access_flags ) ; c = ( ConstantUtf8 ) constant_pool . getConstant ( signature_index , Constants . CONSTANT_Utf8 ) ; signature = c . getBytes ( ) ; c = ( ConstantUtf8 ) constant_pool . getConstant ( name_index , Constants . CONSTANT_Utf8 ) ; name = c . getBytes ( ) ; signature = Utility . methodSignatureToString ( signature , name , access , true , getLocalVariableTable ( ) ) ; buf = new StringBuffer ( signature ) ; for ( int i = 0 ; i < attributes_count ; i ++ ) { Attribute a = attributes [ i ] ; if ( ! ( ( a instanceof Code ) || ( a instanceof ExceptionTable ) ) ) buf . append ( "-[" + a . toString ( ) + "]" ) ; } ExceptionTable e = getExceptionTable ( ) ; if ( e != null ) { String str = e . toString ( ) ; if ( ! str . equals ( "" ) ) buf . append ( "-throws-" + str ) ; } return buf . toString ( ) ; } 
public void add ( Population pop ) { list . add ( pop ) ; map . put ( pop . getCoordinate ( ) , pop ) ; } 
public ArrayList < String > getWordsArray ( String transcript ) { Log . i ( debugTag , "getWordsArray" ) ; String [ ] arr = transcript . split ( "[-]+" ) ; ArrayList < String > toReturn = new ArrayList < String > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = arr [ i ] . replaceAll ( "|n" , "" ) ; arr [ i ] = arr [ i ] . replaceAll ( "-" , "" ) ; arr [ i ] = arr [ i ] . replaceAll ( "|r" , "" ) ; } boolean shouldBreak ; for ( String str : arr ) { shouldBreak = false ; for ( String commonWord : common ) { if ( commonWord . equals ( str ) ) { shouldBreak = true ; break ; } } if ( shouldBreak ) continue ; toReturn . add ( str ) ; } return toReturn ; } 
public static void loadEvents ( Context context , ArrayList < Event > events , int startDay , int days , int requestId , AtomicInteger sequenceNumber ) { if ( PROFILE ) { Debug . startMethodTracing ( "loadEvents" ) ; } Cursor cEvents = null ; Cursor cAllday = null ; events . clear ( ) ; try { int endDay = startDay + days - 1 ; SharedPreferences prefs = GeneralPreferences . getSharedPreferences ( context ) ; boolean hideDeclined = prefs . getBoolean ( GeneralPreferences . KEY_HIDE_DECLINED , false ) ; String where = EVENTS_WHERE ; String whereAllday = ALLDAY_WHERE ; if ( hideDeclined ) { String hideString = "-AND-" + Instances . SELF_ATTENDEE_STATUS + "!=" + Attendees . ATTENDEE_STATUS_DECLINED ; where += hideString ; whereAllday += hideString ; } cEvents = instancesQuery ( context . getContentResolver ( ) , EVENT_PROJECTION , startDay , endDay , where , null , SORT_EVENTS_BY ) ; cAllday = instancesQuery ( context . getContentResolver ( ) , EVENT_PROJECTION , startDay , endDay , whereAllday , null , SORT_ALLDAY_BY ) ; if ( requestId != sequenceNumber . get ( ) ) { return ; } buildEventsFromCursor ( events , cEvents , context , startDay , endDay ) ; buildEventsFromCursor ( events , cAllday , context , startDay , endDay ) ; } finally { if ( cEvents != null ) { cEvents . close ( ) ; } if ( cAllday != null ) { cAllday . close ( ) ; } if ( PROFILE ) { Debug . stopMethodTracing ( ) ; } } } 
private List < T > draw ( int nbrOfTs , boolean top ) throws DeckExhaustedException { if ( nbrOfTs < 0 ) { throw new IllegalArgumentException ( "Integer-arg-must-be-1-or-more." ) ; } if ( nbrOfTs == 0 ) { return Collections . emptyList ( ) ; } List < T > hand = new ArrayList < > ( ) ; try { for ( int i = nbrOfTs ; i > 0 ; -- i ) { hand . add ( top ? internal . removeFirst ( ) : internal . removeLast ( ) ) ; } } catch ( NoSuchElementException e ) { throw new DeckExhaustedException ( hand ) ; } return hand ; } 
public static Response executeAndWait ( Request request ) { List < Response > responses = executeBatchAndWait ( request ) ; if ( responses == null || responses . size ( ) != 1 ) { throw new FacebookException ( "invalid-state:-expected-a-single-response" ) ; } return responses . get ( 0 ) ; } 
public void setVisitedNetworkID ( Token networkID ) { if ( networkID == null ) throw new NullPointerException ( "-the-networkID-parameter-is-null" ) ; this . networkID = networkID . getTokenValue ( ) ; this . isQuoted = false ; } 
final boolean transferForSignal ( Node node ) { if ( ! compareAndSetWaitStatus ( node , Node . CONDITION , 0 ) ) return false ; Node p = enq ( node ) ; int ws = p . waitStatus ; if ( ws > 0 || ! compareAndSetWaitStatus ( p , ws , Node . SIGNAL ) ) LockSupport . unpark ( node . thread ) ; return true ; } 
public Location transform ( int diffX , int diffY , int diffZ ) { return Location . create ( x + diffX , y + diffY , z + diffZ ) ; } 
@ ZAttr ( id = 545 ) public Map < String , Object > setReverseProxyDomainNameQuery ( String zimbraReverseProxyDomainNameQuery , Map < String , Object > attrs ) { if ( attrs == null ) attrs = new HashMap < String , Object > ( ) ; attrs . put ( Provisioning . A_zimbraReverseProxyDomainNameQuery , zimbraReverseProxyDomainNameQuery ) ; return attrs ; } 
@ Override public void changeCursor ( Cursor c ) { if ( DBG ) Log . d ( LOG_TAG , "changeCursor(" + c + ")" ) ; if ( mClosed ) { Log . w ( LOG_TAG , "Tried-to-change-cursor-after-adapter-was-closed." ) ; if ( c != null ) c . close ( ) ; return ; } try { super . changeCursor ( c ) ; if ( c != null ) { mText1Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_TEXT_1 ) ; mText2Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_TEXT_2 ) ; mText2UrlCol = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_TEXT_2_URL ) ; mIconName1Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_ICON_1 ) ; mIconName2Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_ICON_2 ) ; mFlagsCol = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_FLAGS ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , "error-changing-cursor-and-caching-columns" , e ) ; } } 
public final R visit ( TypeMirror t , P p ) { return t . accept ( this , p ) ; } 
public void initialize ( Map configParams ) { String delimiterConfig = ( String ) configParams . get ( PolicyConfig . RESOURCE_COMPARATOR_DELIMITER ) ; if ( delimiterConfig != null ) { this . delimiter = delimiterConfig ; } String caseConfig = ( String ) configParams . get ( PolicyConfig . RESOURCE_COMPARATOR_CASE_SENSITIVE ) ; if ( caseConfig != null ) { if ( caseConfig . equals ( "true" ) ) { this . caseSensitive = true ; } else if ( caseConfig . equals ( "false" ) ) { this . caseSensitive = false ; } else { this . caseSensitive = false ; } } String wildcardConfig = ( String ) configParams . get ( PolicyConfig . RESOURCE_COMPARATOR_WILDCARD ) ; if ( wildcardConfig != null ) { this . wildcard = wildcardConfig ; } return ; } 
public InputStream getUnicodeStream ( int columnIndex ) throws SQLException { if ( ! this . isBinaryEncoded ) { checkRowPos ( ) ; return getBinaryStream ( columnIndex ) ; } return getNativeBinaryStream ( columnIndex ) ; } 
void push ( String entry ) { stack . add ( "---" + entry ) ; } 
private void parsePrefix ( Name name , NameTokenizer tokens ) { if ( tokens . mStartPointer == tokens . mEndPointer ) { return ; } String firstToken = tokens . mTokens [ tokens . mStartPointer ] ; if ( mPrefixesSet . contains ( firstToken . toUpperCase ( ) ) ) { if ( tokens . hasDot ( tokens . mStartPointer ) ) { firstToken += '.' ; } name . prefix = firstToken ; tokens . mStartPointer ++ ; } } 
public boolean tryAcquire ( ) { return sync . nonfairTryAcquireShared ( 1 ) >= 0 ; } 
public void setEscapedPath ( String escapedPath ) throws URIException { if ( escapedPath == null ) { _path = _opaque = null ; setURI ( ) ; return ; } setRawPath ( escapedPath . toCharArray ( ) ) ; } 
protected int findOffsetToCharactersInString ( char [ ] string , int start ) { int stringLength = string . length ; int end = getEndOffset ( ) ; Segment seg = new Segment ( ) ; try { getDocument ( ) . getText ( start , end - start , seg ) ; } catch ( BadLocationException ble ) { return - 1 ; } for ( int counter = seg . offset , maxCounter = seg . offset + seg . count ; counter < maxCounter ; counter ++ ) { char currentChar = seg . array [ counter ] ; for ( int subCounter = 0 ; subCounter < stringLength ; subCounter ++ ) { if ( currentChar == string [ subCounter ] ) return counter - seg . offset + start ; } } return - 1 ; } 
public void startContentModel ( String elementName , Augmentations augs ) throws XNIException { if ( fValidation ) { fDTDElementDeclName = elementName ; fMixedElementTypes . clear ( ) ; } if ( fDTDGrammar != null ) fDTDGrammar . startContentModel ( elementName , augs ) ; if ( fDTDContentModelHandler != null ) { fDTDContentModelHandler . startContentModel ( elementName , augs ) ; } } 
public String getDataType ( final String name ) { return DATA_TYPE_MAP . get ( name ) ; } 
public static byte [ ] copyJpegMetaData ( byte [ ] source , byte [ ] dest ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ImageOutputStream out = new MemoryCacheImageOutputStream ( baos ) ; copyJpegMetaData ( new ByteArrayInputStream ( source ) , new ByteArrayInputStream ( dest ) , out ) ; return baos . toByteArray ( ) ; } 
public Icon getIconAt ( int index ) { return pages . get ( index ) . icon ; } 
public int getDirectionToward ( Location target ) { int dx = target . getCol ( ) - getCol ( ) ; int dy = target . getRow ( ) - getRow ( ) ; int angle = ( int ) Math . toDegrees ( Math . atan2 ( - dy , dx ) ) ; int compassAngle = RIGHT - angle ; compassAngle += HALF_RIGHT / 2 ; if ( compassAngle < 0 ) compassAngle += FULL_CIRCLE ; return ( compassAngle / HALF_RIGHT ) * HALF_RIGHT ; } 
public List < String > getNullFlavor ( ) { if ( nullFlavor == null ) { nullFlavor = new ArrayList < String > ( ) ; } return this . nullFlavor ; } 
public static byte [ ] streamToBytes ( InputStream is ) throws IOException { byte [ ] xferBuffer = new byte [ 10240 ] ; byte [ ] outBytes = null ; int i ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { while ( ( i = is . read ( xferBuffer ) ) > 0 ) baos . write ( xferBuffer , 0 , i ) ; outBytes = baos . toByteArray ( ) ; } finally { baos = null ; } return outBytes ; } 
@ SuppressWarnings ( "rawtypes" ) public static PathEvaluator atDepth ( final int depth ) { return new PathEvaluator . Adapter ( ) { public Evaluation evaluate ( Path path , BranchState state ) { return path . length ( ) == depth ? Evaluation . INCLUDE_AND_PRUNE : Evaluation . EXCLUDE_AND_CONTINUE ; } } ; } 
public int getSequenceNumber ( ) { return mSequenceGenerator . incrementAndGet ( ) ; } 
public static byte [ ] copyOf ( byte [ ] original , int newLength ) { if ( newLength < 0 ) { throw new NegativeArraySizeException ( ) ; } return copyOfRange ( original , 0 , newLength ) ; } 
private LExp lookupIdInGlobalEnv ( LId id ) { return globalEnvironment . getValueOf ( id ) ; } 
public void stopFetchRequests ( ) { if ( fetchTimer != null ) { fetchTimer . cancel ( ) ; fetchTimer = null ; } } 
public static IStatus makeCommittable ( IResource [ ] resources , Object context ) { List < IResource > readOnlyFiles = new ArrayList < IResource > ( ) ; for ( int i = 0 ; i < resources . length ; i ++ ) { IResource resource = resources [ i ] ; if ( resource . getType ( ) == IResource . FILE && isReadOnly ( resource ) ) readOnlyFiles . add ( resource ) ; } if ( readOnlyFiles . size ( ) == 0 ) return Status . OK_STATUS ; Map < IFile , Long > oldTimeStamps = createModificationStampMap ( readOnlyFiles ) ; IStatus status = ResourcesPlugin . getWorkspace ( ) . validateEdit ( readOnlyFiles . toArray ( new IFile [ readOnlyFiles . size ( ) ] ) , context ) ; if ( ! status . isOK ( ) ) return status ; IStatus modified = null ; Map < IFile , Long > newTimeStamps = createModificationStampMap ( readOnlyFiles ) ; for ( Iterator < IFile > iter = oldTimeStamps . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { IFile file = iter . next ( ) ; if ( ! oldTimeStamps . get ( file ) . equals ( newTimeStamps . get ( file ) ) ) modified = addModified ( modified , file ) ; } if ( modified != null ) return modified ; return Status . OK_STATUS ; } 
public String nextTo ( char delimiter ) throws JSONException { StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c == '|n' || c == '|r' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } } 
public static final void copy ( final InputStream pInputStream , final OutputStream pOutputStream , final int pByteLimit ) throws IOException { if ( pByteLimit == StreamUtils . END_OF_STREAM ) { final byte [ ] buf = new byte [ StreamUtils . IO_BUFFER_SIZE ] ; int read ; while ( ( read = pInputStream . read ( buf ) ) != StreamUtils . END_OF_STREAM ) { pOutputStream . write ( buf , 0 , read ) ; } } else { final byte [ ] buf = new byte [ StreamUtils . IO_BUFFER_SIZE ] ; final int bufferReadLimit = Math . min ( pByteLimit , StreamUtils . IO_BUFFER_SIZE ) ; long pBytesLeftToRead = pByteLimit ; int read ; while ( ( read = pInputStream . read ( buf , 0 , bufferReadLimit ) ) != StreamUtils . END_OF_STREAM ) { if ( pBytesLeftToRead > read ) { pOutputStream . write ( buf , 0 , read ) ; pBytesLeftToRead -= read ; } else { pOutputStream . write ( buf , 0 , ( int ) pBytesLeftToRead ) ; break ; } } } pOutputStream . flush ( ) ; } 
public V setValue ( V value ) { if ( value == null ) throw new NullPointerException ( ) ; V v = super . setValue ( value ) ; ConcurrentHashMap . this . put ( getKey ( ) , value ) ; return v ; } 
private final void pingIpAddr ( ) { try { String ipAddress = "74.125.47.104" ; Process p = Runtime . getRuntime ( ) . exec ( "ping--c-1-" + ipAddress ) ; int status = p . waitFor ( ) ; if ( status == 0 ) { mPingIpAddrResult = "Pass" ; } else { mPingIpAddrResult = "Fail:-IP-addr-not-reachable" ; } } catch ( IOException e ) { mPingIpAddrResult = "Fail:-IOException" ; } catch ( InterruptedException e ) { mPingIpAddrResult = "Fail:-InterruptedException" ; } } 
public synchronized List < IndexCommit > getSnapshots ( ) { return new ArrayList < > ( indexCommits . values ( ) ) ; } 
public void dump ( PrintStream os , ResultFormatter < R > formatter ) { for ( Entry < String , Map < CallStringSerialization , Map < Integer , R >>> miEntry : serializedResults . entrySet ( ) ) { os . println ( miEntry . getKey ( ) ) ; for ( Entry < CallStringSerialization , Map < Integer , R >> csEntry : miEntry . getValue ( ) . entrySet ( ) ) { os . println ( "-" + csEntry . getKey ( ) . toString ( ) ) ; for ( Entry < Integer , R > posEntry : csEntry . getValue ( ) . entrySet ( ) ) { String rStr ; if ( formatter != null ) { rStr = formatter . format ( miEntry . getKey ( ) , csEntry . getKey ( ) , posEntry . getKey ( ) , posEntry . getValue ( ) ) ; } else { rStr = "" + posEntry . getValue ( ) ; } os . println ( String . format ( "-%-6d:-%s" , posEntry . getKey ( ) , rStr ) ) ; } } } } 
public static final boolean isChildrenSelectable ( Map map ) { Boolean bool = ( Boolean ) map . get ( CHILDRENSELECTABLE ) ; if ( bool != null ) return bool . booleanValue ( ) ; return true ; } 
@ Override public int read ( char [ ] cbuf , int off , int len ) { buf . get ( cbuf , off , len ) ; return len ; } 
public final boolean isFilterBitmap ( ) { return ( getFlags ( ) & FILTER_BITMAP_FLAG ) != 0 ; } 
public float getTabbedSpan ( float x , TabExpander e ) { checkPainter ( ) ; expander = e ; this . x = ( int ) x ; int p0 = getStartOffset ( ) ; int p1 = getEndOffset ( ) ; float width = painter . getSpan ( this , p0 , p1 , expander , x ) ; return width ; } 
public static Perl5Matcher getMatcher ( ) { return localMatcher . get ( ) ; } 
private void sendInterrupt ( ) { messageSent . V ( ) ; } 
public static String getFirstAttributeValue ( Map attrMap , String key ) { String retValue = null ; if ( ( attrMap != null ) && ! attrMap . isEmpty ( ) ) { List valueList = ( List ) attrMap . get ( key ) ; if ( ( valueList != null ) && ! valueList . isEmpty ( ) ) { retValue = ( String ) valueList . iterator ( ) . next ( ) ; } } return retValue ; } 
public String getStringProperty ( String name , String def ) throws ConfigException { String [ ] path = name . split ( "|." ) ; for ( String elementName : path ) { NodeList list = xmlNode . getElementsByTagName ( elementName ) ; if ( list . item ( 0 ) == null ) { throw new ConfigException ( "Path-element-'" + elementName + "'-from-'" + name + "'-was-not-found." ) ; } if ( list . item ( 0 ) . getNodeName ( ) . equals ( path [ path . length - 1 ] ) ) { return list . item ( 0 ) . getTextContent ( ) ; } } return def ; } 
public static void sortSelectItems ( List < SelectItem > items ) { Collections . sort ( items , selectItemComparator ) ; } 
public boolean isCommand ( String aString ) { return validCommands . containsKey ( aString ) ; } 
public int minInsertionsForPalindrome ( String str ) { int x = _minInsertionsForPalindrome ( str . toCharArray ( ) , 0 , str . length ( ) - 1 ) ; System . out . printf ( "Min-insertions-for-a-palindrome-=-%d-" , x ) ; return x ; } 
public boolean isEmpty ( ) { return delegate . isEmpty ( ) ; } 
public void register ( Region region , String prefix ) { if ( region == null || prefix == null ) { throw new IllegalArgumentException ( "Neither-Region-nor-Prefix-may-be-null" ) ; } List < LazyStyle > styles = styleMap . get ( region ) ; if ( styles == null ) { styles = new LinkedList < LazyStyle > ( ) ; styles . add ( new LazyStyle ( prefix ) ) ; styleMap . put ( region , styles ) ; } else { for ( LazyStyle s : styles ) { if ( prefix . equals ( s . prefix ) ) { return ; } } styles . add ( new LazyStyle ( prefix ) ) ; } registeredRegions . put ( region . getName ( ) , region ) ; } 
public static boolean close ( Closeable stream ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { return false ; } } return true ; } 
private FileStatus [ ] listStatusUnderPath ( FileSystem fs , Path p ) throws IOException { HiveConf hiveConf = new HiveConf ( job , FetchOperator . class ) ; boolean recursive = hiveConf . getBoolVar ( HiveConf . ConfVars . HADOOPMAPREDINPUTDIRRECURSIVE ) ; if ( ! recursive ) { return fs . listStatus ( p ) ; } List < FileStatus > results = new ArrayList < FileStatus > ( ) ; for ( FileStatus stat : fs . listStatus ( p ) ) { FileUtils . listStatusRecursively ( fs , stat , results ) ; } return results . toArray ( new FileStatus [ results . size ( ) ] ) ; } 
private String localize ( String key , String defaultValue ) { String result = defaultValue ; if ( bundle != null ) { try { result = bundle . getString ( key ) ; } catch ( MissingResourceException mre ) { } } return result ; } 
protected Connection createObject ( ) { try { Class . forName ( "org.hsqldb.jdbcDriver" ) ; return DriverManager . getConnection ( "jdbc:hsqldb:/hsql/test/test" , "sa" , "" ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return null ; } 
void stop ( String filename ) { try { stopEncoding ( ) ; new File ( mExportFilename ) . delete ( ) ; } catch ( IllegalStateException ex ) { Log . e ( TAG , "Illegal-state-exception-in-unload-settings" ) ; throw ex ; } catch ( RuntimeException ex ) { Log . e ( TAG , "Runtime-exception-in-unload-settings" ) ; throw ex ; } } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public synchronized void newPixels ( int x , int y , int w , int h , boolean framenotify ) { if ( animated == true ) { if ( fullbuffers ) newPixels ( ) ; else { ImageConsumer ic ; Vector list = ( Vector ) consumers . clone ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { ic = ( ImageConsumer ) list . elementAt ( i ) ; ic . setHints ( ImageConsumer . TOPDOWNLEFTRIGHT ) ; if ( props != null ) ic . setProperties ( props ) ; if ( pixeli != null ) { int [ ] pixelbuf = new int [ w * h ] ; for ( int row = y ; row < y + h ; row ++ ) System . arraycopy ( pixeli , row * scansize + x + offset , pixelbuf , 0 , w * h ) ; ic . setPixels ( x , y , w , h , cm , pixelbuf , 0 , w ) ; } else { byte [ ] pixelbuf = new byte [ w * h ] ; for ( int row = y ; row < y + h ; row ++ ) System . arraycopy ( pixelb , row * scansize + x + offset , pixelbuf , 0 , w * h ) ; ic . setPixels ( x , y , w , h , cm , pixelbuf , 0 , w ) ; } if ( framenotify == true ) ic . imageComplete ( ImageConsumer . SINGLEFRAME ) ; } } } } 
private String getAttribute ( Element e , String att ) { String val = e . getAttribute ( att ) ; if ( val . equals ( "" ) ) return "0" ; return val ; } 
public boolean checkEndsWith ( String str , String end ) { int endLen = end . length ( ) ; return str . regionMatches ( ! sensitive , str . length ( ) - endLen , end , 0 , endLen ) ; } 
public Leaf getBackLeaf ( BSPLine partition ) { return getLeaf ( root , partition , BSPLine . BACK ) ; } 
public static TQuotYear get ( Connect connect , int _from , int _to , String page_title ) { if ( _from < 0 || _to < 0 || _from > _to ) { System . out . println ( "Warning-(TQuotYear.get())::-entry-'" + page_title + "',-invalid-years:-from='" + _from + "',-to='" + _to + "'." ) ; return null ; } StringBuilder str_sql = new StringBuilder ( ) ; str_sql . append ( "SELECT-id-FROM-quot_year-WHERE-`from`=" ) ; str_sql . append ( _from ) ; str_sql . append ( "-AND-`to`=" ) ; str_sql . append ( _to ) ; TQuotYear result = null ; try { Statement s = connect . conn . createStatement ( ) ; try { ResultSet rs = s . executeQuery ( str_sql . toString ( ) ) ; try { if ( rs . next ( ) ) { int _id = rs . getInt ( "id" ) ; result = new TQuotYear ( _id , _from , _to ) ; } } finally { rs . close ( ) ; } } finally { s . close ( ) ; } } catch ( SQLException ex ) { System . out . println ( "SQLException-(TQuotYear.get())::-entry-'" + page_title + "',-years:-_from=" + _from + ";-_to=" + _to + ";-sql='" + ex . getMessage ( ) ) ; } return result ; } 
public int numNodes ( ) { return m_Tree . numNodes ( ) ; } 
public FileBackedObject ( Class < T > clazz ) throws IOException { this ( clazz , File . createTempFile ( "fileBackedObject" , ".ser" ) ) ; backingFile . deleteOnExit ( ) ; } 
public static ColorUIResource getControlDarkShadow ( ) { return getCurrentTheme ( ) . getControlDarkShadow ( ) ; } 
public ObjectHandle publish ( Object o , Class < ? > iface ) { if ( ! iface . isInterface ( ) ) throw new IllegalAccessError ( "Only-objects-that-implement-interfaces-can-be-exported" ) ; if ( ! iface . isInstance ( o ) ) throw new IllegalArgumentException ( "The-object-should-implement-the-interface" ) ; publishedInterfaces . put ( iface , o ) ; exportedInterfaces . add ( iface ) ; return createHandle ( o , iface ) ; } 
public VarSet intersection ( VarSet c ) { return Utils . defaultIntersection ( this , c ) ; } 
public static Image getPluginImage ( String symbolicName , String path ) { try { URL url = getPluginImageURL ( symbolicName , path ) ; if ( url != null ) { return getPluginImageFromUrl ( url ) ; } } catch ( Throwable e ) { } return null ; } 
public void writeString ( String headerName ) throws IOException { byte [ ] bytes = headerName . getBytes ( "UTF-8" ) ; writeInt ( bytes . length , PREFIX_8_BITS , 0 ) ; out . write ( bytes ) ; } 
public final int getAndSet ( int i , int newValue ) { long offset = checkedByteOffset ( i ) ; while ( true ) { int current = getRaw ( offset ) ; if ( compareAndSetRaw ( offset , current , newValue ) ) return current ; } } 
public void marshal ( org . xml . sax . ContentHandler handler ) throws java . io . IOException , org . exolab . castor . xml . MarshalException , org . exolab . castor . xml . ValidationException { Marshaller . marshal ( this , handler ) ; } 
public void printStackTrace ( ) { super . printStackTrace ( ) ; if ( cause != null ) { cause . printStackTrace ( ) ; } } 
public Array2DRowFieldMatrix < T > subtract ( final Array2DRowFieldMatrix < T > m ) throws IllegalArgumentException { checkSubtractionCompatible ( m ) ; final int rowCount = getRowDimension ( ) ; final int columnCount = getColumnDimension ( ) ; final T [ ] [ ] outData = buildArray ( getField ( ) , rowCount , columnCount ) ; for ( int row = 0 ; row < rowCount ; row ++ ) { final T [ ] dataRow = data [ row ] ; final T [ ] mRow = m . data [ row ] ; final T [ ] outDataRow = outData [ row ] ; for ( int col = 0 ; col < columnCount ; col ++ ) { outDataRow [ col ] = dataRow [ col ] . subtract ( mRow [ col ] ) ; } } return new Array2DRowFieldMatrix < T > ( outData , false ) ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public Future < IndexDocumentsResult > indexDocumentsAsync ( final IndexDocumentsRequest indexDocumentsRequest ) throws AmazonServiceException , AmazonClientException { return executorService . submit ( new Callable < IndexDocumentsResult > ( ) { public IndexDocumentsResult call ( ) throws Exception { return indexDocuments ( indexDocumentsRequest ) ; } } ) ; } 
private String getCorrectStackTrace ( String stackTrace ) { if ( null == stackTrace ) { return null ; } else { int index = stackTrace . indexOf ( "-at" ) ; if ( index >= 0 ) { return stackTrace . substring ( index + 1 ) ; } else { return stackTrace ; } } } 
public static boolean isGnomeAbility ( String ability ) { return AbilityModuleManager . gnomeabilities . contains ( ability ) ; } 
public final synchronized int lastIndexOf ( Object elem , int index ) { for ( int i = index ; i >= 0 ; i -- ) { if ( elem . equals ( elementData [ i ] ) ) { return i ; } } return - 1 ; } 
private void sourceAdd ( char c ) { if ( sourceTop == sourceBuffer . length ) { increaseSourceCapacity ( sourceTop + 1 ) ; } sourceBuffer [ sourceTop ] = c ; ++ sourceTop ; } 
private void loadProperties ( String fname ) { try { _properties = new Properties ( ) ; FileInputStream in = new FileInputStream ( fname ) ; _properties . load ( in ) ; } catch ( Exception e ) { String msg = "Unable-to-read-properties-file:-" + fname ; _logger . error ( msg , e ) ; throw new TSSException ( msg , e ) ; } } 
public void clearSelection ( ) { getSelectionModel ( ) . clearSelection ( ) ; } 
protected InputStream getStreamFromDrawable ( String imageUri , Object extra ) { String drawableIdString = Scheme . DRAWABLE . crop ( imageUri ) ; int drawableId = Integer . parseInt ( drawableIdString ) ; return context . getResources ( ) . openRawResource ( drawableId ) ; } 
public void resetInteractingEntity ( ) { this . interactingEntity = null ; this . updateFlags . flag ( UpdateFlag . FACE_ENTITY ) ; } 
public static void wrapAndRethrow ( Exception e ) throws IOException { if ( e instanceof InterruptedException ) { Thread . currentThread ( ) . interrupt ( ) ; } else if ( e instanceof IOException ) { throw ( IOException ) e ; } else if ( e instanceof RuntimeException ) { throw ( RuntimeException ) e ; } else { throw new KijiIOException ( e ) ; } } 
public int getNumFreePE ( ) { int free = 0 ; Machine obj = null ; Iterator < Machine > it = super . iterator ( ) ; while ( it . hasNext ( ) ) { obj = it . next ( ) ; free += obj . getNumFreePE ( ) ; } return free ; } 
public Deleter getDeleter ( String className , int classVersion , String fieldName ) { return deleters . get ( new Key ( className , classVersion , fieldName ) ) ; } 
@ Override public boolean handle ( T event , C context ) { boolean cancelled = false ; for ( EventHandler < T , C > handler : handlers ) { if ( cancelled && ! handler . getMeta ( ) . ignoreCancel ( ) ) { continue ; } if ( ! handler . handle ( event , context ) ) { cancelled = true ; } } return cancelled ; } 
public InputStream openRawResource ( int id , TypedValue value ) throws NotFoundException { getValue ( id , value , true ) ; try { return mAssets . openNonAsset ( value . assetCookie , value . string . toString ( ) , AssetManager . ACCESS_STREAMING ) ; } catch ( Exception e ) { NotFoundException rnf = new NotFoundException ( "File-" + value . string . toString ( ) + "-from-drawable-resource-ID-#0x" + Integer . toHexString ( id ) ) ; rnf . initCause ( e ) ; throw rnf ; } } 
public boolean offer ( E e ) { if ( e == null ) throw new NullPointerException ( ) ; final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { if ( count == items . length ) return false ; else { enqueue ( e ) ; return true ; } } finally { lock . unlock ( ) ; } } 
public int executeUpdate ( String sql , int autoGeneratedKeys ) throws SQLException { throw Util . notSupported ( ) ; } 
private JTextField getQuestionTextField ( ) { if ( questionTextField == null ) { questionTextField = new JTextField ( ) ; questionTextField . setBounds ( new Rectangle ( 120 , 59 , 300 , 20 ) ) ; } return questionTextField ; } 
protected InputStream getInputStream ( ) throws IOException { return new FileInputStream ( file ) ; } 
public static void nextGeneration ( ) { nextGrid = new boolean [ size ] [ size ] ; for ( int i = 0 ; i < cores ; ++ i ) threadPool . execute ( tasks [ i ] ) ; try { barrier . await ( ) ; barrier . reset ( ) ; acceptNextGeneration ( ) ; } catch ( InterruptedException e ) { System . out . println ( "Error:-" + e . getMessage ( ) ) ; } catch ( BrokenBarrierException e ) { System . out . println ( "Error:-" + e . getMessage ( ) ) ; } } 
public void clear ( ) { final Object [ ] items = this . items ; final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { int k = count ; if ( k > 0 ) { final int putIndex = this . putIndex ; int i = takeIndex ; do { items [ i ] = null ; } while ( ( i = inc ( i ) ) != putIndex ) ; takeIndex = putIndex ; count = 0 ; if ( itrs != null ) itrs . queueIsEmpty ( ) ; for ( ; k > 0 && lock . hasWaiters ( notFull ) ; k -- ) notFull . signal ( ) ; } } finally { lock . unlock ( ) ; } } 
public void setData ( ResultSet rs ) throws SQLException { this . type = rs . getInt ( "mht.type" ) ; this . fieldName = rs . getString ( "mht.field_name" ) ; this . modDate = rs . getString ( "modDate" ) ; this . userName = rs . getString ( "mut.username" ) ; this . newValue = rs . getString ( "mht.new_value" ) ; this . oldValue = rs . getString ( "mht.old_value" ) ; } 
synchronized String [ ] getContainerNames ( ) { actionCode = GET_CONTAINER_NAMES_ACTION ; try { return ( String [ ] ) AccessController . doPrivileged ( this ) ; } catch ( PrivilegedActionException pae ) { return null ; } } 
public void linkSize ( Component ... components ) { linkSize ( SwingConstants . HORIZONTAL , components ) ; linkSize ( SwingConstants . VERTICAL , components ) ; } 
boolean analyzeMarkup ( String xml , List < XmlRegion > positions ) { int newPos = this . offset ; boolean result = false ; if ( xml . charAt ( newPos ) == '<' ) { if ( newPos + 1 < xml . length ( ) && xml . charAt ( newPos + 1 ) == '!' ) return false ; char c = '!' ; while ( newPos < xml . length ( ) && ( c = xml . charAt ( newPos ) ) != '>' && ! Character . isWhitespace ( c ) ) newPos ++ ; if ( c == '>' ) newPos ++ ; positions . add ( new XmlRegion ( XmlRegionType . MARKUP , this . offset , newPos ) ) ; this . offset = newPos ; result = true ; } else if ( xml . charAt ( newPos ) == '/' && ++ newPos < xml . length ( ) && xml . charAt ( newPos ) == '>' ) { positions . add ( new XmlRegion ( XmlRegionType . MARKUP , this . offset , ++ newPos ) ) ; this . offset = newPos ; result = true ; } else if ( xml . charAt ( newPos ) == '>' ) { positions . add ( new XmlRegion ( XmlRegionType . MARKUP , this . offset , ++ newPos ) ) ; this . offset = newPos ; result = true ; } return result ; } 
public float getFloat ( String property , float def ) { Object value = super . get ( property ) ; if ( value == null ) { return def ; } if ( value instanceof Float ) { return ( ( Float ) value ) . floatValue ( ) ; } throw new TypeException ( property , value , "float" ) ; } 
public void addFeature ( String feature ) { if ( feature == null ) throw new IllegalArgumentException ( "Feature-to-add-cannot-be-null" ) ; features . add ( feature ) ; } 
public void removeAttribute ( String name ) { logConfig . remove ( name ) ; } 
public EndpointStudyRecord . ScientificPart . ECBACTOX . ANALYTMETHODDETAILS . Set createEndpointStudyRecordScientificPartECBACTOXANALYTMETHODDETAILSSet ( ) { return new EndpointStudyRecord . ScientificPart . ECBACTOX . ANALYTMETHODDETAILS . Set ( ) ; } 
public Iterable < KmlGroundOverlay > getGroundOverlays ( ) { return mGroundOverlays . keySet ( ) ; } 
public void quiesce ( ) { final String methodName = "quiesce" ; this . quiescing = true ; synchronized ( spaceAvailable ) { log . fine ( className , methodName , "711" ) ; spaceAvailable . notifyAll ( ) ; } } 
public static void main ( String [ ] args ) throws Exception { Environment env = new Environment ( ) ; env . getParameters ( ) . setString ( "nat_search_policy" , "never" ) ; try { int bindport = Integer . parseInt ( args [ 0 ] ) ; InetAddress bootaddr = InetAddress . getByName ( args [ 1 ] ) ; int bootport = Integer . parseInt ( args [ 2 ] ) ; InetSocketAddress bootaddress = new InetSocketAddress ( bootaddr , bootport ) ; DistTutorial dt = new DistTutorial ( bindport , bootaddress , env ) ; } catch ( Exception e ) { System . out . println ( "Usage:" ) ; System . out . println ( "java-[-cp-FreePastry-<version>.jar]-rice.tutorial.lesson1.DistTutorial-localbindport-bootIP-bootPort" ) ; System . out . println ( "example-java-rice.tutorial.DistTutorial-9001-pokey.cs.almamater.edu-9001" ) ; throw e ; } } 
public Object getDecodedObject ( BerInputStream in ) throws IOException { byte [ ] bytesEncoded = new byte [ in . offset - in . tagOffset ] ; System . arraycopy ( in . buffer , in . tagOffset , bytesEncoded , 0 , bytesEncoded . length ) ; return bytesEncoded ; } 
protected void layoutMajorAxis ( int targetSpan , int axis , int [ ] offsets , int [ ] spans ) { int col = 0 ; int ncells = getViewCount ( ) ; for ( int cell = 0 ; cell < ncells ; cell ++ ) { View cv = getView ( cell ) ; if ( skipComments && ! ( cv instanceof CellView ) ) { continue ; } for ( ; isFilled ( col ) ; col ++ ) ; int colSpan = getColumnsOccupied ( cv ) ; spans [ cell ] = columnSpans [ col ] ; offsets [ cell ] = columnOffsets [ col ] ; if ( colSpan > 1 ) { int n = columnSpans . length ; for ( int j = 1 ; j < colSpan ; j ++ ) { if ( ( col + j ) < n ) { spans [ cell ] += columnSpans [ col + j ] ; spans [ cell ] += cellSpacing ; } } col += colSpan - 1 ; } col ++ ; } } 
private void writeHex ( int i ) throws IOException { int cursor = 8 ; do { hex [ -- cursor ] = HEX_DIGITS [ i & 0xf ] ; } while ( ( i >>>= 4 ) != 0 ) ; socketOut . write ( hex , cursor , hex . length - cursor ) ; } 
private int findSplitIndex ( String value , int splitTreshold , String lineSeparator ) { String valueMax = value . substring ( 0 , splitTreshold ) ; int index = valueMax . lastIndexOf ( '-' ) ; if ( ( index < 0 ) || ( index > splitTreshold ) ) { index = value . lastIndexOf ( lineSeparator ) ; if ( ( index < 0 ) || ( index > splitTreshold ) ) { index = splitTreshold ; } } return index ; } 
public com . google . protobuf . ByteString getJobIdBytes ( ) { java . lang . Object ref = jobId_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; jobId_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public AdamsIntegrator ( final String name , final int nSteps , final int order , final double minStep , final double maxStep , final double [ ] vecAbsoluteTolerance , final double [ ] vecRelativeTolerance ) throws IllegalArgumentException { super ( name , nSteps , order , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; transformer = AdamsNordsieckTransformer . getInstance ( nSteps ) ; } 
static URL getURL ( URL base , String cssString ) { if ( cssString == null ) { return null ; } if ( cssString . startsWith ( "url(" ) && cssString . endsWith ( ")" ) ) { cssString = cssString . substring ( 4 , cssString . length ( ) - 1 ) ; } try { URL url = new URL ( cssString ) ; if ( url != null ) { return url ; } } catch ( MalformedURLException mue ) { } if ( base != null ) { try { URL url = new URL ( base , cssString ) ; return url ; } catch ( MalformedURLException muee ) { } } return null ; } 
public final void display ( ) { if ( site != null ) { site . swap ( this ) ; } } 
private void waitForCleanupCallableToRun ( ) { try { executorService . submit ( new Runnable ( ) { @ Override public void run ( ) { } } ) . get ( ) ; } catch ( Exception e ) { throw new AssertionError ( ) ; } } 
public int getLocalPort ( ) { if ( isClosed ( ) ) return - 1 ; try { return getImpl ( ) . getLocalPort ( ) ; } catch ( Exception e ) { return 0 ; } } 
public void addCustomDevOption ( String optionName , DevOptionHandler optionHandler ) { mCustomDevOptions . put ( optionName , optionHandler ) ; } 
public void printf ( String format , Object ... args ) { out . printf ( US_LOCALE , format , args ) ; out . flush ( ) ; } 
private void readObject ( ObjectInputStream s ) throws ClassNotFoundException , IOException , HeadlessException { s . defaultReadObject ( ) ; for ( int i = 0 ; i < menus . size ( ) ; i ++ ) { Menu m = ( Menu ) menus . elementAt ( i ) ; m . parent = this ; } } 
public static Index toIndex ( boolean indexed , boolean analyzed ) { return toIndex ( indexed , analyzed , false ) ; } 
protected List < String > getMatchingKeys ( List messagePropertyList , String [ ] keysToMatch ) { List < String > matchingKeys = new ArrayList < String > ( ) ; if ( messagePropertyList != null && messagePropertyList . size ( ) > 0 ) { for ( Object keyAsObject : messagePropertyList ) { String key = ( String ) keyAsObject ; if ( matchesGroup ( key , keysToMatch ) ) { matchingKeys . add ( key ) ; } } } return matchingKeys ; } 
@ XmlElementDecl ( namespace = "http://www.dicarta.com/contracts/services/contract" , name = "internal-contact-last-name" , scope = SearchData . class ) public JAXBElement < StringSearchCriteria > createSearchDataInternalContactLastName ( StringSearchCriteria value ) { return new JAXBElement < StringSearchCriteria > ( _SearchDataInternalContactLastName_QNAME , StringSearchCriteria . class , SearchData . class , value ) ; } 
public static boolean isBlank ( String str ) { return ( str == null || str . trim ( ) . length ( ) == 0 ) ; } 
public double getCenterX ( ) { return getX ( ) + getWidth ( ) / 2.0 ; } 
public String nextCDATA ( ) throws JSONException { char c ; int i ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( end ( ) ) { throw syntaxError ( "Unclosed-CDATA" ) ; } sb . append ( c ) ; i = sb . length ( ) - 3 ; if ( i >= 0 && sb . charAt ( i ) == ']' && sb . charAt ( i + 1 ) == ']' && sb . charAt ( i + 2 ) == '>' ) { sb . setLength ( i ) ; return sb . toString ( ) ; } } } 
public static String removeWhitespace ( String inputString ) { StringBuilder sb = new StringBuilder ( ) ; char [ ] chars = inputString . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( Character . isWhitespace ( c ) ) { continue ; } sb . append ( c ) ; } return sb . toString ( ) ; } 
public void setTickMarksVisible ( boolean flag ) { if ( flag != this . tickMarksVisible ) { this . tickMarksVisible = flag ; fireChangeEvent ( ) ; } } 
public final void setFeatureDrawable ( int featureId , Drawable drawable ) { getWindow ( ) . setFeatureDrawable ( featureId , drawable ) ; } 
public static String printStoreWiseDistribution ( Cluster cluster , List < StoreDefinition > storeDefs , List < ByteArray > keys ) { StringBuilder builder = new StringBuilder ( ) ; for ( StoreDefinition def : storeDefs ) { HashMap < Integer , Double > storeDistribution = generateDistribution ( cluster , def , keys ) ; builder . append ( "-For-Store-'" + def . getName ( ) + "'-" ) ; for ( int nodeId : storeDistribution . keySet ( ) ) { builder . append ( "Node-" + nodeId + "---" + formatter . format ( storeDistribution . get ( nodeId ) ) + "-" ) ; } builder . append ( "Std-dev---" + getStdDeviation ( storeDistribution ) + "-" ) ; } return builder . toString ( ) ; } 
public boolean onKeyUp ( int keyCode , KeyEvent event ) { if ( event . getKeyCode ( ) == KeyEvent . KEYCODE_BACK && event . isTracking ( ) && ! event . isCanceled ( ) ) { return handleBack ( true ) ; } return doMovementKey ( keyCode , event , MOVEMENT_UP ) ; } 
public void clearFocus ( ) { if ( DBG ) { System . out . println ( this + "-clearFocus()" ) ; } if ( ( mPrivateFlags & FOCUSED ) != 0 ) { mPrivateFlags &= ~ FOCUSED ; if ( mParent != null ) { mParent . clearChildFocus ( this ) ; } onFocusChanged ( false , 0 , null ) ; refreshDrawableState ( ) ; } } 
public Transferable getTransferable ( ) { return getDropTargetContext ( ) . getTransferable ( ) ; } 
public byte [ ] getBody ( ) throws AuthFailureError { Map < String , String > params = getParams ( ) ; if ( params != null && params . size ( ) > 0 ) { return encodeParameters ( params , getParamsEncoding ( ) ) ; } return null ; } 
synchronized public void removeComponent ( Entity e , Class < ? extends Component > type ) { Component c = this . getComponent ( e , type ) ; if ( c == null ) { return ; } ObjectMap < Entity , ? extends Component > store = componentStores . get ( type ) ; store . remove ( e ) ; PooledLinkedList < ? extends Component > components = this . entityComponents . get ( e ) ; Component component = null ; for ( components . iter ( ) ; ( component = components . next ( ) ) != null ; ) { if ( component . getClass ( ) . equals ( type ) ) { components . remove ( ) ; } } ComponentManager . getInstance ( ) . free ( c ) ; } 
@ Override public void callSessionMergeFailed ( IImsCallSession session , ImsReasonInfo reasonInfo ) { if ( mListener != null ) { mListener . callSessionMergeFailed ( ImsCallSession . this , reasonInfo ) ; } } 
private void validateQuery ( String query ) { if ( query == null ) { return ; } int UNSIGNED_SHORT_MAX = 0xffff ; if ( query . length ( ) % 2 == 1 ) { throw new IllegalArgumentException ( "query-size-is-invalid.-query=" + query ) ; } if ( query . length ( ) / 2 > UNSIGNED_SHORT_MAX ) { throw new IllegalArgumentException ( "query-size-is-too-large.-len=" + query . length ( ) ) ; } query = query . toLowerCase ( Locale . ROOT ) ; char [ ] chars = query . toCharArray ( ) ; for ( char c : chars ) { if ( ! ( ( c >= '0' && c <= '9' ) || ( c >= 'a' && c <= 'f' ) ) ) { throw new IllegalArgumentException ( "query-should-be-hex-string.-query=" + query ) ; } } } 
public void displayError ( final String title , final String message , final String button , final boolean exit ) { final CordovaActivity me = this ; me . runOnUiThread ( new Runnable ( ) { public void run ( ) { try { AlertDialog . Builder dlg = new AlertDialog . Builder ( me ) ; dlg . setMessage ( message ) ; dlg . setTitle ( title ) ; dlg . setCancelable ( false ) ; dlg . setPositiveButton ( button , new AlertDialog . OnClickListener ( ) { public void onClick ( DialogInterface dialog , int which ) { dialog . dismiss ( ) ; if ( exit ) { me . endActivity ( ) ; } } } ) ; dlg . create ( ) ; dlg . show ( ) ; } catch ( Exception e ) { finish ( ) ; } } } ) ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public static Color findColorRGB ( final String token ) { if ( token == null ) { return null ; } final Matcher tmpMatcher = RGB_COLOR . matcher ( token ) ; final boolean tmpFound = tmpMatcher . find ( ) ; if ( ! tmpFound ) { return null ; } final int tmpRed = Integer . parseInt ( tmpMatcher . group ( 1 ) ) ; final int tmpGreen = Integer . parseInt ( tmpMatcher . group ( 2 ) ) ; final int tmpBlue = Integer . parseInt ( tmpMatcher . group ( 3 ) ) ; final Color tmpColor = new Color ( tmpRed , tmpGreen , tmpBlue ) ; return tmpColor ; } 
public Accessible getAccessibleAt ( int row , int column ) { TableColumn aColumn = headerModel . getColumn ( column ) ; TableCellRenderer renderer = aColumn . getHeaderRenderer ( ) ; if ( renderer == null ) { renderer = header . getDefaultRenderer ( ) ; } Component component = renderer . getTableCellRendererComponent ( header . getTable ( ) , aColumn . getHeaderValue ( ) , false , false , - 1 , column ) ; return new AccessibleJTableHeaderCell ( row , column , JTable . this . getTableHeader ( ) , component ) ; } 
@ Deprecated protected String getPostParamsEncoding ( ) { return getParamsEncoding ( ) ; } 
private void storeSendDetails ( final String topic , final MqttMessage msg , final IMqttDeliveryToken messageToken , final String invocationContext , final String activityToken ) { savedTopics . put ( messageToken , topic ) ; savedSentMessages . put ( messageToken , msg ) ; savedActivityTokens . put ( messageToken , activityToken ) ; savedInvocationContexts . put ( messageToken , invocationContext ) ; } 
protected void setup ( final Set < MetricAccumulationLevel > accumulationLevels , final List < SAMReadGroupRecord > samRgRecords ) { outputOrderedDistributors = new ArrayList < Distributor > ( 4 ) ; if ( accumulationLevels . contains ( MetricAccumulationLevel . ALL_READS ) ) { outputOrderedDistributors . add ( new AllReadsDistributor ( samRgRecords ) ) ; } if ( accumulationLevels . contains ( MetricAccumulationLevel . SAMPLE ) ) { outputOrderedDistributors . add ( new SampleDistributor ( samRgRecords ) ) ; } if ( accumulationLevels . contains ( MetricAccumulationLevel . LIBRARY ) ) { outputOrderedDistributors . add ( new LibraryDistributor ( samRgRecords ) ) ; } if ( accumulationLevels . contains ( MetricAccumulationLevel . READ_GROUP ) ) { outputOrderedDistributors . add ( new ReadGroupCollector ( samRgRecords ) ) ; } } 
static void checkMethodIdentifier ( int version , final String name , final String msg ) { if ( name == null || name . length ( ) == 0 ) { throw new IllegalArgumentException ( "Invalid-" + msg + "-(must-not-be-null-or-empty)" ) ; } if ( ( version & 0xFFFF ) >= Opcodes . V1_5 ) { for ( int i = 0 ; i < name . length ( ) ; ++ i ) { if ( ".;[/<>" . indexOf ( name . charAt ( i ) ) != - 1 ) { throw new IllegalArgumentException ( "Invalid-" + msg + "-(must-be-a-valid-unqualified-name):-" + name ) ; } } return ; } if ( ! Character . isJavaIdentifierStart ( name . charAt ( 0 ) ) ) { throw new IllegalArgumentException ( "Invalid-" + msg + "-(must-be-a-'<init>',-'<clinit>'-or-a-valid-Java-identifier):-" + name ) ; } for ( int i = 1 ; i < name . length ( ) ; ++ i ) { if ( ! Character . isJavaIdentifierPart ( name . charAt ( i ) ) ) { throw new IllegalArgumentException ( "Invalid-" + msg + "-(must-be-'<init>'-or-'<clinit>'-or-a-valid-Java-identifier):-" + name ) ; } } } 
public Object [ ] lookupCflow ( String name ) { if ( cflow == null ) cflow = new Hashtable ( ) ; return ( Object [ ] ) cflow . get ( name ) ; } 
static Integer getCommonClassId ( Class < ? > clazz ) { HashMap < Class < ? > , Integer > map = COMMON_CLASSES_MAP ; if ( map . size ( ) == 0 ) { for ( int i = 0 , size = COMMON_CLASSES . length ; i < size ; i ++ ) { COMMON_CLASSES_MAP . put ( COMMON_CLASSES [ i ] , i ) ; } } return map . get ( clazz ) ; } 
public synchronized boolean isEmpty ( ) { return view . isEmpty ( ) && constraints . isEmpty ( ) ; } 
public void testGetLastMillisecond ( ) { Locale saved = Locale . getDefault ( ) ; Locale . setDefault ( Locale . UK ) ; TimeZone savedZone = TimeZone . getDefault ( ) ; TimeZone . setDefault ( TimeZone . getTimeZone ( "Europe/London" ) ) ; Week w = new Week ( 31 , 1970 ) ; assertEquals ( 18485999999L , w . getLastMillisecond ( ) ) ; Locale . setDefault ( saved ) ; TimeZone . setDefault ( savedZone ) ; } 
@ SuppressWarnings ( "unchecked" ) private T [ ] buildArray ( final int length ) { return ( T [ ] ) Array . newInstance ( field . getZero ( ) . getClass ( ) , length ) ; } 
public Object getWeight ( Node child ) { for ( Object weight : __children . keySet ( ) ) { Node c = getChild ( weight ) ; if ( child . equals ( getChild ( weight ) ) ) return weight ; } return null ; } 
public static String constantToHuman ( Constant cst ) { int type = constantToValueType ( cst ) ; if ( type == VALUE_NULL ) { return "null" ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( cst . typeName ( ) ) ; sb . append ( '-' ) ; sb . append ( cst . toHuman ( ) ) ; return sb . toString ( ) ; } 
public void copyFromLocalFile ( boolean delSrc , Path src , Path dst ) throws IOException { fs . copyFromLocalFile ( delSrc , src , dst ) ; } 
private OperandStack stack ( ) { return frame . getStack ( ) ; } 
public void dump ( PrintStream out ) { out . println ( "PEOldMSHeader:" ) ; out . println ( "e_cblp:-" + e_cblp + "-//-Bytes-on-last-page-of-file-//-2" ) ; out . println ( "e_cp:-" + e_cp + "-//-Pages-in-file-//-4" ) ; out . println ( "e_crlc:-" + e_crlc + "-//-Relocations-//-6" ) ; out . println ( "e_cparhdr:-" + e_cparhdr + "-//-Size-of-header-in-paragraphs-//-8" ) ; out . println ( "e_minalloc:-" + e_minalloc + "-//-Minimum-extra-paragraphs-needed-//-A" ) ; out . println ( "e_maxalloc:-" + e_maxalloc + "-//-Maximum-extra-paragraphs-needed-//-C" ) ; out . println ( "e_ss:-" + e_ss + "-//-Initial-(relative)-SS-value-//-E" ) ; out . println ( "e_sp:-" + e_sp + "-//-Initial-SP-value-//-10" ) ; out . println ( "e_csum:-" + e_csum + "-//-Checksum-//-12" ) ; out . println ( "e_ip:-" + e_ip + "-//-Initial-IP-value-//-14" ) ; out . println ( "e_cs:-" + e_cs + "-//-Initial-(relative)-CS-value-//-16" ) ; out . println ( "e_lfarlc:-" + e_lfarlc + "-//-File-address-of-relocation-table-//-18" ) ; out . println ( "e_ovno:-" + e_ovno + "-//-Overlay-number-//-1A" ) ; out . println ( "e_oemid:-" + e_oemid + "-//-OEM-identifier-(for-e_oeminfo)-//-24" ) ; out . println ( "e_oeminfo:-" + e_oeminfo + "-//-OEM-information;-e_oemid-specific-//-26" ) ; out . println ( "e_lfanew:-" + e_lfanew + "-//-File-address-of-new-exe-header-//-3C" ) ; } 
protected Tuple readNext ( ) throws NoSuchElementException , TransactionAbortedException , DbException { if ( it != null && it . hasNext ( ) ) { return it . next ( ) ; } else return null ; } 
public int size ( ) { return mItems . size ( ) ; } 
boolean reclaimKey ( ReferenceEntry < K , V > entry , int hash ) { lock ( ) ; try { int newCount = count - 1 ; AtomicReferenceArray < ReferenceEntry < K , V >> table = this . table ; int index = hash & ( table . length ( ) - 1 ) ; ReferenceEntry < K , V > first = table . get ( index ) ; for ( ReferenceEntry < K , V > e = first ; e != null ; e = e . getNext ( ) ) { if ( e == entry ) { ++ modCount ; ReferenceEntry < K , V > newFirst = removeValueFromChain ( first , e , e . getKey ( ) , hash , e . getValueReference ( ) , RemovalCause . COLLECTED ) ; newCount = this . count - 1 ; table . set ( index , newFirst ) ; this . count = newCount ; return true ; } } return false ; } finally { unlock ( ) ; postWriteCleanup ( ) ; } } 
public final long getAndIncrement ( int i ) { return getAndAdd ( i , 1 ) ; } 
public static String right ( String str , int len ) { if ( str == null ) { return null ; } if ( len < 0 ) { return EMPTY ; } if ( str . length ( ) <= len ) { return str ; } return str . substring ( str . length ( ) - len ) ; } 
private void findLargestCells ( int widthMeasureSpec ) { boolean firstRow = true ; final int count = getChildCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final View child = getChildAt ( i ) ; if ( child . getVisibility ( ) == GONE ) { continue ; } if ( child instanceof TableRow ) { final TableRow row = ( TableRow ) child ; final ViewGroup . LayoutParams layoutParams = row . getLayoutParams ( ) ; layoutParams . height = LayoutParams . WRAP_CONTENT ; final int [ ] widths = row . getColumnsWidths ( widthMeasureSpec ) ; final int newLength = widths . length ; if ( firstRow ) { if ( mMaxWidths == null || mMaxWidths . length != newLength ) { mMaxWidths = new int [ newLength ] ; } System . arraycopy ( widths , 0 , mMaxWidths , 0 , newLength ) ; firstRow = false ; } else { int length = mMaxWidths . length ; final int difference = newLength - length ; if ( difference > 0 ) { final int [ ] oldMaxWidths = mMaxWidths ; mMaxWidths = new int [ newLength ] ; System . arraycopy ( oldMaxWidths , 0 , mMaxWidths , 0 , oldMaxWidths . length ) ; System . arraycopy ( widths , oldMaxWidths . length , mMaxWidths , oldMaxWidths . length , difference ) ; } final int [ ] maxWidths = mMaxWidths ; length = Math . min ( length , newLength ) ; for ( int j = 0 ; j < length ; j ++ ) { maxWidths [ j ] = Math . max ( maxWidths [ j ] , widths [ j ] ) ; } } } } } 
public static BidiFormatter getInstance ( boolean rtlContext ) { return new Builder ( rtlContext ) . build ( ) ; } 
protected void comment ( Element elem ) throws BadLocationException , IOException { AttributeSet as = elem . getAttributes ( ) ; if ( matchNameAttribute ( as , HTML . Tag . COMMENT ) ) { Object comment = as . getAttribute ( HTML . Attribute . COMMENT ) ; if ( comment instanceof String ) { writeComment ( ( String ) comment ) ; } else { writeComment ( null ) ; } } } 
@ Override synchronized public final SelectionKey keyFor ( Selector selector ) { for ( SelectionKey key : keyList ) { if ( key != null && key . selector ( ) == selector ) { return key ; } } return null ; } 
public synchronized XSObjectList getAnnotations ( ) { if ( fAnnotations != null ) { return fAnnotations ; } int totalAnnotations = 0 ; for ( int i = 0 ; i < fGrammarCount ; i ++ ) { totalAnnotations += fGrammarList [ i ] . fNumAnnotations ; } if ( totalAnnotations == 0 ) { fAnnotations = XSObjectListImpl . EMPTY_LIST ; return fAnnotations ; } XSAnnotationImpl [ ] annotations = new XSAnnotationImpl [ totalAnnotations ] ; int currPos = 0 ; for ( int i = 0 ; i < fGrammarCount ; i ++ ) { SchemaGrammar currGrammar = fGrammarList [ i ] ; if ( currGrammar . fNumAnnotations > 0 ) { System . arraycopy ( currGrammar . fAnnotations , 0 , annotations , currPos , currGrammar . fNumAnnotations ) ; currPos += currGrammar . fNumAnnotations ; } } fAnnotations = new XSObjectListImpl ( annotations , annotations . length ) ; return fAnnotations ; } 
private static Taxon removeTaxon ( Connection conn , DBHelper helper , int taxon_id ) throws BioRuntimeException { Taxon taxon = getTaxon ( conn , taxon_id ) ; try { Stack children = getChildrenOf ( conn , taxon ) ; while ( ! children . isEmpty ( ) ) try { Taxon child = ( Taxon ) children . pop ( ) ; setParent ( conn , child , child ) ; } catch ( BioRuntimeException exc ) { exc . printStackTrace ( ) ; } } catch ( BioException exc ) { exc . printStackTrace ( ) ; } try { Statement delete = conn . createStatement ( ) ; delete . executeUpdate ( "DELETE-FROM-taxon_name-WHERE-taxon_id-=-" + taxon_id ) ; delete . close ( ) ; delete = ( Statement ) conn . createStatement ( ) ; delete . executeUpdate ( "DELETE-FROM-bioentry-WHERE-taxon_id-=-" + taxon_id ) ; delete . close ( ) ; delete = ( Statement ) conn . createStatement ( ) ; delete . executeUpdate ( "DELETE-FROM-taxon-WHERE-taxon_id-=-" + taxon_id ) ; delete . close ( ) ; } catch ( SQLException exc ) { throw new BioRuntimeException ( "Could-not-delete-successfully" , exc ) ; } return taxon ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public static < T extends AbstractOrganizerObject > ArrayList < String > getParameterStringList ( T obj ) { Field [ ] fields = obj . getClass ( ) . getDeclaredFields ( ) ; ArrayList < String > parameters = new ArrayList < String > ( ) ; for ( Field f : fields ) { if ( f . getModifiers ( ) != Modifier . PRIVATE ) continue ; f . setAccessible ( true ) ; try { Object value = f . get ( obj ) ; if ( f . getName ( ) . equals ( "accepted" ) ) { continue ; } if ( value instanceof List < ? > ) { continue ; } else if ( value instanceof String ) { parameters . add ( f . getName ( ) + "=" + parseStringToHTTP ( ( String ) value ) ) ; } else if ( value instanceof Date ) { parameters . add ( f . getName ( ) + "=" + parseDateToNetDateTime ( ( Date ) value ) ) ; } else { parameters . add ( f . getName ( ) + "=" + value ) ; } } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } f . setAccessible ( false ) ; } return parameters ; } 
public void incrementBytesRead ( long newBytes ) { bytesRead . getAndAdd ( newBytes ) ; } 
public int getLength ( ) { return hbuf . size ( ) ; } 
String before ( List known , String version ) { if ( known . isEmpty ( ) ) { return null ; } String before = null ; for ( Iterator i = known . iterator ( ) ; i . hasNext ( ) ; ) { String test = ( String ) i . next ( ) ; if ( test . compareTo ( version ) < 0 ) { if ( ( before == null ) || ( before . compareTo ( test ) < 0 ) ) { before = test ; } } } return before ; } 
private static byte [ ] readZoneInfoFile ( final String fileName ) { if ( fileName . indexOf ( ".." ) >= 0 ) { return null ; } byte [ ] buffer = null ; try { buffer = ( byte [ ] ) AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws IOException { File file = new File ( ziDir , fileName ) ; byte [ ] buf = null ; int filesize = ( int ) file . length ( ) ; if ( filesize > 0 ) { FileInputStream fis = new FileInputStream ( file ) ; buf = new byte [ filesize ] ; try { if ( fis . read ( buf ) != filesize ) { throw new IOException ( "read-error-on-" + fileName ) ; } } finally { fis . close ( ) ; } } return buf ; } } ) ; } catch ( PrivilegedActionException e ) { Exception ex = e . getException ( ) ; if ( ! ( ex instanceof FileNotFoundException ) || JAVAZM_FILE_NAME . equals ( fileName ) ) { System . err . println ( "ZoneInfo:-" + ex . getMessage ( ) ) ; } } return buffer ; } 
@ Deprecated public void addDefaultLicenseKey ( String key ) { pDefaultLicenseKeys . add ( key ) ; } 
RuleDescriptor ( final String id , final String description , final Collection < CursorState > states , final IConfigurationElement configurationElement ) { assert id != null ; assert description != null ; _id = id ; _description = description ; _states = new ArrayList < CursorState > ( states ) ; _configurationElement = configurationElement ; } 
public static String encode ( final String s ) { if ( s == null ) { return null ; } try { return URLEncoder . encode ( s , "UTF-8" ) ; } catch ( final UnsupportedEncodingException ignored ) { } return null ; } 
public int getRowForPath ( TreePath path ) { if ( path == null ) return - 1 ; TreeStateNode visNode = getNodeForPath ( path , true , false ) ; if ( visNode != null ) return visNode . getRow ( ) ; return - 1 ; } 
public void close ( ) throws IOException { if ( _stream != null ) _stream . close ( ) ; } 
public byte [ ] toByteArray ( ) { int len = ( mPos >>> 3 ) + ( ( mPos & 0x07 ) > 0 ? 1 : 0 ) ; byte [ ] newBuf = new byte [ len ] ; System . arraycopy ( mBuf , 0 , newBuf , 0 , len ) ; return newBuf ; } 
public static void println ( float x ) { out . println ( x ) ; } 
private static void initMapping ( ) { labelToDSCAlarmItemType = new HashMap < String , DSCAlarmItemType > ( ) ; for ( DSCAlarmItemType s : values ( ) ) { labelToDSCAlarmItemType . put ( s . label , s ) ; } } 
public void appendNodes ( NodeSet nodes ) { int nNodes = nodes . size ( ) ; if ( null == m_map ) { m_mapSize = nNodes + m_blocksize ; m_map = new Node [ m_mapSize ] ; } else if ( ( m_firstFree + nNodes ) >= m_mapSize ) { m_mapSize += ( nNodes + m_blocksize ) ; Node newMap [ ] = new Node [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + nNodes ) ; m_map = newMap ; } System . arraycopy ( nodes . m_map , 0 , m_map , m_firstFree , nNodes ) ; m_firstFree += nNodes ; } 
public static void unhandled ( final String str , final Type t ) { System . err . println ( "Unhandled-type-(" + str + "):-" + t . toString ( ) ) ; } 
public boolean sourceEquals ( Calendar cal ) { if ( this == cal ) return true ; if ( cal == null ) return false ; if ( getClass ( ) != cal . getClass ( ) ) return false ; if ( id != cal . id ) return false ; return true ; } 
public void forceCacheRefresh ( ) { this . nextCacheRefreshAt = new Date ( ) ; } 
public BigDecimal [ ] divideAndRemainder ( BigDecimal divisor , MathContext mc ) { BigDecimal quotAndRem [ ] = new BigDecimal [ 2 ] ; quotAndRem [ 0 ] = this . divideToIntegralValue ( divisor , mc ) ; quotAndRem [ 1 ] = this . subtract ( quotAndRem [ 0 ] . multiply ( divisor ) ) ; return quotAndRem ; } 
public static boolean verifySaltedPassword ( byte [ ] password , String entry ) throws NoSuchAlgorithmException , UnsupportedEncodingException { if ( ! entry . startsWith ( SSHA ) ) { throw new IllegalArgumentException ( "Hash-not-prefixed-by-{SSHA};-is-it-really-a-salted-hash?" ) ; } byte [ ] challenge = Base64 . decodeBase64 ( entry . substring ( 6 ) . getBytes ( "UTF-8" ) ) ; byte [ ] passwordHash = extractPasswordHash ( challenge ) ; byte [ ] salt = extractSalt ( challenge ) ; MessageDigest digest = MessageDigest . getInstance ( "SHA" ) ; digest . update ( password ) ; byte [ ] hash = digest . digest ( salt ) ; return Arrays . equals ( passwordHash , hash ) ; } 
@ Override public void characters ( char [ ] ch , int start , int length ) { if ( this . currentText != null ) { this . currentText . append ( String . copyValueOf ( ch , start , length ) ) ; } } 
protected void createVerticalSpacer ( Composite parent , int numColumns ) { Label label = new Label ( parent , SWT . NONE ) ; GridData gridData = new GridData ( ) ; gridData . horizontalSpan = numColumns ; label . setLayoutData ( gridData ) ; } 
public void escape ( char [ ] buf , int start , int len , boolean isAttValue , Writer out ) throws IOException { for ( int ii = start ; ii < start + len ; ii ++ ) { char ch = buf [ ii ] ; if ( ch == '|n' ) { out . write ( "&#10;" ) ; continue ; } out . write ( ch ) ; } } 
public static void buildEventsFromCursor ( ArrayList < Event > events , Cursor cEvents , Context context , int startDay , int endDay ) { if ( cEvents == null || events == null ) { Log . e ( TAG , "buildEventsFromCursor:-null-cursor-or-null-events-list!" ) ; return ; } int count = cEvents . getCount ( ) ; if ( count == 0 ) { return ; } Resources res = context . getResources ( ) ; mNoTitleString = res . getString ( R . string . no_title_label ) ; mNoColorColor = res . getColor ( R . color . event_center ) ; while ( cEvents . moveToNext ( ) ) { Event e = generateEventFromCursor ( cEvents ) ; if ( e . startDay > endDay || e . endDay < startDay ) { continue ; } events . add ( e ) ; } } 
private static double computeAverage ( Collection < Double > c ) { double sum = 0 ; for ( double d : c ) { sum += d ; } return sum / c . size ( ) ; } 
private boolean containsSqlScriptDelimiters ( String script , char delim ) { boolean inLiteral = false ; char [ ] content = script . toCharArray ( ) ; for ( int i = 0 ; i < script . length ( ) ; i ++ ) { if ( content [ i ] == '|'' ) { inLiteral = ! inLiteral ; } if ( content [ i ] == delim && ! inLiteral ) { return true ; } } return false ; } 
private static InputStreamReader getInputStreamReader ( URL url ) throws IOException { java . net . URLConnection cnx1 = url . openConnection ( ) ; cnx1 . setUseCaches ( false ) ; return new InputStreamReader ( cnx1 . getInputStream ( ) , "UTF-8" ) ; } 
public static void replaceUIInputMap ( JComponent component , int type , InputMap uiInputMap ) { InputMap map = component . getInputMap ( type , ( uiInputMap != null ) ) ; while ( map != null ) { InputMap parent = map . getParent ( ) ; if ( parent == null || ( parent instanceof UIResource ) ) { map . setParent ( uiInputMap ) ; return ; } map = parent ; } } 
public boolean isRunning ( ) { File f = new File ( mFolderPath , "userdata-qemu.img.lock" ) ; return f . isFile ( ) ; } 
public Iterator < Member > iterator ( ) { final Iterator < String > namesIterator = names . iterator ( ) ; final Iterator < JsonValue > valuesIterator = values . iterator ( ) ; return new Iterator < JsonObject . Member > ( ) { public boolean hasNext ( ) { return namesIterator . hasNext ( ) ; } public Member next ( ) { String name = namesIterator . next ( ) ; JsonValue value = valuesIterator . next ( ) ; return new Member ( name , value ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } 
private void copyINSURL ( INSURL url ) { rirFlag = url . getRIRFlag ( ) ; theEndpointInfo = ( java . util . ArrayList ) url . getEndpointInfo ( ) ; theKeyString = url . getKeyString ( ) ; theStringifiedName = url . getStringifiedName ( ) ; } 
public void keyPressed ( KeyEvent e ) { String keyText = KeyEvent . getKeyText ( e . getKeyCode ( ) ) . toLowerCase ( ) ; synchronized ( keyLock ) { keysDown . add ( keyText ) ; if ( keyBindings . containsKey ( keyText ) ) { unprocessedKeys . add ( keyText ) ; } } } 
public final Message obtainMessage ( int what ) { return Message . obtain ( mSmHandler , what ) ; } 
public Map getOIDs ( ) { return Collections . unmodifiableMap ( oid2a_ ) ; } 
public void removeDependentTask ( Task < ? extends Serializable > dependent ) { if ( ( getChildTasks ( ) != null ) && ( getChildTasks ( ) . contains ( dependent ) ) ) { getChildTasks ( ) . remove ( dependent ) ; if ( ( dependent . getParentTasks ( ) != null ) && ( dependent . getParentTasks ( ) . contains ( this ) ) ) { dependent . getParentTasks ( ) . remove ( this ) ; } } } 
public static Shape createStar ( double size , int points ) { final double center = size / 2 ; final double outerRadius = size / 2 ; final double innerRadius = size / 4 ; final double pointAngle = 360 / points ; double x [ ] = new double [ points * 2 ] ; double y [ ] = new double [ points * 2 ] ; GeneralPath star = new GeneralPath ( ) ; double offset = Math . PI / 2 ; for ( int i = 0 ; i < points ; i ++ ) { double innerDegree = ( Math . toRadians ( i - 0.5 ) * pointAngle ) - offset ; double innerX = innerRadius * Math . cos ( innerDegree ) + center ; double innerY = innerRadius * Math . sin ( innerDegree ) + center ; double outerDegree = ( Math . toRadians ( i ) * pointAngle ) - offset ; double outerX = outerRadius * Math . cos ( outerDegree ) + center ; double outerY = outerRadius * Math . sin ( outerDegree ) + center ; int pos = 2 * i ; x [ pos ] = innerX ; y [ pos ] = innerY ; x [ pos + 1 ] = outerX ; y [ pos + 1 ] = outerY ; } star . moveTo ( x [ 0 ] , y [ 0 ] ) ; for ( int i = 1 ; i < x . length ; i ++ ) { star . lineTo ( x [ i ] , y [ i ] ) ; } star . closePath ( ) ; return star ; } 
@ Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . splash ) ; Thread splashTread = new Thread ( ) { @ Override public void run ( ) { try { int waited = 0 ; while ( _active && ( waited < _splashTime ) ) { sleep ( 100 ) ; if ( _active ) { waited += 100 ; } } } catch ( InterruptedException e ) { } finally { Intent mainIntent = new Intent ( SplashScreen . this , NFCLauncherActivty . class ) ; SplashScreen . this . startActivity ( mainIntent ) ; SplashScreen . this . finish ( ) ; } } } ; splashTread . start ( ) ; } 
private Component getTaskTreeCellRenderer ( Task t , boolean selected , boolean hasFocus ) { JLabel tree_label = new JLabel ( ) ; tree_label . setText ( t . getText ( ) ) ; tree_label . setIcon ( getStatusIcon ( t ) ) ; applyFont ( t , tree_label ) ; return tree_label ; } 
private String getNamingContextName ( ) { if ( namingContextName == null ) { Container parent = getParent ( ) ; if ( parent == null ) { namingContextName = getName ( ) ; } else { Stack < String > stk = new Stack < > ( ) ; StringBuilder buff = new StringBuilder ( ) ; while ( parent != null ) { stk . push ( parent . getName ( ) ) ; parent = parent . getParent ( ) ; } while ( ! stk . empty ( ) ) { buff . append ( "/" + stk . pop ( ) ) ; } buff . append ( getName ( ) ) ; namingContextName = buff . toString ( ) ; } } return namingContextName ; } 
public Configuration addClass ( Class persistentClass ) throws MappingException { String mappingResourceName = persistentClass . getName ( ) . replace ( '.' , '/' ) + ".hbm.xml" ; LOG . readingMappingsFromResource ( mappingResourceName ) ; return addResource ( mappingResourceName , persistentClass . getClassLoader ( ) ) ; } 
static String getWhereClauseForIds ( long [ ] ids ) { StringBuilder whereClause = new StringBuilder ( ) ; whereClause . append ( "(" ) ; for ( int i = 0 ; i < ids . length ; i ++ ) { if ( i > 0 ) { whereClause . append ( "OR-" ) ; } whereClause . append ( Downloads . Impl . _ID ) ; whereClause . append ( "-=-?-" ) ; } whereClause . append ( ")" ) ; return whereClause . toString ( ) ; } 
protected int indentTo ( int i , StringBuffer buf ) { int indent = i * m_indentStep ; for ( int j = 0 ; j < indent ; j ++ ) { buf . append ( '-' ) ; } return indent ; } 
public void showError ( Throwable t , String resource ) { String text ; try { text = resources . getString ( resource + ".text" ) ; } catch ( MissingResourceException e ) { text = resources . getString ( "error.text" ) ; } String title ; try { title = resources . getString ( resource + ".title" ) ; } catch ( MissingResourceException e ) { title = resources . getString ( "error.title" ) ; } String reason = resources . getString ( "error.reason" ) ; String message = text + "-" + MessageFormat . format ( reason , new Object [ ] { t } ) ; JOptionPane . showMessageDialog ( this , message , title , JOptionPane . ERROR_MESSAGE ) ; } 
public void add ( L left , R right ) { if ( left == null ) { throw new NullPointerException ( "left-must-not-be-null." ) ; } if ( right == null ) { throw new NullPointerException ( "right-must-not-be-null." ) ; } Set < R > rights = lToRMappings . get ( left ) ; if ( rights == null ) { rights = new HashSet < R > ( ) ; } rights . add ( right ) ; lToRMappings . put ( left , rights ) ; Set < L > lefts = rToLMappings . get ( right ) ; if ( lefts == null ) { lefts = new HashSet < L > ( ) ; } lefts . add ( left ) ; rToLMappings . put ( right , lefts ) ; } 
protected int getThumbOverhang ( ) { return ( int ) ( getThumbSize ( ) . getHeight ( ) - getTrackWidth ( ) ) / 2 ; } 
public List < DebuggerEvent > getEvents ( ) throws DebuggerException { List < DebuggerEvent > eventsSnapshot ; synchronized ( events ) { eventsSnapshot = new ArrayList < > ( events ) ; events . clear ( ) ; } return eventsSnapshot ; } 
protected void setNextPosition ( int next ) { assertion ( false , "setNextPosition-not-supported-in-this-iterator!" ) ; } 
private static byte [ ] makeNTLM2RandomChallenge ( ) throws NTLMEngineException { if ( RND_GEN == null ) { throw new NTLMEngineException ( "Random-generator-not-available" ) ; } byte [ ] rval = new byte [ 24 ] ; synchronized ( RND_GEN ) { RND_GEN . nextBytes ( rval ) ; } Arrays . fill ( rval , 8 , 24 , ( byte ) 0x00 ) ; return rval ; } 
protected int addNodeInDocOrder ( int node ) { assertion ( hasCache ( ) , "addNodeInDocOrder-must-be-done-on-a-mutable-sequence!" ) ; int insertIndex = - 1 ; NodeVector vec = getVector ( ) ; int size = vec . size ( ) , i ; for ( i = size - 1 ; i >= 0 ; i -- ) { int child = vec . elementAt ( i ) ; if ( child == node ) { i = - 2 ; break ; } DTM dtm = m_dtmMgr . getDTM ( node ) ; if ( ! dtm . isNodeAfter ( node , child ) ) { break ; } } if ( i != - 2 ) { insertIndex = i + 1 ; vec . insertElementAt ( node , insertIndex ) ; } return insertIndex ; } 
public void add ( int index , E element ) { insertElementAt ( element , index ) ; } 
void addNeighbourRegion ( MapRegion neighbour ) { neighbours . add ( neighbour ) ; } 
public String getNotes ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < notes . size ( ) ; i ++ ) { sb . append ( "Note-" + i + "-" ) ; sb . append ( notes . get ( i ) + "-" ) ; } return sb . toString ( ) ; } 
private void appendEventCountAnnouncement ( Context context , AccessibilityEvent event , StringBuilder textBuilder ) { int eventIndex = event . getCurrentItemIndex ( ) + 1 ; int eventCount = event . getItemCount ( ) ; textBuilder . append ( context . getString ( R . string . template_announce_item_index , eventIndex , eventCount ) ) ; textBuilder . append ( SPACE ) ; textBuilder . append ( context . getResources ( ) . getQuantityString ( R . plurals . plural_event , eventCount ) ) ; } 
public void installUI ( JComponent a ) { for ( int i = 0 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . installUI ( a ) ; } } 
public void treeCollapsed ( TreeExpansionEvent e ) { fireTreeCollapsed ( e . getPath ( ) ) ; } 
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ 0x10000 ] ; int i = 0 ; int j = 0 ; while ( i < 106 ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > 0 ) ; } return map ; } 
public int countPOS ( final String pos ) { int count = 0 ; for ( Tag t : tags ) { if ( t . getPos ( ) . startsWith ( pos ) ) count ++ ; } return count ; } 
Field ( MySQLConnection conn , byte [ ] buffer , int nameStart , int nameLength , int tableNameStart , int tableNameLength , int length , int mysqlType , short colFlag , int colDecimals ) throws SQLException { this ( conn , buffer , - 1 , - 1 , tableNameStart , tableNameLength , - 1 , - 1 , nameStart , nameLength , - 1 , - 1 , length , mysqlType , colFlag , colDecimals , - 1 , - 1 , NO_CHARSET_INFO ) ; } 
public void setAttribute ( final int index ) { setHeader ( index ) ; if ( m_AttributeStats [ index ] == null ) { Thread t = new Thread ( ) { @ Override public void run ( ) { m_AttributeStats [ index ] = m_Instances . attributeStats ( index ) ; SwingUtilities . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { setDerived ( index ) ; m_StatsTable . sizeColumnsToFit ( - 1 ) ; m_StatsTable . revalidate ( ) ; m_StatsTable . repaint ( ) ; } } ) ; } } ; t . setPriority ( Thread . MIN_PRIORITY ) ; t . start ( ) ; } else { setDerived ( index ) ; } } 
private static boolean isRightChild ( final Node node , final int index ) { return ( node == null ) ? true : ( ( node . getParent ( index ) == null ) ? false : ( node == node . getParent ( index ) . getRight ( index ) ) ) ; } 
public static < T > T create ( Class < T > listenerInterface , Object target , String action ) { return create ( listenerInterface , target , action , null , null ) ; } 
public void onStartTemporaryDetach ( ) { removeUnsetPressCallback ( ) ; mPrivateFlags |= PFLAG_CANCEL_NEXT_UP_EVENT ; } 
private float clampMag ( float value , float absMin , float absMax ) { final float absValue = Math . abs ( value ) ; if ( absValue < absMin ) return 0 ; if ( absValue > absMax ) return value > 0 ? absMax : - absMax ; return value ; } 
public final void removeChangeListener ( ChangeListener cl ) { listeners . remove ( cl ) ; } 
public void insertNode ( Node n , int pos ) { if ( ! m_mutable ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_NOT_MUTABLE , null ) ) ; insertElementAt ( n , pos ) ; } 
final public void litecoinSerialize ( OutputStream stream ) throws IOException { if ( bytes != null && length != UNKNOWN_LENGTH ) { stream . write ( bytes , offset , length ) ; return ; } litecoinSerializeToStream ( stream ) ; } 
public String toString ( ) { String result = super . toString ( ) ; int vmcid = minor & 0xFFFFF000 ; switch ( vmcid ) { case OMGVMCID . value : result += "-vmcid:-OMG" ; break ; case SUNVMCID . value : result += "-vmcid:-SUN" ; break ; default : result += "-vmcid:-0x" + Integer . toHexString ( vmcid ) ; break ; } int mc = minor & 0x00000FFF ; result += "-minor-code:-" + mc ; switch ( completed . value ( ) ) { case CompletionStatus . _COMPLETED_YES : result += "-completed:-Yes" ; break ; case CompletionStatus . _COMPLETED_NO : result += "-completed:-No" ; break ; case CompletionStatus . _COMPLETED_MAYBE : default : result += "-completed:-Maybe" ; break ; } return result ; } 
public RigidConstraint . TechniqueCommon . Spring createRigidConstraintTechniqueCommonSpring ( ) { return new RigidConstraint . TechniqueCommon . Spring ( ) ; } 
public EventRecord [ ] monitor ( ) { ArrayList < EventRecord > recs = new ArrayList < EventRecord > ( ) ; for ( String device : devices ) { try { recs . add ( query ( device ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } EventRecord [ ] T = new EventRecord [ recs . size ( ) ] ; return recs . toArray ( T ) ; } 
public List < Long > getAppliedTeamIds ( ) { if ( appliedTeamIds == null ) { appliedTeamIds = new ArrayList < Long > ( ) ; } return this . appliedTeamIds ; } 
public static ImageLoaderConfiguration createDefault ( Context context ) { return new Builder ( context ) . build ( ) ; } 
public static java . util . Enumeration < Driver > getDrivers ( ) { java . util . Vector < Driver > result = new java . util . Vector < Driver > ( ) ; java . util . Vector drivers = null ; if ( ! initialized ) { initialize ( ) ; } synchronized ( DriverManager . class ) { drivers = readDrivers ; } ClassLoader callerCL = DriverManager . getCallerClassLoader ( ) ; for ( int i = 0 ; i < drivers . size ( ) ; i ++ ) { DriverInfo di = ( DriverInfo ) drivers . elementAt ( i ) ; if ( getCallerClass ( callerCL , di . driverClassName ) != di . driverClass ) { println ( "-skipping:-" + di ) ; continue ; } result . addElement ( di . driver ) ; } return ( result . elements ( ) ) ; } 
public void setSneaking ( boolean par1 ) { this . setFlag ( 1 , par1 ) ; } 
private void putForCreate ( K key , V value ) { int hash = null == key ? 0 : hash ( key ) ; int i = indexFor ( hash , table . length ) ; for ( Entry < K , V > e = table [ i ] ; e != null ; e = e . next ) { Object k ; if ( e . hash == hash && ( ( k = e . key ) == key || ( key != null && key . equals ( k ) ) ) ) { e . value = value ; return ; } } createEntry ( hash , key , value , i ) ; } 
@ XmlElementDecl ( namespace = "" , name = "phone2" ) public JAXBElement < String > createPhone2 ( String value ) { return new JAXBElement < String > ( _Phone2_QNAME , String . class , null , value ) ; } 
public final boolean postDelayed ( Runnable r , long delayMillis ) { return sendMessageDelayed ( getPostMessage ( r ) , delayMillis ) ; } 
public synchronized void setMaxSize ( long maxSize ) { this . maxSize = maxSize ; executorService . submit ( cleanupCallable ) ; } 
private boolean isLocked ( String path , String ifHeader ) { LockInfo lock = ( LockInfo ) resourceLocks . get ( path ) ; Enumeration < String > tokenList = null ; if ( ( lock != null ) && ( lock . hasExpired ( ) ) ) { resourceLocks . remove ( path ) ; } else if ( lock != null ) { tokenList = lock . tokens . elements ( ) ; boolean tokenMatch = false ; while ( tokenList . hasMoreElements ( ) ) { String token = ( String ) tokenList . nextElement ( ) ; if ( ifHeader . indexOf ( token ) != - 1 ) tokenMatch = true ; } if ( ! tokenMatch ) return true ; } Enumeration < LockInfo > collectionLocksList = collectionLocks . elements ( ) ; while ( collectionLocksList . hasMoreElements ( ) ) { lock = collectionLocksList . nextElement ( ) ; if ( lock . hasExpired ( ) ) { collectionLocks . removeElement ( lock ) ; } else if ( path . startsWith ( lock . path ) ) { tokenList = lock . tokens . elements ( ) ; boolean tokenMatch = false ; while ( tokenList . hasMoreElements ( ) ) { String token = ( String ) tokenList . nextElement ( ) ; if ( ifHeader . indexOf ( token ) != - 1 ) tokenMatch = true ; } if ( ! tokenMatch ) return true ; } } return false ; } 
public void addFrom ( String entityName , String alias ) { froms . add ( Pair . make ( entityName , alias ) ) ; } 
public double getVertexRankScore ( V v ) { Number rankScore = vertexRankScores . get ( getRankScoreKey ( ) ) . get ( v ) ; if ( rankScore != null ) { return rankScore . doubleValue ( ) ; } else { throw new RuntimeException ( "setRemoveRankScoresOnFinalize(false)-must-be-called-before-evaluate()." ) ; } } 
private void createAndShowGUI ( ) { frame . setDefaultCloseOperation ( JFrame . DO_NOTHING_ON_CLOSE ) ; frame . setVisible ( true ) ; } 
public static Map < ObjectName , Map < String , Object >> getMBeanAttributeMap ( MBeanServerConnection server , ObjectName objectName , String delimeter , Collection < String > attributeNames ) { if ( attributeNames == null || attributeNames . size ( ) < 1 ) throw new RuntimeException ( "Attribute-names-collection-was-null-or-zero-size" , new Throwable ( ) ) ; return getMBeanAttributeMap ( server , objectName , delimeter , attributeNames . toArray ( new String [ attributeNames . size ( ) ] ) ) ; } 
public boolean isNewer ( Object o ) { return ( compareTo ( o ) == 1 ) ; } 
final void updateHead ( Node < E > h , Node < E > p ) { if ( h != p && casHead ( h , p ) ) h . lazySetNext ( h ) ; } 
@ Override public UriBuilder queryParam ( String name , Object ... values ) throws IllegalArgumentException { if ( values == null ) { throw new IllegalArgumentException ( "The-values-must-not-be-null" ) ; } CharSequence ncs ; ncs = EncodeOrCheck . nameOrValue ( name , true , "query-parameter-name" ) ; final List < String > valuesStr = new ArrayList < String > ( ) ; for ( final Object value : values ) { final String vcs = EncodeOrCheck . nameOrValue ( value , true , "query-parameter-value" ) ; valuesStr . add ( vcs ) ; } final Iterator < String > valueIter = valuesStr . iterator ( ) ; StringBuilder query ; if ( this . query == null ) { query = new StringBuilder ( ) ; this . query = query ; } else if ( this . query instanceof StringBuilder ) { query = ( StringBuilder ) this . query ; query . append ( '&' ) ; } else { query = new StringBuilder ( this . query . toString ( ) ) ; query . append ( '&' ) ; } query . append ( ncs ) ; query . append ( '=' ) ; query . append ( valueIter . next ( ) ) ; while ( valueIter . hasNext ( ) ) { query . append ( '&' ) ; query . append ( ncs ) ; query . append ( '=' ) ; query . append ( valueIter . next ( ) ) ; } return this ; } 
public boolean dispatchKeyShortcutEvent ( KeyEvent event ) { return onKeyShortcut ( event . getKeyCode ( ) , event ) ; } 
public List < PlanType > getPlan ( ) { if ( plan == null ) { plan = new ArrayList < PlanType > ( ) ; } return this . plan ; } 
public void put ( String hostname , String detailMessage ) { put ( hostname , detailMessage , false ) ; } 
public RE ( Object pattern ) throws REException { this ( pattern , 0 , RESyntax . RE_SYNTAX_PERL5 , 0 , 0 ) ; } 
public static void checkState ( boolean expression , Object msg ) { if ( ! expression ) { throw new IllegalStateException ( String . valueOf ( msg ) ) ; } } 
public int createDeferredProcessingInstruction ( String target , String data ) { int nodeIndex = createNode ( Node . PROCESSING_INSTRUCTION_NODE ) ; int chunk = nodeIndex >> CHUNK_SHIFT ; int index = nodeIndex & CHUNK_MASK ; setChunkValue ( fNodeName , target , chunk , index ) ; setChunkValue ( fNodeValue , data , chunk , index ) ; return nodeIndex ; } 
private boolean isDeviceRemoved ( DeviceId deviceId , Timestamp timestampToCheck ) { Timestamp removalTimestamp = removalRequest . get ( deviceId ) ; if ( removalTimestamp != null && removalTimestamp . compareTo ( timestampToCheck ) >= 0 ) { return true ; } return false ; } 
public static HeapFile createDuplicateHeapFile ( ArrayList < ArrayList < Integer >> tuples , int columns , String colPrefix ) throws IOException { File temp = File . createTempFile ( "table" , ".dat" ) ; temp . deleteOnExit ( ) ; HeapFileEncoder . convert ( tuples , temp , BufferPool . PAGE_SIZE , columns ) ; return Utility . openHeapFile ( columns , colPrefix , temp ) ; } 
public boolean equalsIgnoreCase ( String s ) { byte [ ] b = buff ; int blen = end - start ; if ( b == null || blen != s . length ( ) ) { return false ; } int boff = start ; for ( int i = 0 ; i < blen ; i ++ ) { if ( Ascii . toLower ( b [ boff ++ ] ) != Ascii . toLower ( s . charAt ( i ) ) ) { return false ; } } return true ; } 
public static Request newStatusUpdateRequest ( Session session , String message , GraphPlace place , List < GraphUser > tags , Callback callback ) { List < String > tagIds = null ; if ( tags != null ) { tagIds = new ArrayList < String > ( tags . size ( ) ) ; for ( GraphUser tag : tags ) { tagIds . add ( tag . getId ( ) ) ; } } String placeId = place == null ? null : place . getId ( ) ; return newStatusUpdateRequest ( session , message , placeId , tagIds , callback ) ; } 
public Node getNamedItemNS ( String namespaceURI , String localName ) { Node retNode = null ; for ( int n = dtm . getFirstAttribute ( element ) ; n != DTM . NULL ; n = dtm . getNextAttribute ( n ) ) { if ( localName . equals ( dtm . getLocalName ( n ) ) ) { String nsURI = dtm . getNamespaceURI ( n ) ; if ( ( namespaceURI == null && nsURI == null ) || ( namespaceURI != null && namespaceURI . equals ( nsURI ) ) ) { retNode = dtm . getNode ( n ) ; break ; } } } return retNode ; } 
public void characters ( XMLString text , Augmentations augs ) throws XNIException { boolean callNextCharacters = true ; boolean allWhiteSpace = true ; for ( int i = text . offset ; i < text . offset + text . length ; i ++ ) { if ( ! isSpace ( text . ch [ i ] ) ) { allWhiteSpace = false ; break ; } } if ( fInElementContent && allWhiteSpace && ! fInCDATASection ) { if ( fDocumentHandler != null ) { fDocumentHandler . ignorableWhitespace ( text , augs ) ; callNextCharacters = false ; } } if ( fPerformValidation ) { if ( fInElementContent ) { if ( fGrammarBucket . getStandalone ( ) && fDTDGrammar . getElementDeclIsExternal ( fCurrentElementIndex ) ) { if ( allWhiteSpace ) { fErrorReporter . reportError ( XMLMessageFormatter . XML_DOMAIN , "MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE" , null , XMLErrorReporter . SEVERITY_ERROR ) ; } } if ( ! allWhiteSpace ) { charDataInContent ( ) ; } if ( augs != null && augs . getItem ( Constants . CHAR_REF_PROBABLE_WS ) == Boolean . TRUE ) { fErrorReporter . reportError ( XMLMessageFormatter . XML_DOMAIN , "MSG_CONTENT_INVALID_SPECIFIED" , new Object [ ] { fCurrentElement . rawname , fDTDGrammar . getContentSpecAsString ( fElementDepth ) , "character-reference" } , XMLErrorReporter . SEVERITY_ERROR ) ; } } if ( fCurrentContentSpecType == XMLElementDecl . TYPE_EMPTY ) { charDataInContent ( ) ; } } if ( callNextCharacters && fDocumentHandler != null ) { fDocumentHandler . characters ( text , augs ) ; } } 
public static void storeMAPFaultName ( String faultName , Message message ) { message . put ( MAP_FAULT_NAME_PROPERTY , faultName ) ; } 
static final private String rawToHexFingerprint ( byte [ ] fingerprint ) { final char [ ] alpha = "0123456789abcdef" . toCharArray ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < fingerprint . length ; i ++ ) { if ( i != 0 ) sb . append ( ':' ) ; int b = fingerprint [ i ] & 0xff ; sb . append ( alpha [ b >> 4 ] ) ; sb . append ( alpha [ b & 15 ] ) ; } return sb . toString ( ) ; } 
public void setLayoutArrays ( int offsets [ ] , int spans [ ] , int targetSpan ) { this . offsets = offsets ; this . spans = spans ; updatePercentagesAndAdjustmentWeights ( targetSpan ) ; } 
private static String cleanupJavadocHtml ( String s ) { if ( s != null ) { s = s . replaceAll ( LT_ENTITY , """ ) ; s = s . replaceAll ( GT_ENTITY , """ ) ; s = s . replaceAll ( "<[^>]+>" , "" ) ; } return s ; } 
public Element toElement ( ) { Element e = new Element ( Path . parallel_tag ) ; e . addContent ( op1 . toElement ( ) ) ; e . addContent ( op2 . toElement ( ) ) ; return e ; } 
public void parse ( final InputStream is ) throws IOException { final byte [ ] buf = readFully ( is ) ; parse ( buf , 0 , buf . length ) ; } 
public static final String getDefaultAlgorithm ( ) { String algorithm = Security . getProperty ( PROPERTY_NAME ) ; return ( algorithm != null ? algorithm : DEFAULT_PROPERTY ) ; } 
public void setRequestMethod ( String method ) throws ProtocolException { if ( connected ) { throw new ProtocolException ( "Connection-already-established" ) ; } for ( String permittedUserMethod : PERMITTED_USER_METHODS ) { if ( permittedUserMethod . equals ( method ) ) { this . method = permittedUserMethod ; return ; } } throw new ProtocolException ( "Unknown-method-'" + method + "';-must-be-one-of-" + Arrays . toString ( PERMITTED_USER_METHODS ) ) ; } 
public void addUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { mUpdateListeners = new ArrayList < AnimatorUpdateListener > ( ) ; } mUpdateListeners . add ( listener ) ; } 
protected static void deleteDir ( File dir ) { String files [ ] = dir . list ( ) ; if ( files == null ) { files = new String [ 0 ] ; } for ( int i = 0 ; i < files . length ; i ++ ) { File file = new File ( dir , files [ i ] ) ; if ( file . isDirectory ( ) ) { deleteDir ( file ) ; } else { file . delete ( ) ; } } dir . delete ( ) ; } 
@ Override public Object acceptVisitor ( final Visitor visitor ) { return visitor . visit ( this ) ; } 
void showmove ( ) { int oldblock = blocklen [ printoldline ] ; int newother = newinfo . other [ printnewline ] ; int newblock = blocklen [ newother ] ; if ( newblock < 0 ) { skipnew ( ) ; } else if ( oldblock >= newblock ) { blocklen [ newother ] = - 1 ; println ( ">>>>-" + newother + "-THRU-" + ( newother + newblock - 1 ) + "-MOVED-TO-BEFORE-" + printoldline ) ; for ( ; newblock > 0 ; newblock -- , printnewline ++ ) { println ( newinfo . symbol [ printnewline ] . showSymbol ( ) ) ; } anyprinted = true ; printstatus = idle ; } else { skipold ( ) ; } } 
public static org . hotswap . agent . javassist . compiler . ast . ASTree parseExpr ( String src , SymbolTable st ) throws CompileError { Parser p = new Parser ( new Lex ( src ) ) ; return p . parseExpression ( st ) ; } 
public static void d ( String tag , String s , Object ... args ) { if ( LOG . DEBUG >= LOGLEVEL ) Log . d ( tag , String . format ( s , args ) ) ; } 
public static boolean isEmpty ( ) { return ! scanner . hasNext ( ) ; } 
private boolean checkBackwardExtension ( Sequence prefix ) { for ( int i = 0 ; i < prefix . getItemOccurencesTotalCount ( ) ; i ++ ) { List < PseudoSequence > maximumPeriods = new ArrayList < PseudoSequence > ( ) ; for ( PseudoSequence sequence : initialDatabase . getPseudoSequences ( ) ) { if ( prefix . getSequencesID ( ) . contains ( sequence . getId ( ) ) ) { PseudoSequence period = sequence . getIthMaximumPeriodOfAPrefix ( prefix , i , false ) ; if ( period != null ) { maximumPeriods . add ( period ) ; } } } for ( Pair pair : findAllFrequentPairsForBackwardExtensionCheck ( prefix , maximumPeriods , i ) ) { if ( pair . getCount ( ) == prefix . getAbsoluteSupport ( ) ) { return true ; } } } return false ; } 
private void addExportedPackages ( Map < Bundle , List < String >> map , Bundle bundle , ExportedPackage [ ] pkgs ) { List < String > packages = map . get ( bundle ) ; if ( packages == null ) { packages = new ArrayList < String > ( pkgs . length ) ; map . put ( bundle , packages ) ; } for ( int i = 0 ; i < pkgs . length ; i ++ ) { packages . add ( pkgs [ i ] . getName ( ) ) ; } } 
public Vector objects ( String className ) { Object obj = objects . get ( className ) ; Vector v = new Vector ( ) ; Vector aux ; if ( obj != null ) { aux = ( Vector ) obj ; for ( Enumeration e = aux . elements ( ) ; e . hasMoreElements ( ) ; ) { v . addElement ( e . nextElement ( ) ) ; } } obj = subClasses . get ( className ) ; if ( obj != null ) { aux = ( Vector ) obj ; for ( Enumeration e = aux . elements ( ) ; e . hasMoreElements ( ) ; ) { String subClassName = ( String ) e . nextElement ( ) ; obj = objects . get ( subClassName ) ; if ( obj != null ) { Vector aux2 = ( Vector ) obj ; for ( Enumeration e2 = aux2 . elements ( ) ; e2 . hasMoreElements ( ) ; ) { v . addElement ( e2 . nextElement ( ) ) ; } } } } return v ; } 
public String getType ( String name ) { return getType ( names . indexOf ( name ) ) ; } 
private void interruptWorkers ( ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { for ( Worker w : workers ) { try { w . thread . interrupt ( ) ; } catch ( SecurityException ignore ) { } } } finally { mainLock . unlock ( ) ; } } 
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; } 
public static void close ( ) { out . close ( ) ; } 
public void draw ( Graphics2D g2 , Rectangle2D plotArea , Point2D rotate , double angle ) { Paint savePaint = g2 . getColor ( ) ; Stroke saveStroke = g2 . getStroke ( ) ; drawNeedle ( g2 , plotArea , rotate , Math . toRadians ( angle ) ) ; g2 . setStroke ( saveStroke ) ; g2 . setPaint ( savePaint ) ; } 
public void parse ( InputSource source , HandlerBase handler ) throws SAXException , IOException { Parser parser = getParser ( ) ; if ( source == null ) { throw new IllegalArgumentException ( "source-must-not-be-null" ) ; } if ( handler != null ) { parser . setDocumentHandler ( handler ) ; parser . setDTDHandler ( handler ) ; parser . setEntityResolver ( handler ) ; parser . setErrorHandler ( handler ) ; } parser . parse ( source ) ; } 
protected final void end ( ) { closeLock . readLock ( ) . unlock ( ) ; } 
public static final ObjectName makeMBeanName ( Class clazz , String name ) { try { return ObjectName . getInstance ( makeSingletonName ( clazz ) . toString ( ) + ",name=" + name ) ; } catch ( MalformedObjectNameException x ) { final IllegalArgumentException iae = new IllegalArgumentException ( String . valueOf ( name ) , x ) ; throw iae ; } } 
public static float saturation ( int color ) { int r = ( color >> 16 ) & 0xFF ; int g = ( color >> 8 ) & 0xFF ; int b = color & 0xFF ; int V = Math . max ( b , Math . max ( r , g ) ) ; int temp = Math . min ( b , Math . min ( r , g ) ) ; float S ; if ( V == temp ) { S = 0 ; } else { S = ( V - temp ) / ( float ) V ; } return S ; } 
public static JarMapping convertSrgMapping ( SrgMapping mapping ) { JarMapping outMapping = new JarMapping ( ) ; for ( Entry < SrgClass , SrgClass > entry : mapping . getClassMapping ( ) . entrySet ( ) ) { outMapping . classes . put ( entry . getKey ( ) . getQualifiedName ( ) , entry . getValue ( ) . getQualifiedName ( ) ) ; } for ( Entry < SrgField , SrgField > entry : mapping . getFieldMapping ( ) . entrySet ( ) ) { outMapping . fields . put ( entry . getKey ( ) . getQualifiedName ( ) , entry . getValue ( ) . getFieldName ( ) ) ; } for ( Entry < SrgMethod , SrgMethod > entry : mapping . getMethodMapping ( ) . entrySet ( ) ) { outMapping . methods . put ( entry . getKey ( ) . getQualifiedName ( ) , entry . getValue ( ) . getMethodName ( ) ) ; } return outMapping ; } 
public static Date getLastDayOfMonth ( Date date ) { if ( date == null ) { return null ; } Calendar c = Calendar . getInstance ( ) ; c . setTime ( date ) ; int lastDay = c . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; c . set ( Calendar . DATE , lastDay ) ; return c . getTime ( ) ; } 
public void endGeneralEntity ( String name , Augmentations augs ) throws XNIException { if ( fDocumentHandler != null && ! fOnlyPassPrefixMappingEvents ) { fDocumentHandler . endGeneralEntity ( name , augs ) ; } } 
public static void flushDirectoryContent ( File dir ) { File [ ] files = dir . listFiles ( ) ; if ( files == null ) return ; for ( int i = 0 , max = files . length ; i < max ; i ++ ) { Util . delete ( files [ i ] ) ; } } 
public int getSize ( ) { return objects . size ( ) ; } 
private static Map < String , String > extractOptions ( List < String > args ) { Map < String , String > optionValues = new HashMap < String , String > ( 13 ) ; Iterator < String > iterator = args . iterator ( ) ; while ( iterator . hasNext ( ) ) { String arg = iterator . next ( ) ; boolean foundOption = false ; for ( String option : OPTIONS ) { if ( ! arg . startsWith ( option ) ) { continue ; } foundOption = true ; iterator . remove ( ) ; if ( option . endsWith ( "=" ) ) { int index = arg . indexOf ( "=" ) ; if ( index == arg . length ( ) - 1 ) { } else { String value = arg . substring ( index + 1 ) ; optionValues . put ( option , value ) ; } } else { String value = "" ; optionValues . put ( option , value ) ; } } if ( ! foundOption ) { break ; } } return optionValues ; } 
public com . google . protobuf . ByteString getDiagnosticsBytes ( ) { java . lang . Object ref = diagnostics_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; diagnostics_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public boolean isCutOff ( List < Action > result ) { return 1 == result . size ( ) && CutOffIndicatorAction . CUT_OFF . equals ( result . get ( 0 ) ) ; } 
public void remove ( T object ) { synchronized ( mLock ) { if ( mOriginalValues != null ) { mOriginalValues . remove ( object ) ; } else { mObjects . remove ( object ) ; } } if ( mNotifyOnChange ) notifyDataSetChanged ( ) ; } 
private String unfoldNewline ( String str ) { int ind = str . indexOf ( "-" ) ; if ( ind == - 1 ) { return str ; } else { String tmpString1 = str . substring ( 0 , ind ) ; String tmpString2 = str . substring ( ind + 1 ) ; return unfoldNewline ( tmpString1 + tmpString2 ) ; } } 
public static FacesContext getFacesContext ( Tag tag , Map objectModel ) { FacesContext context = ( FacesContext ) objectModel . get ( FACES_CONTEXT_OBJECT ) ; if ( context == null ) { context = FacesContext . getCurrentInstance ( ) ; if ( context == null ) { throw new FacesException ( "Tag-<" + tag . getClass ( ) . getName ( ) + ">-" + "could-not-find-current-FacesContext" ) ; } objectModel . put ( FACES_CONTEXT_OBJECT , context ) ; } return context ; } 
public static boolean isService ( String processName ) { return SERVICES . contains ( processName ) ; } 
@ Deprecated public static RequestAsyncTask executeMeRequestAsync ( Session session , GraphUserCallback callback ) { return newMeRequest ( session , callback ) . executeAsync ( ) ; } 
public List < String > getScriptTagsForId ( String id , Locale locale , boolean includeGlobal ) { String cacheKey = getCacheKey ( id , locale ) ; if ( scriptsCache . containsKey ( cacheKey ) ) { return scriptsCache . get ( cacheKey ) ; } List < String > scriptTags = new ArrayList < String > ( ) ; Map globalAssets = ( Map ) assets . get ( FooGlueConstants . GLOBAL ) ; Map idAssets = ( Map ) assets . get ( id ) ; if ( requireIdForAssets && idAssets == null ) { return scriptTags ; } if ( includeGlobal && globalAssets != null ) { List < Map > globalScripts = ( List < Map > ) globalAssets . get ( FooGlueConstants . SCRIPTS ) ; if ( globalScripts != null && globalScripts . size ( ) > 0 ) { for ( Map < String , String > scriptAttrs : globalScripts ) { String scriptTag = createScriptTag ( scriptAttrs , locale ) ; scriptTags . add ( scriptTag ) ; } } } if ( idAssets != null ) { List < Map > idScripts = ( List < Map > ) idAssets . get ( FooGlueConstants . SCRIPTS ) ; if ( idScripts != null && idScripts . size ( ) > 0 ) { for ( Map < String , String > scriptAttrs : idScripts ) { String scriptTag = createScriptTag ( scriptAttrs , locale ) ; scriptTags . add ( scriptTag ) ; } } } Collections . unmodifiableList ( scriptTags ) ; if ( cacheAssets && scriptTags . size ( ) > 0 ) { scriptsCache . put ( cacheKey , scriptTags ) ; } return scriptTags ; } 
public Collection < Role > getAllRoles ( Collection < Service > services ) { final Collection < Role > allRoles = new LinkedHashSet < Role > ( ) ; CollectionUtils . forAllDo ( services , new Closure ( ) { public void execute ( Object object ) { if ( object != null && Service . class . isAssignableFrom ( object . getClass ( ) ) ) { allRoles . addAll ( ( ( Service ) object ) . getAllRoles ( ) ) ; } } } ) ; return allRoles ; } 
public StringBuilder encodeBody ( StringBuilder buffer ) { return text != null ? buffer . append ( Integer . toString ( code ) ) . append ( SP ) . append ( agent ) . append ( SP ) . append ( DOUBLE_QUOTE ) . append ( text ) . append ( DOUBLE_QUOTE ) : buffer . append ( Integer . toString ( code ) ) . append ( SP ) . append ( agent ) ; } 
void registerContentObserver ( Cursor cursor , ContentObserver observer ) { cursor . registerContentObserver ( mObserver ) ; } 
public String getGlEsVersion ( ) { int major = ( ( reqGlEsVersion & 0xffff0000 ) >> 16 ) ; int minor = reqGlEsVersion & 0x0000ffff ; return String . valueOf ( major ) + "." + String . valueOf ( minor ) ; } 
@ Deprecated public static < T > String getPathString ( Tree < T > start , Tree < T > end , Tree < T > tree , int maxDepth ) throws Exception { Pair < List < Tree < T >> , List < Tree < T >>> paths = getPath ( start , end , tree , maxDepth ) ; StringBuilder buffer = new StringBuilder ( ) ; for ( Tree < T > up : paths . getFirst ( ) ) { buffer . append ( up . getLabel ( ) ) . append ( PATH_UP_STRING ) ; } for ( Tree < T > up : paths . getSecond ( ) ) { buffer . append ( up . getLabel ( ) ) . append ( PATH_DOWN_STRING ) ; } return buffer . toString ( ) ; } 
static public String getIndexLocation ( Properties properties ) { return properties . getProperty ( KEY_LUCENE_INDEX_LOCATION ) ; } 
public boolean equals ( Object obj2 ) { if ( null == obj2 ) return false ; else if ( obj2 instanceof XNodeSet ) return obj2 . equals ( this ) ; else if ( obj2 instanceof XNumber ) return obj2 . equals ( this ) ; else return str ( ) . equals ( obj2 . toString ( ) ) ; } 
public static Object readObject ( java . sql . ResultSet resultSet , int index ) throws Exception { ObjectInputStream objIn = new ObjectInputStream ( resultSet . getBinaryStream ( index ) ) ; Object obj = objIn . readObject ( ) ; objIn . close ( ) ; return obj ; } 
public void exiting ( Object o ) { StackTraceElement ste = new Throwable ( ) . getStackTrace ( ) [ 1 ] ; exiting ( ste . getClassName ( ) , ste . getMethodName ( ) , o == null ? "null" : o . toString ( ) ) ; } 
private ArrayList < Integer > find ( int i ) { ArrayList < Integer > indices = new ArrayList < Integer > ( ) ; for ( int x = 0 ; x < Pt_x . length ; x ++ ) { if ( Pt_x [ x ] == i ) { indices . add ( x ) ; } } return indices ; } 
public void addListener ( ConnectedHostsListener listener ) { listeners . add ( listener ) ; } 
public boolean equals ( Object obj ) { if ( ! ( obj instanceof Float ) ) return false ; float f = ( ( Float ) obj ) . value ; if ( value == f ) return ( value != 0 ) || ( 1 / value == 1 / f ) ; return isNaN ( value ) && isNaN ( f ) ; } 
public Element size ( String s ) { size = - 1 ; return attribute ( SIZE , s ) ; } 
public static String toString ( Object obj ) { return obj == null ? "" : obj . toString ( ) ; } 
private static String uniquePath ( String dir , String base ) { base = base . replaceAll ( "[][<>:/|" , "" ) ; int extensionOffset = base . lastIndexOf ( "." ) ; String root = base . substring ( 0 , extensionOffset ) ; String ext = base . substring ( extensionOffset ) ; File file = null ; while ( true ) { file = new File ( dir , root + ext ) ; if ( ! file . exists ( ) ) { break ; } Matcher regMatcher = regPattern . matcher ( root ) ; if ( ! regMatcher . find ( ) ) { root = root + "-(1)" ; } else { int num = Integer . parseInt ( regMatcher . group ( 1 ) ) ; root = root . substring ( regMatcher . start ( ) ) + "-(" + num + ")" ; } } return dir + "/" + root + ext ; } 
@ Nonnull default DoubleBiConsumer consume ( @ Nonnull final LongConsumer consumer ) { Objects . requireNonNull ( consumer ) ; return ( value1 , value2 ) -> consumer . accept ( applyAsLong ( value1 , value2 ) ) ; } 
public BigDecimal round ( MathContext mc ) { BigDecimal thisBD = new BigDecimal ( getUnscaledValue ( ) , scale ) ; thisBD . inplaceRound ( mc ) ; return thisBD ; } 
public int getXkrFNum ( ) { return Util . readIntBE ( xkrFNum ) ; } 
String readLine ( boolean ignoreLF ) throws IOException { StringBuffer s = null ; int startChar ; synchronized ( lock ) { ensureOpen ( ) ; boolean omitLF = ignoreLF || skipLF ; bufferLoop : for ( ; ; ) { if ( nextChar >= nChars ) fill ( ) ; if ( nextChar >= nChars ) { if ( s != null && s . length ( ) > 0 ) return s . toString ( ) ; else return null ; } boolean eol = false ; char c = 0 ; int i ; if ( omitLF && ( cb [ nextChar ] == LF ) ) nextChar ++ ; skipLF = false ; omitLF = false ; charLoop : for ( i = nextChar ; i < nChars ; i ++ ) { c = cb [ i ] ; if ( ( c == LF ) || ( c == '|r' ) ) { eol = true ; break charLoop ; } } startChar = nextChar ; nextChar = i ; if ( eol ) { String str ; if ( s == null ) { str = new String ( cb , startChar , i - startChar ) ; } else { s . append ( cb , startChar , i - startChar ) ; str = s . toString ( ) ; } nextChar ++ ; if ( c == '|r' ) { skipLF = true ; } return str ; } if ( s == null ) s = new StringBuffer ( defaultExpectedLineLength ) ; s . append ( cb , startChar , i - startChar ) ; } } } 
public void setDividerLocation ( double proportionalLocation ) { if ( proportionalLocation < 0.0 || proportionalLocation > 1.0 ) { throw new IllegalArgumentException ( "proportional-location-must-" + "be-between-0.0-and-1.0." ) ; } if ( getOrientation ( ) == VERTICAL_SPLIT ) { setDividerLocation ( ( int ) ( ( double ) ( getHeight ( ) - getDividerSize ( ) ) * proportionalLocation ) ) ; } else { setDividerLocation ( ( int ) ( ( double ) ( getWidth ( ) - getDividerSize ( ) ) * proportionalLocation ) ) ; } } 
public Object clone ( ) { try { CopyOnWriteArrayList c = ( CopyOnWriteArrayList ) ( super . clone ( ) ) ; c . resetLock ( ) ; return c ; } catch ( CloneNotSupportedException e ) { throw new InternalError ( ) ; } } 
private String capitalize ( final String line ) { return Character . toUpperCase ( line . charAt ( 0 ) ) + line . substring ( 1 ) ; } 
private void waitForMapLoaded ( ) { MediaTracker tracker = new MediaTracker ( component ) ; tracker . addImage ( img , 0 ) ; try { tracker . waitForID ( 0 ) ; } catch ( InterruptedException e ) { logger . log ( Level . SEVERE , "waitForMapLoaded()" , e ) ; } imageDone = true ; } 
public final ImmutableList < TypeToken < ? extends Throwable >> getExceptionTypes ( ) { ImmutableList . Builder < TypeToken < ? extends Throwable >> builder = ImmutableList . builder ( ) ; for ( Type type : getGenericExceptionTypes ( ) ) { @ SuppressWarnings ( "unchecked" ) TypeToken < ? extends Throwable > exceptionType = ( TypeToken < ? extends Throwable > ) TypeToken . of ( type ) ; builder . add ( exceptionType ) ; } return builder . build ( ) ; } 
private void addResolver ( IResolvable resolver , Class [ ] resolvableClasses ) { for ( Class clazz : resolvableClasses ) { map . put ( clazz , resolver ) ; } } 
protected void modelChanged ( ) { final Document doc = document ; if ( needLock ) { readLock ( doc ) ; } try { setDocument ( document ) ; View view = getRootView ( ) . getViewFactory ( ) . create ( document . getDefaultRootElement ( ) ) ; setView ( view ) ; setViewSize ( ) ; } finally { if ( needLock ) { readUnlock ( doc ) ; } } if ( component != null ) { component . repaint ( ) ; } } 
public static double [ ] rotateVector ( double angle , double [ ] v ) { double [ ] n = new double [ 2 ] ; n [ 0 ] = Math . cos ( Math . toRadians ( angle ) ) * v [ 0 ] - Math . sin ( Math . toRadians ( angle ) ) * v [ 1 ] ; n [ 1 ] = Math . sin ( Math . toRadians ( angle ) ) * v [ 0 ] + Math . cos ( Math . toRadians ( angle ) ) * v [ 1 ] ; return n ; } 
public boolean isLessThan ( Object a , Object b ) { return ( ( Integer ) a ) . intValue ( ) > ( ( Integer ) b ) . intValue ( ) ; } 
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; } 
public void setTime ( int parameterIndex , java . sql . Time x ) throws SQLException { checkParamIndex ( parameterIndex ) ; if ( params == null ) { throw new SQLException ( "Set-initParams()-before-setTime" ) ; } params . put ( Integer . valueOf ( parameterIndex - 1 ) , x ) ; } 
private void updateMaxSuffix ( NodeInst ni ) { Name name = ni . getNameKey ( ) ; if ( ! name . isTempname ( ) ) { return ; } Name basename = name . getBasename ( ) ; String basenameString = basename . toString ( ) ; MaxSuffix ms = maxSuffix . get ( basenameString ) ; if ( ms == null ) { ms = new MaxSuffix ( ) ; maxSuffix . put ( basenameString , ms ) ; } int numSuffix = name . getNumSuffix ( ) ; if ( numSuffix > ms . v ) { ms . v = numSuffix ; } } 
public final void addPoliticalBoundary ( final PoliticalBoundary politicalBoundary ) { pBoundaries . add ( politicalBoundary ) ; } 
public TextArea ( String text ) throws HeadlessException { this ( text , 0 , 0 , SCROLLBARS_BOTH ) ; } 
public List sequence ( ) { List l = new ArrayList ( size ( ) ) ; Iterator iter = keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { l . add ( iter . next ( ) ) ; } return UnmodifiableList . decorate ( l ) ; } 
public static Annotation get ( String annoString ) throws Annotation . MalformedAnnotationException { boolean wellformed = true ; if ( ! ( annoString . matches ( ".*<INVINFO>.*</INVINFO>.*" ) && annoString . matches ( ".*<DAIKON>(.*)</DAIKON>.*" ) && annoString . matches ( ".*<METHOD>(.*)</METHOD>.*" ) ) ) { throw new Annotation . MalformedAnnotationException ( annoString ) ; } Kind k = null ; if ( annoString . matches ( ".*<ENTER>.*" ) ) { k = Kind . enter ; } else if ( annoString . matches ( ".*<EXIT>.*" ) ) { k = Kind . exit ; } else if ( annoString . matches ( ".*<OBJECT>.*" ) || annoString . matches ( ".*<CLASS>.*" ) ) { k = Kind . objectInvariant ; } else { throw new Annotation . MalformedAnnotationException ( annoString ) ; } String theDaikonRep = annoString . replaceFirst ( ".*<DAIKON>(.*)</DAIKON>.*" , "$1" ) . trim ( ) ; String theMethod = annoString . replaceFirst ( ".*<METHOD>(.*)</METHOD>.*" , "$1" ) . trim ( ) ; Annotation anno = Annotation . get ( k , theDaikonRep , theMethod ) ; if ( annoString . matches ( ".*<INV>(.*)</INV>.*" ) ) { anno . invRep = annoString . replaceFirst ( ".*<INV>(.*)</INV>.*" , "$1" ) . trim ( ) ; } if ( annoString . matches ( ".*<DAIKONCLASS>(.*)</DAIKONCLASS>.*" ) ) { anno . daikonClass = annoString . replaceFirst ( ".*<DAIKONCLASS>(.*)</DAIKONCLASS>.*" , "$1" ) . trim ( ) ; } return anno ; } 
private void validateTermsToKeep ( ) { List < String > invalidTermsConfigured = new ArrayList < String > ( ) ; for ( String term : termsToKeep ) { if ( ! term . contains ( "#" ) && ! term . contains ( "." ) && oboNameToIdentifier . get ( term ) == null ) { invalidTermsConfigured . add ( term ) ; } } if ( ! invalidTermsConfigured . isEmpty ( ) ) { throw new BuildException ( "The-following-terms-specified-in-so_terms-are-not-valid-" + "Sequence-Ontology-terms-according-to-so.obo:-" + StringUtil . prettyList ( invalidTermsConfigured ) ) ; } } 
static @ ForceInline Object getCallSiteTarget ( Object site ) { return ( ( CallSite ) site ) . getTarget ( ) ; } 
public int search ( Vector vct , String target ) { if ( vct == null ) return - 1 ; for ( int i = 0 ; i < vct . size ( ) ; i ++ ) if ( target . equals ( ( ( TreeNode ) vct . elementAt ( i ) ) . value ) ) return i ; return - 1 ; } 
public int getExpandedTypeID ( int nodeHandle ) { nodes . readSlot ( nodeHandle , gotslot ) ; String qName = m_localNames . indexToString ( gotslot [ 3 ] ) ; int colonpos = qName . indexOf ( ":" ) ; String localName = qName . substring ( colonpos + 1 ) ; String namespace = m_nsNames . indexToString ( gotslot [ 0 ] << 16 ) ; String expandedName = namespace + ":" + localName ; int expandedNameID = m_nsNames . stringToIndex ( expandedName ) ; return expandedNameID ; } 
public int addObject ( String s ) { int ofs = offset ; out ( "" + oid + "-0-obj-" ) ; out ( s ) ; out ( "-endobj-" ) ; String t = "" + ofs ; while ( t . length ( ) < 10 ) { t = "0" + t ; } ; xref . append ( t + "-00000-n-" ) ; return oid ++ ; } 
public static Credential basic ( String userName , String password ) { try { String usernameAndPassword = userName + ":" + password ; byte [ ] bytes = usernameAndPassword . getBytes ( "ISO-8859-1" ) ; String encoded = Base64 . encode ( bytes ) ; return new Credential ( "Basic-" + encoded ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( ) ; } } 
public boolean isDecimalSeparatorAlwaysShown ( ) { return ndf . isDecimalSeparatorAlwaysShown ( ) ; } 
public void process ( ICode iCode , SymTab symTab ) throws Exception { long startTime = System . currentTimeMillis ( ) ; float elapsedTime = ( System . currentTimeMillis ( ) - startTime ) / 1000f ; int executionCount = 0 ; int runtimeErrors = 0 ; sendMessage ( new Message ( INTERPRETER_SUMMARY , new Number [ ] { executionCount , runtimeErrors , elapsedTime } ) ) ; } 
static void clearGatheredViolations ( ) { gatheredViolations . set ( null ) ; } 
protected void readAndValidateParams ( Params params ) { if ( params . mMustFillScreen ) { double totalFactor = 0.0 ; for ( int i = 0 ; i < params . mNumItems ; i ++ ) { if ( params . mOverrideItemScreenSizeFactors . containsKey ( i ) ) { totalFactor += params . mOverrideItemScreenSizeFactors . get ( i ) ; } else { totalFactor += params . mItemScreenSizeFactor ; } } if ( totalFactor < 1.0 ) { throw new IllegalArgumentException ( "list-items-must-combine-to-be-at-least-" + "the-height-of-the-screen.-this-is-not-the-case-with-" + params . mNumItems + "-items-and-" + params . mItemScreenSizeFactor + "-screen-factor-and-" + "screen-height-of-" + mScreenHeight ) ; } } mNumItems = params . mNumItems ; mItemsFocusable = params . mItemsFocusable ; mStartingSelectionPosition = params . mStartingSelectionPosition ; mItemScreenSizeFactor = params . mItemScreenSizeFactor ; mOverrideItemScreenSizeFactors . putAll ( params . mOverrideItemScreenSizeFactors ) ; mUnselectableItems . addAll ( params . mUnselectableItems ) ; mIncludeHeader = params . mIncludeHeader ; mStackFromBottom = params . mStackFromBottom ; mHeaderViewCount = params . mHeaderViewCount ; mHeadersFocusable = params . mHeaderFocusable ; mFooterViewCount = params . mFooterViewCount ; } 
public boolean attemptStamp ( V expectedReference , int newStamp ) { Pair < V > current = pair ; return expectedReference == current . reference && ( newStamp == current . stamp || casPair ( current , Pair . of ( expectedReference , newStamp ) ) ) ; } 
public static String getFolderName ( String filePath ) { if ( StringUtils . isEmpty ( filePath ) ) { return filePath ; } int filePosi = filePath . lastIndexOf ( File . separator ) ; return ( filePosi == - 1 ) ? "" : filePath . substring ( 0 , filePosi ) ; } 
public void clear ( int rgb ) { frame . clear ( rgb ) ; } 
@ Override public void saveUserPayments ( UserPayments payments ) { UserTransaction tr = Utils . getInstance ( ) . openTransaction ( ) ; Session session = Utils . getInstance ( ) . getSession ( ) ; session . persist ( payments ) ; Utils . getInstance ( ) . commitTransaction ( tr ) ; } 
public void cancel ( ) { if ( mRequest != null ) { mRequest . cancel ( ) ; } } 
public static void createConnection ( Neuron fromNeuron , Neuron toNeuron , double weightVal ) { Connection connection = new Connection ( fromNeuron , toNeuron , weightVal ) ; toNeuron . addInputConnection ( connection ) ; } 
@ Override public int read ( ) throws IOException { synchronized ( lock ) { checkNotClosed ( ) ; if ( pos == count ) { return - 1 ; } return buf [ pos ++ ] ; } } 
public int indexX ( int k ) { int i = Arrays . binarySearch ( this . xIndex , k ) ; if ( i >= 0 ) { return i ; } else { return - 1 * i - 2 ; } } 
private void writeStartElement ( java . lang . String prefix , java . lang . String namespace , java . lang . String localPart , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String writerPrefix = xmlWriter . getPrefix ( namespace ) ; if ( writerPrefix != null ) { xmlWriter . writeStartElement ( namespace , localPart ) ; } else { if ( namespace . length ( ) == 0 ) { prefix = "" ; } else if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; } xmlWriter . writeStartElement ( prefix , localPart , namespace ) ; xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } } 
public void ejercicio03 ( ) { cabecera ( "03" , "" ) ; StringBuffer cadena = new StringBuffer ( "Viaje-al-Parnaso" ) ; System . out . println ( cadena . toString ( ) ) ; } 
public void setExpectedStartDate ( String startDate ) { try { calendar . setTime ( queryDateFormat . parse ( startDate ) ) ; expectedStartDate = resultDateFormat . format ( calendar . getTime ( ) ) ; } catch ( ParseException e ) { handleException ( e ) ; } } 
@ Override public void create ( ) throws de . fu . bakery . orm . java . DatabaseException { String query = "INSERT-INTO-" + ""scetris"."Feature"" + "-("name",-"timekey")" + "-VALUES-(?,-?)-RETURNING-id;" ; timekey ( true ) ; try { java . sql . PreparedStatement stmt = manager . connectionManager . getConnection ( ) . prepareStatement ( query ) ; int i = 1 ; stmt . setString ( i ++ , _name ) ; stmt . setTimestamp ( i ++ , _timekey ) ; java . sql . ResultSet keys = manager . executeQuery ( stmt ) ; if ( keys . next ( ) ) { _id = keys . getInt ( 1 ) ; } else { throw new de . fu . bakery . orm . java . DatabaseException ( "no-key-was-generated.-phail." ) ; } changed_name = false ; } catch ( java . sql . SQLException e ) { throw new de . fu . bakery . orm . java . DatabaseException ( query , e ) ; } exists = true ; } 
public static String getSeamConversationId ( ) { if ( ! isSeamEnvironment ( ) ) { return null ; } String returnVal = null ; try { Object seamManagerInstance = seamInstanceMethod . invoke ( null , seamMethodNoArgs ) ; if ( seamConversationIdMethodInstance != null ) { String conversationId = ( String ) seamConversationIdMethodInstance . invoke ( seamManagerInstance , seamMethodNoArgs ) ; Boolean is = ( Boolean ) seamLongRunningMethodInstance . invoke ( seamManagerInstance , seamMethodNoArgs ) ; if ( is . booleanValue ( ) ) { returnVal = conversationId ; } } } catch ( Exception e ) { seamInstanceMethod = null ; seamManagerClass = null ; log . log ( Level . INFO , "Exception-determining-Seam-ConversationId:-" , e ) ; } return returnVal ; } 
public static String replaceEmptyTokens ( String fileRow , Character fieldDelimiter ) { String aEmptyToken = fieldDelimiter . toString ( ) + fieldDelimiter . toString ( ) ; String aNullToken = fieldDelimiter . toString ( ) + " " + fieldDelimiter . toString ( ) ; if ( fileRow . substring ( fileRow . length ( ) - 1 ) . equalsIgnoreCase ( fieldDelimiter . toString ( ) ) ) { fileRow = fileRow + " " ; } StringBuffer fileRowAsBuffer = new StringBuffer ( fileRow ) ; int aTokenPos = fileRow . indexOf ( aEmptyToken ) ; while ( aTokenPos > - 1 ) { fileRowAsBuffer . replace ( aTokenPos , aTokenPos + 2 , aNullToken ) ; fileRow = fileRowAsBuffer . toString ( ) ; aTokenPos = fileRow . indexOf ( aEmptyToken ) ; } return fileRow ; } 
public Object clone ( ) { try { return ( DecimalFormatSymbols ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new InternalError ( ) ; } } 
public static List < Range < Token >> difference ( MerkleTrees ltree , MerkleTrees rtree ) { List < Range < Token >> differences = new ArrayList < > ( ) ; for ( MerkleTree tree : ltree . merkleTrees . values ( ) ) { differences . addAll ( MerkleTree . difference ( tree , rtree . getMerkleTree ( tree . fullRange ) ) ) ; } return differences ; } 
public static UnicodeScript of ( int codePoint ) { if ( ! isValidCodePoint ( codePoint ) ) throw new IllegalArgumentException ( ) ; int type = getType ( codePoint ) ; if ( type == UNASSIGNED ) return UNKNOWN ; int index = Arrays . binarySearch ( scriptStarts , codePoint ) ; if ( index < 0 ) index = - index - 2 ; return scripts [ index ] ; } 
public String getResourceNameSAKAI ( Entity mbr ) { String idx = mbr . getId ( ) ; ResourceProperties props = mbr . getProperties ( ) ; String resourceName = props . getProperty ( ResourceProperties . PROP_DISPLAY_NAME ) ; if ( idx . startsWith ( "/" ) && idx . endsWith ( "/" ) && idx . length ( ) > 3 ) { int lastSlash = idx . lastIndexOf ( "/" , idx . length ( ) - 2 ) ; if ( lastSlash > 0 && lastSlash + 1 <= idx . length ( ) - 2 ) { resourceName = idx . substring ( lastSlash + 1 , idx . length ( ) - 1 ) ; } } else if ( idx . startsWith ( "/" ) && ! idx . endsWith ( "/" ) && idx . length ( ) > 2 ) { int lastSlash = idx . lastIndexOf ( "/" ) ; if ( lastSlash > - 1 ) { resourceName = idx . substring ( lastSlash + 1 ) ; } } String parts [ ] = StringUtil . split ( idx , Entity . SEPARATOR ) ; if ( parts . length == 4 && parts [ 1 ] . equals ( "group-user" ) ) { try { UserDirectoryService . getUserByEid ( parts [ 3 ] ) ; } catch ( UserNotDefinedException tryId ) { try { resourceName = UserDirectoryService . getUserEid ( parts [ 3 ] ) ; } catch ( UserNotDefinedException notId ) { } } } return resourceName ; } 
public void addListener ( Component comp , CollapsibleSplitListener listener ) { if ( componentMap . containsKey ( comp ) ) componentMap . get ( comp ) . addListener ( listener ) ; } 
public List < String > getText ( ) { if ( text == null ) { text = new ArrayList < String > ( ) ; } return this . text ; } 
public static Object getEntityObjectFromProxyMethod ( Method method , Object [ ] arguments ) { Annotation [ ] [ ] annotations = method . getParameterAnnotations ( ) ; for ( int i = 0 ; i < annotations . length ; i ++ ) { for ( Annotation annotation : annotations [ i ] ) { if ( ! ( annotation instanceof Entity ) ) continue ; return arguments [ i ] ; } } return null ; } 
public static String formatPaddLeft ( String s , String col ) { String res = padd + s ; return res . substring ( res . length ( ) - col . length ( ) ) ; } 
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( "-Compresses-the-data-(uses-'" + ArffLoader . FILE_EXTENSION_COMPRESSED + "'-as-extension-instead-of-'" + ArffLoader . FILE_EXTENSION + "')-" + "-(default:-off)" , "compress" , 0 , "-compress" ) ) ; result . addElement ( new Option ( "-The-maximum-number-of-digits-to-print-after-the-decimal-" + "-place-for-numeric-values-(default:-6)" , "decimal" , 1 , "-decimal-<num>" ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; } 
public void comment ( XMLString text , Augmentations augs ) throws XNIException { if ( fDocumentHandler != null ) { fDocumentHandler . comment ( text , augs ) ; } } 
public void reset ( byte [ ] input , int start , int length ) { buffer . reset ( input , start , length ) ; } 
public Object castToType ( SessionInterface session , Object a , Type type ) { return convertToType ( session , a , type ) ; } 
public static String parseITypeTwo ( String s , LookupTable table ) { Scanner instructionScanner = new Scanner ( s ) ; String output = "" ; if ( instructionScanner . hasNext ( ) ) { String operation = instructionScanner . next ( ) ; String opcode = table . getOP ( operation ) ; output += opcode ; } String rd = "" ; String r1 = "" ; if ( instructionScanner . hasNext ( ) ) { rd = table . getRegCode ( instructionScanner . next ( ) ) ; } if ( instructionScanner . hasNext ( ) ) { String part2 = instructionScanner . next ( ) ; int sub1 = part2 . indexOf ( "(" ) ; int imm = Integer . parseInt ( part2 . substring ( 0 , sub1 ) ) ; r1 = table . getRegCode ( part2 . substring ( sub1 + 1 , sub1 + 3 ) ) ; String immed = table . parseImmediate ( imm , 5 ) ; output = output + r1 + rd + immed ; } return output ; } 
public void ensureCapacity ( int required ) { if ( required <= 0 ) { return ; } int available = this . buffer . length - this . len ; if ( required > available ) { expand ( this . len + required ) ; } } 
public GameClient ( String session_id , Socket clientSocket ) throws IOException { this . session_id = session_id ; this . clientSocket = clientSocket ; updates = new LinkedList < GameResponse > ( ) ; inputStream = clientSocket . getInputStream ( ) ; outputStream = clientSocket . getOutputStream ( ) ; dataInputStream = new DataInputStream ( inputStream ) ; } 
static ThreadLocalRandom current ( ) { return localRandom . get ( ) ; } 
@ Override public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255.0 ) ; return new Color ( g , g , g , this . alpha ) ; } 
public void addSelectionChangedListener ( ISelectionChangedListener listener ) { selectionChangedListeners . add ( listener ) ; } 
public static synchronized void define ( Class c , WritableComparator comparator ) { comparators . put ( c , comparator ) ; } 
public static BigInteger [ ] extgcd ( BigInteger a , BigInteger b ) { BigInteger u = ONE ; BigInteger v = ZERO ; BigInteger d = a ; if ( b . signum ( ) != 0 ) { BigInteger v1 = ZERO ; BigInteger v3 = b ; while ( v3 . signum ( ) != 0 ) { BigInteger [ ] tmp = d . divideAndRemainder ( v3 ) ; BigInteger q = tmp [ 0 ] ; BigInteger t3 = tmp [ 1 ] ; BigInteger t1 = u . subtract ( q . multiply ( v1 ) ) ; u = v1 ; d = v3 ; v1 = t1 ; v3 = t3 ; } v = d . subtract ( a . multiply ( u ) ) . divide ( b ) ; } return new BigInteger [ ] { d , u , v } ; } 
public void copyTo ( @ NonNull Calendar calendar ) { calendar . clear ( ) ; calendar . set ( year , month , day ) ; calendar . getTimeInMillis ( ) ; } 
public synchronized boolean remove ( String key ) throws IOException { checkNotClosed ( ) ; validateKey ( key ) ; Entry entry = lruEntries . get ( key ) ; if ( entry == null || entry . currentEditor != null ) { return false ; } for ( int i = 0 ; i < valueCount ; i ++ ) { File file = entry . getCleanFile ( i ) ; if ( ! file . delete ( ) ) { throw new IOException ( "failed-to-delete-" + file ) ; } size -= entry . lengths [ i ] ; entry . lengths [ i ] = 0 ; } redundantOpCount ++ ; journalWriter . append ( REMOVE + '-' + key + '|n' ) ; lruEntries . remove ( key ) ; if ( journalRebuildRequired ( ) ) { executorService . submit ( cleanupCallable ) ; } return true ; } 
public static byte [ ] decodeChecked ( String input ) throws AddressFormatException { byte [ ] tmp = decode ( input ) ; if ( tmp . length < 4 ) throw new AddressFormatException ( "Input-too-short" ) ; byte [ ] checksum = new byte [ 4 ] ; System . arraycopy ( tmp , tmp . length - 4 , checksum , 0 , 4 ) ; byte [ ] bytes = new byte [ tmp . length - 4 ] ; System . arraycopy ( tmp , 0 , bytes , 0 , tmp . length - 4 ) ; tmp = Utils . doubleDigest ( bytes ) ; byte [ ] hash = new byte [ 4 ] ; System . arraycopy ( tmp , 0 , hash , 0 , 4 ) ; if ( ! Arrays . equals ( hash , checksum ) ) throw new AddressFormatException ( "Checksum-does-not-validate" ) ; return bytes ; } 
public void removePEPListener ( PEPListener pepListener ) { synchronized ( pepListeners ) { pepListeners . remove ( pepListener ) ; } } 
public static List < File > getFileRecursive ( File dir ) throws FileNotFoundException { List < File > result = new ArrayList < File > ( ) ; File [ ] filesAndDirs = dir . listFiles ( ) ; List filesDirs = Arrays . asList ( filesAndDirs ) ; Iterator filesIter = filesDirs . iterator ( ) ; File file ; while ( filesIter . hasNext ( ) ) { file = ( File ) filesIter . next ( ) ; if ( file . isFile ( ) ) result . add ( file ) ; else { List < File > deeperList = getFileRecursive ( file ) ; result . addAll ( deeperList ) ; } } return result ; } 
@ Override public int getAD_Note_ID ( ) { Integer ii = ( Integer ) get_Value ( COLUMNNAME_AD_Note_ID ) ; if ( ii == null ) return 0 ; return ii . intValue ( ) ; } 
@ Override public boolean AddPhoto ( File photo ) throws IOException { boolean imageFound = false ; for ( int i = 0 ; ! imageFound && i < pictures . size ( ) ; i ++ ) { imageFound = pictures . get ( i ) . equals ( photo ) ; } if ( ! imageFound ) { byte [ ] jpegIdBytes = { - 1 , - 40 } ; byte [ ] signature = new byte [ 2 ] ; FileInputStream fileInputStream = new FileInputStream ( photo ) ; if ( fileInputStream . read ( signature , 0 , 2 ) == 2 && Arrays . equals ( signature , jpegIdBytes ) ) { pictures . add ( photo ) ; this . createRandomizedList ( ) ; } else { throw new IOException ( "File-not-a-JPEG-image." ) ; } } return ! imageFound ; } 
public static float getLineSpacing ( AttributeSet a ) { Float space = ( Float ) a . getAttribute ( LineSpacing ) ; if ( space != null ) { return space . floatValue ( ) ; } return 0 ; } 
static byte [ ] getPixels ( BufferedImage img , int x , int y , int w , int h , byte [ ] pixels ) { if ( w == 0 || h == 0 ) { return new byte [ 0 ] ; } if ( pixels == null ) { pixels = new byte [ w * h ] ; } else if ( pixels . length < w * h ) { throw new IllegalArgumentException ( "pixels-array-must-have-a-length->=-w*h" ) ; } int imageType = img . getType ( ) ; if ( imageType == BufferedImage . TYPE_BYTE_GRAY ) { Raster raster = img . getRaster ( ) ; return ( byte [ ] ) raster . getDataElements ( x , y , w , h , pixels ) ; } else { throw new IllegalArgumentException ( "Only-type-BYTE_GRAY-is-supported" ) ; } } 
public Enumeration getDeclaredPrefixes ( ) { return currentContext . getDeclaredPrefixes ( ) ; } 
public int decodeDigits ( ByteArrayInputStream bis ) throws ParameterException { if ( bis . available ( ) == 0 ) { throw new ParameterException ( "No-more-data-to-read." ) ; } int count = 0 ; address = "" ; int b = 0 ; while ( bis . available ( ) - 1 > 0 ) { b = ( byte ) bis . read ( ) ; int d1 = b & 0x0f ; int d2 = ( b & 0xf0 ) >> 4 ; address += Integer . toHexString ( d1 ) + Integer . toHexString ( d2 ) ; } b = bis . read ( ) & 0xff ; address += Integer . toHexString ( ( b & 0x0f ) ) ; if ( oddFlag != 1 ) { address += Integer . toHexString ( ( b & 0xf0 ) >> 4 ) ; } return count ; } 
public static Segment getSharedSegment ( ) { return getSharedInstance ( ) . getSegment ( ) ; } 
@ Override public Point2D getGlyphPosition ( int glyphIndex ) { if ( ( glyphIndex > vector . length ) || ( glyphIndex < 0 ) ) { throw new IndexOutOfBoundsException ( Messages . getString ( "awt.43" ) ) ; } int index = glyphIndex << 1 ; Point2D pos = new Point2D . Float ( visualPositions [ index ] , visualPositions [ index + 1 ] ) ; if ( glyphIndex == vector . length ) { return pos ; } AffineTransform at = getGlyphTransform ( glyphIndex ) ; if ( ( at == null ) || ( at . isIdentity ( ) ) ) { return pos ; } pos . setLocation ( pos . getX ( ) + at . getTranslateX ( ) , pos . getY ( ) + at . getTranslateY ( ) ) ; return pos ; } 
public Enumeration enumerateRequests ( ) { Vector newVector = new Vector ( 0 ) ; if ( m_buildThread != null ) { newVector . addElement ( "Stop" ) ; } return newVector . elements ( ) ; } 
public JSONArray put ( Object value ) { values . add ( value ) ; return this ; } 
public void setModelPath ( String modelPath ) throws Exception { if ( m_env == null ) { m_env = Environment . getSystemWide ( ) ; } m_modelPath = modelPath ; } 
public void save ( OutputStream out ) throws IOException { Writer w = new OutputStreamWriter ( out , "UTF8" ) ; save ( w ) ; w . flush ( ) ; } 
private void removeValues ( Object value , HashMap cache ) { org . simonme . tracer . logger . Tracer . traceMethodInvoke ( value , cache ) ; Collection keysToRemove = new ArrayList ( ) ; Iterator keys = cache . keySet ( ) . iterator ( ) ; while ( keys . hasNext ( ) ) { String key = ( String ) keys . next ( ) ; Object next = cache . get ( key ) ; if ( next instanceof Collection ) { Collection collection = ( Collection ) next ; if ( collection . contains ( value ) ) { collection . remove ( value ) ; if ( collection . isEmpty ( ) ) { keysToRemove . add ( key ) ; } break ; } } else { if ( cache . get ( key ) . equals ( value ) ) { keysToRemove . add ( key ) ; } } } Iterator keysToRemoveIterator = keysToRemove . iterator ( ) ; while ( keysToRemoveIterator . hasNext ( ) ) { cache . remove ( keysToRemoveIterator . next ( ) ) ; } } 
public static String getString ( final Reader reader ) throws IOException { if ( reader == null ) return "" ; try { int charsRead ; final char [ ] copyBuffer = new char [ BUFFER_SIZE ] ; final StringBuilder sb = new StringBuilder ( ) ; while ( ( charsRead = reader . read ( copyBuffer , 0 , BUFFER_SIZE ) ) != - 1 ) sb . append ( copyBuffer , 0 , charsRead ) ; return sb . toString ( ) ; } finally { reader . close ( ) ; } } 
public BridgeXmlBlockParser getCurrentParser ( ) { return mParserStack . peek ( ) ; } 
public void set ( Object object ) { this . set ( object . position , object . angle , object . scale , object . pivot , object . alpha , object . ref ) ; } 
public static URI getProxyUri ( URI originalUri , URI proxyUri , ApplicationId id ) { try { String path = getPath ( id , originalUri == null ? "/" : originalUri . getPath ( ) ) ; return new URI ( proxyUri . getScheme ( ) , proxyUri . getAuthority ( ) , path , originalUri == null ? null : originalUri . getQuery ( ) , originalUri == null ? null : originalUri . getFragment ( ) ) ; } catch ( URISyntaxException e ) { throw new RuntimeException ( "Could-not-proxify-" + originalUri , e ) ; } } 
public void setSnmpAdaptor ( SnmpMibHandler stack , String contextName , SnmpOid [ ] oids ) { if ( adaptor != null ) { adaptor . removeMib ( this , contextName ) ; } adaptor = stack ; if ( adaptor != null ) { adaptor . addMib ( this , contextName , oids ) ; } } 
private static List < Integer > addSubcategoriesByCategories ( Map < Integer , TreeNode > categoryNodeMap , String categoryType , Integer repository , List < Integer > parentCategoryIDs ) { CategoryFacade categoryFacade = CategoryFacadeFactory . getInstance ( ) . getCategoryFacade ( categoryType ) ; List < ILabelBeanWithParent > subcategories = ( List ) categoryFacade . getByParents ( parentCategoryIDs ) ; List < Integer > subcategoryIDs = new LinkedList < Integer > ( ) ; for ( ILabelBeanWithParent categoryBean : subcategories ) { Integer categoryID = categoryBean . getObjectID ( ) ; Integer parentCategoryID = categoryBean . getParentID ( ) ; TreeNode childNode = categoryFacade . getSimpleNode ( categoryType , repository , categoryBean ) ; childNode . setSelectable ( false ) ; TreeNode parentTreeNode = categoryNodeMap . get ( parentCategoryID ) ; if ( parentTreeNode != null ) { List < TreeNode > childrenNodes = parentTreeNode . getChildren ( ) ; if ( childrenNodes == null ) { parentTreeNode . setLeaf ( Boolean . FALSE ) ; childrenNodes = new LinkedList < TreeNode > ( ) ; parentTreeNode . setChildren ( childrenNodes ) ; } childrenNodes . add ( childNode ) ; categoryNodeMap . put ( categoryID , childNode ) ; } subcategoryIDs . add ( categoryID ) ; } return subcategoryIDs ; } 
public PrivateKey getPrivateKey ( ) { return keyPair . getPrivate ( ) ; } 
int appendSlot ( int w0 , int w1 , int w2 , int w3 ) { { final int slotsize = 4 ; int newoffset = ( lastUsed + 1 ) * slotsize ; int chunkpos = newoffset >> lowbits ; int slotpos = ( newoffset & lowmask ) ; if ( chunkpos > chunks . size ( ) - 1 ) chunks . addElement ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . elementAt ( chunkpos ) ; chunk [ slotpos ] = w0 ; chunk [ slotpos + 1 ] = w1 ; chunk [ slotpos + 2 ] = w2 ; chunk [ slotpos + 3 ] = w3 ; return ++ lastUsed ; } } 
public static String removeFNC1 ( String code ) { int len = code . length ( ) ; StringBuffer buf = new StringBuffer ( len ) ; for ( int k = 0 ; k < len ; ++ k ) { char c = code . charAt ( k ) ; if ( c >= 32 && c <= 126 ) buf . append ( c ) ; } return buf . toString ( ) ; } 
public int [ ] getPixel ( int x , int y , int iArray [ ] , DataBuffer data ) { if ( ( x < 0 ) || ( y < 0 ) || ( x >= width ) || ( y >= height ) ) { throw new ArrayIndexOutOfBoundsException ( "Coordinate-out-of-bounds!" ) ; } int pixels [ ] ; if ( iArray == null ) { pixels = new int [ numBands ] ; } else { pixels = iArray ; } int value = data . getElem ( y * scanlineStride + x ) ; for ( int i = 0 ; i < numBands ; i ++ ) { pixels [ i ] = ( value & bitMasks [ i ] ) >>> bitOffsets [ i ] ; } return pixels ; } 
protected static ArrayList < Mount > getMounts ( ) throws Exception { LineNumberReader lnr = null ; lnr = new LineNumberReader ( new FileReader ( "/proc/mounts" ) ) ; String line ; ArrayList < Mount > mounts = new ArrayList < Mount > ( ) ; while ( ( line = lnr . readLine ( ) ) != null ) { RootTools . log ( line ) ; String [ ] fields = line . split ( "-" ) ; mounts . add ( new Mount ( new File ( fields [ 0 ] ) , new File ( fields [ 1 ] ) , fields [ 2 ] , fields [ 3 ] ) ) ; } InternalVariables . mounts = mounts ; if ( InternalVariables . mounts != null ) { return InternalVariables . mounts ; } else { throw new Exception ( ) ; } } 
public com . google . protobuf . ByteString getLongFieldNameIsLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong211Bytes ( ) { java . lang . Object ref = longFieldNameIsLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong211_ ; if ( ref instanceof java . lang . String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; longFieldNameIsLooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooong211_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public String getStyleClass ( ) { String value = ( String ) getStateHelper ( ) . eval ( PropertyKeys . styleClass ) ; return value ; } 
@ Override public String toString ( ) { return "Content---source:-" + getSource ( ) + "-type:-" + getType ( ) ; } 
private static void rankNumberOfSpotsIndexed ( List < SampleRankingVO > sampleRankingValues ) { Double previousVal = null ; int currentRank = 1 ; Collections . sort ( sampleRankingValues , SampleRankingComparator . ORDER_VALUE_NumberOfSpotsIndexed_DESC ) ; for ( int i = 0 ; i < sampleRankingValues . size ( ) ; i ++ ) { Double currentVal = null ; if ( sampleRankingValues . get ( i ) . getNumberOfImagesValue ( ) != null ) currentVal = sampleRankingValues . get ( i ) . getNumberOfImagesValue ( ) . doubleValue ( ) ; if ( previousVal != null && currentVal != null && ! currentVal . equals ( previousVal ) ) currentRank ++ ; else if ( previousVal != null && currentVal == null ) currentRank ++ ; sampleRankingValues . get ( i ) . setNumberOfSpotsIndexedRank ( currentRank ) ; previousVal = currentVal ; } } 
private static ImmutableList < String > parseHeader ( String line ) { ImmutableList . Builder < String > extraHeaderBuilder = new ImmutableList . Builder < String > ( ) ; Iterator < String > it = Splitter . on ( '|t' ) . split ( line . trim ( ) . substring ( 1 ) ) . iterator ( ) ; for ( int i = 0 ; it . hasNext ( ) ; ++ i ) if ( i < 6 ) it . next ( ) ; else extraHeaderBuilder . add ( it . next ( ) ) ; return extraHeaderBuilder . build ( ) ; } 
public Displayable getDisplayable ( Element element ) { DisplayableClass c = ( DisplayableClass ) classes . get ( element . getTagName ( ) ) ; if ( c == null ) { System . err . println ( "No-DisplayableClass-found-for-'" + element . getTagName ( ) + "'." ) ; return null ; } return c . getDisplayable ( element ) ; } 
protected File downloadFile ( String url ) throws IOException { File pFolder = runtimeManager . getFileOrFolder ( Keys . plugins . folder , "${baseFolder}/plugins" ) ; pFolder . mkdirs ( ) ; File tmpFile = new File ( pFolder , StringUtils . getSHA1 ( url ) + ".tmp" ) ; if ( tmpFile . exists ( ) ) { tmpFile . delete ( ) ; } URL u = new URL ( url ) ; final URLConnection conn = getConnection ( u ) ; long lastModified = conn . getHeaderFieldDate ( "Last-Modified" , System . currentTimeMillis ( ) ) ; try ( InputStream is = conn . getInputStream ( ) ; OutputStream os = new FileOutputStream ( tmpFile ) ) { ByteStreams . copy ( is , os ) ; } File destFile = new File ( pFolder , StringUtils . getLastPathElement ( u . getPath ( ) ) ) ; if ( destFile . exists ( ) ) { destFile . delete ( ) ; } tmpFile . renameTo ( destFile ) ; destFile . setLastModified ( lastModified ) ; return destFile ; } 
public static void setNativeLookAndFeel ( ) { try { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( Exception e ) { System . out . println ( "Error-setting-native-LAF:-" + e ) ; } } 
public static ColorUIResource getMenuForeground ( ) { return getCurrentTheme ( ) . getMenuForeground ( ) ; } 
public void actionPerformed ( ActionEvent e ) { int count = 0 ; Component src = controller . removeBatch . getMenuComponent ( count ) ; String action = "" ; if ( src instanceof JMenuItem ) { action = ( ( JMenuItem ) src ) . getActionCommand ( ) ; } while ( ! e . getActionCommand ( ) . equals ( action ) ) { src = controller . removeBatch . getMenuComponent ( ++ count ) ; if ( src instanceof JMenuItem ) { action = ( ( JMenuItem ) src ) . getActionCommand ( ) ; } } controller . batches . remove ( count ) ; controller . removeBatch . remove ( count ) ; controller . viewBatch . remove ( count ) ; if ( controller . batches . size ( ) == 0 ) { controller . removeBatch . setEnabled ( false ) ; controller . viewBatch . setEnabled ( false ) ; } } 
public static < C , K extends C , V > TreeMap < K , V > newTreeMap ( @ Nullable Comparator < C > comparator ) { return new TreeMap < K , V > ( comparator ) ; } 
public void validateStructure ( ) throws FileNotFoundException { if ( ! getCtsDir ( ) . exists ( ) ) { throw new FileNotFoundException ( String . format ( "CTS-install-folder-%s-does-not-exist" , getCtsDir ( ) . getAbsolutePath ( ) ) ) ; } if ( ! getTestCasesDir ( ) . exists ( ) ) { throw new FileNotFoundException ( String . format ( "CTS-test-cases-folder-%s-does-not-exist" , getTestCasesDir ( ) . getAbsolutePath ( ) ) ) ; } if ( ! getTestPlansDir ( ) . exists ( ) ) { throw new FileNotFoundException ( String . format ( "CTS-test-plans-folder-%s-does-not-exist" , getTestPlansDir ( ) . getAbsolutePath ( ) ) ) ; } } 
private String getElementValue ( Element parent , String elementName ) { String value = null ; NodeList nodes = parent . getElementsByTagName ( elementName ) ; if ( nodes . getLength ( ) > 0 ) { value = nodes . item ( 0 ) . getChildNodes ( ) . item ( 0 ) . getNodeValue ( ) ; } return value ; } 
private void init ( ) { runnerThread = Thread . currentThread ( ) ; keepAlive = true ; try { socket . setTcpNoDelay ( true ) ; dataInput = new DataInputStream ( new BufferedInputStream ( socket . getInputStream ( ) ) ) ; dataOutput = new DataOutputStream ( socket . getOutputStream ( ) ) ; int firstInt = handshake ( ) ; switch ( streamProtocol ) { case HSQL_STREAM_PROTOCOL : if ( firstInt != ClientConnection . NETWORK_COMPATIBILITY_VERSION_INT ) { if ( firstInt == - 1900000 ) { firstInt = - 2000000 ; } String verString = ClientConnection . toNetCompVersionString ( firstInt ) ; throw Error . error ( null , ErrorCode . SERVER_VERSIONS_INCOMPATIBLE , 0 , new String [ ] { verString , HsqlDatabaseProperties . THIS_VERSION } ) ; } Result resultIn = Result . newResult ( dataInput , rowIn ) ; resultIn . readAdditionalResults ( session , dataInput , rowIn ) ; Result resultOut ; resultOut = setDatabase ( resultIn ) ; resultOut . write ( session , dataOutput , rowOut ) ; break ; case ODBC_STREAM_PROTOCOL : odbcConnect ( firstInt ) ; break ; default : keepAlive = false ; } } catch ( Exception e ) { StringBuffer sb = new StringBuffer ( mThread + ":Failed-to-connect-client." ) ; if ( user != null ) { sb . append ( "-User-'" + user + "'." ) ; } server . printWithThread ( sb . toString ( ) + "-Stack-trace-follows." ) ; server . printStackTrace ( e ) ; } } 
private long getVerificationTimeout ( ) { return android . provider . Settings . Global . getLong ( mContext . getContentResolver ( ) , android . provider . Settings . Global . PACKAGE_VERIFIER_TIMEOUT , DEFAULT_VERIFICATION_TIMEOUT ) ; } 
public void rename ( Name oldName , Name newName ) throws NamingException { Object value = lookup ( oldName ) ; bind ( newName , value ) ; unbind ( oldName ) ; } 
public ArrayList getChunks ( ) { return new ArrayList ( ) ; } 
public Dimension getMaximumSize ( ) { Dimension dim = maxSize ; if ( dim == null || ! ( isMaximumSizeSet ( ) || isValid ( ) ) ) { synchronized ( getTreeLock ( ) ) { if ( layoutMgr instanceof LayoutManager2 ) { LayoutManager2 lm = ( LayoutManager2 ) layoutMgr ; maxSize = lm . maximumLayoutSize ( this ) ; } else { maxSize = super . getMaximumSize ( ) ; } dim = maxSize ; } } if ( dim != null ) { return new Dimension ( dim ) ; } else { return dim ; } } 
synchronized void receive ( byte b [ ] , int off , int len ) throws IOException { checkStateForReceive ( ) ; writeSide = Thread . currentThread ( ) ; int bytesToTransfer = len ; while ( bytesToTransfer > 0 ) { if ( in == out ) awaitSpace ( ) ; int nextTransferAmount = 0 ; if ( out < in ) { nextTransferAmount = buffer . length - in ; } else if ( in < out ) { if ( in == - 1 ) { in = out = 0 ; nextTransferAmount = buffer . length - in ; } else { nextTransferAmount = out - in ; } } if ( nextTransferAmount > bytesToTransfer ) nextTransferAmount = bytesToTransfer ; assert ( nextTransferAmount > 0 ) ; System . arraycopy ( b , off , buffer , in , nextTransferAmount ) ; bytesToTransfer -= nextTransferAmount ; off += nextTransferAmount ; in += nextTransferAmount ; if ( in >= buffer . length ) { in = 0 ; } } } 
public NavigationRequestBuilder < P > setParams ( Map < String , Object > params ) { params . putAll ( params ) ; return this ; } 
public String nextTo ( String delimiters ) throws JSONException { char c ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = next ( ) ; if ( delimiters . indexOf ( c ) >= 0 || c == 0 || c == '|n' || c == '|r' ) { if ( c != 0 ) { back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } } 
public void addPropertyChangeListener ( PropertyChangeListener listener ) { support . addPropertyChangeListener ( listener ) ; } 
public boolean isEmpty ( ) { return parameters . isEmpty ( ) ; } 
public void setOnBufferAvailableListener ( OnBufferAvailableListener callback ) { synchronized ( mAllocationMap ) { mAllocationMap . put ( new Long ( getID ( mRS ) ) , this ) ; mBufferNotifier = callback ; } } 
public void addDiscoveryListener ( DiscoveryListener listener ) { if ( listener == null ) { throw new NullPointerException ( "can't-add-null-listener" ) ; } listeners . add ( listener ) ; if ( discoveredSet . isEmpty ( ) ) return ; HashMap groupsMap = new HashMap ( discoveredSet . size ( ) ) ; Iterator < ProxyReg > it = discoveredSet . iterator ( ) ; while ( it . hasNext ( ) ) { ProxyReg reg = it . next ( ) ; groupsMap . put ( reg . proxy , reg . getMemberGroups ( ) ) ; } notifyListener ( listener , groupsMap , DISCOVERED ) ; } 
synchronized boolean addPendingDB ( DatabaseId dbId ) { boolean added = pendingDBs . add ( dbId ) ; anyPendingDuringCheckpoint = true ; return added ; } 
public static byte countBits ( int num ) { byte result ; for ( result = 0 ; Math . abs ( num ) > 0 ; result ++ ) { num &= num - 1 ; } return result ; } 
public String toString ( ) { StringBuffer sb = new StringBuffer ( 3 * size ) ; for ( int idx = 0 ; idx < size ; idx ++ ) { if ( idx != 0 ) { sb . append ( '-' ) ; } String num = Integer . toHexString ( 0xff & bytes [ idx ] ) ; if ( num . length ( ) < 2 ) { sb . append ( '0' ) ; } sb . append ( num ) ; } return sb . toString ( ) ; } 
public com . google . protobuf . ByteString getNameBytes ( ) { java . lang . Object ref = name_ ; if ( ref instanceof java . lang . String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; name_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public void setTransactionIsolation ( int level ) throws SQLException { int currentLevel = conn . getTransactionIsolation ( ) ; if ( level != currentLevel ) { if ( overwroteOriginalTxIsolationValue == false ) { overwroteOriginalTxIsolationValue = true ; originalTxIsolationValue = currentLevel ; } conn . setTransactionIsolation ( level ) ; } } 
public void addListener ( AnimatorListener listener ) { if ( mListeners == null ) { mListeners = new ArrayList < AnimatorListener > ( ) ; } mListeners . add ( listener ) ; } 
public static long getOrCreateThreadId ( Context context , String recipient ) { Set < String > recipients = new HashSet < String > ( ) ; recipients . add ( recipient ) ; return getOrCreateThreadId ( context , recipients ) ; } 
public boolean isSealed ( URL url ) { return sealBase != null && sealBase . sameFile ( url ) ; } 
public void setPosition ( int offset ) { if ( position != offset ) { int oldValue = position ; position = offset ; listeners . firePropertyChange ( PROPERTY_POSITION , new Integer ( oldValue ) , new Integer ( position ) ) ; } } 
public void closeAllSessions ( ) { try { Set < ClientSession > sessions = new HashSet < ClientSession > ( ) ; sessions . addAll ( preAuthSessions . values ( ) ) ; sessions . addAll ( clientSessions . values ( ) ) ; for ( ClientSession session : sessions ) { try { session . getConnection ( ) . systemShutdown ( ) ; } catch ( Throwable t ) { } } } catch ( Exception e ) { } } 
public static void setOnProgressThreshold ( long threshold ) { onProgressThreshold . set ( threshold ) ; } 
protected void initPredicateInfo ( Compiler compiler , int opPos ) throws javax . xml . transform . TransformerException { int pos = compiler . getFirstPredicateOpPos ( opPos ) ; if ( pos > 0 ) { m_predicates = compiler . getCompiledPredicates ( pos ) ; if ( null != m_predicates ) { for ( int i = 0 ; i < m_predicates . length ; i ++ ) { m_predicates [ i ] . exprSetParent ( this ) ; } } } } 
public static String requestPath ( URL url ) { String fileOnly = url . getFile ( ) ; if ( fileOnly == null ) { return "/" ; } else if ( ! fileOnly . startsWith ( "/" ) ) { return "/" + fileOnly ; } else { return fileOnly ; } } 
protected void paint ( SynthContext context , Graphics g ) { SynthContext subcontext = getContext ( scrollbar , Region . SCROLL_BAR_TRACK ) ; paintTrack ( subcontext , g , getTrackBounds ( ) ) ; subcontext . dispose ( ) ; subcontext = getContext ( scrollbar , Region . SCROLL_BAR_THUMB ) ; paintThumb ( subcontext , g , getThumbBounds ( ) ) ; subcontext . dispose ( ) ; } 
public List < Extra > getExtras ( ) { if ( extras == null ) { extras = new ArrayList < Extra > ( ) ; } return this . extras ; } 
public void setFontColor ( Color color ) { int rgb = new Color ( color . getBlue ( ) , color . getGreen ( ) , color . getRed ( ) , 254 ) . getRGB ( ) ; setFontColor ( rgb ) ; } 
public boolean hasShare ( BluetoothOppShareInfo info ) { return mShares . contains ( info ) ; } 
public DTMIterator createDTMIterator ( int whatToShow , DTMFilter filter , boolean entityReferenceExpansion ) { return m_dtmManager . createDTMIterator ( whatToShow , filter , entityReferenceExpansion ) ; } 
private void loadUserImage ( ArrayList < UserInfo > userInfoList ) { if ( userInfoList == null ) { return ; } System . gc ( ) ; for ( UserInfo info : userInfoList ) { info . setUserImage ( TimelineActivity . userImageMap . get ( info . getUid ( ) ) ) ; } System . gc ( ) ; } 
@ Override public void run ( Context context ) throws IOException , InterruptedException { outer = context ; int numberOfThreads = getNumberOfThreads ( context ) ; mapClass = getMapperClass ( context ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Configuring-multithread-runner-to-use-" + numberOfThreads + "-threads" ) ; } executor = Executors . newFixedThreadPool ( numberOfThreads ) ; for ( int i = 0 ; i < numberOfThreads ; ++ i ) { MapRunner thread = new MapRunner ( context ) ; executor . execute ( thread ) ; } executor . shutdown ( ) ; while ( ! executor . isTerminated ( ) ) { Thread . sleep ( 1000 ) ; } } 
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj instanceof LocalTime ) { LocalTime other = ( LocalTime ) obj ; return hour == other . hour && minute == other . minute && second == other . second && nano == other . nano ; } return false ; } 
public static void addSecurityPolicy ( SecurityPolicy policy ) { policies . put ( policy . policyUri , policy ) ; } 
public List < String > getAllServletName ( ) { List < String > result = new ArrayList < String > ( ) ; List < Node > nodes = childNode . get ( "servlet-name" ) ; for ( Node node : nodes ) { result . add ( node . getText ( ) ) ; } return result ; } 
public XMLGregorianCalendar newXMLGregorianCalendarDate ( final int year , final int month , final int day , final int timezone ) { return newXMLGregorianCalendar ( year , month , day , DatatypeConstants . FIELD_UNDEFINED , DatatypeConstants . FIELD_UNDEFINED , DatatypeConstants . FIELD_UNDEFINED , DatatypeConstants . FIELD_UNDEFINED , timezone ) ; } 
public void write ( DataOutput out ) throws IOException { out . writeShort ( major ) ; out . writeShort ( minor ) ; } 
public int getStartOffset ( ) { return p0 . getOffset ( ) ; } 
public boolean isLargerThan ( Complex that ) { return this . magnitude ( ) > that . magnitude ( ) ; } 
public double totalCount ( ) { double total = 0.0 ; for ( Map . Entry < E , Double > entry : entries . entrySet ( ) ) { total += entry . getValue ( ) ; } return total ; } 
private void splitVarDeclarations ( Node n ) { for ( Node next , c = n . getFirstChild ( ) ; c != null ; c = next ) { next = c . getNext ( ) ; if ( c . isVar ( ) ) { if ( assertOnChange && ! c . hasChildren ( ) ) { throw new IllegalStateException ( "Empty-VAR-node." ) ; } while ( c . getFirstChild ( ) != c . getLastChild ( ) ) { Node name = c . getFirstChild ( ) ; c . removeChild ( name ) ; Node newVar = IR . var ( name ) . srcref ( n ) ; n . addChildBefore ( newVar , c ) ; reportCodeChange ( "VAR-with-multiple-children" ) ; } } } } 
public void setBit ( int index ) { if ( index < 0 ) { return ; } int byteIndex = index / 8 ; int newByteSize = byteIndex + 1 ; if ( bytes . length < newByteSize ) { bytes = Arrays . copyOf ( bytes , newByteSize ) ; } int bitIndex = index % 8 ; int mask = 1 << bitIndex ; bytes [ byteIndex ] |= mask ; } 
public static String responseCode ( String response ) { return response . substring ( 0 , 3 ) ; } 
public void print ( int inum ) { print ( String . valueOf ( inum ) ) ; } 
void setupEndValue ( Object target ) { setupValue ( target , mKeyframeSet . mKeyframes . get ( mKeyframeSet . mKeyframes . size ( ) - 1 ) ) ; } 
public BufferedImage createCompatibleDestImage ( BufferedImage src , ColorModel dstCM ) { if ( dstCM != null ) return new BufferedImage ( dstCM , src . getRaster ( ) . createCompatibleWritableRaster ( ) , src . isAlphaPremultiplied ( ) , null ) ; return new BufferedImage ( src . getWidth ( ) , src . getHeight ( ) , src . getType ( ) ) ; } 
private boolean add ( SyncOperation operation , SyncStorageEngine . PendingOperation pop ) { final String operationKey = operation . key ; final SyncOperation existingOperation = mOperationsMap . get ( operationKey ) ; if ( existingOperation != null ) { boolean changed = false ; if ( operation . compareTo ( existingOperation ) <= 0 ) { long newRunTime = Math . min ( existingOperation . latestRunTime , operation . latestRunTime ) ; existingOperation . latestRunTime = newRunTime ; existingOperation . flexTime = operation . flexTime ; changed = true ; } return changed ; } operation . pendingOperation = pop ; if ( operation . pendingOperation == null ) { pop = mSyncStorageEngine . insertIntoPending ( operation ) ; if ( pop == null ) { throw new IllegalStateException ( "error-adding-pending-sync-operation-" + operation ) ; } operation . pendingOperation = pop ; } mOperationsMap . put ( operationKey , operation ) ; return true ; } 
@ Override public Query rewrite ( IndexReader reader ) throws IOException { int numDisjunctions = disjuncts . size ( ) ; if ( numDisjunctions == 1 ) { Query singleton = disjuncts . get ( 0 ) ; Query result = singleton . rewrite ( reader ) ; if ( getBoost ( ) != 1.0f ) { if ( result == singleton ) result = result . clone ( ) ; result . setBoost ( getBoost ( ) * result . getBoost ( ) ) ; } return result ; } DisjunctionMaxQuery clone = null ; for ( int i = 0 ; i < numDisjunctions ; i ++ ) { Query clause = disjuncts . get ( i ) ; Query rewrite = clause . rewrite ( reader ) ; if ( rewrite != clause ) { if ( clone == null ) clone = this . clone ( ) ; clone . disjuncts . set ( i , rewrite ) ; } } if ( clone != null ) return clone ; else return this ; } 
private static final int getStatusOfDownload ( Cursor c , long redownload_threshold ) { int status = c . getInt ( DOWNLOADS_COLUMN_STATUS ) ; long realtime = SystemClock . elapsedRealtime ( ) ; if ( ! android . provider . Downloads . Impl . isStatusCompleted ( status ) ) { long modified = c . getLong ( DOWNLOADS_COLUMN_LAST_MODIFICATION ) ; long now = System . currentTimeMillis ( ) ; if ( now < modified || now - modified > redownload_threshold ) { return STATUS_INVALID ; } return STATUS_DOWNLOADING_UPDATE ; } if ( android . provider . Downloads . Impl . isStatusError ( status ) ) { return STATUS_INVALID ; } String filename = c . getString ( DOWNLOADS_COLUMN_FILENAME ) ; if ( filename == null ) { return STATUS_INVALID ; } return STATUS_DOWNLOADED_UPDATE ; } 
@ Override public synchronized List < RMContainer > getReservedContainers ( ) { List < RMContainer > reservedContainers = new ArrayList < RMContainer > ( ) ; for ( Map . Entry < Priority , Map < NodeId , RMContainer >> e : this . reservedContainers . entrySet ( ) ) { reservedContainers . addAll ( e . getValue ( ) . values ( ) ) ; } return reservedContainers ; } 
@ XmlElementDecl ( namespace = "http://schema.sksPackage.org/2013/ShippingService" , name = "City" , scope = Address . class ) public JAXBElement < String > createAddressCity ( String value ) { return new JAXBElement < String > ( _AddressCity_QNAME , String . class , Address . class , value ) ; } 
public void addMessage ( String message , int xPos , int yPos ) { Graphics2D graphics2d = bufferedImage . createGraphics ( ) ; graphics2d . setPaint ( Color . white ) ; graphics2d . setFont ( new Font ( "Helvetica" , Font . BOLD , 16 ) ) ; graphics2d . drawString ( message , xPos , yPos ) ; } 
private void readObject ( ObjectInputStream ois ) throws ClassNotFoundException , IOException { ois . defaultReadObject ( ) ; needsSyncChildren ( false ) ; } 
public Option getOption ( String optionflag ) throws MaltChainedException { Option option = flagOptionMap . get ( optionflag ) ; if ( option == null ) { throw new OptionException ( "The-option-flag--" + optionflag + "-could-not-be-found.-" ) ; } return option ; } 
static synchronized XPStyle getXP ( ) { if ( themeActive == null ) { Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; themeActive = ( Boolean ) toolkit . getDesktopProperty ( "win.xpstyle.themeActive" ) ; if ( themeActive == null ) { themeActive = Boolean . FALSE ; } if ( themeActive . booleanValue ( ) ) { GetPropertyAction propertyAction = new GetPropertyAction ( "swing.noxp" ) ; if ( AccessController . doPrivileged ( propertyAction ) == null && ThemeReader . isThemed ( ) && ! ( UIManager . getLookAndFeel ( ) instanceof WindowsClassicLookAndFeel ) ) { xp = new XPStyle ( ) ; } } } return xp ; } 
protected AbstractAnnotation ( ) { this . listenerList = new EventListenerList ( ) ; } 
public static < T > Predicate < T > or ( final Predicate < T > ... that ) { return new OrPredicate < T > ( that ) ; } 
public static int skipWhitespace ( String input , int pos ) { for ( ; pos < input . length ( ) ; pos ++ ) { char c = input . charAt ( pos ) ; if ( c != '-' && c != '|t' ) { break ; } } return pos ; } 
public Dimension getMinimumSize ( JComponent c ) { Dimension result = null ; Iterator iterator = uis . iterator ( ) ; if ( iterator . hasNext ( ) ) { ComponentUI ui = ( ComponentUI ) iterator . next ( ) ; result = ui . getMinimumSize ( c ) ; } while ( iterator . hasNext ( ) ) { ComponentUI ui = ( ComponentUI ) iterator . next ( ) ; ui . getMinimumSize ( c ) ; } return result ; } 
public boolean on ( ASN1ObjectIdentifier stem ) { String id = getId ( ) , stemId = stem . getId ( ) ; return id . length ( ) > stemId . length ( ) && id . charAt ( stemId . length ( ) ) == '.' && id . startsWith ( stemId ) ; } 
@ Override public int hashCode ( ) { return format . hashCode ( ) ; } 
public final static String getElementValue ( Node elem ) { Node kid ; if ( elem != null ) { if ( elem . hasChildNodes ( ) ) { for ( kid = elem . getFirstChild ( ) ; kid != null ; kid = kid . getNextSibling ( ) ) { if ( kid . getNodeType ( ) == Node . TEXT_NODE ) { return kid . getNodeValue ( ) ; } } } } return "" ; } 
public final boolean isFinal ( ) { return Modifier . isFinal ( getModifiers ( ) ) ; } 
@ Transient public static Map < EProcessingState , Integer > toCountMap ( Map < EProcessingState , Integer > countMap ) { Map < EProcessingState , Integer > retCountMap = new TreeMap < EProcessingState , Integer > ( ) ; Collection < Integer > counts = countMap . values ( ) ; float totalCount = 0 ; for ( Integer count : counts ) { totalCount = totalCount + count ; } if ( totalCount > 0 ) { retCountMap . putAll ( countMap ) ; } else { retCountMap . put ( EProcessingState . NO_PARTICIPATIONS , 1 ) ; } return retCountMap ; } 
private void verifySemicolon ( StringTokenizer tokenizer ) throws IOException { if ( tokenizer . hasMoreTokens ( ) ) { String semicolon = tokenizer . nextToken ( ) ; if ( ! semicolon . equals ( ";" ) ) { throw new IOException ( "Error:-Expected-semicolon-in-stream-actual='" + semicolon + "'" ) ; } } else { throw new IOException ( "CharMetrics-is-missing-a-semicolon-after-a-command" ) ; } } 
protected void drawVerticalLine ( Graphics2D g2 , Rectangle2D dataArea , double value , Stroke stroke , Paint paint ) { double xx = getDomainAxis ( ) . valueToJava2D ( value , dataArea , RectangleEdge . BOTTOM ) ; Line2D line = new Line2D . Double ( xx , dataArea . getMinY ( ) , xx , dataArea . getMaxY ( ) ) ; g2 . setStroke ( stroke ) ; g2 . setPaint ( paint ) ; g2 . draw ( line ) ; } 
public static String getNodeAttrText ( Node node , String attribute ) { Attr attr = ( Attr ) node . getAttributes ( ) . getNamedItem ( attribute ) ; if ( attr == null ) { return "" ; } else { return attr . getNodeValue ( ) ; } } 
private String getFileExtension ( String fileName ) { String extension = null ; int index = fileName . lastIndexOf ( '.' ) ; if ( index > - 1 && ( index < fileName . length ( ) - 1 ) ) { extension = fileName . substring ( index + 1 ) ; } return extension ; } 
@ Override public final int charLength ( ) { return _value . length ( ) ; } 
public boolean dispatchMediaButtonEvent ( @ NonNull KeyEvent keyEvent ) { if ( keyEvent == null ) { throw new IllegalArgumentException ( "KeyEvent-may-not-be-null" ) ; } if ( ! KeyEvent . isMediaKey ( keyEvent . getKeyCode ( ) ) ) { return false ; } try { return mSessionBinder . sendMediaButton ( keyEvent ) ; } catch ( RemoteException e ) { } return false ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public List < LearnerHandler > getObservingLearners ( ) { synchronized ( observingLearners ) { return new ArrayList < LearnerHandler > ( observingLearners ) ; } } 
static void addEvent ( ControllerEvent event ) { if ( event != null ) { events . add ( event ) ; } } 
private static byte getCachedDirectionality ( char c ) { return c < DIR_TYPE_CACHE_SIZE ? DIR_TYPE_CACHE [ c ] : Character . getDirectionality ( c ) ; } 
public static boolean equals ( double [ ] array1 , double [ ] array2 ) { if ( array1 == array2 ) { return true ; } if ( array1 == null || array2 == null || array1 . length != array2 . length ) { return false ; } for ( int i = 0 ; i < array1 . length ; i ++ ) { if ( Double . doubleToLongBits ( array1 [ i ] ) != Double . doubleToLongBits ( array2 [ i ] ) ) { return false ; } } return true ; } 
public final void signal ( ) { if ( ! isHeldExclusively ( ) ) throw new IllegalMonitorStateException ( ) ; Node first = firstWaiter ; if ( first != null ) doSignal ( first ) ; } 
public int nextSetBit ( int fromIndex ) { if ( fromIndex < 0 ) throw new IndexOutOfBoundsException ( "fromIndex-<-0:-" + fromIndex ) ; int u = unitIndex ( fromIndex ) ; if ( u >= unitsInUse ) return - 1 ; int testIndex = ( fromIndex & BIT_INDEX_MASK ) ; long unit = bits [ u ] >> testIndex ; if ( unit == 0 ) testIndex = 0 ; while ( ( unit == 0 ) && ( u < unitsInUse - 1 ) ) unit = bits [ ++ u ] ; if ( unit == 0 ) return - 1 ; testIndex += trailingZeroCnt ( unit ) ; return ( ( u * BITS_PER_UNIT ) + testIndex ) ; } 
public static TypeCode type ( ) { ORB orb = OrbRestricted . Singleton ; TypeCode component = orb . create_string_tc ( 0 ) ; return orb . create_alias_tc ( id ( ) , "AdapterName" , component ) ; } 
@ Override public void close ( ) throws IOException { if ( in != null ) { in . close ( ) ; } in = null ; } 
@ Override public boolean ready ( ) throws IOException { synchronized ( lock ) { return in . ready ( ) ; } } 
private static EncodingType encodingFromElement ( Element element ) throws Exception { EncodingType result = new EncodingType ( ) ; if ( ! ENCODING_ELEMENT . equals ( element . getLocalName ( ) ) || ! NAMESPACE . equals ( getNamespaceUri ( element ) ) ) { throw new Exception ( "encoding-element-is-invalid" ) ; } NamedNodeMap attributes = element . getAttributes ( ) ; for ( int i = 0 ; i < attributes . getLength ( ) ; i ++ ) { Attr attribute = ( Attr ) attributes . item ( i ) ; String namespaceUri = getNamespaceUri ( attribute ) ; if ( namespaceUri == null ) { throw new Exception ( "encoding-element-is-invalid" ) ; } if ( isStandartXmlNamespace ( namespaceUri ) ) { continue ; } if ( NAMESPACE . equals ( namespaceUri ) ) { throw new Exception ( "encoding-element-is-invalid" ) ; } QName qName = new QName ( namespaceUri , attribute . getLocalName ( ) , attribute . getPrefix ( ) == null ? "" : attribute . getPrefix ( ) ) ; result . getAnyAttributes ( ) . put ( qName , attribute . getValue ( ) ) ; } NodeList childNodes = element . getChildNodes ( ) ; for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) { Node node = childNodes . item ( i ) ; if ( node . getNodeType ( ) == Node . ELEMENT_NODE ) { throw new Exception ( "encoding-element-is-invalid" ) ; } } result . setValue ( element . getTextContent ( ) ) ; return result ; } 
public void reset ( ) { contexts = new Context [ 32 ] ; namespaceDeclUris = false ; contextPos = 0 ; contexts [ contextPos ] = currentContext = new Context ( ) ; currentContext . declarePrefix ( "xml" , XMLNS ) ; } 
@ Override public int getC_TaxGroup_ID ( ) { Integer ii = ( Integer ) get_Value ( COLUMNNAME_C_TaxGroup_ID ) ; if ( ii == null ) return 0 ; return ii . intValue ( ) ; } 
public boolean readBoolean ( ) throws IOException { return bin . readBoolean ( ) ; } 
public synchronized void sendMessage ( String message ) throws RemoteException { Object [ ] sockets , inputs , outputs ; synchronized ( clientSockets ) { sockets = clientSockets . toArray ( ) ; inputs = clientInputs . toArray ( ) ; outputs = clientOutputs . toArray ( ) ; } for ( int i = 0 ; i < sockets . length ; i ++ ) { updateClient ( message , ( Socket ) sockets [ i ] , ( DataInputStream ) inputs [ i ] , ( DataOutputStream ) outputs [ i ] ) ; } } 
private final void cleanUpActivityLocked ( HistoryRecord r , boolean cleanServices ) { if ( mResumedActivity == r ) { mResumedActivity = null ; } if ( mFocusedActivity == r ) { mFocusedActivity = null ; } r . configDestroy = false ; r . frozenBeforeDestroy = false ; mFinishingActivities . remove ( r ) ; mWaitingVisibleActivities . remove ( r ) ; if ( r . finishing && r . pendingResults != null ) { for ( WeakReference < PendingIntentRecord > apr : r . pendingResults ) { PendingIntentRecord rec = apr . get ( ) ; if ( rec != null ) { cancelIntentSenderLocked ( rec , false ) ; } } r . pendingResults = null ; } if ( cleanServices ) { cleanUpActivityServicesLocked ( r ) ; } if ( mPendingThumbnails . size ( ) > 0 ) { mCancelledThumbnails . add ( r ) ; } mHandler . removeMessages ( PAUSE_TIMEOUT_MSG , r ) ; mHandler . removeMessages ( IDLE_TIMEOUT_MSG , r ) ; } 
@ Override public void flushBuffer ( byte [ ] b , int offset , int size ) throws IOException { file . write ( b , offset , size ) ; } 
List < WifiConfiguration > getConfiguredNetworks ( ) { List < WifiConfiguration > networks = new ArrayList < WifiConfiguration > ( ) ; for ( WifiConfiguration config : mConfiguredNetworks . values ( ) ) { networks . add ( new WifiConfiguration ( config ) ) ; } return networks ; } 
public static OrderLocateXIDObjectFilter fromMapFilter ( Map record , String rootName ) { if ( record == null ) return null ; if ( rootName == null ) rootName = "OrderLocateXIDObject" ; Map root = ( Map ) record . get ( rootName ) ; if ( root == null ) return null ; return getFilter ( root ) ; } 
public static String write ( List < Product > products ) { StringBuilder builder = new StringBuilder ( ) ; for ( Iterator < Product > iterator = products . iterator ( ) ; iterator . hasNext ( ) ; ) { Product product = iterator . next ( ) ; if ( ( product . getName ( ) == null ) || ( product . getName ( ) . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "Product-name-cannot-be-null." ) ; } builder . append ( product . getName ( ) ) ; if ( product . getVersion ( ) != null ) { builder . append ( "/" ) . append ( product . getVersion ( ) ) ; } if ( product . getComment ( ) != null ) { builder . append ( "-(" ) . append ( product . getComment ( ) ) . append ( ")" ) ; } if ( iterator . hasNext ( ) ) { builder . append ( "-" ) ; } } return builder . toString ( ) ; } 
public Individual recombine ( Individual other ) { Random rand = new Random ( ) ; int position = rand . nextInt ( size ) + 1 ; System . out . println ( "random-number-is" + position ) ; for ( int i = ( position - 1 ) ; i < size ; i ++ ) { this . attributes [ i ] = other . attributes [ i ] ; } return this ; } 
public static void sort ( double [ ] a ) { sort2 ( a , 0 , a . length ) ; } 
public static void printHashKey ( Context context ) { try { PackageInfo info = context . getPackageManager ( ) . getPackageInfo ( context . getPackageName ( ) , PackageManager . GET_SIGNATURES ) ; for ( Signature signature : info . signatures ) { MessageDigest md = MessageDigest . getInstance ( "SHA" ) ; md . update ( signature . toByteArray ( ) ) ; Log . d ( TAG , "Application-hashKey-=-" + Base64 . encodeToString ( md . digest ( ) , Base64 . DEFAULT ) ) ; } } catch ( NameNotFoundException e ) { } catch ( NoSuchAlgorithmException e ) { } } 
public Long ( java . lang . String name , InputStream i ) throws IOException , FormatException { this ( name , new DataInputStream ( i ) . readLong ( ) ) ; } 
public boolean containsKey ( double key ) { if ( m_Cache . containsKey ( key ) ) { return true ; } return false ; } 
private void readObject ( ObjectInputStream s ) throws ClassNotFoundException , IOException { if ( GraphicsEnvironment . isHeadless ( ) ) throw new HeadlessException ( ) ; s . defaultReadObject ( ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public void testSerialization ( ) { LevelRenderer r1 = new LevelRenderer ( ) ; LevelRenderer r2 = null ; try { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; ObjectOutput out = new ObjectOutputStream ( buffer ) ; out . writeObject ( r1 ) ; out . close ( ) ; ObjectInput in = new ObjectInputStream ( new ByteArrayInputStream ( buffer . toByteArray ( ) ) ) ; r2 = ( LevelRenderer ) in . readObject ( ) ; in . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } assertEquals ( r1 , r2 ) ; } 
private JTextField getJTextFieldDbscanEps ( ) { if ( jTextFieldDbscanEps == null ) { jTextFieldDbscanEps = new JTextField ( ) ; jTextFieldDbscanEps . setBounds ( new Rectangle ( 78 , 33 , 34 , 20 ) ) ; jTextFieldDbscanEps . setText ( "12" ) ; } return jTextFieldDbscanEps ; } 
public int compareTypeSave ( Value a , Value b ) { return a . compareTypeSave ( b , compareMode ) ; } 
private void doAcquireShared ( long arg ) { final Node node = addWaiter ( Node . SHARED ) ; boolean failed = true ; try { boolean interrupted = false ; for ( ; ; ) { final Node p = node . predecessor ( ) ; if ( p == head ) { long r = tryAcquireShared ( arg ) ; if ( r >= 0 ) { setHeadAndPropagate ( node , r ) ; p . next = null ; if ( interrupted ) selfInterrupt ( ) ; failed = false ; return ; } } if ( shouldParkAfterFailedAcquire ( p , node ) && parkAndCheckInterrupt ( ) ) interrupted = true ; } } finally { if ( failed ) cancelAcquire ( node ) ; } } 
public void addFile ( String tag , File file , int flags ) throws IOException { if ( file == null ) throw new NullPointerException ( "file-==-null" ) ; Entry entry = new Entry ( tag , 0 , file , flags ) ; try { mService . add ( entry ) ; } catch ( RemoteException e ) { } finally { entry . close ( ) ; } } 
public void setScripts ( Resource [ ] scripts ) { this . scripts = Arrays . asList ( scripts ) ; } 
public boolean intersects ( Point2D p1 , Point2D p2 ) { double xDiff = p2 . getX ( ) - p1 . getX ( ) ; double yDiff = p2 . getY ( ) - p1 . getY ( ) ; if ( this . piece > 0 || ( xDiff == 0 && yDiff == 0 ) ) { return false ; } if ( xDiff < 75 && yDiff < 75 ) return false ; Rectangle2D . Double rect = new Rectangle2D . Double ( ) ; rect . setFrame ( this . getX ( ) , this . getY ( ) , ( double ) 75 , ( double ) 75 ) ; boolean intersect = rect . getBounds2D ( ) . intersectsLine ( p1 . getX ( ) , p1 . getY ( ) , p2 . getX ( ) , p2 . getY ( ) ) ; if ( intersect ) { return true ; } else return false ; } 
protected boolean accept ( Component aComponent ) { if ( ! ( aComponent . isVisible ( ) && aComponent . isDisplayable ( ) && aComponent . isEnabled ( ) ) ) { return false ; } if ( ! ( aComponent instanceof Window ) ) { for ( Container enableTest = aComponent . getParent ( ) ; enableTest != null ; enableTest = enableTest . getParent ( ) ) { if ( ! ( enableTest . isEnabled ( ) || enableTest . isLightweight ( ) ) ) { return false ; } if ( enableTest instanceof Window ) { break ; } } } boolean focusable = aComponent . isFocusable ( ) ; if ( aComponent . isFocusTraversableOverridden ( ) ) { return focusable ; } ComponentPeer peer = aComponent . getPeer ( ) ; return ( peer != null && peer . isFocusable ( ) ) ; } 
public final Collection < Thread > getQueuedThreads ( ) { ArrayList < Thread > list = new ArrayList < Thread > ( ) ; for ( Node p = tail ; p != null ; p = p . prev ) { Thread t = p . thread ; if ( t != null ) list . add ( t ) ; } return list ; } 
private final boolean eq ( Object o1 , Object o2 ) { return o1 == o2 || ( ( o1 != null ) && o1 . equals ( o2 ) ) ; } 
@ Override public void readFields ( DataInput in ) throws IOException { seqno = in . readLong ( ) ; short numOfReplies = in . readShort ( ) ; replies = new short [ numOfReplies ] ; for ( int i = 0 ; i < numOfReplies ; i ++ ) { replies [ i ] = in . readShort ( ) ; } } 
public List < Integer > firstNum ( int fromNum , int toNum , int MaxNumber ) { this . maxNumber = MaxNumber ; List < Integer > alist = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < maxNumber ; i ++ ) { alist . add ( i , getIntRandomNum ( fromNum , toNum ) ) ; } return alist ; } 
public void add ( Object ele ) { mArray . add ( ele ) ; } 
public void processingInstruction ( String target , String data ) { out . print ( "<?" ) ; out . print ( target ) ; if ( data != null && data . length ( ) > 0 ) { out . print ( '-' ) ; out . print ( data ) ; } out . print ( "?>" ) ; } 
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! ( obj instanceof DigitList ) ) return false ; DigitList other = ( DigitList ) obj ; if ( count != other . count || decimalAt != other . decimalAt ) return false ; for ( int i = 0 ; i < count ; i ++ ) if ( digits [ i ] != other . digits [ i ] ) return false ; return true ; } 
private void checkForClosed ( ) { if ( handle == null || handle . equals ( "" ) ) throw new WebDriverException ( "Web-Window-closed-or-not-initialized" ) ; } 
public synchronized void progressValue ( int value ) { if ( this . progressDialog != null ) { this . progressDialog . setProgress ( value ) ; } } 
Vector < Books > buscarPorISBN ( String isbn ) throws SQLException { Vector < Books > resultado = new Vector < > ( ) ; Statement sentencia = conexion . createStatement ( ) ; ResultSet result = sentencia . executeQuery ( "SELECT-*-FROM-books-WHERE-isbn='" + isbn + "'" ) ; while ( result . next ( ) ) { Books books = new Books ( result . getInt ( "id_book" ) , result . getString ( "title" ) , result . getString ( "isbn" ) , result . getString ( "author" ) , result . getString ( "genre" ) , result . getString ( "date" ) , result . getString ( "img" ) , result . getString ( "publisher" ) , result . getString ( "info" ) ) ; resultado . add ( books ) ; } return resultado ; } 
public static void print ( double x ) { out . print ( x ) ; out . flush ( ) ; } 
public static < T > Response < T > error ( VolleyError error ) { return new Response < T > ( error ) ; } 
public int getLargestPoolSize ( ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { return largestPoolSize ; } finally { mainLock . unlock ( ) ; } } 
public double u ( double r2 ) { double s2 = sigma2 / r2 ; double sig_rn = 1 ; if ( n >= 1e6 ) { return r2 < sigma2 ? 0.0 : Double . POSITIVE_INFINITY ; } if ( n > 50 ) { sig_rn = Math . pow ( s2 , 0.5 * n ) ; } else { switch ( n ) { case 6 : sig_rn = s2 * s2 * s2 ; break ; case 9 : double s3 = s2 * Math . sqrt ( s2 ) ; sig_rn = s3 * s3 * s3 ; break ; case 12 : double s6 = s2 * s2 * s2 ; sig_rn = s6 * s6 ; break ; case 15 : double s5 = s2 * s2 * Math . sqrt ( s2 ) ; sig_rn = s5 * s5 * s5 ; break ; case 16 : double s4 = s2 * s2 ; sig_rn = s4 * s4 * s4 * s4 ; break ; case 20 : s4 = s2 * s2 ; sig_rn = s4 * s4 * s4 * s4 * s4 ; break ; case 24 : s4 = s2 * s2 ; double s8 = s4 * s4 ; sig_rn = s8 * s8 * s8 ; break ; default : for ( int i = 0 ; i < n / 2 ; i ++ ) { sig_rn *= s2 ; } if ( ! evenN ) { sig_rn *= Math . sqrt ( s2 ) ; } break ; } } return epsilon * sig_rn ; } 
public float ms_per_frame ( ) { if ( h_vbr == true ) { double tpf = h_vbr_time_per_frame [ layer ( ) ] / frequency ( ) ; if ( ( h_version == MPEG2_LSF ) || ( h_version == MPEG25_LSF ) ) tpf /= 2 ; return ( ( float ) ( tpf * 1000 ) ) ; } else { float ms_per_frame_array [ ] [ ] = { { 8.707483f , 8.0f , 12.0f } , { 26.12245f , 24.0f , 36.0f } , { 26.12245f , 24.0f , 36.0f } } ; return ( ms_per_frame_array [ h_layer - 1 ] [ h_sample_frequency ] ) ; } } 
public Border getBorder ( Object key , Locale l ) { Object value = get ( key , l ) ; return ( value instanceof Border ) ? ( Border ) value : null ; } 
private void createColorMap ( int size , byte r [ ] , byte g [ ] , byte b [ ] , byte a [ ] , int trans ) { if ( size < 1 ) { throw new IllegalArgumentException ( Messages . getString ( "awt.264" ) ) ; } mapSize = size ; colorMap = new int [ mapSize ] ; if ( trans >= 0 && trans < mapSize ) { transparency = Transparency . BITMASK ; transparentIndex = trans ; } else { transparency = Transparency . OPAQUE ; transparentIndex = - 1 ; } int alpha = 0 ; for ( int i = 0 ; i < mapSize ; i ++ ) { colorMap [ i ] = ( ( r [ i ] & 0xff ) << 16 ) | ( ( g [ i ] & 0xff ) << 8 ) | ( b [ i ] & 0xff ) ; if ( trans == i ) { continue ; } if ( a == null ) { colorMap [ i ] |= 0xff000000 ; } else { alpha = a [ i ] & 0xff ; if ( alpha == 0xff ) { colorMap [ i ] |= 0xff000000 ; } else if ( alpha == 0 ) { if ( transparency == Transparency . OPAQUE ) { transparency = Transparency . BITMASK ; } if ( transparentIndex < 0 ) { transparentIndex = i ; } } else { colorMap [ i ] |= ( a [ i ] & 0xff ) << 24 ; if ( transparency != Transparency . TRANSLUCENT ) { transparency = Transparency . TRANSLUCENT ; } } } } } 
public < T extends Result > T getResult ( int i , Class < T > type ) { Object result = results . get ( i ) ; if ( result != null && type . getName ( ) . equals ( result . getClass ( ) . getName ( ) ) ) return ( T ) result ; return null ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public Scope getDefiningScope ( String name ) { for ( Scope s = this ; s != null ; s = s . parentScope ) { Map < String , Symbol > symbolTable = s . getSymbolTable ( ) ; if ( symbolTable != null && symbolTable . containsKey ( name ) ) { return s ; } } return null ; } 
Messenger ( QuorumCnxManager manager ) { this . ws = new WorkerSender ( manager ) ; Thread t = new Thread ( this . ws , "WorkerSender-Thread" ) ; t . setDaemon ( true ) ; t . start ( ) ; this . wr = new WorkerReceiver ( manager ) ; t = new Thread ( this . wr , "WorkerReceiver-Thread" ) ; t . setDaemon ( true ) ; t . start ( ) ; } 
static void send ( PlainDatagramSocketImpl socket , DatagramPacket packet ) throws IOException { nativeSendTo ( socket , packet . getAddress ( ) , packet . getPort ( ) , packet . getData ( ) , packet . getOffset ( ) , packet . getLength ( ) ) ; } 
public static List < String > getSearchableIsoDataTypeFieldsWithFN ( Field field , List attrs ) { String typeName = field . getType ( ) . getName ( ) ; log . debug ( "typeName:-" + typeName ) ; if ( typeName . equals ( "gov.nih.nci.iso21090.Ad" ) || typeName . equals ( "gov.nih.nci.iso21090.En" ) || typeName . equals ( "gov.nih.nci.iso21090.EnOn" ) || typeName . equals ( "gov.nih.nci.iso21090.EnPn" ) ) return getSearchableIsoDataTypeFieldsForAd ( field , attrs ) ; else if ( typeName . equals ( "gov.nih.nci.iso21090.DSet" ) ) return getSearchableIsoDataTypeFieldsForDsetAd ( field , attrs ) ; else if ( typeName . equals ( "gov.nih.nci.iso21090.Cd" ) ) return getSearchableIsoDataTypeFieldsForCd ( field , attrs ) ; else if ( typeName . equals ( "gov.nih.nci.iso21090.Sc" ) || typeName . equals ( "gov.nih.nci.iso21090.Ivl" ) ) return getSearchableIsoDataTypeFieldsForSc ( field , attrs ) ; String fieldName = field . getName ( ) ; List < String > fnAttrs = new ArrayList ( ) ; Iterator iter = attrs . iterator ( ) ; while ( iter . hasNext ( ) ) { Object obj = iter . next ( ) ; if ( obj instanceof java . lang . String ) { String value = ( String ) obj ; if ( field . getName ( ) . equals ( value ) ) fnAttrs . add ( value ) ; else fnAttrs . add ( field . getName ( ) + "." + value ) ; } } return fnAttrs ; } 
@ Override protected void drawNeedle ( Graphics2D g2 , Rectangle2D plotArea , Point2D rotate , double angle ) { Line2D shape = new Line2D . Double ( ) ; double x = plotArea . getMinX ( ) + ( plotArea . getWidth ( ) / 2 ) ; shape . setLine ( x , plotArea . getMinY ( ) , x , plotArea . getMaxY ( ) ) ; Shape s = shape ; if ( ( rotate != null ) && ( angle != 0 ) ) { getTransform ( ) . setToRotation ( angle , rotate . getX ( ) , rotate . getY ( ) ) ; s = getTransform ( ) . createTransformedShape ( s ) ; } defaultDisplay ( g2 , s ) ; } 
public boolean isPrivateDnsRouteSet ( ) { return mPrivateDnsRouteSet . get ( ) ; } 
public static Object wrap ( Object object ) { try { if ( object == null ) { return NULL ; } if ( object instanceof JSONObject || object instanceof JSONArray || NULL . equals ( object ) || object instanceof JSONString || object instanceof Byte || object instanceof Character || object instanceof Short || object instanceof Integer || object instanceof Long || object instanceof Boolean || object instanceof Float || object instanceof Double || object instanceof String ) { return object ; } if ( object instanceof Collection ) { return new JSONArray ( ( Collection ) object ) ; } if ( object . getClass ( ) . isArray ( ) ) { return new JSONArray ( object ) ; } if ( object instanceof Map ) { return new JSONObject ( ( Map ) object ) ; } Package objectPackage = object . getClass ( ) . getPackage ( ) ; String objectPackageName = objectPackage != null ? objectPackage . getName ( ) : "" ; if ( objectPackageName . startsWith ( "java." ) || objectPackageName . startsWith ( "javax." ) || object . getClass ( ) . getClassLoader ( ) == null ) { return object . toString ( ) ; } return new JSONObject ( object ) ; } catch ( Exception exception ) { return null ; } } 
public Constructor getDeclaredConstructor ( Class [ ] parameterTypes ) throws NoSuchMethodException , SecurityException { checkMemberAccess ( Member . DECLARED , ClassLoader . getCallerClassLoader ( ) ) ; return getConstructor0 ( parameterTypes , Member . DECLARED ) ; } 
public boolean shouldYieldFocus ( JComponent input ) { return verify ( input ) ; } 
public static boolean isFileExist ( String filePath ) { if ( StringUtils . isBlank ( filePath ) ) { return false ; } File file = new File ( filePath ) ; return ( file . exists ( ) && file . isFile ( ) ) ; } 
public static void encodeFileToFile ( String infile , String outfile ) throws java . io . IOException { String encoded = Base64 . encodeFromFile ( infile ) ; java . io . OutputStream out = null ; try { out = new java . io . BufferedOutputStream ( new java . io . FileOutputStream ( outfile ) ) ; out . write ( encoded . getBytes ( "US-ASCII" ) ) ; } catch ( java . io . IOException e ) { throw e ; } finally { try { out . close ( ) ; } catch ( Exception ex ) { } } } 
private int nextTlsMode ( ) { if ( nextTlsMode == TLS_MODE_MODERN ) { nextTlsMode = TLS_MODE_COMPATIBLE ; return TLS_MODE_MODERN ; } else if ( nextTlsMode == TLS_MODE_COMPATIBLE ) { nextTlsMode = TLS_MODE_NULL ; return TLS_MODE_COMPATIBLE ; } else { throw new AssertionError ( ) ; } } 
public String getPath ( ) throws Exception { return label . getPath ( ) ; } 
public void readGroup ( AttributeSet attrs ) { groupId = attrs . getAttributeResourceValue ( XML_NS , "id" , defaultGroupId ) ; groupCategory = attrs . getAttributeIntValue ( XML_NS , "menuCategory" , defaultItemCategory ) ; groupOrder = attrs . getAttributeIntValue ( XML_NS , "orderInCategory" , defaultItemOrder ) ; groupCheckable = attrs . getAttributeIntValue ( XML_NS , "checkableBehavior" , defaultItemCheckable ) ; groupVisible = attrs . getAttributeBooleanValue ( XML_NS , "visible" , defaultItemVisible ) ; groupEnabled = attrs . getAttributeBooleanValue ( XML_NS , "enabled" , defaultItemEnabled ) ; } 
public static String getTempDirectoryPath ( Context ctx ) { File cache = null ; if ( Environment . getExternalStorageState ( ) . equals ( Environment . MEDIA_MOUNTED ) ) { cache = new File ( Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) + "/Android/data/" + ctx . getPackageName ( ) + "/cache/" ) ; } else { cache = ctx . getCacheDir ( ) ; } if ( ! cache . exists ( ) ) { cache . mkdirs ( ) ; } return cache . getAbsolutePath ( ) ; } 
public void setGravity ( int gravity ) { if ( mGravity != gravity ) { if ( ( gravity & Gravity . HORIZONTAL_GRAVITY_MASK ) == 0 ) { gravity |= Gravity . START ; } mGravity = gravity ; requestLayout ( ) ; } } 
public static String requestPath ( URL url ) { String fileOnly = url . getFile ( ) ; if ( fileOnly == null ) { return "/" ; } else if ( ! fileOnly . startsWith ( "/" ) ) { return "/" + fileOnly ; } else { return fileOnly ; } } 
private void fireMessageEventNotificationListeners ( String from , String packetID , String methodName ) { MessageEventNotificationListener [ ] listeners = null ; Method method ; synchronized ( messageEventNotificationListeners ) { listeners = new MessageEventNotificationListener [ messageEventNotificationListeners . size ( ) ] ; messageEventNotificationListeners . toArray ( listeners ) ; } try { method = MessageEventNotificationListener . class . getDeclaredMethod ( methodName , new Class [ ] { String . class , String . class } ) ; for ( int i = 0 ; i < listeners . length ; i ++ ) { method . invoke ( listeners [ i ] , new Object [ ] { from , packetID } ) ; } } catch ( NoSuchMethodException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } 
public String getProperty ( String par1Str , String par2Str ) { if ( ! this . properties . containsKey ( par1Str ) ) { this . properties . setProperty ( par1Str , par2Str ) ; this . saveProperties ( ) ; } return this . properties . getProperty ( par1Str , par2Str ) ; } 
public final void setBuffering ( boolean buffering ) { this . buffering = buffering ; if ( ! buffering ) lines = new StringBuilder ( ) ; } 
public int indexOf ( byte b ) { return indexOf ( b , 0 , this . len ) ; } 
@ NotNull @ Override public final Collection < V > values ( ) { Collection < V > vs ; return ( vs = values ) != null ? vs : ( values = new Values ( ) ) ; } 
public static boolean isPackageExists ( Context context , String packageName ) { try { context . getPackageManager ( ) . getApplicationInfo ( packageName , 0 ) ; return true ; } catch ( PackageManager . NameNotFoundException e ) { return false ; } } 
public LightMap get ( int radius , Color color ) { LightMapKey key = new LightMapKey ( radius , color ) ; SoftReference < LightMap > ref = loadedLightMaps . get ( key ) ; LightMap current = ref == null ? null : ref . get ( ) ; if ( current != null ) { return current ; } else { loadedLightMaps . remove ( radius ) ; LightMap result = new LightMap ( device , radius , color ) ; loadedLightMaps . put ( key , new SoftReference < LightMap > ( result ) ) ; return result ; } } 
private boolean isValidHost ( boolean forceServer , String host ) throws URISyntaxException { if ( host . startsWith ( "[" ) ) { if ( ! host . endsWith ( "]" ) ) { throw new URISyntaxException ( host , "Expected-a-closing-square-bracket-for-IPv6-address" , 0 ) ; } if ( InetAddress . isNumeric ( host ) ) { return true ; } throw new URISyntaxException ( host , "Malformed-IPv6-address" ) ; } if ( host . indexOf ( '[' ) != - 1 || host . indexOf ( ']' ) != - 1 ) { throw new URISyntaxException ( host , "Illegal-character-in-host-name" , 0 ) ; } int index = host . lastIndexOf ( '.' ) ; if ( index < 0 || index == host . length ( ) - 1 || ! Character . isDigit ( host . charAt ( index + 1 ) ) ) { if ( isValidDomainName ( host ) ) { return true ; } if ( forceServer ) { throw new URISyntaxException ( host , "Illegal-character-in-host-name" , 0 ) ; } return false ; } try { InetAddress ia = InetAddress . parseNumericAddress ( host ) ; if ( ia instanceof Inet4Address ) { return true ; } } catch ( IllegalArgumentException ignored ) { } if ( forceServer ) { throw new URISyntaxException ( host , "Malformed-IPv4-address" , 0 ) ; } return false ; } 
void write ( DataOutput par1DataOutput ) throws IOException { par1DataOutput . writeDouble ( this . data ) ; } 
public void setFREETEXTBELOW ( JAXBElement < String > value ) { this . freetextbelow = ( ( JAXBElement < String > ) value ) ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public String readUTF ( ) throws IOException { return primitiveTypes . readUTF ( ) ; } 
private final void loadD16 ( ) { float d [ ] = null ; ObjectInputStream in = null ; try { in = new ObjectInputStream ( Resources . getResourceAsStream ( "system/resource/d16.ser" ) ) ; d = ( float [ ] ) in . readObject ( ) ; } catch ( Exception e ) { System . out . println ( "2-couldn't-load-the-array-for-the-SynthesisFilter-" ) ; System . exit ( 1 ) ; } finally { try { in . close ( ) ; } catch ( Exception e ) { } } int size = d . length / 16 ; d16 = new float [ size ] [ ] ; for ( int i = 0 ; i < size ; i ++ ) { d16 [ i ] = subArray ( d , i * 16 , 16 ) ; } } 
public static String padToColumn ( String stringToPad , int columnWidth ) { String blanks = "-" ; if ( stringToPad . length ( ) > columnWidth ) { return stringToPad . substring ( 0 , columnWidth ) ; } else { int blankLength = columnWidth - stringToPad . length ( ) ; return stringToPad + blanks . substring ( 0 , blankLength ) ; } } 
ConstantUtf8 ( DataInputStream file ) throws IOException { super ( Constants . CONSTANT_Utf8 ) ; bytes = file . readUTF ( ) ; } 
private void updateMatchScoresBasedOnNameMatches ( SQLiteDatabase db , long rawContactId , ContactMatcher matcher ) { mSelectionArgs1 [ 0 ] = String . valueOf ( rawContactId ) ; Cursor c = db . query ( NameLookupMatchQuery . TABLE , NameLookupMatchQuery . COLUMNS , NameLookupMatchQuery . SELECTION , mSelectionArgs1 , null , null , null , PRIMARY_HIT_LIMIT_STRING ) ; try { while ( c . moveToNext ( ) ) { long contactId = c . getLong ( NameLookupMatchQuery . CONTACT_ID ) ; String name = c . getString ( NameLookupMatchQuery . NAME ) ; int nameTypeA = c . getInt ( NameLookupMatchQuery . NAME_TYPE_A ) ; int nameTypeB = c . getInt ( NameLookupMatchQuery . NAME_TYPE_B ) ; matcher . matchName ( contactId , nameTypeA , name , nameTypeB , name , ContactMatcher . MATCHING_ALGORITHM_EXACT ) ; if ( nameTypeA == NameLookupType . NICKNAME && nameTypeB == NameLookupType . NICKNAME ) { matcher . updateScoreWithNicknameMatch ( contactId ) ; } } } finally { c . close ( ) ; } } 
public static java . util . Date getLastDayOfMonth ( Date date ) { Calendar cl = Calendar . getInstance ( ) ; if ( date != null ) cl . setTime ( date ) ; cl . add ( Calendar . MONTH , 1 ) ; cl . add ( Calendar . DATE , - cl . get ( Calendar . DAY_OF_MONTH ) ) ; return parseDate ( cl ) ; } 
@ Deprecated public static RequestAsyncTask executeStatusUpdateRequestAsync ( Session session , String message , Callback callback ) { return newStatusUpdateRequest ( session , message , callback ) . executeAsync ( ) ; } 
private void writeObject ( java . io . ObjectOutputStream poStream ) throws IOException { poStream . writeObject ( this . adSample ) ; } 
static public boolean classExists ( String classname ) { Class tmpClass = null ; try { tmpClass = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( classname ) ; } catch ( ClassNotFoundException cnfe ) { return false ; } catch ( IllegalArgumentException iae ) { return false ; } return true ; } 
public static String joinObjects ( CharSequence separator , Iterable < ? extends Object > objects ) { StringBuffer sb = new StringBuffer ( ) ; boolean first = true ; for ( Object o : objects ) { if ( first ) { first = false ; } else { sb . append ( separator ) ; } sb . append ( String . valueOf ( o ) ) ; } return sb . toString ( ) ; } 
public final boolean readBoolean ( ) throws IOException { int temp = this . read ( ) ; if ( temp < 0 ) { throw new EOFException ( ) ; } return temp != 0 ; } 
public void addTreeModelListener ( TreeModelListener l ) { treeModelListeners . addElement ( l ) ; } 
private AffineTransform toAwtTransform ( Transform swtTransform ) { float [ ] elements = new float [ 6 ] ; swtTransform . getElements ( elements ) ; AffineTransform awtTransform = new AffineTransform ( elements ) ; return awtTransform ; } 
private ActionMap createDefaultActions ( ) { ActionMapUIResource am = new ActionMapUIResource ( ) ; Action action = new NavigateAction ( "selectNext" ) ; am . put ( action . getValue ( Action . NAME ) , action ) ; action = new NavigateAction ( "selectPrevious" ) ; am . put ( action . getValue ( Action . NAME ) , action ) ; action = new NavigateAction ( "selectParent" ) ; am . put ( action . getValue ( Action . NAME ) , action ) ; action = new NavigateAction ( "selectChild" ) ; am . put ( action . getValue ( Action . NAME ) , action ) ; action = new NavigateAction ( "return" ) ; am . put ( action . getValue ( Action . NAME ) , action ) ; action = new NavigateAction ( "cancel" ) ; am . put ( action . getValue ( Action . NAME ) , action ) ; return am ; } 
public void print ( String s ) { writer . print ( s ) ; } 
public static void w ( String tag , String s , Object ... args ) { if ( LOG . WARN >= LOGLEVEL ) Log . w ( tag , String . format ( s , args ) ) ; } 
@ XmlElementDecl ( namespace = "http://www.xbrl.org/tw/fr/gaap/tw-gaap-fh-2010-03-31" , name = "ReceivablesNet" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < MonetaryItemType > createReceivablesNet ( MonetaryItemType value ) { return new JAXBElement < MonetaryItemType > ( _ReceivablesNet_QNAME , MonetaryItemType . class , null , value ) ; } 
@ Override public boolean needsTaskCommit ( TaskAttemptContext context ) throws IOException { return workPath != null && outputFileSystem . exists ( workPath ) ; } 
public void testFloatValuePositive2 ( ) { String a = "27467238945723645782" ; float result = 2.7467239E19f ; float aNumber = new BigInteger ( a ) . floatValue ( ) ; assertEquals ( result , aNumber , 1e12 ) ; } 
public void addSocket ( Socket s ) { conditions . addElement ( s ) ; } 
public CharEscaperBuilder addEscape ( char c , String r ) { map . put ( c , r ) ; if ( c > max ) { max = c ; } return this ; } 
public boolean equals ( Object other ) { if ( ! ( other instanceof BinaryTree < ? > ) ) return false ; BinaryTree < E > t2 = ( BinaryTree < E > ) other ; if ( hasLeft ( ) != t2 . hasLeft ( ) || hasRight ( ) != t2 . hasRight ( ) ) return false ; if ( ! data . equals ( t2 . data ) ) return false ; if ( hasLeft ( ) && ! left . equals ( t2 . left ) ) return false ; if ( hasRight ( ) && ! right . equals ( t2 . right ) ) return false ; return true ; } 
public void close ( ) { Enumeration enm = ( ( Vector ) listeners . clone ( ) ) . elements ( ) ; while ( enm . hasMoreElements ( ) ) { PiListener pil = ( PiListener ) enm . nextElement ( ) ; pil . close ( ) ; } dispose ( ) ; if ( standalone ) System . exit ( 0 ) ; } 
public String getNameInNamespace ( ) throws NamingException { return dirContext . getNameInNamespace ( ) ; } 
public int getCM_Media_ID ( ) { Integer ii = ( Integer ) get_Value ( COLUMNNAME_CM_Media_ID ) ; if ( ii == null ) return 0 ; return ii . intValue ( ) ; } 
public final FTPSrvSession findSession ( Integer id ) { return m_sessions . get ( id ) ; } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; elementList . add ( new javax . xml . namespace . QName ( "http://www.betfair.com/publicapi/v5/BFExchangeService/" , "Result" ) ) ; elementList . add ( localResult == null ? null : localResult ) ; return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
public static Triple < Long , Long , Long > solveDiophEqOne ( long a , long b , long c ) { if ( ( a == 0 ) && ( b == 0 ) ) return null ; Triple < Long , Long , Long > egcdResult = egcd ( Math . abs ( a ) , Math . abs ( b ) ) ; long x0 = egcdResult . get1 ( ) ; long y0 = egcdResult . get2 ( ) ; long g = egcdResult . get3 ( ) ; if ( c % g != 0 ) return null ; x0 *= c / g ; y0 *= c / g ; if ( a < 0 ) x0 *= - 1 ; if ( b < 0 ) y0 *= - 1 ; return new Triple < Long , Long , Long > ( x0 , y0 , g ) ; } 
private void checkOpenAndCreate ( boolean create ) throws SocketException { if ( isClosed ( ) ) { throw new SocketException ( "Socket-is-closed" ) ; } if ( ! create ) { if ( ! isConnected ( ) ) { throw new SocketException ( "Socket-is-not-connected" ) ; } return ; } if ( isCreated ) { return ; } synchronized ( this ) { if ( isCreated ) { return ; } try { impl . create ( true ) ; } catch ( SocketException e ) { throw e ; } catch ( IOException e ) { throw new SocketException ( e . toString ( ) ) ; } isCreated = true ; } } 
protected Instance process ( Instance instance ) throws Exception { m_Remove . input ( instance ) ; return m_Remove . output ( ) ; } 
public void write ( OutputStream os ) throws IOException { write ( this , os ) ; } 
private static int getWordEndPosition ( final String string , final int len , final int startIndex ) { int end ; int cp = 0 ; for ( end = startIndex + 1 ; end < len ; end += Character . charCount ( cp ) ) { cp = string . codePointAt ( end ) ; if ( ! ( cp == Constants . CODE_DASH || cp == Constants . CODE_SINGLE_QUOTE || Character . isLetter ( cp ) ) ) { break ; } } return end ; } 
public AstNode parse ( String code ) { Parser p = new Parser ( compilerEnvirons , null ) ; return p . parse ( code , null , 0 ) ; } 
@ Override public Object [ ] toArray ( final ResultSet _rs ) throws SQLException { final ResultSetMetaData metaData = _rs . getMetaData ( ) ; final int cols = metaData . getColumnCount ( ) ; final Object [ ] result = new Object [ cols ] ; for ( int i = 0 ; i < cols ; i ++ ) { switch ( metaData . getColumnType ( i + 1 ) ) { case java . sql . Types . TIMESTAMP : result [ i ] = _rs . getTimestamp ( i + 1 ) ; break ; default : result [ i ] = _rs . getObject ( i + 1 ) ; } } return result ; } 
public boolean offer ( E e , long timeout , TimeUnit unit ) throws InterruptedException { if ( e == null ) throw new NullPointerException ( ) ; long nanos = unit . toNanos ( timeout ) ; int c = - 1 ; final ReentrantLock putLock = this . putLock ; final AtomicInteger count = this . count ; putLock . lockInterruptibly ( ) ; try { while ( count . get ( ) == capacity ) { if ( nanos <= 0 ) return false ; nanos = notFull . awaitNanos ( nanos ) ; } enqueue ( new Node < E > ( e ) ) ; c = count . getAndIncrement ( ) ; if ( c + 1 < capacity ) notFull . signal ( ) ; } finally { putLock . unlock ( ) ; } if ( c == 0 ) signalNotEmpty ( ) ; return true ; } 
public Error createError ( ) { return new Error ( ) ; } 
protected int weightedDistribution ( int [ ] weights ) { int sum = 0 ; for ( int weight : weights ) { sum += weight ; } int val = ( int ) Math . floor ( m_random . nextDouble ( ) * sum ) ; for ( int i = 0 ; i < weights . length ; i ++ ) { val -= weights [ i ] ; if ( val < 0 ) { return i ; } } return - 1 ; } 
public List < FlightInfo > getFlightInfo ( ) { if ( flightInfo == null ) { flightInfo = new ArrayList < FlightInfo > ( ) ; } return this . flightInfo ; } 
public void clear ( ) { ArrayList < BttSurfaceView > tmp_view_list = new ArrayList < BttSurfaceView > ( ) ; synchronized ( view_list ) { tmp_view_list . addAll ( view_list ) ; view_list . clear ( ) ; } Iterator < BttSurfaceView > view_it = tmp_view_list . iterator ( ) ; while ( view_it . hasNext ( ) ) { BttSurfaceView v = view_it . next ( ) ; v . close ( ) ; } tmp_view_list . clear ( ) ; for ( int i = 0 ; i < num_textures2D ; ++ i ) { textures2D [ i ] . clearTextures ( ) ; textures2D [ i ] = null ; } index = null ; status = null ; int_lonlat = null ; int_h = null ; int_dh = null ; int_cartesian = null ; own_obj_radius = null ; tot_obj_radius = null ; tot_dev = null ; source = null ; ellps = null ; } 
public final CDATASection createCDATASection ( final String data ) { return document . createCDATASection ( data ) ; } 
public boolean isApproved ( ) { Object oo = get_Value ( "IsApproved" ) ; if ( oo != null ) { if ( oo instanceof Boolean ) return ( ( Boolean ) oo ) . booleanValue ( ) ; return "Y" . equals ( oo ) ; } return false ; } 
@ Override @ SuppressWarnings ( "unchecked" ) public boolean remove ( Object o ) { if ( o == null ) { return false ; } for ( int targetIndex = 0 ; targetIndex < size ; targetIndex ++ ) { if ( o . equals ( elements [ targetIndex ] ) ) { removeAt ( targetIndex ) ; return true ; } } return false ; } 
@ Override public Set < Map . Entry < K , V >> entrySet ( ) { poll ( ) ; return new AbstractSet < Map . Entry < K , V >> ( ) { @ Override public int size ( ) { return WeakHashMap . this . size ( ) ; } @ Override public void clear ( ) { WeakHashMap . this . clear ( ) ; } @ Override public boolean remove ( Object object ) { if ( contains ( object ) ) { WeakHashMap . this . remove ( ( ( Map . Entry < ? , ? > ) object ) . getKey ( ) ) ; return true ; } return false ; } @ Override public boolean contains ( Object object ) { if ( object instanceof Map . Entry ) { Entry < ? , ? > entry = getEntry ( ( ( Map . Entry < ? , ? > ) object ) . getKey ( ) ) ; if ( entry != null ) { Object key = entry . get ( ) ; if ( key != null || entry . isNull ) { return object . equals ( entry ) ; } } } return false ; } @ Override public Iterator < Map . Entry < K , V >> iterator ( ) { return new HashIterator < Map . Entry < K , V >> ( new Entry . Type < Map . Entry < K , V > , K , V > ( ) { public Map . Entry < K , V > get ( Map . Entry < K , V > entry ) { return entry ; } } ) ; } } ; } 
private Short getNextSeq ( Bundle bundle ) { Integer nextI = this . getMaxSeq ( bundle ) . intValue ( ) + 10 ; Short next = new Short ( new String ( nextI . toString ( ) ) ) ; return next ; } 
@ ZAttr ( id = 26 ) public Map < String , Object > setLmtpNumThreads ( int zimbraLmtpNumThreads , Map < String , Object > attrs ) { if ( attrs == null ) attrs = new HashMap < String , Object > ( ) ; attrs . put ( Provisioning . A_zimbraLmtpNumThreads , Integer . toString ( zimbraLmtpNumThreads ) ) ; return attrs ; } 
public static void removeEdge ( Edge edge ) { edge . removeEdgeFromGraph ( ) ; edge . startNode . outgoingConnections . remove ( edge . startNode , edge . endNode ) ; edge . free ( ) ; } 
public static void main ( final String [ ] args ) { int versuche = 1 ; if ( args . length > 0 ) { try { versuche = Integer . parseInt ( args [ 0 ] ) ; } catch ( NumberFormatException x ) { versuche = 0 ; } if ( versuche == 0 || args . length > 1 ) { System . err . printf ( "Zu-viele-oder-falsche-Parameter!%n" + "Aufruf:-Wuerfel-[Anzahl]%n" ) ; return ; } } Random wuerfel = new Random ( ) ; final int anzahlAugen = 6 ; for ( int i = 0 ; i < versuche ; ++ i ) { System . out . println ( wuerfel . nextInt ( anzahlAugen ) + 1 ) ; } } 
public boolean setCurrentAccessibleValue ( Number n ) { try { model . setValue ( n ) ; return true ; } catch ( IllegalArgumentException iae ) { } return false ; } 
public static Task recoverSlavesAsync ( Connection c ) throws BadServerResponse , XenAPIException , XmlRpcException { String method_call = "Async.pool.recover_slaves" ; String session = c . getSessionReference ( ) ; Object [ ] method_params = { Marshalling . toXMLRPC ( session ) } ; Map response = c . dispatch ( method_call , method_params ) ; Object result = response . get ( "Value" ) ; return Types . toTask ( result ) ; } 
ViewPropertyAnimatorHC ( View view ) { mView = new WeakReference < View > ( view ) ; } 
public void unregisterCallback ( @ NonNull final TvInputCallback callback ) { Preconditions . checkNotNull ( callback ) ; synchronized ( mLock ) { for ( Iterator < TvInputCallbackRecord > it = mCallbackRecords . iterator ( ) ; it . hasNext ( ) ; ) { TvInputCallbackRecord record = it . next ( ) ; if ( record . getCallback ( ) == callback ) { it . remove ( ) ; break ; } } } } 
public static BufferedImage clear ( BufferedImage image , Color background ) { if ( image == null ) { throw new NullPointerException ( "image" ) ; } if ( background != null ) { Graphics2D g2d = image . createGraphics ( ) ; try { g2d . setBackground ( background ) ; g2d . clearRect ( 0 , 0 , image . getWidth ( ) , image . getHeight ( ) ) ; } finally { g2d . dispose ( ) ; } } return image ; } 
public static String getInstanceUserdata ( ) throws IOException { int retries = 0 ; while ( true ) { try { URL url = new URL ( "http://169.254.169.254/latest/user-data/" ) ; InputStreamReader rdr = new InputStreamReader ( url . openStream ( ) ) ; StringWriter wtr = new StringWriter ( ) ; char [ ] buf = new char [ 1024 ] ; int bytes ; while ( ( bytes = rdr . read ( buf ) ) > - 1 ) { if ( bytes > 0 ) { wtr . write ( buf , 0 , bytes ) ; } } rdr . close ( ) ; return wtr . toString ( ) ; } catch ( IOException ex ) { if ( retries == 5 ) { logger . debug ( "Problem-getting-user-data,-retries-exhausted..." ) ; return null ; } else { logger . debug ( "Problem-getting-user-data,-retrying..." ) ; try { Thread . sleep ( ( int ) Math . pow ( 2.0 , retries ) * 1000 ) ; } catch ( InterruptedException e ) { } } } } } 
private void newListener ( ) { ( new Thread ( this ) ) . start ( ) ; } 
public static Cursor getCursor ( int id ) { Integer key = Integer . valueOf ( id ) ; Cursor cursor = m_idToCursorMap . get ( key ) ; if ( cursor == null ) { cursor = new Cursor ( Display . getDefault ( ) , id ) ; m_idToCursorMap . put ( key , cursor ) ; } return cursor ; } 
private int parseNumber ( String str ) { if ( str . isEmpty ( ) ) { return 0 ; } try { return Integer . parseInt ( str ) ; } catch ( NumberFormatException e ) { } int found = 0 ; int index = 1 ; while ( index < str . length ( ) ) { String peek = str . substring ( 0 , index ) ; try { found = Integer . parseInt ( peek ) ; index ++ ; } catch ( NumberFormatException e ) { return found ; } } return found ; } 
protected static int extractByteValue ( ByteArrayInputStream pduDataStream ) { assert ( null != pduDataStream ) ; int temp = pduDataStream . read ( ) ; assert ( - 1 != temp ) ; return temp & 0xFF ; } 
public int getTimeSinceHit ( ) { return this . dataWatcher . getWatchableObjectInt ( 17 ) ; } 
@ XmlElementDecl ( namespace = "http://www.xbrl.org/tw/fr/gaap/tw-gaap-basi-2010-03-31-cr" , name = "ProvisiGuaranteeReserve" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < MonetaryItemType > createProvisiGuaranteeReserve ( MonetaryItemType value ) { return new JAXBElement < MonetaryItemType > ( _ProvisiGuaranteeReserve_QNAME , MonetaryItemType . class , null , value ) ; } 
protected void paintCenteredText ( Graphics2D g2 , String s , Rectangle rect , double fontHeight , Color color ) { g2 = ( Graphics2D ) g2 . create ( ) ; g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2 . setPaint ( color ) ; Rectangle2D bounds = null ; LineMetrics lm = null ; boolean done = false ; while ( ! done ) { g2 . setFont ( new Font ( "SansSerif" , Font . BOLD , ( int ) ( fontHeight * rect . height ) ) ) ; FontRenderContext frc = g2 . getFontRenderContext ( ) ; bounds = g2 . getFont ( ) . getStringBounds ( s , frc ) ; if ( bounds . getWidth ( ) > rect . getWidth ( ) ) fontHeight = fontHeight * Math . sqrt ( 2 ) / 2 ; else { done = true ; lm = g2 . getFont ( ) . getLineMetrics ( s , frc ) ; } } float centerX = rect . x + rect . width / 2 ; float centerY = rect . y + rect . height / 2 ; float leftX = centerX - ( float ) bounds . getWidth ( ) / 2 ; float baselineY = centerY - lm . getHeight ( ) / 2 + lm . getAscent ( ) ; g2 . drawString ( s , leftX , baselineY ) ; g2 . dispose ( ) ; } 
public XSElementDeclaration getElementDeclaration ( String name , String namespace ) { SchemaGrammar sg = ( SchemaGrammar ) fGrammarMap . get ( null2EmptyString ( namespace ) ) ; if ( sg == null ) { return null ; } return ( XSElementDeclaration ) sg . fGlobalElemDecls . get ( name ) ; } 
protected static String [ ] commaDelimitedListToStringArray ( String commaDelimitedStrings ) { return ( commaDelimitedStrings == null || commaDelimitedStrings . length ( ) == 0 ) ? new String [ 0 ] : commaSeparatedValuesPattern . split ( commaDelimitedStrings ) ; } 
public void addRect ( int x , int y , int w , int h , float r , float g , float b ) { x = millipointsToTwixels ( x ) ; y = millipointsToTwixels ( y ) ; w = millipointsToTwixels ( w ) ; h = millipointsToTwixels ( h ) ; h = - h ; y = pageHeight - y ; Shape shape = new Shape ( ) ; shape . setFillStyle0 ( FillStyle . newSolid ( new AlphaColor ( r , g , b ) ) ) ; Rectangle2D movieRect = GeomHelper . newRectangle ( x , y , w , h ) ; shape . drawRectangle ( movieRect ) ; shape . setBounds ( movieRect ) ; currentFrame . addInstance ( shape , layerCount ++ , new AffineTransform ( ) , null ) ; } 
public void remove ( LocalObjectId key ) { hashTable . remove ( key ) ; } 
private Properties load ( File propFile ) throws TelosysToolsException { if ( propFile . exists ( ) != true ) { return null ; } Properties props = new Properties ( ) ; FileInputStream fis = null ; try { fis = new FileInputStream ( propFile ) ; props . load ( fis ) ; } catch ( IOException ioe ) { throw new TelosysToolsException ( ERR_CANNOT_LOAD , ioe ) ; } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException e ) { } } return props ; } 
private static Uri uriWithAddedParameters ( final Context context , final Uri baseUri ) { final Uri . Builder builder = baseUri . buildUpon ( ) ; builder . appendQueryParameter ( PARAM_LANGUAGE_CODE , Locale . getDefault ( ) . toString ( ) ) ; if ( sCachedVersionCode == null ) { try { final PackageInfo info = context . getPackageManager ( ) . getPackageInfo ( context . getPackageName ( ) , 0 ) ; sCachedVersionCode = Integer . toString ( info . versionCode ) ; builder . appendQueryParameter ( PARAM_VERSION , sCachedVersionCode ) ; } catch ( final NameNotFoundException e ) { Log . wtf ( TAG , "Invalid-package-name-for-context" , e ) ; } } else { builder . appendQueryParameter ( PARAM_VERSION , sCachedVersionCode ) ; } return builder . build ( ) ; } 
public void setExcludeRange ( final java . util . List < com . netxforge . oss2 . config . poller . ExcludeRange > vExcludeRangeList ) { this . _excludeRangeList . clear ( ) ; this . _excludeRangeList . addAll ( vExcludeRangeList ) ; } 
public static int getAttemptsToStartSkipping ( Configuration conf ) { return conf . getInt ( ATTEMPTS_TO_START_SKIPPING , 2 ) ; } 
public static float ulp ( float f ) { int exp = getExponent ( f ) ; switch ( exp ) { case FloatConsts . MAX_EXPONENT + 1 : return Math . abs ( f ) ; case FloatConsts . MIN_EXPONENT - 1 : return FloatConsts . MIN_VALUE ; default : assert exp <= FloatConsts . MAX_EXPONENT && exp >= FloatConsts . MIN_EXPONENT ; exp = exp - ( FloatConsts . SIGNIFICAND_WIDTH - 1 ) ; if ( exp >= FloatConsts . MIN_EXPONENT ) { return powerOfTwoF ( exp ) ; } else { return Float . intBitsToFloat ( 1 << ( exp - ( FloatConsts . MIN_EXPONENT - ( FloatConsts . SIGNIFICAND_WIDTH - 1 ) ) ) ) ; } } } 
public R scan ( Element e , P p ) { return e . accept ( this , p ) ; } 
public static ECPoint decodeECPoint ( byte [ ] M , EllipticCurve curve ) { if ( M . length == 0 ) { return null ; } int elementSize = ( curve . getField ( ) . getFieldSize ( ) + 7 ) / 8 ; if ( M . length != 2 * elementSize + 1 ) { return null ; } if ( M [ 0 ] != 0x04 ) { return null ; } byte [ ] xp = new byte [ elementSize ] ; System . arraycopy ( M , 1 , xp , 0 , elementSize ) ; byte [ ] yp = new byte [ elementSize ] ; System . arraycopy ( M , 1 + elementSize , yp , 0 , elementSize ) ; ECPoint P = new ECPoint ( new BigInteger ( 1 , xp ) , new BigInteger ( 1 , yp ) ) ; return P ; } 
public ScrollBarUI getUI ( ) { return ( ScrollBarUI ) ui ; } 
private Collection < Insanity > checkValueMismatch ( MapOfSets < Integer , CacheEntry > valIdToItems , MapOfSets < ReaderField , Integer > readerFieldToValIds , Set < ReaderField > valMismatchKeys ) { final List < Insanity > insanity = new ArrayList < Insanity > ( valMismatchKeys . size ( ) * 3 ) ; if ( ! valMismatchKeys . isEmpty ( ) ) { final Map < ReaderField , Set < Integer >> rfMap = readerFieldToValIds . getMap ( ) ; final Map < Integer , Set < CacheEntry >> valMap = valIdToItems . getMap ( ) ; for ( final ReaderField rf : valMismatchKeys ) { final List < CacheEntry > badEntries = new ArrayList < CacheEntry > ( valMismatchKeys . size ( ) * 2 ) ; for ( final Integer value : rfMap . get ( rf ) ) { for ( final CacheEntry cacheEntry : valMap . get ( value ) ) { badEntries . add ( cacheEntry ) ; } } CacheEntry [ ] badness = new CacheEntry [ badEntries . size ( ) ] ; badness = badEntries . toArray ( badness ) ; insanity . add ( new Insanity ( InsanityType . VALUEMISMATCH , "Multiple-distinct-value-objects-for-" + rf . toString ( ) , badness ) ) ; } } return insanity ; } 
public static void init ( ) { window = new JFrame ( "BitBook" ) ; window . setSize ( windowWidth , windowHeight ) ; window . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; window . setResizable ( false ) ; } 
public static String [ ] getNames ( Object object ) { if ( object == null ) { return null ; } Class klass = object . getClass ( ) ; Field [ ] fields = klass . getFields ( ) ; int length = fields . length ; if ( length == 0 ) { return null ; } String [ ] names = new String [ length ] ; for ( int i = 0 ; i < length ; i += 1 ) { names [ i ] = fields [ i ] . getName ( ) ; } return names ; } 
public final < B , C , D > Option < D > bind ( final Option < B > ob , final Option < C > oc , final Func < A , Func < B , Func < C , D >>> f ) { return oc . apply ( bind ( ob , f ) ) ; } 
public synchronized int search ( Object o ) { int i = lastIndexOf ( o ) ; if ( i >= 0 ) { return size ( ) - i ; } return - 1 ; } 
public void genByte ( String dataByte ) { out . println ( "-.byte-" + dataByte ) ; } 
@ Override public Object lookupLink ( String name ) throws NamingException { return lookup ( new CompositeName ( name ) , false ) ; } 
protected void resetOptions ( ) { m_starting = null ; m_startRange = new Range ( ) ; m_attributeList = null ; m_attributeMerit = null ; m_threshold = - Double . MAX_VALUE ; } 
public JType [ ] listParamTypes ( ) { JType [ ] r = new JType [ params . size ( ) ] ; for ( int i = 0 ; i < r . length ; i ++ ) r [ i ] = params . get ( i ) . type ( ) ; return r ; } 
@ Override public int hashCode ( ) { return Arrays . hashCode ( address ) + 11 * prefixLength ; } 
public String toString ( ) { ToStringBuilder builder = new ToStringBuilder ( this , ToStringStyle . MULTI_LINE_STYLE ) ; builder . append ( "file" , System . getProperty ( CONFIG_LOCATION_PROPERTY , filename ) ) . append ( "loaded" , isLoaded ) ; for ( Iterator < String > i = config . getKeys ( ) ; i . hasNext ( ) ; ) { String key = i . next ( ) ; if ( SITE_NUMBER . equals ( key ) ) { builder . append ( key , Arrays . toString ( config . getStringArray ( key ) ) ) ; } else { builder . append ( key , config . getString ( key ) ) ; } } return builder . toString ( ) ; } 
public String [ ] getClasses ( ) { ArrayList al = new ArrayList ( ) ; if ( cls != null ) { StringTokenizer tok = new StringTokenizer ( cls , "," , false ) ; while ( tok . hasMoreTokens ( ) ) { al . add ( tok . nextToken ( ) . trim ( ) ) ; } } if ( files . size ( ) > 0 ) { for ( Enumeration e = files . elements ( ) ; e . hasMoreElements ( ) ; ) { FileSet fs = ( FileSet ) e . nextElement ( ) ; String [ ] includedClasses = fs . getDirectoryScanner ( getProject ( ) ) . getIncludedFiles ( ) ; for ( int i = 0 ; i < includedClasses . length ; i ++ ) { String className = includedClasses [ i ] . replace ( '|' , '.' ) . replace ( '/' , '.' ) . substring ( 0 , includedClasses [ i ] . length ( ) - 6 ) ; al . add ( className ) ; } } } Enumeration e = classes . elements ( ) ; while ( e . hasMoreElements ( ) ) { ClassArgument arg = ( ClassArgument ) e . nextElement ( ) ; al . add ( arg . getName ( ) ) ; } return ( String [ ] ) al . toArray ( new String [ al . size ( ) ] ) ; } 
private void readObject ( java . io . ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; numGlyphs = - 1 ; missingGlyphCode = - 1 ; } 
public static double dotProduct ( Vector3D v1 , Vector3D v2 ) { return v1 . dotProduct ( v2 ) ; } 
final long getLongValue ( ) { return ( ( Long ) object ) . longValue ( ) ; } 
private void fireRosterExchangeListeners ( String from , Iterator remoteRosterEntries ) { RosterExchangeListener [ ] listeners = null ; synchronized ( rosterExchangeListeners ) { listeners = new RosterExchangeListener [ rosterExchangeListeners . size ( ) ] ; rosterExchangeListeners . toArray ( listeners ) ; } for ( int i = 0 ; i < listeners . length ; i ++ ) { listeners [ i ] . entriesReceived ( from , remoteRosterEntries ) ; } } 
private JSONObject parseUrl ( String urlString ) { InputStream is = null ; try { java . net . URL url = new java . net . URL ( urlString ) ; URLConnection urlConnection = url . openConnection ( ) ; is = new BufferedInputStream ( urlConnection . getInputStream ( ) ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( urlConnection . getInputStream ( ) , "iso-8859-1" ) , 8 ) ; StringBuilder sb = new StringBuilder ( ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { sb . append ( line ) ; } return new JSONObject ( sb . toString ( ) ) ; } catch ( Exception e ) { Log . d ( TAG , "Failed-to-parse-the-json-for-media-list" , e ) ; return null ; } finally { if ( null != is ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } 
@ Override public void encode ( BufferedImage bufferedImage , OutputStream outputStream ) throws IOException { ParamChecks . nullNotPermitted ( bufferedImage , "bufferedImage" ) ; ParamChecks . nullNotPermitted ( outputStream , "outputStream" ) ; Iterator iterator = ImageIO . getImageWritersByFormatName ( "jpeg" ) ; ImageWriter writer = ( ImageWriter ) iterator . next ( ) ; ImageWriteParam p = writer . getDefaultWriteParam ( ) ; p . setCompressionMode ( ImageWriteParam . MODE_EXPLICIT ) ; p . setCompressionQuality ( this . quality ) ; ImageOutputStream ios = ImageIO . createImageOutputStream ( outputStream ) ; writer . setOutput ( ios ) ; writer . write ( null , new IIOImage ( bufferedImage , null , null ) , p ) ; ios . flush ( ) ; writer . dispose ( ) ; ios . close ( ) ; } 
public boolean getScrollableTracksViewportWidth ( ) { Container parent = getParent ( ) ; return parent != null && parent instanceof JViewport && parent . getWidth ( ) > getUI ( ) . getMinimumSize ( this ) . width ; } 
private static Label copyLabel ( Label label ) { Label copiedLabel = new Label ( label . getText ( ) ) ; copiedLabel . setStyle ( label . getStyle ( ) ) ; return copiedLabel ; } 
public int codePointBefore ( int index ) { int i = index - 1 ; if ( ( i < 0 ) || ( i >= count ) ) { throw new StringIndexOutOfBoundsException ( index ) ; } return Character . codePointBeforeImpl ( value , offset + index , offset ) ; } 
public List < CartCreateRequest . Items . Item . MetaData > getMetaData ( ) { if ( metaData == null ) { metaData = new ArrayList < CartCreateRequest . Items . Item . MetaData > ( ) ; } return this . metaData ; } 
private JPanel createPortPanel ( ) { JPanel portPanel = new JPanel ( new BorderLayout ( 5 , 0 ) ) ; JLabel label = new JLabel ( JMeterUtils . getResString ( "port" ) ) ; label . setLabelFor ( port ) ; portPanel . add ( label , BorderLayout . WEST ) ; portPanel . add ( port , BorderLayout . CENTER ) ; return portPanel ; } 
@ Override public void updateTime ( int columnIndex , Time x ) throws SQLException { realResultSet . updateTime ( columnIndex , x ) ; } 
public int getInteger ( int index , int defValue ) { index *= AssetManager . STYLE_NUM_ENTRIES ; final int [ ] data = mData ; final int type = data [ index + AssetManager . STYLE_TYPE ] ; if ( type == TypedValue . TYPE_NULL ) { return defValue ; } else if ( type >= TypedValue . TYPE_FIRST_INT && type <= TypedValue . TYPE_LAST_INT ) { return data [ index + AssetManager . STYLE_DATA ] ; } throw new UnsupportedOperationException ( "Can't-convert-to-integer:-type=0x" + Integer . toHexString ( type ) ) ; } 
private void loadImages ( ) { try { File imagesDir = new File ( ImageBrowser . class . getResource ( "./images" ) . toURI ( ) ) ; FileTreeWalker walker = new FileTreeWalker ( imagesDir , new UnixGlobFileFilter ( "*.jpg" ) ) ; walker . walk ( new FileTreeWalk ( ) { public void walk ( File path ) { numImages ++ ; try { BufferedImage image = ImageIO . read ( path ) ; images . add ( new ImageHolder ( image ) ) ; } catch ( Exception e ) { System . out . println ( "Problem-loading-images:-" + e ) ; } } } ) ; } catch ( Exception e ) { System . out . println ( "Problem-loading-images:-" + e ) ; } } 
public synchronized boolean contains ( Object value ) { if ( value == null ) throw new NullPointerException ( ) ; for ( int i = buckets . length - 1 ; i >= 0 ; i -- ) { HashEntry e = buckets [ i ] ; while ( e != null ) { if ( e . value . equals ( value ) ) return true ; e = e . next ; } } return false ; } 
public boolean isCompound ( ) { return compareTo ( OCTAVE ) >= 0 ; } 
static public String getOriginalTextInHtml ( GxmlElement p_node ) { StringBuffer result = new StringBuffer ( 128 ) ; getOriginalTextInHtml ( p_node , GxmlElement . NONE , result ) ; return result . toString ( ) ; } 
@ Override public boolean equals ( final Object obj ) { if ( obj instanceof MutableInt ) { return value == ( ( MutableInt ) obj ) . intValue ( ) ; } return false ; } 
public List < AbstractType < ? >> getReturnTypes ( ) { return Lists . transform ( factories , new com . google . common . base . Function < Selector . Factory , AbstractType < ? >> ( ) { public AbstractType < ? > apply ( Selector . Factory factory ) { return factory . getReturnType ( ) ; } } ) ; } 
private void reportWarning ( String key , Object [ ] arguments ) throws XNIException { fXPointerErrorReporter . reportError ( XPointerMessageFormatter . XPOINTER_DOMAIN , key , arguments , XMLErrorReporter . SEVERITY_WARNING ) ; } 
@ XmlElementDecl ( namespace = "http://webservice.miapeconverter.miapeapi.proteored.org/" , name = "storeMiapeMSMSIFromMzIdentMLResponse" ) public JAXBElement < StoreMiapeMSMSIFromMzIdentMLResponse > createStoreMiapeMSMSIFromMzIdentMLResponse ( StoreMiapeMSMSIFromMzIdentMLResponse value ) { return new JAXBElement < StoreMiapeMSMSIFromMzIdentMLResponse > ( _StoreMiapeMSMSIFromMzIdentMLResponse_QNAME , StoreMiapeMSMSIFromMzIdentMLResponse . class , null , value ) ; } 
public int getAccessibleChildrenCount ( JComponent a ) { int returnValue = ( ( ComponentUI ) ( uis . elementAt ( 0 ) ) ) . getAccessibleChildrenCount ( a ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . getAccessibleChildrenCount ( a ) ; } return returnValue ; } 
@ XmlElementDecl ( namespace = "http://docs.oasis-open.org/ns/cmis/messaging/200908/" , name = "versioningState" , scope = CreateDocument . class ) public JAXBElement < EnumVersioningState > createCreateDocumentVersioningState ( EnumVersioningState value ) { return new JAXBElement < EnumVersioningState > ( _CreateDocumentFromSourceVersioningState_QNAME , EnumVersioningState . class , CreateDocument . class , value ) ; } 
public double [ ] [ ] solve ( double [ ] [ ] B ) { if ( B . length != m ) { throw new IllegalArgumentException ( "Matrix-row-dimensions-must-agree." ) ; } if ( ! this . isNonsingular ( ) ) { throw new RuntimeException ( "Matrix-is-singular." ) ; } int nx = B [ 0 ] . length ; double [ ] [ ] Xmat = DoubleArray . getRowsCopy ( B , piv ) ; for ( int k = 0 ; k < n ; k ++ ) { for ( int i = k + 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < nx ; j ++ ) { Xmat [ i ] [ j ] = Xmat [ i ] [ j ] - Xmat [ k ] [ j ] * LU [ i ] [ k ] ; } } } for ( int k = n - 1 ; k >= 0 ; k -- ) { for ( int j = 0 ; j < nx ; j ++ ) { Xmat [ k ] [ j ] = Xmat [ k ] [ j ] - LU [ k ] [ k ] ; } for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < nx ; j ++ ) { Xmat [ i ] [ j ] = Xmat [ i ] [ j ] - Xmat [ k ] [ j ] * LU [ i ] [ k ] ; } } } return Xmat ; } 
public boolean clipPath ( Path path ) { return clipPath ( path , Region . Op . INTERSECT ) ; } 
public List < String > getValuePath ( ) { List < String > out = parentPivot . getValuePath ( ) ; if ( null == value ) { out . add ( null ) ; } else if ( value instanceof Date ) { out . add ( ( ( Date ) value ) . toInstant ( ) . toString ( ) ) ; } else { out . add ( value . toString ( ) ) ; } return out ; } 
public String printMatrix ( ) { String res = "" ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { double d = matrix [ i ] [ j ] ; DecimalFormat df = new DecimalFormat ( "0.00" ) ; String s = df . format ( d ) ; for ( int k = 8 - s . length ( ) ; k > 0 ; k -- ) { res += "-" ; } res += s ; } res += "-" ; } res += "-" ; System . out . println ( res ) ; return res ; } 
public static String getTempDirectoryPath ( Context ctx ) { File cache = null ; if ( Environment . getExternalStorageState ( ) . equals ( Environment . MEDIA_MOUNTED ) ) { cache = new File ( Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) + "/Android/data/" + ctx . getPackageName ( ) + "/cache/" ) ; } else { cache = ctx . getCacheDir ( ) ; } if ( ! cache . exists ( ) ) { cache . mkdirs ( ) ; } return cache . getAbsolutePath ( ) ; } 
public void addSample ( boolean success , long time ) { if ( time < 0L ) { throw new IllegalArgumentException ( "Sample-time-cannot-be-negative." ) ; } if ( success ) { statsSuccess . addValue ( time ) ; } else { statsFailure . addValue ( time ) ; } } 
public Collection < OsmPrimitiveAction > getPrimitiveActions ( ) { return Collections . unmodifiableCollection ( primitiveActions ) ; } 
private JComboBox getJComboBoxAgence ( ) { if ( jComboBoxAgence == null ) { jComboBoxAgence = new JComboBox ( ) ; jComboBoxAgence . setPreferredSize ( new Dimension ( 150 , 20 ) ) ; jComboBoxAgence . setSize ( new Dimension ( 150 , 20 ) ) ; jComboBoxAgence . setLocation ( new Point ( 130 , 170 ) ) ; } return jComboBoxAgence ; } 
public static < E > void gridPrint ( E [ ] grid , int sourceRows , int sourceColumns , int width , PrintStream ps ) { for ( int i = 0 ; i < sourceRows ; i ++ ) { for ( int j = 0 ; j < sourceColumns ; j ++ ) { ps . printf ( "%-" + ( width + 1 ) + "s" , grid [ i * sourceColumns + j ] . toString ( ) + "," ) ; } ps . println ( ) ; } } 
public Schema getImport ( String namespace ) { return ( Schema ) imports . get ( namespace ) ; } 
public int hashCode ( ) { return ( field . hashCode ( ) << 6 + ( a . hashCode ( ) << 4 ) + ( b . hashCode ( ) << 2 ) ) ; } 
public void actionPerformed ( ActionEvent e ) { Calendar cal = Calendar . getInstance ( ) ; int seed = cal . get ( Calendar . SECOND ) ; Random rand = new Random ( seed ) ; Iterator iterator = mappedKeys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object key = iterator . next ( ) ; int r = rand . nextInt ( 255 ) ; int g = rand . nextInt ( 255 ) ; int b = rand . nextInt ( 255 ) ; Color c1 = new Color ( r , g , b ) ; dm . putMapValue ( key , c1 ) ; } } 
public boolean isConstructor ( ) { return Modifier . isConstructor ( parser ( ) . getModifiers ( ) ) ; } 
public PacketScheduler getScheduler ( String dest ) { if ( dest == null || dest . length ( ) == 0 ) { return null ; } PacketScheduler sched = null ; try { if ( hostTable . containsValue ( dest ) ) { String linkName = ( String ) linkTable . get ( dest ) ; sched = ( PacketScheduler ) schedTable . get ( linkName ) ; } else { Object [ ] data = ( Object [ ] ) forwardTable . get ( dest ) ; if ( data == null ) { return null ; } String router = ( String ) data [ 0 ] ; String linkName = ( String ) linkTable . get ( router ) ; sched = ( PacketScheduler ) schedTable . get ( linkName ) ; } } catch ( Exception e ) { sched = null ; } return sched ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
private final String toPrettyPrintedStack ( String type ) { StringBuffer result = new StringBuffer ( ) ; StringBuffer spaces = new StringBuffer ( ) ; result . append ( "Unable-to-serialize-class:-" ) ; result . append ( type ) ; result . append ( "-Field-hierarchy-is:" ) ; for ( Iterator < TraceSlot > i = traceStack . listIterator ( ) ; i . hasNext ( ) ; ) { spaces . append ( "-" ) ; TraceSlot slot = i . next ( ) ; result . append ( "-" ) . append ( spaces ) . append ( slot . fieldDescription ) ; result . append ( "-[class=" ) . append ( slot . object . getClass ( ) . getName ( ) ) ; if ( slot . object instanceof Component ) { Component component = ( Component ) slot . object ; result . append ( ",-path=" ) . append ( component . getPath ( ) ) ; } result . append ( "]" ) ; } result . append ( "-<------field-that-is-not-serializable" ) ; return result . toString ( ) ; } 
public boolean getBoolean ( String key ) { return Boolean . parseBoolean ( configProperties . getProperty ( key ) ) ; } 
private void hilightFocusedVerSlider ( Canvas canvas ) { mPosMarker . setColor ( Color . WHITE ) ; canvas . drawRect ( new Rect ( 0 , 0 , SLIDER_THICKNESS , PALETTE_DIM ) , mPosMarker ) ; mPosMarker . setColor ( Color . BLACK ) ; canvas . drawRect ( new Rect ( 2 , 2 , SLIDER_THICKNESS - 2 , PALETTE_DIM - 2 ) , mPosMarker ) ; } 
public Builder loadFromPath ( Path path ) throws SettingsException { try { return loadFromStream ( path . getFileName ( ) . toString ( ) , Files . newInputStream ( path ) ) ; } catch ( IOException e ) { throw new SettingsException ( "Failed-to-open-stream-for-url-[" + path + "]" , e ) ; } } 
public boolean rewriteExif ( String filename , Collection < ExifTag > tags ) throws FileNotFoundException , IOException { RandomAccessFile file = null ; InputStream is = null ; boolean ret ; try { File temp = new File ( filename ) ; is = new BufferedInputStream ( new FileInputStream ( temp ) ) ; ExifParser parser = null ; try { parser = ExifParser . parse ( is , this ) ; } catch ( ExifInvalidFormatException e ) { throw new IOException ( "Invalid-exif-format-:-" , e ) ; } long exifSize = parser . getOffsetToExifEndFromSOF ( ) ; is . close ( ) ; is = null ; file = new RandomAccessFile ( temp , "rw" ) ; long fileLength = file . length ( ) ; if ( fileLength < exifSize ) { throw new IOException ( "Filesize-changed-during-operation" ) ; } ByteBuffer buf = file . getChannel ( ) . map ( MapMode . READ_WRITE , 0 , exifSize ) ; ret = rewriteExif ( buf , tags ) ; } catch ( IOException e ) { closeSilently ( file ) ; throw e ; } finally { closeSilently ( is ) ; } file . close ( ) ; return ret ; } 
public static int osisIdToVerseNum ( String osisID ) { if ( osisID != null ) { String [ ] parts = osisID . split ( "|." ) ; if ( parts . length > 1 ) { String verse = parts [ parts . length - 1 ] ; return Integer . valueOf ( verse ) ; } } return 0 ; } 
public static void registerFilter ( String name , String filterClass ) { if ( LOG . isInfoEnabled ( ) ) LOG . info ( "Registering-new-filter-" + name ) ; filterHashMap . put ( name , filterClass ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public InputStream getResourceAsStream ( String name ) { name = resolveName ( name ) ; ClassLoader cl = getClassLoader0 ( ) ; if ( cl == null ) { return ClassLoader . getSystemResourceAsStream ( name ) ; } return cl . getResourceAsStream ( name ) ; } 
@ Override public void cleanModel ( Set < URI > resourcesToDelete ) { if ( ! resourcesToDelete . isEmpty ( ) ) { Iterator < Resource > modelResourcesIterator = getResources ( ) . iterator ( ) ; List < Resource > referencedDeletedResources = new ArrayList < Resource > ( ) ; while ( modelResourcesIterator . hasNext ( ) ) { Resource currentResource = modelResourcesIterator . next ( ) ; if ( resourcesToDelete . contains ( currentResource . getURI ( ) ) ) { referencedDeletedResources . add ( currentResource ) ; } } if ( ! referencedDeletedResources . isEmpty ( ) ) { getResources ( ) . removeAll ( referencedDeletedResources ) ; } } } 
public void setScaleY ( float scaleY ) { ensureTransformationInfo ( ) ; final TransformationInfo info = mTransformationInfo ; if ( info . mScaleY != scaleY ) { invalidateParentCaches ( ) ; invalidate ( false ) ; info . mScaleY = scaleY ; info . mMatrixDirty = true ; mPrivateFlags |= DRAWN ; invalidate ( false ) ; } } 
public void setDataHora ( int ano , int mes , int dia , int hora , int minuto ) { data . set ( ano , mes , dia , hora , minuto ) ; } 
public void setDesktopIcon ( JDesktopIcon d ) { JDesktopIcon oldValue = getDesktopIcon ( ) ; desktopIcon = d ; firePropertyChange ( "desktopIcon" , oldValue , d ) ; } 
public String terminate ( ) { Collections . sort ( data ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < data . size ( ) ; i ++ ) { sb . append ( data . get ( i ) ) ; } return sb . toString ( ) ; } 
@ Override public synchronized void initialize ( ) { if ( ! mRootDirectory . exists ( ) ) { if ( ! mRootDirectory . mkdirs ( ) ) { VolleyLog . e ( "Unable-to-create-cache-dir-%s" , mRootDirectory . getAbsolutePath ( ) ) ; } return ; } File [ ] files = mRootDirectory . listFiles ( ) ; if ( files == null ) { return ; } for ( File file : files ) { FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; CacheHeader entry = CacheHeader . readHeader ( fis ) ; entry . size = file . length ( ) ; putEntry ( entry . key , entry ) ; } catch ( IOException e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ignored ) { } } } } 
static Set < Pair < IDKey , IDKey >> getRegistry ( ) { return REGISTRY . get ( ) ; } 
public void onQueryComplete ( List < OperatorInfo > networkInfoArray , int status ) { if ( DBG ) log ( "notifying-message-loop-of-query-completion." ) ; Message msg = mHandler . obtainMessage ( EVENT_NETWORK_SCAN_COMPLETED , status , 0 , networkInfoArray ) ; msg . sendToTarget ( ) ; } 
public void clear ( ) { column = new String [ 0 ] ; types = null ; rows = new Vector ( ) ; ncolumns = nrows = 0 ; atmaxrows = false ; } 
public Object get ( Object key ) { if ( key == null ) { return null ; } if ( IGNORE_CASE ) { key = ( ( String ) key ) . toLowerCase ( ) ; } String sKey = ( String ) key ; if ( sKey . indexOf ( '/' ) >= 0 || sKey . indexOf ( '.' ) >= 0 || sKey . indexOf ( '|' ) >= 0 || sKey . indexOf ( '[' ) >= 0 ) { return getSeq ( sKey ) ; } if ( sKey . equalsIgnoreCase ( "_value" ) ) { return getText ( ) ; } else if ( this . containsKey ( key ) ) { return super . get ( key ) ; } else { return attributes . get ( key ) ; } } 
public byte [ ] getData ( ) { return buffer . getData ( ) ; } 
public FacesConfigManagedBeanType < T > removeEager ( ) { childNode . removeAttribute ( "eager" ) ; return this ; } 
public List < ClassDescriptor > getTablePerTenantDescriptors ( ) { if ( tablePerTenantDescriptors == null ) { tablePerTenantDescriptors = new ArrayList < ClassDescriptor > ( ) ; } return tablePerTenantDescriptors ; } 
private static void throwMiscException ( Throwable th ) throws IOException { if ( th instanceof RuntimeException ) { throw ( RuntimeException ) th ; } else if ( th instanceof Error ) { throw ( Error ) th ; } else { IOException ex = new IOException ( "unexpected-exception-type" ) ; ex . initCause ( th ) ; throw ex ; } } 
public void add ( Permission permission ) { if ( ! ( permission instanceof DmtPrincipalPermission ) ) throw new IllegalArgumentException ( "Cannot-add-permission,-invalid-permission-type:-" + permission ) ; if ( isReadOnly ( ) ) throw new SecurityException ( "Cannot-add-permission,-collection-is-marked-read-only." ) ; if ( ! implies ( permission ) ) { Iterator i = perms . iterator ( ) ; while ( i . hasNext ( ) ) if ( permission . implies ( ( DmtPrincipalPermission ) i . next ( ) ) ) i . remove ( ) ; perms . add ( permission ) ; } } 
public void setRenderingHint ( Key hintCategory , Object hintValue ) { mGraphics . setRenderingHint ( hintCategory , hintValue ) ; } 
public static AnimationData getTextureData ( String string ) { AnimationData t = textures . get ( string ) ; if ( t != null ) { return t ; } else { System . err . println ( "Warn:-" + string + "-not-explicitly-defined" ) ; for ( String loc : searchFolders ) { if ( ResourceLoader . resourceExists ( "res/" + loc + "/" + string + ".png" ) ) { AnimationData txt = new AnimationData ( "res/" + loc + "/" + string + ".png" ) ; textures . put ( string , txt ) ; return txt ; } } return textures . get ( "whoops" ) ; } } 
private void setNextRunTime ( ) { long p = period ; if ( p > 0 ) time += p ; else time = triggerTime ( - p ) ; } 
protected IPath resolveLocation ( ) { if ( sketchbookPathField == null ) return null ; String text = sketchbookPathField . getText ( ) . trim ( ) ; if ( text . length ( ) == 0 ) return null ; IPath path = new Path ( text ) ; if ( ! path . isAbsolute ( ) ) path = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) . getLocation ( ) . append ( path ) ; return path ; } 
public static Calendar getCalendar ( Date date ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; return calendar ; } 
public static < K , V > V firstValue ( final Map < K , V > map ) { return map . values ( ) . iterator ( ) . next ( ) ; } 
public static String bitcoinValueToFriendlyString ( BigInteger value ) { boolean negative = value . compareTo ( BigInteger . ZERO ) < 0 ; if ( negative ) value = value . negate ( ) ; BigDecimal bd = new BigDecimal ( value , 8 ) ; String formatted = bd . toPlainString ( ) ; int decimalPoint = formatted . indexOf ( "." ) ; int toDelete = 0 ; for ( int i = formatted . length ( ) - 1 ; i > decimalPoint + 2 ; i -- ) { if ( formatted . charAt ( i ) == '0' ) toDelete ++ ; else break ; } return ( negative ? "-" : "" ) + formatted . substring ( 0 , formatted . length ( ) - toDelete ) ; } 
protected void finalize ( ) { if ( catfile != null ) { try { catfile . close ( ) ; } catch ( IOException e ) { } } catfile = null ; } 
public static Request newStatusUpdateRequest ( Session session , String message , Callback callback ) { return newStatusUpdateRequest ( session , message , ( String ) null , null , callback ) ; } 
public SIPHeader parseSIPHeader ( String header ) throws ParseException { int start = 0 ; int end = header . length ( ) - 1 ; try { while ( header . charAt ( start ) <= 0x20 ) start ++ ; while ( header . charAt ( end ) <= 0x20 ) end -- ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new ParseException ( "Empty-header." , 0 ) ; } StringBuffer buffer = new StringBuffer ( end + 1 ) ; int i = start ; int lineStart = start ; boolean endOfLine = false ; while ( i <= end ) { char c = header . charAt ( i ) ; if ( c == '|r' || c == '|n' ) { if ( ! endOfLine ) { buffer . append ( header . substring ( lineStart , i ) ) ; endOfLine = true ; } } else { if ( endOfLine ) { endOfLine = false ; if ( c == '-' || c == '|t' ) { buffer . append ( '-' ) ; lineStart = i + 1 ; } else { lineStart = i ; } } } i ++ ; } buffer . append ( header . substring ( lineStart , i ) ) ; buffer . append ( '|n' ) ; HeaderParser hp = ParserFactory . createParser ( buffer . toString ( ) ) ; if ( hp == null ) throw new ParseException ( "could-not-create-parser" , 0 ) ; return hp . parse ( ) ; } 
public List < DvsServiceConsoleVNicProfile > getDvsServiceConsoleNic ( ) { if ( dvsServiceConsoleNic == null ) { dvsServiceConsoleNic = new ArrayList < DvsServiceConsoleVNicProfile > ( ) ; } return this . dvsServiceConsoleNic ; } 
protected DocumentBuilder getDocumentBuilder ( ) throws ServletException { DocumentBuilder documentBuilder = null ; DocumentBuilderFactory documentBuilderFactory = null ; try { documentBuilderFactory = DocumentBuilderFactory . newInstance ( ) ; documentBuilderFactory . setNamespaceAware ( true ) ; documentBuilderFactory . setExpandEntityReferences ( false ) ; documentBuilder = documentBuilderFactory . newDocumentBuilder ( ) ; } catch ( ParserConfigurationException e ) { throw new ServletException ( sm . getString ( "webdavservlet.jaxpfailed" ) ) ; } return documentBuilder ; } 
public void addFilter ( QueryFilter filter ) { if ( ! filters . contains ( filter ) ) { filters . add ( filter ) ; } } 
public int compare ( File file1 , File file2 ) { long result = file1 . lastModified ( ) - file2 . lastModified ( ) ; if ( result < 0 ) { return - 1 ; } else if ( result > 0 ) { return 1 ; } else { return 0 ; } } 
public void removeMenuPresenter ( MenuPresenter presenter ) { for ( WeakReference < MenuPresenter > ref : mPresenters ) { final MenuPresenter item = ref . get ( ) ; if ( item == null || item == presenter ) { mPresenters . remove ( ref ) ; } } } 
private int scanData ( String data , StringBuffer schemeData , int endOffset , int currentOffset ) { while ( true ) { if ( currentOffset == endOffset ) { break ; } int ch = data . charAt ( currentOffset ) ; byte chartype = ( ch >= 0x80 ) ? CHARTYPE_NONASCII : fASCIICharMap [ ch ] ; if ( chartype == CHARTYPE_OPEN_PAREN ) { schemeData . append ( ch ) ; currentOffset = scanData ( data , schemeData , endOffset , ++ currentOffset ) ; if ( currentOffset == endOffset ) { return currentOffset ; } ch = data . charAt ( currentOffset ) ; chartype = ( ch >= 0x80 ) ? CHARTYPE_NONASCII : fASCIICharMap [ ch ] ; if ( chartype != CHARTYPE_CLOSE_PAREN ) { return endOffset ; } schemeData . append ( ( char ) ch ) ; ++ currentOffset ; } else if ( chartype == CHARTYPE_CLOSE_PAREN ) { return currentOffset ; } else if ( chartype == CHARTYPE_CARRET ) { ch = data . charAt ( ++ currentOffset ) ; chartype = ( ch >= 0x80 ) ? CHARTYPE_NONASCII : fASCIICharMap [ ch ] ; if ( chartype != CHARTYPE_CARRET && chartype != CHARTYPE_OPEN_PAREN && chartype != CHARTYPE_CLOSE_PAREN ) { break ; } schemeData . append ( ( char ) ch ) ; ++ currentOffset ; } else { schemeData . append ( ( char ) ch ) ; ++ currentOffset ; } } return currentOffset ; } 
public static long secondsSinceMillis ( long timeInMillis ) { return ( System . currentTimeMillis ( ) - timeInMillis ) / 1000 ; } 
private ArrayDeque < Node > findRoots ( int [ ] rulesFilter ) { final SparseArray < Node > keyNodes = mKeyNodes ; final ArrayList < Node > nodes = mNodes ; final int count = nodes . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final Node node = nodes . get ( i ) ; node . dependents . clear ( ) ; node . dependencies . clear ( ) ; } for ( int i = 0 ; i < count ; i ++ ) { final Node node = nodes . get ( i ) ; final LayoutParams layoutParams = ( LayoutParams ) node . view . getLayoutParams ( ) ; final int [ ] rules = layoutParams . mRules ; final int rulesCount = rulesFilter . length ; for ( int j = 0 ; j < rulesCount ; j ++ ) { final int rule = rules [ rulesFilter [ j ] ] ; if ( rule > 0 ) { final Node dependency = keyNodes . get ( rule ) ; if ( dependency == null || dependency == node ) { continue ; } dependency . dependents . put ( node , this ) ; node . dependencies . put ( rule , dependency ) ; } } } final ArrayDeque < Node > roots = mRoots ; roots . clear ( ) ; for ( int i = 0 ; i < count ; i ++ ) { final Node node = nodes . get ( i ) ; if ( node . dependencies . size ( ) == 0 ) roots . addLast ( node ) ; } return roots ; } 
public int compareTo ( Object other ) { if ( other instanceof TCTimestampResult ) { Timestamp otherTimestamp = ( ( Timestamp ) ( ( TCTimestampResult ) other ) . getResultData ( ) ) ; if ( value == null && otherTimestamp == null ) return 0 ; if ( value == null ) return - 1 ; if ( otherTimestamp == null ) return 1 ; return new Long ( value . getTime ( ) ) . compareTo ( new Long ( otherTimestamp . getTime ( ) ) ) ; } else return this . toString ( ) . compareToIgnoreCase ( other . toString ( ) ) ; } 
private void updateNodeSizes ( boolean updateAll ) { int aY , counter , maxCounter ; TreeStateNode node ; updateNodeSizes = false ; for ( aY = counter = 0 , maxCounter = visibleNodes . size ( ) ; counter < maxCounter ; counter ++ ) { node = ( TreeStateNode ) visibleNodes . elementAt ( counter ) ; node . setYOrigin ( aY ) ; if ( updateAll || ! node . hasValidSize ( ) ) node . updatePreferredSize ( counter ) ; aY += node . getPreferredHeight ( ) ; } } 
@ Override public boolean retainAll ( Collection < ? > c ) { boolean modified = false ; Iterator < E > e = iterator ( ) ; while ( e . hasNext ( ) ) { if ( ! c . contains ( e . next ( ) ) ) { e . remove ( ) ; modified = true ; } } return modified ; } 
public ValuesDelta getEntry ( Long childId ) { if ( childId == null ) { return null ; } for ( ArrayList < ValuesDelta > mimeEntries : mEntries . values ( ) ) { for ( ValuesDelta entry : mimeEntries ) { if ( childId . equals ( entry . getId ( ) ) ) { return entry ; } } } return null ; } 
private void onGetImageSuccess ( String cacheKey , Bitmap response ) { mCache . putBitmap ( cacheKey , response ) ; BatchedImageRequest request = mInFlightRequests . remove ( cacheKey ) ; if ( request != null ) { request . mResponseBitmap = response ; batchResponse ( cacheKey , request , null ) ; } } 
private Button createVisualButton ( int row , int column ) { Button cellButton = new Button ( ) ; cellButton . setOnMouseClicked ( new MouseClickHandler ( row , column , this ) ) ; cellButton . setPrefWidth ( 30.0 ) ; cellButton . setPrefHeight ( 30.0 ) ; return cellButton ; } 
public List < String > getSubType ( ) { if ( subType == null ) { subType = new ArrayList < String > ( ) ; } return this . subType ; } 
@ Override protected void itemEffect ( Character target ) { target . setArmor ( target . getArmor ( ) + 20 ) ; } 
public List < Parcel > getParcels ( ) { if ( parcels == null ) { parcels = new ArrayList < Parcel > ( ) ; } return this . parcels ; } 
public synchronized boolean getBoolean ( int parameterIndex ) throws SQLException { Object o = getColumnInType ( parameterIndex , Type . SQL_BOOLEAN ) ; return o == null ? false : ( ( Boolean ) o ) . booleanValue ( ) ; } 
public Object clone ( ) throws CloneNotSupportedException { try { UnicastRemoteObject cloned = ( UnicastRemoteObject ) super . clone ( ) ; cloned . reexport ( ) ; return cloned ; } catch ( RemoteException e ) { throw new ServerCloneException ( "Clone-failed" , e ) ; } } 
private String addNonce ( String url ) { if ( ( url == null ) || ( nonce == null ) ) { return ( url ) ; } String path = url ; String query = "" ; String anchor = "" ; int pound = path . indexOf ( '#' ) ; if ( pound >= 0 ) { anchor = path . substring ( pound ) ; path = path . substring ( 0 , pound ) ; } int question = path . indexOf ( '?' ) ; if ( question >= 0 ) { query = path . substring ( question ) ; path = path . substring ( 0 , question ) ; } StringBuilder sb = new StringBuilder ( path ) ; if ( query . length ( ) > 0 ) { sb . append ( query ) ; sb . append ( '&' ) ; } else { sb . append ( '?' ) ; } sb . append ( Constants . CSRF_NONCE_REQUEST_PARAM ) ; sb . append ( '=' ) ; sb . append ( nonce ) ; sb . append ( anchor ) ; return ( sb . toString ( ) ) ; } 
public List < E > getEdgesRemoved ( ) { return new ArrayList < E > ( edges_removed . keySet ( ) ) ; } 
public void addPropertyChangeListener ( PropertyChangeListener listener ) { if ( m_LibraryPropertySupport != null ) { m_LibraryPropertySupport . addPropertyChangeListener ( listener ) ; } } 
public String getToolTipTextAt ( int index ) { return pages . get ( index ) . tip ; } 
public void setTarget ( Node v ) { m_target = v ; v . setParent ( this ) ; } 
private boolean isReconnectionAllowed ( ) { return ! done && ! connection . isConnected ( ) && connection . isReconnectionAllowed ( ) ; } 
@ Override public void update ( Graphics g , JComponent c ) { SynthContext context = getContext ( c ) ; SynthLookAndFeel . update ( context , g ) ; context . getPainter ( ) . paintDesktopPaneBackground ( context , g , 0 , 0 , c . getWidth ( ) , c . getHeight ( ) ) ; paint ( context , g ) ; context . dispose ( ) ; } 
public boolean setOrdering ( Object first , Object second ) { DigraphNode firstPONode = ( DigraphNode ) poNodes . get ( first ) ; DigraphNode secondPONode = ( DigraphNode ) poNodes . get ( second ) ; secondPONode . removeEdge ( firstPONode ) ; return firstPONode . addEdge ( secondPONode ) ; } 
private static void setImageViewScaleTypeMatrix ( ImageView imageView ) { if ( null != imageView && ! ( imageView instanceof PhotoView ) ) { if ( ! ScaleType . MATRIX . equals ( imageView . getScaleType ( ) ) ) { imageView . setScaleType ( ScaleType . MATRIX ) ; } } } 
public void clearAllSubscription ( ) { continuousQueries . clear ( ) ; } 
public Enumeration listOptions ( ) { Vector newVector = new Vector ( 1 ) ; newVector . addElement ( new Option ( "-Specify-list-of-columns-to-take-the-differences-between.-" + "-First-and-last-are-valid-indexes.-" + "-(default-none)" , "R" , 1 , "-R-<index1,index2-index4,...>" ) ) ; return newVector . elements ( ) ; } 
public SAXException createSAXException ( String message , Exception e ) { if ( ( e != null ) && ( e instanceof InvocationTargetException ) ) { Throwable t = e . getCause ( ) ; if ( t instanceof ThreadDeath ) { throw ( ThreadDeath ) t ; } if ( t instanceof VirtualMachineError ) { throw ( VirtualMachineError ) t ; } if ( t instanceof Exception ) { e = ( Exception ) t ; } } if ( locator != null ) { String error = "Error-at-(" + locator . getLineNumber ( ) + ",-" + locator . getColumnNumber ( ) + ")-:-" + message ; if ( e != null ) { return new SAXParseException ( error , locator , e ) ; } else { return new SAXParseException ( error , locator ) ; } } log . error ( "No-Locator!" ) ; if ( e != null ) { return new SAXException ( message , e ) ; } else { return new SAXException ( message ) ; } } 
public void setVerticalScrollbarPosition ( int position ) { if ( mVerticalScrollbarPosition != position ) { mVerticalScrollbarPosition = position ; computeOpaqueFlags ( ) ; resolvePadding ( ) ; } } 
public void doResumeDownload ( ) { synchronized ( downloadPauseLock ) { downloadResume = true ; downloadPauseLock . notifyAll ( ) ; } } 
public static Vector getVector ( Point a , Point b ) { Vector v = new Vector ( ) ; v . setX ( b . getX ( ) - a . getX ( ) ) ; v . setY ( b . getY ( ) - a . getY ( ) ) ; v . setZ ( b . getZ ( ) - a . getZ ( ) ) ; return v ; } 
public void add ( String key , String value ) { if ( key != null && value != null ) { ArrayList < String > paramArray = urlParamsWithArray . get ( key ) ; if ( paramArray == null ) { paramArray = new ArrayList < String > ( ) ; this . put ( key , paramArray ) ; } paramArray . add ( value ) ; } } 
public static void closeAll ( Closeable a , Closeable b ) throws IOException { Throwable thrown = null ; try { a . close ( ) ; } catch ( Throwable e ) { thrown = e ; } try { b . close ( ) ; } catch ( Throwable e ) { if ( thrown == null ) thrown = e ; } if ( thrown == null ) return ; if ( thrown instanceof IOException ) throw ( IOException ) thrown ; if ( thrown instanceof RuntimeException ) throw ( RuntimeException ) thrown ; if ( thrown instanceof Error ) throw ( Error ) thrown ; throw new AssertionError ( thrown ) ; } 
public void paintComponentWhiteColor ( List < Composite > components ) { Iterator < Composite > it = components . iterator ( ) ; while ( it . hasNext ( ) ) { Composite item = it . next ( ) ; if ( item instanceof Composite ) { Control [ ] children = ( ( Composite ) item ) . getChildren ( ) ; for ( int x = 0 ; x < children . length ; x ++ ) { if ( children [ x ] instanceof Composite ) { Control [ ] grandChildren = ( ( Composite ) children [ x ] ) . getChildren ( ) ; for ( int i = 0 ; i < grandChildren . length ; i ++ ) { if ( grandChildren [ i ] instanceof Text ) { Text text = ( Text ) grandChildren [ i ] ; if ( text . getBackground ( ) . equals ( Display . getCurrent ( ) . getSystemColor ( SWT . COLOR_RED ) ) ) { text . setBackground ( Display . getCurrent ( ) . getSystemColor ( SWT . COLOR_WHITE ) ) ; } } } } } } } } 
public static int countOccurences ( String str , String subStr ) { int len = subStr . length ( ) ; if ( len == 0 ) { return 0 ; } int pos = 0 ; int count = 0 ; while ( ( pos = str . indexOf ( subStr , pos ) ) >= 0 ) { count ++ ; pos += len ; } return count ; } 
private int indexOfDuplicate ( Attribute attribute ) { int duplicate = - 1 ; String name = attribute . getName ( ) ; Namespace namespace = attribute . getNamespace ( ) ; duplicate = indexOf ( name , namespace ) ; return duplicate ; } 
@ XmlElementDecl ( namespace = "http://esb.spdbbiz.com/services/S120030026" , name = "EndDate" ) public JAXBElement < String > createEndDate ( String value ) { return new JAXBElement < String > ( _EndDate_QNAME , String . class , null , value ) ; } 
private JMenuItem getJMenuItemExit ( ) { if ( jMenuItemExit == null ) { jMenuItemExit = new JMenuItem ( ) ; jMenuItemExit . setText ( "Exit" ) ; jMenuItemExit . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent e ) { System . exit ( 1 ) ; System . out . println ( "actionPerformed()" ) ; } } ) ; } return jMenuItemExit ; } 
public List < Object > getAny ( ) { if ( any == null ) { any = new ArrayList < Object > ( ) ; } return this . any ; } 
@ XmlElementDecl ( namespace = "" , name = "DeclIndCurUlt" ) public JAXBElement < String > createDeclIndCurUlt ( String value ) { return new JAXBElement < String > ( _DeclIndCurUlt_QNAME , String . class , null , value ) ; } 
protected boolean copy ( File from , File to ) { try { if ( ! to . exists ( ) ) { if ( ! to . createNewFile ( ) ) { log . error ( sm . getString ( "fileNewFail" , to ) ) ; return false ; } } java . io . FileInputStream is = new java . io . FileInputStream ( from ) ; java . io . FileOutputStream os = new java . io . FileOutputStream ( to , false ) ; byte [ ] buf = new byte [ 4096 ] ; while ( true ) { int len = is . read ( buf ) ; if ( len < 0 ) break ; os . write ( buf , 0 , len ) ; } is . close ( ) ; os . close ( ) ; } catch ( IOException e ) { log . error ( sm . getString ( "farmWarDeployer.fileCopyFail" , from , to ) , e ) ; return false ; } return true ; } 
public String [ ] getOptions ( ) { Vector < String > result ; String [ ] options ; int i ; result = new Vector < String > ( ) ; options = super . getOptions ( ) ; for ( i = 0 ; i < options . length ; i ++ ) result . add ( options [ i ] ) ; result . add ( "-S" ) ; result . add ( "" + m_Seed ) ; return result . toArray ( new String [ result . size ( ) ] ) ; } 
public int codePointBefore ( int index ) { if ( index < 1 || index > count ) { throw indexAndLength ( index ) ; } return Character . codePointBefore ( value , index ) ; } 
public void clear ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { q . clear ( ) ; } finally { lock . unlock ( ) ; } } 
private void humanTurn ( Scanner in ) { boolean turnOver = false ; while ( ! turnOver ) { System . out . println ( NEWLINE + REMOVE_STONES_PROMPT ) ; int stones = 0 ; try { stones = in . nextInt ( ) ; turnOver = pickupStones ( stones ) ; } catch ( InputMismatchException e ) { System . out . println ( INVALID_INPUT_TRY_AGAIN ) ; in . next ( ) ; } catch ( NoSuchElementException e ) { System . out . println ( GOODBYE_HUMAN ) ; System . exit ( 0 ) ; } catch ( IllegalStateException e ) { System . out . println ( GOODBYE_HUMAN ) ; System . exit ( 0 ) ; } if ( turnOver ) { history += NEWLINE + STONES_HUMAN_REMOVED_HISTORY + stones ; System . out . println ( STONES_HUMAN_REMOVED_ECHO + stones ) ; } } if ( currentStones == 0 ) { lose ( ) ; } } 
protected void addURL ( URL url ) { try { originalUrls . add ( url ) ; searchList . add ( createSearchURL ( url ) ) ; } catch ( MalformedURLException e ) { } } 
public static Enumeration < NetworkInterface > getNetworkInterfaces ( ) throws SocketException { final NetworkInterface [ ] netifs = getAll ( ) ; if ( netifs == null ) return null ; return new Enumeration < NetworkInterface > ( ) { private int i = 0 ; public NetworkInterface nextElement ( ) { if ( netifs != null && i < netifs . length ) { NetworkInterface netif = netifs [ i ++ ] ; return netif ; } else { throw new NoSuchElementException ( ) ; } } public boolean hasMoreElements ( ) { return ( netifs != null && i < netifs . length ) ; } } ; } 
public String getInternalName ( ) { return new String ( buf , off + 1 , len - 2 ) ; } 
public void replaceRange ( String str , int start , int end ) { if ( end < start ) { throw new IllegalArgumentException ( "end-before-start" ) ; } Document doc = getDocument ( ) ; if ( doc != null ) { try { if ( doc instanceof AbstractDocument ) { ( ( AbstractDocument ) doc ) . replace ( start , end - start , str , null ) ; } else { doc . remove ( start , end - start ) ; doc . insertString ( start , str , null ) ; } } catch ( BadLocationException e ) { throw new IllegalArgumentException ( e . getMessage ( ) ) ; } } } 
public void removeIngredient ( int position ) { ingredients . remove ( position ) ; } 
protected boolean printView ( Graphics2D graphics2D , Shape allocation , View view ) { boolean pageExists = false ; Rectangle clipRectangle = graphics2D . getClipBounds ( ) ; Shape childAllocation ; View childView ; if ( view . getViewCount ( ) > 0 ) { for ( int i = 0 ; i < view . getViewCount ( ) ; i ++ ) { childAllocation = view . getChildAllocation ( i , allocation ) ; if ( childAllocation != null ) { childView = view . getView ( i ) ; if ( printView ( graphics2D , childAllocation , childView ) ) { pageExists = true ; } } } } else { if ( allocation . getBounds ( ) . getMaxY ( ) >= clipRectangle . getY ( ) ) { pageExists = true ; if ( ( allocation . getBounds ( ) . getHeight ( ) > clipRectangle . getHeight ( ) ) && ( allocation . intersects ( clipRectangle ) ) ) { view . paint ( graphics2D , allocation ) ; } else { if ( allocation . getBounds ( ) . getY ( ) >= clipRectangle . getY ( ) ) { if ( allocation . getBounds ( ) . getMaxY ( ) <= clipRectangle . getMaxY ( ) ) { view . paint ( graphics2D , allocation ) ; } else { if ( allocation . getBounds ( ) . getY ( ) < m_PageEndY ) { m_PageEndY = allocation . getBounds ( ) . getY ( ) ; } } } } } } return pageExists ; } 
public boolean removeCapabilitiesFilterListener ( CapabilitiesFilterChangeListener l ) { return m_CapabilitiesFilterChangeListeners . remove ( l ) ; } 
public Object getProperty ( String propertyId ) throws XMLConfigurationException { if ( LOCALE . equals ( propertyId ) ) { return getLocale ( ) ; } return super . getProperty ( propertyId ) ; } 
public int size ( ) { return map . size ( ) ; } 
public String toString ( ) { return Long . toString ( get ( ) ) ; } 
public static String getProperFileName ( final String name ) { final StringBuilder newName = new StringBuilder ( ) ; for ( int i = 0 ; i < name . length ( ) ; ++ i ) { if ( ! isIllegalFileNameChar ( name . charAt ( i ) ) ) { newName . append ( name . charAt ( i ) ) ; } } return newName . toString ( ) . replaceAll ( "-" , "_" ) ; } 
public final Collection < Thread > getSharedQueuedThreads ( ) { ArrayList < Thread > list = new ArrayList < Thread > ( ) ; for ( Node p = tail ; p != null ; p = p . prev ) { if ( p . isShared ( ) ) { Thread t = p . thread ; if ( t != null ) list . add ( t ) ; } } return list ; } 
public String getSignature ( ) { return "lts-" + node . hashCode ( ) + "-ws-" + wordSequence ; } 
public static String encode ( String username ) { return username == null ? null : username . replace ( '@' , '+' ) . replace ( ':' , '+' ) ; } 
public String readLine ( ) throws IOException { synchronized ( in ) { if ( buf == null ) { throw new IOException ( "LineReader-is-closed" ) ; } if ( pos >= end ) { fillBuf ( ) ; } for ( int i = pos ; i != end ; ++ i ) { if ( buf [ i ] == LF ) { int lineEnd = ( i != pos && buf [ i - 1 ] == CR ) ? i - 1 : i ; String res = new String ( buf , pos , lineEnd - pos , charset . name ( ) ) ; pos = i + 1 ; return res ; } } ByteArrayOutputStream out = new ByteArrayOutputStream ( end - pos + 80 ) { @ Override public String toString ( ) { int length = ( count > 0 && buf [ count - 1 ] == CR ) ? count - 1 : count ; try { return new String ( buf , 0 , length , charset . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( e ) ; } } } ; while ( true ) { out . write ( buf , pos , end - pos ) ; end = - 1 ; fillBuf ( ) ; for ( int i = pos ; i != end ; ++ i ) { if ( buf [ i ] == LF ) { if ( i != pos ) { out . write ( buf , pos , i - pos ) ; } pos = i + 1 ; return out . toString ( ) ; } } } } } 
protected void buildView ( ) { JPanel buttonPanel = new JPanel ( new FlowLayout ( ) ) ; JButton okButton = new JSmartButton ( ACTION_OK ) ; okButton . setActionCommand ( ACTION_OK ) ; okButton . addActionListener ( this ) ; JButton cancelButton = new JSmartButton ( ACTION_CANCEL ) ; cancelButton . setActionCommand ( ACTION_CANCEL ) ; cancelButton . addActionListener ( this ) ; buttonPanel . add ( okButton ) ; buttonPanel . add ( cancelButton ) ; JPanel view = new JPanel ( new BorderLayout ( ) ) ; view . add ( BorderLayout . CENTER , buildPreferencesPanel ( ) ) ; view . add ( BorderLayout . SOUTH , buttonPanel ) ; setContentPane ( view ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public void sendErrorPacket ( byte [ ] errCode , InetAddress address , int port , Exception cause ) { if ( errCode . length != 2 ) { throw new IllegalArgumentException ( "Op-code-must-be-length-2!-Found-length-" + errCode . length + "." ) ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; buffer . write ( 0 ) ; buffer . write ( 5 ) ; buffer . write ( errCode [ 0 ] ) ; buffer . write ( errCode [ 1 ] ) ; buffer . write ( cause . getMessage ( ) . getBytes ( ) , 0 , cause . getMessage ( ) . length ( ) ) ; buffer . write ( 0 ) ; System . out . println ( ) ; LOG . severe ( "Error-code-" + errCode [ 0 ] + errCode [ 1 ] + "-has-occurred." + ( cause instanceof AddressException ? "" : "Closing-the-current-request..." ) + "-Cause-of-error:-" + cause . getMessage ( ) ) ; DatagramPacket errPack = new DatagramPacket ( buffer . toByteArray ( ) , buffer . toByteArray ( ) . length , address , port ) ; try { socket . send ( errPack ) ; } catch ( IOException e ) { LOG . log ( Level . SEVERE , e . getMessage ( ) , e ) ; } } 
public void writeValue ( Object value ) { if ( value == null ) { return ; } String stringForm = String . valueOf ( value ) ; if ( ( stringForm . indexOf ( '-' ) >= 0 ) || ( stringForm . indexOf ( '|n' ) >= 0 ) || ( stringForm . indexOf ( '|t' ) >= 0 ) || ( stringForm . indexOf ( '|r' ) >= 0 ) || ( stringForm . indexOf ( '|f' ) >= 0 ) || ( stringForm . indexOf ( 0x0B ) >= 0 ) ) { throw new IllegalArgumentException ( "A-value-in-an-xml-list-cannot-contain-a-whitespace.-Offending-value:-" + stringForm ) ; } items . add ( stringForm ) ; } 
public Object getWrapperForObject ( Object javaObject ) { return weakJavaWrapperCache . get ( javaObject ) ; } 
@ Override public String toString ( ) { StringBuilder toBeReturned = new StringBuilder ( ) ; toBeReturned . append ( this . nickname ) ; toBeReturned . append ( "-" ) ; toBeReturned . append ( this . dateCreated . toString ( ) ) ; return toBeReturned . toString ( ) ; } 
public List < BankAccount > getReturn ( ) { if ( _return == null ) { _return = new ArrayList < BankAccount > ( ) ; } return this . _return ; } 
private int getRecordCountFromInfo ( String serverInfo ) { StringBuffer recordsBuf = new StringBuffer ( ) ; int recordsCount = 0 ; int duplicatesCount = 0 ; char c = ( char ) 0 ; int length = serverInfo . length ( ) ; int i = 0 ; for ( ; i < length ; i ++ ) { c = serverInfo . charAt ( i ) ; if ( Character . isDigit ( c ) ) { break ; } } recordsBuf . append ( c ) ; i ++ ; for ( ; i < length ; i ++ ) { c = serverInfo . charAt ( i ) ; if ( ! Character . isDigit ( c ) ) { break ; } recordsBuf . append ( c ) ; } recordsCount = Integer . parseInt ( recordsBuf . toString ( ) ) ; StringBuffer duplicatesBuf = new StringBuffer ( ) ; for ( ; i < length ; i ++ ) { c = serverInfo . charAt ( i ) ; if ( Character . isDigit ( c ) ) { break ; } } duplicatesBuf . append ( c ) ; i ++ ; for ( ; i < length ; i ++ ) { c = serverInfo . charAt ( i ) ; if ( ! Character . isDigit ( c ) ) { break ; } duplicatesBuf . append ( c ) ; } duplicatesCount = Integer . parseInt ( duplicatesBuf . toString ( ) ) ; return recordsCount - duplicatesCount ; } 
public void endEmptyTag ( String tag ) throws IOException { if ( state != IN_TAG ) throw new IllegalStateException ( ) ; out . write ( ">" ) ; state = IN_BODY ; out . newLine ( ) ; } 
public void setProperty ( QualifiedName key , Object value ) { if ( properties == null ) { properties = new HashMap ( ) ; } properties . put ( key , value ) ; } 
private void removeItemAtInt ( int index , boolean updateChildrenOnMenuViews ) { if ( ( index < 0 ) || ( index >= mItems . size ( ) ) ) return ; mItems . remove ( index ) ; if ( updateChildrenOnMenuViews ) onItemsChanged ( true ) ; } 
public double rank ( double element ) { this . sort ( ) ; return cern . jet . stat . Descriptive . rankInterpolated ( this . values , element ) ; } 
@ Override public void attack ( Character c ) { Random rand = new Random ( ) ; int damage = rand . nextInt ( 5 * c . getLevel ( ) + 1 ) ; System . out . printf ( "%s-hit-a-%s-for-%d-damage.%n" , getName ( ) , c . getName ( ) , damage ) ; c . takeDamage ( damage ) ; } 
public static final String jasminEscape ( String str ) { boolean flag ; StringBuffer sb = new StringBuffer ( ) ; flag = isJasminKeyWord ( str ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( ! jasminIsSafelyPrintable ( c ) || flag ) { flag = false ; if ( c < 256 ) { String octval = Integer . toOctalString ( ( int ) c ) ; while ( octval . length ( ) < 3 ) octval = "0" + octval ; sb . append ( '|' ) ; sb . append ( octval ) ; } else { String hexval = Integer . toHexString ( ( int ) c ) ; while ( hexval . length ( ) < 4 ) hexval = "0" + hexval ; sb . append ( '|' ) ; sb . append ( 'u' ) ; sb . append ( hexval ) ; } } else sb . append ( c ) ; } return sb . toString ( ) ; } 
public final boolean tryAcquireSharedNanos ( int arg , long nanosTimeout ) throws InterruptedException { if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; return tryAcquireShared ( arg ) >= 0 || doAcquireSharedNanos ( arg , nanosTimeout ) ; } 
public void reassignTopic ( final String topic ) { this . topic = topic ; updateNeeded . set ( true ) ; } 
@ Override protected double [ ] applyMelCosine ( double [ ] melspectrum ) { double [ ] cepstrum = new double [ cepstrumSize ] ; double sqrt_inv_n = Math . sqrt ( 1.0 / numberMelFilters ) ; double sqrt_inv_2n = Math . sqrt ( 2.0 / numberMelFilters ) ; cepstrum [ 0 ] = melspectrum [ 0 ] ; for ( int j = 1 ; j < numberMelFilters ; j ++ ) { cepstrum [ 0 ] += melspectrum [ j ] ; } cepstrum [ 0 ] *= sqrt_inv_n ; if ( numberMelFilters <= 0 ) { return cepstrum ; } for ( int i = 1 ; i < cepstrum . length ; i ++ ) { double [ ] melcosine_i = melcosine [ i ] ; int j = 0 ; cepstrum [ i ] = 0 ; for ( j = 0 ; j < numberMelFilters ; j ++ ) { cepstrum [ i ] += ( melspectrum [ j ] * melcosine_i [ j ] ) ; } cepstrum [ i ] *= sqrt_inv_2n ; } return cepstrum ; } 
public List list ( ) { return new ArrayList ( ) ; } 
public void deleteEmptyJavaFiles ( ) { if ( javaFiles != null ) { Enumeration e = javaFiles . elements ( ) ; while ( e . hasMoreElements ( ) ) { File file = ( File ) e . nextElement ( ) ; if ( file . exists ( ) && file . length ( ) == 0 ) { log ( "deleting-empty-output-file-" + file ) ; file . delete ( ) ; } } } } 
public void checkLink ( String libName ) { if ( libName == null ) { throw new NullPointerException ( ) ; } checkPermission ( new RuntimePermission ( "loadLibrary." + libName ) ) ; } 
public int getPerUserMinIdle ( String key ) { Integer value = null ; if ( perUserMinIdle != null ) { value = perUserMinIdle . get ( key ) ; } if ( value == null ) { return getDefaultMinIdle ( ) ; } return value . intValue ( ) ; } 
public static void sort ( char [ ] a ) { sort1 ( a , 0 , a . length ) ; } 
@ Override public PrintWriter append ( CharSequence csq ) { if ( csq == null ) { csq = "null" ; } append ( csq , 0 , csq . length ( ) ) ; return this ; } 
public String [ ] split ( CharSequence input ) { return split ( input , 0 ) ; } 
private static < T > List < T > filterSelection ( Class < T > clazz , IStructuredSelection selection ) { List < T > list = new ArrayList < T > ( ) ; for ( Object obj : selection . toList ( ) ) { if ( clazz . isAssignableFrom ( obj . getClass ( ) ) ) { list . add ( ( T ) obj ) ; } } return list ; } 
public static boolean isDialogCreated ( String method ) { return dialogCreatingMethods . contains ( method ) ; } 
public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; for ( Period p : this . list ) { buffer . append ( p . toString ( ) ) ; buffer . append ( '|n' ) ; } return buffer . toString ( ) ; } 
public static String getUUID ( ) { return UUID . randomUUID ( ) . toString ( ) ; } 
@ Nullable public final View findViewById ( @ IdRes int id ) { if ( id < 0 ) { return null ; } return findViewTraversal ( id ) ; } 
public static boolean addressAlreadyInUse ( Throwable t ) { if ( t == null ) { throw new IllegalArgumentException ( "Exception-cannot-be-null" ) ; } Throwable root = t ; while ( root != null ) { if ( root instanceof BindException && root . getMessage ( ) != null && root . getMessage ( ) . contains ( ADDRESS_ALREADY_IN_USE ) ) { Log . getLogWriter ( ) . warning ( "Got-BindException:-" + ADDRESS_ALREADY_IN_USE ) ; return true ; } if ( root instanceof SocketException && root . getMessage ( ) != null && root . getMessage ( ) . contains ( UNRECOGNIZED_SOCKET ) ) { Log . getLogWriter ( ) . warning ( "Got-SocketException:-" + UNRECOGNIZED_SOCKET ) ; return true ; } root = root . getCause ( ) ; } return false ; } 
public List getIntervals ( ) { return Collections . unmodifiableList ( this . intervals ) ; } 
public Object object ( ) { if ( null == m_obj ) setObject ( new Boolean ( m_val ) ) ; return m_obj ; } 
protected void reportWrongNumberArgs ( ) throws WrongNumberArgsException { throw new WrongNumberArgsException ( XSLMessages . createXPATHMessage ( "two" , null ) ) ; } 
public void addPossibilityToMove ( final Button button , final Composite source , final Composite destination , final Data dSource , final Data dDestination , final char id , final boolean checked ) { button . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { dSource . move ( button . getText ( ) , id , dDestination ) ; String btSaving = new String ( button . getText ( ) ) ; button . dispose ( ) ; Button button2 = new Button ( destination , SWT . CHECK ) ; button2 . setText ( btSaving ) ; button2 . setSelection ( ! checked ) ; addPossibilityToMove ( button2 , destination , source , dDestination , dSource , id , ! checked ) ; addMouseMenu ( button2 , id , dSource ) ; source . setSize ( source . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ) ; destination . setSize ( destination . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) ) ; } } ) ; } 
@ XmlElementDecl ( namespace = "http://www.collada.org/2008/03/COLLADASchema" , name = "bool3x4" , scope = CgArrayType . class ) public JAXBElement < List < Boolean >> createCgArrayTypeBool3X4 ( List < Boolean > value ) { return new JAXBElement < List < Boolean >> ( _CgArrayTypeBool3X4_QNAME , ( ( Class ) List . class ) , CgArrayType . class , ( ( List < Boolean > ) value ) ) ; } 
public < T > List < List < T >> getSubsets ( List < T > set , int index ) { List < List < T >> allSubsets ; if ( index == set . size ( ) ) { allSubsets = new ArrayList < List < T >> ( ) ; allSubsets . add ( new ArrayList < T > ( ) ) ; } else { allSubsets = getSubsets ( set , index + 1 ) ; T item = set . get ( index ) ; List < List < T >> moreSubsets = new ArrayList < List < T >> ( ) ; for ( List < T > subset : allSubsets ) { List < T > newSubset = new ArrayList < T > ( ) ; newSubset . addAll ( subset ) ; newSubset . add ( item ) ; moreSubsets . add ( newSubset ) ; } allSubsets . addAll ( moreSubsets ) ; } return allSubsets ; } 
public void removeRowSetListener ( RowSetListener listener ) { listeners . remove ( listener ) ; } 
@ Override public java . lang . String getCc ( ) { return _message . getCc ( ) ; } 
public boolean replaceTarget ( Restlet originalTarget , Restlet newTarget ) { ArrayList < Restlet > targetsCopy = new ArrayList < Restlet > ( targets ) ; int index = targetsCopy . indexOf ( originalTarget ) ; if ( index != - 1 ) { targetsCopy . set ( index , newTarget ) ; targets = new CopyOnWriteArrayList < Restlet > ( targetsCopy ) ; return true ; } return false ; } 
protected boolean handle ( final String uri , final Request req , final Response res ) throws Exception { boolean found = false ; final File [ ] fileFolders = docRoots . getArray ( ) ; if ( fileFolders == null ) { return false ; } File resource = null ; for ( int i = 0 ; i < fileFolders . length ; i ++ ) { final File webDir = fileFolders [ i ] ; resource = new File ( webDir , uri ) ; final boolean exists = resource . exists ( ) ; final boolean isDirectory = resource . isDirectory ( ) ; if ( exists && isDirectory ) { final File f = new File ( resource , "/index.html" ) ; if ( f . exists ( ) ) { resource = f ; found = true ; break ; } } if ( isDirectory || ! exists ) { found = false ; } else { found = true ; break ; } } if ( ! found ) { if ( LOGGER . isLoggable ( Level . FINE ) ) { LOGGER . log ( Level . FINE , "File-not-found-{0}" , resource ) ; } return false ; } pickupContentType ( res , resource ) ; sendFile ( res , resource ) ; return true ; } 
public String getExpandedElementName ( Element elem ) { String namespace = getNamespaceOfNode ( elem ) ; return ( null != namespace ) ? namespace + ":" + getLocalNameOfNode ( elem ) : getLocalNameOfNode ( elem ) ; } 
public static int sizeOfString ( String string ) { if ( string == null ) { return 0 ; } return 4 + string . getBytes ( ) . length ; } 
public Type [ ] getGenericInterfaces ( ) { Type [ ] result ; synchronized ( Caches . genericInterfaces ) { result = Caches . genericInterfaces . get ( this ) ; if ( result == null ) { String annotationSignature = AnnotationAccess . getSignature ( this ) ; if ( annotationSignature == null ) { result = getInterfaces ( ) ; } else { GenericSignatureParser parser = new GenericSignatureParser ( getClassLoader ( ) ) ; parser . parseForClass ( this , annotationSignature ) ; result = Types . getTypeArray ( parser . interfaceTypes , false ) ; } Caches . genericInterfaces . put ( this , result ) ; } } return ( result . length == 0 ) ? result : result . clone ( ) ; } 
public boolean equals ( Object obj ) { try { return url . equals ( ( ( Entry ) obj ) . getUrl ( ) ) ; } catch ( ClassCastException ex ) { return false ; } } 
void writeFrame ( byte [ ] bytes , int offset , int length ) throws IOException { synchronized ( spdyWriter ) { spdyWriter . out . write ( bytes , offset , length ) ; } } 
public BufferedReader openBufferedStream ( ) throws IOException { Reader reader = openStream ( ) ; return ( reader instanceof BufferedReader ) ? ( BufferedReader ) reader : new BufferedReader ( reader ) ; } 
private static void parseLine ( String line , Listener l ) throws IOException { Map < String , String > parseBuffer = new HashMap < String , String > ( ) ; int idx = line . indexOf ( '-' ) ; String recType = line . substring ( 0 , idx ) ; String data = line . substring ( idx + 1 , line . length ( ) ) ; Matcher matcher = pattern . matcher ( data ) ; while ( matcher . find ( ) ) { String tuple = matcher . group ( 0 ) ; String [ ] parts = tuple . split ( "=" ) ; parseBuffer . put ( parts [ 0 ] , parts [ 1 ] . substring ( 1 , parts [ 1 ] . length ( ) - 1 ) ) ; } l . handle ( RecordTypes . valueOf ( recType ) , parseBuffer ) ; } 
@ JsonIgnore public Set < String > getExtensionSet ( ) { Set < String > extensions = new LinkedHashSet < > ( ) ; for ( String extension : this . extension . split ( "," ) ) extensions . add ( extension ) ; return extensions ; } 
private Result pMultiplicativeExpression ( final int yyStart ) throws IOException { Result yyResult ; int yyRepetition1 ; Pair < Action < Node >> yyRepValue1 ; Node yyValue ; ParseError yyError = ParseError . DUMMY ; yyResult = pUnaryExpression ( yyStart ) ; yyError = yyResult . select ( yyError ) ; if ( yyResult . hasValue ( ) ) { yyValue = yyResult . semanticValue ( ) ; yyRepetition1 = yyResult . index ; yyRepValue1 = Pair . empty ( ) ; while ( true ) { yyResult = pMultiplicativeExpression$$Tail1 ( yyRepetition1 ) ; yyError = yyResult . select ( yyError , yyRepetition1 ) ; if ( yyResult . hasValue ( ) ) { final Action < Node > v$4 = yyResult . semanticValue ( ) ; yyRepetition1 = yyResult . index ; yyRepValue1 = new Pair < Action < Node >> ( v$4 , yyRepValue1 ) ; continue ; } break ; } { final Pair < Action < Node >> v$5 = yyRepValue1 . reverse ( ) ; yyValue = apply ( v$5 , yyValue , yyStart ) ; return new SemanticValue ( yyValue , yyRepetition1 , yyError ) ; } } return yyError ; } 
public void closeSession ( udpSession udpsess ) { allUDPsessions . removeElement ( udpsess ) ; } 
public void identityChanged ( String universalId ) { log ( Level . FINEST , "identityChanged" , "Recvd-notification:" + "-identityChanged:" + universalId + "-eventID-is-" + eventID ) ; if ( ( eventID == 0 ) || ( eventID == 1 ) ) { log ( Level . FINEST , "identityChanged" , "strID:-" + strID ) ; String uid = universalId . toUpperCase ( ) . toLowerCase ( ) ; String struID = strID . toUpperCase ( ) . toLowerCase ( ) ; int index = uid . indexOf ( struID ) ; log ( Level . FINEST , "identityChanged" , "index-of-strID-" + struID + "is-" + index ) ; if ( index != - 1 ) result = true ; } } 
private boolean linkFirst ( Node < E > node ) { if ( count >= capacity ) return false ; Node < E > f = first ; node . next = f ; first = node ; if ( last == null ) last = node ; else f . prev = node ; ++ count ; notEmpty . signal ( ) ; return true ; } 
public static int [ ] getActivatedColorFor ( String encodedColor ) { int [ ] result = new int [ ] { 0 , 0 } ; if ( encodedColor != null ) { String [ ] parts = encodedColor . split ( ";" ) ; result [ 0 ] = Boolean . parseBoolean ( parts [ 0 ] ) ? 1 : 0 ; result [ 1 ] = Integer . parseInt ( parts [ 1 ] ) ; } return result ; } 
private static File getOverride ( ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( JiveGlobals . getHomeDirectory ( ) ) ; if ( ! sb . substring ( sb . length ( ) - 1 ) . startsWith ( File . separator ) ) { sb . append ( File . separator ) ; } sb . append ( "conf" ) ; sb . append ( File . separator ) ; return new File ( sb . toString ( ) , "crossdomain.xml" ) ; } 
public void registerIntentBuilder ( IntentBuilder builder ) { if ( mIntentBuilders == null ) { mIntentBuilders = new ArrayList < IntentBuilder > ( ) ; } mIntentBuilders . add ( builder ) ; } 
public void setLenient ( boolean value ) { calendar . setLenient ( value ) ; } 
public String toString ( ) { return stateToString ( reconcileState ( ) ) ; } 
public boolean testBit ( int n ) { if ( n == 0 ) { return ( ( digits [ 0 ] & 1 ) != 0 ) ; } if ( n < 0 ) { throw new ArithmeticException ( "Negative-bit-address" ) ; } int intCount = n >> 5 ; if ( intCount >= numberLength ) { return ( sign < 0 ) ; } int digit = digits [ intCount ] ; n = ( 1 << ( n & 31 ) ) ; if ( sign < 0 ) { int firstNonZeroDigit = getFirstNonzeroDigit ( ) ; if ( intCount < firstNonZeroDigit ) { return false ; } else if ( firstNonZeroDigit == intCount ) { digit = - digit ; } else { digit = ~ digit ; } } return ( ( digit & n ) != 0 ) ; } 
public static String getCurrentDir ( ) { return System . getProperty ( "user.dir" ) ; } 
private void appendCmdsToList ( Map typeHash , List cmdList ) { Iterator verb_enum = typeHash . keySet ( ) . iterator ( ) ; while ( verb_enum . hasNext ( ) ) { String verb = ( String ) verb_enum . next ( ) ; List cmdList2 = ( List ) typeHash . get ( verb ) ; Iterator cmd_enum = ( ( List ) cmdList2 ) . iterator ( ) ; while ( cmd_enum . hasNext ( ) ) { String cmd = ( String ) cmd_enum . next ( ) ; cmdList . add ( new CommandInfo ( verb , cmd ) ) ; } } } 
public boolean set ( Region region ) { return nativeSetRegion ( mNativeRegion , region . mNativeRegion ) ; } 
public static CipherSuite getByName ( String name ) { return SUITES_BY_NAME . get ( name ) ; } 
public boolean paintCachedImage ( Graphics g , int x , int y , int w , int h , Object ... args ) { if ( w <= 0 || h <= 0 ) { return true ; } Image img = cache . getImage ( getClass ( ) , null , w , h , args ) ; if ( img != null ) { g . drawImage ( img , x , y , null ) ; return true ; } return false ; } 
@ HLEFunction ( nid = 0xB58E61B7 , version = 150 ) public int sceNetAdhocMatchingSetHelloOpt ( @ CheckArgument ( "checkMatchingId" ) int matchingId , int optLen , @ CanBeNull TPointer optData ) { if ( log . isTraceEnabled ( ) ) { log . trace ( String . format ( "Hello-opt-data:-%s" , Utilities . getMemoryDump ( optData . getAddress ( ) , optLen ) ) ) ; } matchingObjects . get ( matchingId ) . setHelloOpt ( optLen , optData . getAddress ( ) ) ; return 0 ; } 
public synchronized void setMaxSize ( long maxSize ) { this . maxSize = maxSize ; executorService . submit ( cleanupCallable ) ; } 
public XMLGregorianCalendar normalize ( ) { XMLGregorianCalendar normalized = normalizeToTimezone ( timezone ) ; if ( getTimezone ( ) == DatatypeConstants . FIELD_UNDEFINED ) { normalized . setTimezone ( DatatypeConstants . FIELD_UNDEFINED ) ; } if ( getMillisecond ( ) == DatatypeConstants . FIELD_UNDEFINED ) { normalized . setMillisecond ( DatatypeConstants . FIELD_UNDEFINED ) ; } return normalized ; } 
public static void emitTypeWithParens ( String type , boolean addBreaks ) { if ( type . compareTo ( "" ) == 0 ) reportFile . print ( "()" ) ; else { int idx = type . indexOf ( ",-" ) ; if ( ! addBreaks || idx == - 1 ) { reportFile . print ( "(<code>" + type + "</code>)" ) ; } else { String sepType = null ; StringTokenizer st = new StringTokenizer ( type , ",-" ) ; while ( st . hasMoreTokens ( ) ) { String p = st . nextToken ( ) ; if ( sepType == null ) sepType = p ; else sepType += ",</nobr>-" + p + "<nobr>" ; } reportFile . print ( "(<code>" + sepType + "<nobr></code>)" ) ; } } } 
public synchronized StringBuffer insert ( int index , char ch ) { insert0 ( index , ch ) ; return this ; } 
private void init ( ) { final List < Rule > rulesList = parsePattern ( ) ; mRules = rulesList . toArray ( new Rule [ rulesList . size ( ) ] ) ; int len = 0 ; for ( int i = mRules . length ; -- i >= 0 ; ) { len += mRules [ i ] . estimateLength ( ) ; } mMaxLengthEstimate = len ; } 
@ XmlElementDecl ( namespace = "urn:oio:medcom:chronicdataset:1.0.0" , name = "MedicalPracticeIdentifier" ) public JAXBElement < Integer > createMedicalPracticeIdentifier ( Integer value ) { return new JAXBElement < Integer > ( _MedicalPracticeIdentifier_QNAME , Integer . class , null , value ) ; } 
public void println ( Object x ) { out . println ( x ) ; } 
@ Override public SortedSet < V > get ( @ Nullable K key ) { return ( SortedSet < V > ) super . get ( key ) ; } 
public void transform ( Matrix matrix ) { native_transform ( mNativePath , matrix . native_instance ) ; } 
public < T extends EventListener > T [ ] getListeners ( Class < T > listenerType ) { return listenerList . getListeners ( listenerType ) ; } 
@ Deprecated public static String getAlgorithmProperty ( String algName , String propName ) { if ( algName == null || propName == null ) { return null ; } String prop = "Alg." + propName + "." + algName ; Provider [ ] providers = getProviders ( ) ; for ( Provider provider : providers ) { for ( Enumeration < ? > e = provider . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String propertyName = ( String ) e . nextElement ( ) ; if ( propertyName . equalsIgnoreCase ( prop ) ) { return provider . getProperty ( propertyName ) ; } } } return null ; } 
public int getLocalPort ( ) { return _address . getPort ( ) ; } 
public static boolean isServerSide ( Message message ) { return message . getExchange ( ) . getDestination ( ) != null ; } 
public ZipExtraField [ ] getExtraFields ( ) { if ( extraFields == null ) { return new ZipExtraField [ 0 ] ; } ZipExtraField [ ] result = new ZipExtraField [ extraFields . size ( ) ] ; extraFields . copyInto ( result ) ; return result ; } 
protected void calcYValueSum ( ) { mYValueSum = 0 ; if ( mDataSets == null ) return ; for ( int i = 0 ; i < mDataSets . size ( ) ; i ++ ) { mYValueSum += Math . abs ( mDataSets . get ( i ) . getYValueSum ( ) ) ; } } 
void redispatchEvent ( MouseEvent me ) { me . setSource ( tabPane ) ; Point viewPos = viewport . getViewPosition ( ) ; viewPos . x -= viewport . getX ( ) ; viewPos . y -= viewport . getY ( ) ; me . translatePoint ( - viewPos . x , - viewPos . y ) ; tabPane . dispatchEvent ( me ) ; me . translatePoint ( viewPos . x , viewPos . y ) ; } 
public static File getAppDir ( String par0Str ) { String s = System . getProperty ( "user.home" , "." ) ; File file ; switch ( EnumOSMappingHelper . enumOSMappingArray [ getOs ( ) . ordinal ( ) ] ) { case 1 : case 2 : file = new File ( s , ( new StringBuilder ( ) ) . append ( '.' ) . append ( par0Str ) . append ( '/' ) . toString ( ) ) ; break ; case 3 : String s1 = System . getenv ( "APPDATA" ) ; if ( s1 != null ) { file = new File ( s1 , ( new StringBuilder ( ) ) . append ( "." ) . append ( par0Str ) . append ( '/' ) . toString ( ) ) ; } else { file = new File ( s , ( new StringBuilder ( ) ) . append ( '.' ) . append ( par0Str ) . append ( '/' ) . toString ( ) ) ; } break ; case 4 : file = new File ( s , ( new StringBuilder ( ) ) . append ( "Library/Application-Support/" ) . append ( par0Str ) . toString ( ) ) ; break ; default : file = new File ( s , ( new StringBuilder ( ) ) . append ( par0Str ) . append ( '/' ) . toString ( ) ) ; break ; } if ( ! file . exists ( ) && ! file . mkdirs ( ) ) { throw new RuntimeException ( ( new StringBuilder ( ) ) . append ( "The-working-directory-could-not-be-created:-" ) . append ( file ) . toString ( ) ) ; } else { return file ; } } 
public void setHistory ( DefaultListModel history ) { int i ; m_History . clear ( ) ; for ( i = 0 ; i < history . size ( ) ; i ++ ) { m_History . addElement ( history . get ( i ) ) ; } setButtons ( ) ; } 
void workerUpdate ( File dir , boolean force ) { if ( dir == null ) return ; if ( ( ! force ) && ( workerNextDir != null ) && ( workerNextDir . equals ( dir ) ) ) return ; synchronized ( workerLock ) { workerNextDir = dir ; workerStopped = false ; workerCancelled = true ; workerLock . notifyAll ( ) ; } if ( workerThread == null ) { workerThread = new Thread ( workerRunnable ) ; workerThread . start ( ) ; } } 
public Set < Edge > getEdges ( Set < String > vertexPair ) { Set < Edge > edges = edgeMap . get ( vertexPair ) ; if ( edges == null ) throw new IllegalArgumentException ( ) ; else return edges ; } 
public static final DateFormatSymbols getInstance ( ) { return getInstance ( Locale . getDefault ( ) ) ; } 
public void saveWorldInfo ( WorldInfo par1WorldInfo ) { NBTTagCompound var2 = par1WorldInfo . getNBTTagCompound ( ) ; NBTTagCompound var3 = new NBTTagCompound ( ) ; var3 . setTag ( "Data" , var2 ) ; try { File var4 = new File ( this . worldDirectory , "level.dat_new" ) ; File var5 = new File ( this . worldDirectory , "level.dat_old" ) ; File var6 = new File ( this . worldDirectory , "level.dat" ) ; CompressedStreamTools . writeCompressed ( var3 , new FileOutputStream ( var4 ) ) ; if ( var5 . exists ( ) ) { var5 . delete ( ) ; } var6 . renameTo ( var5 ) ; if ( var6 . exists ( ) ) { var6 . delete ( ) ; } var4 . renameTo ( var6 ) ; if ( var4 . exists ( ) ) { var4 . delete ( ) ; } } catch ( Exception var7 ) { var7 . printStackTrace ( ) ; } } 
public static Location getRandomEmptyAdjacentLocation ( World world , Location loc ) { Location [ ] neighbors = new Location [ 3 * 3 ] ; int numLocs = 0 ; for ( int x = loc . getX ( ) - 1 ; x <= loc . getX ( ) + 1 ; x ++ ) { for ( int y = loc . getY ( ) - 1 ; y <= loc . getY ( ) + 1 ; y ++ ) { Location l = new Location ( x , y ) ; if ( isValidLocation ( world , l ) && isLocationEmpty ( world , l ) ) { neighbors [ numLocs ] = l ; numLocs ++ ; } } } if ( numLocs == 0 ) return null ; return neighbors [ RAND . nextInt ( numLocs ) ] ; } 
private String addDefaultProfile ( ) { String profile = System . getProperty ( "spring.profiles.active" ) ; if ( profile != null ) { log . info ( "Running-with-Spring-profile(s)-:-{}" , profile ) ; return profile ; } log . warn ( "No-Spring-profile-configured,-running-with-default-configuration" ) ; return Constants . SPRING_PROFILE_DEVELOPMENT ; } 
public void setLayoutStyle ( LayoutStyle layoutStyle ) { this . layoutStyle = layoutStyle ; invalidateHost ( ) ; } 
public static void onChange ( Map < String , String > map ) { MAP . putAll ( map ) ; } 
public void print ( PrintWriter output , int w , int d ) { DecimalFormat format = new DecimalFormat ( ) ; format . setDecimalFormatSymbols ( new DecimalFormatSymbols ( Locale . US ) ) ; format . setMinimumIntegerDigits ( 1 ) ; format . setMaximumFractionDigits ( d ) ; format . setMinimumFractionDigits ( d ) ; format . setGroupingUsed ( false ) ; print ( output , format , w + 2 ) ; } 
public void setInputEncoding ( String encoding ) { error ( XMLErrorResources . ER_FUNCTION_NOT_SUPPORTED ) ; } 
public static int numberOfTrailingZeros ( int value ) { return bitCount ( ( value & - value ) - 1 ) ; } 
public static boolean requiresBidi ( char [ ] text , int start , int limit ) { if ( limit < 0 || start < 0 || start > limit || limit > text . length ) { throw new IllegalArgumentException ( ) ; } Bidi bidi = new Bidi ( text , start , null , 0 , limit - start , 0 ) ; return ! bidi . isLeftToRight ( ) ; } 
private void initContextLinks ( ) { demoLinks = new HashMap < String , String > ( ) ; adminLinks = new HashMap < String , String > ( ) ; for ( MarmottaContext ctx : contexts ) { if ( ctx . getServletContext ( ) != null ) { Object ctxAdminAttr = ctx . getServletContext ( ) . getAttribute ( "systray.admin" ) ; if ( ctxAdminAttr != null && ctxAdminAttr instanceof Map ) { @ SuppressWarnings ( "unchecked" ) Map < String , String > ctxAdminLinks = ( Map < String , String > ) ctxAdminAttr ; adminLinks . putAll ( ctxAdminLinks ) ; } Object ctxDemoAttr = ctx . getServletContext ( ) . getAttribute ( "systray.demo" ) ; if ( ctxDemoAttr != null && ctxDemoAttr instanceof Map ) { @ SuppressWarnings ( "unchecked" ) Map < String , String > ctxDemoLinks = ( Map < String , String > ) ctxDemoAttr ; demoLinks . putAll ( ctxDemoLinks ) ; } } else { log . error ( "could-not-register-systray-links-because-servlet-context-is-not-yet-initialised" ) ; } } } 
public boolean checkMonitorHit ( ActivityMonitor monitor , int minHits ) { waitForIdleSync ( ) ; synchronized ( mSync ) { if ( monitor . getHits ( ) < minHits ) { return false ; } mActivityMonitors . remove ( monitor ) ; } return true ; } 
private void writeStartElement ( java . lang . String prefix , java . lang . String namespace , java . lang . String localPart , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String writerPrefix = xmlWriter . getPrefix ( namespace ) ; if ( writerPrefix != null ) { xmlWriter . writeStartElement ( namespace , localPart ) ; } else { if ( namespace . length ( ) == 0 ) { prefix = "" ; } else if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; } xmlWriter . writeStartElement ( prefix , localPart , namespace ) ; xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } } 
@ XmlElementDecl ( namespace = "http://www.collada.org/2005/11/COLLADASchema" , name = "bool3x4" , scope = CgNewarrayType . class ) public JAXBElement < List < Boolean >> createCgNewarrayTypeBool3X4 ( List < Boolean > value ) { return new JAXBElement < List < Boolean >> ( _CgNewarrayTypeBool3X4_QNAME , ( ( Class ) List . class ) , CgNewarrayType . class , ( ( List < Boolean > ) value ) ) ; } 
private static boolean hasAlpha ( Image image ) { if ( image instanceof BufferedImage ) { BufferedImage bimage = ( BufferedImage ) image ; return bimage . getColorModel ( ) . hasAlpha ( ) ; } PixelGrabber pg = new PixelGrabber ( image , 0 , 0 , 1 , 1 , false ) ; try { pg . grabPixels ( ) ; } catch ( InterruptedException e ) { } ColorModel cm = pg . getColorModel ( ) ; return cm . hasAlpha ( ) ; } 
public static Label get ( String name ) { Label existing = labels . get ( name ) ; if ( existing != null ) return existing ; Label newLabel = new Label ( name ) ; labels . put ( name , newLabel ) ; return newLabel ; } 
public Object clone ( ) { return ( new ModelMBeanInfoSupport ( this ) ) ; } 
@ Override public synchronized void close ( ) { for ( Entry < String , ConnectionSource > entry : androidSQLiteMap . entrySet ( ) ) { ( ( OpenHelperConnectionSource ) entry . getValue ( ) ) . close ( ) ; } androidSQLiteMap . clear ( ) ; } 
public Builder with ( Animator anim ) { Node node = mNodeMap . get ( anim ) ; if ( node == null ) { node = new Node ( anim ) ; mNodeMap . put ( anim , node ) ; mNodes . add ( node ) ; } Dependency dependency = new Dependency ( mCurrentNode , Dependency . WITH ) ; node . addDependency ( dependency ) ; return this ; } 
public void write ( CoverageWriter coverageWriter ) { if ( ! fileCoverages . isEmpty ( ) ) { List < FileCoverage > rawCoverage = new LinkedList < FileCoverage > ( fileCoverages ) ; Collections . sort ( rawCoverage ) ; FileCoverage last = rawCoverage . get ( 0 ) ; for ( FileCoverage fileCoverage : rawCoverage . subList ( 1 , rawCoverage . size ( ) ) ) { FileCoverage aggregate = last . aggegrate ( fileCoverage ) ; if ( aggregate == null ) { last . write ( coverageWriter ) ; last = fileCoverage ; } else { last = aggregate ; } } last . write ( coverageWriter ) ; } else { System . out . println ( "No-lines-of-coverage-found." ) ; } } 
public State awaitCompletion ( ) throws Throwable { if ( ! state . isTerminal ( ) ) { try { executor . awaitCompletion ( ) ; state = State . DONE ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw e ; } catch ( Throwable t ) { state = State . FAILED ; throw t ; } } return state ; } 
public static void sort ( char [ ] a ) { DualPivotQuicksort . sort ( a ) ; } 
@ Override protected void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; if ( this . icon != null ) { int iconHeight = icon . getIconHeight ( ) ; int x = 5 ; int y = ( this . getHeight ( ) - iconHeight ) / 2 ; icon . paintIcon ( this , g , x , y ) ; } } 
public byte [ ] getEncoded ( ) throws IOException { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; ASN1OutputStream aOut = new ASN1OutputStream ( bOut ) ; aOut . writeObject ( this ) ; return bOut . toByteArray ( ) ; } 
private URI toUri ( final String path ) { try { return new URI ( null , null , path , null ) ; } catch ( URISyntaxException e ) { throw new IllegalArgumentException ( e ) ; } } 
public Link addLink ( String linkName , int fromNodeID , int toNodeID , double length , boolean priority , ArrayList < CrossSection > crossSections , ArrayList < Vertex > intermediateVertices ) { System . out . println ( "Adding-link-" + linkName + "-to-network-" ) ; if ( null != lookupLink ( linkName ) ) throw new Error ( String . format ( "Link-with-name-%s-already-exists" , linkName ) ) ; Link result ; links . put ( linkName , result = new Link ( this , linkName , lookupNode ( fromNodeID , false ) , lookupNode ( toNodeID , false ) , length , priority , crossSections , intermediateVertices ) ) ; setModified ( ) ; return result ; } 
static String getShortName ( String name , int limit ) { return ( name . length ( ) > limit ? name . substring ( name . length ( ) - limit , name . length ( ) ) : name ) ; } 
private static QT3Env envs ( final ArrayList < QT3Env > envs , final String ref ) { for ( final QT3Env e : envs ) if ( e . name . equals ( ref ) ) return e ; return null ; } 
public static String replace ( String original , String oldSubString , String newSubString ) { String s = original ; int pointer = s . indexOf ( oldSubString ) ; while ( pointer > - 1 ) { s = s . substring ( 0 , pointer ) + newSubString + s . substring ( pointer + oldSubString . length ( ) , s . length ( ) ) ; pointer = s . indexOf ( oldSubString , pointer + newSubString . length ( ) ) ; } return s ; } 
public String lookupProductPrefix ( String name ) { return productNameLookup . get ( name ) ; } 
public void goToPrevWord ( boolean select ) { goToPrevWord ( select , false ) ; } 
public void checkSetFactory ( ) { checkPermission ( new RuntimePermission ( "setFactory" ) ) ; } 
public void setLogicalStyle ( int pos , Style s ) { Element paragraph = getParagraphElement ( pos ) ; if ( ( paragraph != null ) && ( paragraph instanceof AbstractElement ) ) { try { writeLock ( ) ; StyleChangeUndoableEdit edit = new StyleChangeUndoableEdit ( ( AbstractElement ) paragraph , s ) ; ( ( AbstractElement ) paragraph ) . setResolveParent ( s ) ; int p0 = paragraph . getStartOffset ( ) ; int p1 = paragraph . getEndOffset ( ) ; DefaultDocumentEvent e = new DefaultDocumentEvent ( p0 , p1 - p0 , DocumentEvent . EventType . CHANGE ) ; e . addEdit ( edit ) ; e . end ( ) ; fireChangedUpdate ( e ) ; fireUndoableEditUpdate ( new UndoableEditEvent ( this , e ) ) ; } finally { writeUnlock ( ) ; } } } 
public void addValue ( ArgumentMatchSite site , String value ) { if ( ! sites . containsKey ( site ) || sites . get ( site ) == null ) sites . put ( site , new ArrayList < String > ( ) ) ; sites . get ( site ) . add ( value ) ; } 
@ Override public void add ( int index , E object ) { Object [ ] a = array ; int s = size ; if ( index > s || index < 0 ) { throwIndexOutOfBoundsException ( index , s ) ; } if ( s < a . length ) { System . arraycopy ( a , index , a , index + 1 , s - index ) ; } else { Object [ ] newArray = new Object [ newCapacity ( s ) ] ; System . arraycopy ( a , 0 , newArray , 0 , index ) ; System . arraycopy ( a , index , newArray , index + 1 , s - index ) ; array = a = newArray ; } a [ index ] = object ; size = s + 1 ; modCount ++ ; } 
public List < String > getPubconstrainturi ( ) { if ( pubconstrainturi == null ) { pubconstrainturi = new ArrayList < String > ( ) ; } return this . pubconstrainturi ; } 
public static void checkIfEmbedZooKeeperStarted ( int embedZkClientPort ) { try { int i = 0 ; while ( i ++ < RETRY_COUNT && ! isServerAlive ( InetAddress . getLocalHost ( ) , embedZkClientPort ) ) { try { Thread . sleep ( 10 * 1000 ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } System . err . println ( "INFO:-Waiting-embed-server-to-start." ) ; } if ( i == RETRY_COUNT ) { throw new RuntimeException ( "Exception-to-start-embed,-please-specified-zookeeper-server-by--z" ) ; } } catch ( UnknownHostException e ) { throw new RuntimeException ( e ) ; } } 
public static void register ( Class < ? extends ResourceResolverSpi > className , boolean start ) { try { ResourceResolverSpi resourceResolverSpi = className . newInstance ( ) ; register ( resourceResolverSpi , start ) ; } catch ( IllegalAccessException e ) { log . log ( java . util . logging . Level . WARNING , "Error-loading-resolver-" + className + "-disabling-it" ) ; } catch ( InstantiationException e ) { log . log ( java . util . logging . Level . WARNING , "Error-loading-resolver-" + className + "-disabling-it" ) ; } } 
protected void purgeBeforeRead ( ) { purge ( ) ; } 
public void move ( final View photo , float x , float y , float a ) { photo . animate ( ) . cancel ( ) ; photo . setAlpha ( 1f ) ; photo . setX ( ( int ) x ) ; photo . setY ( ( int ) y ) ; photo . setRotation ( ( int ) a ) ; } 
protected void _println ( String s ) { if ( s != null ) { currentOutput . println ( s ) ; } } 
public Set < Type > getChildTypes ( Type t ) { boolean tVert = this . graph . containsVertex ( t ) ; if ( tVert == false ) throw new NullPointerException ( "Type-" + t + "-not-found" ) ; Set < Type > children = new SetWrapper < Type > ( ) ; LinkedList < Type > toExpand = new LinkedList < Type > ( ) ; toExpand . addAll ( this . graph . getOutgoingVertices ( t ) ) ; while ( toExpand . isEmpty ( ) == false ) { Type child = toExpand . poll ( ) ; children . add ( child ) ; toExpand . addAll ( this . graph . getOutgoingVertices ( child ) ) ; } return children ; } 
public static String getDate ( Date dateDigit ) { if ( dateDigit == null ) { return "" ; } Calendar calendar = new GregorianCalendar ( ) ; calendar . setTime ( dateDigit ) ; return getDate ( calendar ) ; } 
public static Node selectSingleNode ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { NodeIterator nl = selectNodeIterator ( contextNode , str , namespaceNode ) ; return nl . nextNode ( ) ; } 
static void visitPostOrder ( Node node , Visitor visitor , Predicate < Node > traverseChildrenPred ) { if ( traverseChildrenPred . apply ( node ) ) { for ( Node c = node . getFirstChild ( ) ; c != null ; c = c . getNext ( ) ) { visitPostOrder ( c , visitor , traverseChildrenPred ) ; } } visitor . visit ( node ) ; } 
public static RegularTimePeriod createInstance ( Class c , Date millisecond , TimeZone zone ) { RegularTimePeriod result = null ; try { Constructor constructor = c . getDeclaredConstructor ( new Class [ ] { Date . class , TimeZone . class } ) ; result = ( RegularTimePeriod ) constructor . newInstance ( new Object [ ] { millisecond , zone } ) ; } catch ( Exception e ) { } return result ; } 
private static Registry getRegistry ( String host , int port , RMIClientSocketFactory socketFactory ) throws NamingException { try { if ( socketFactory == null ) { return LocateRegistry . getRegistry ( host , port ) ; } else { return LocateRegistry . getRegistry ( host , port , socketFactory ) ; } } catch ( RemoteException e ) { throw ( NamingException ) wrapRemoteException ( e ) . fillInStackTrace ( ) ; } } 
public boolean isExpired ( ) { return this . ttl < System . currentTimeMillis ( ) ; } 
public long get ( String name , long defvalue ) throws IOException , IllegalArgumentException { if ( defaulted ( name ) ) return defvalue ; else return ( ( Long ) fields . get ( name ) ) . longValue ( ) ; } 
public void clearCoRoutine ( boolean callDoTerminate ) { if ( null != m_incrementalSAXSource ) { if ( callDoTerminate ) m_incrementalSAXSource . deliverMoreNodes ( false ) ; m_incrementalSAXSource = null ; } } 
@ XmlElementDecl ( namespace = "http://www.delta.org/b2b/edi/t271" , name = "E-INS10-Yes_No_Condition_or_Response_Code" , scope = SINSDependentRelationship . class ) public JAXBElement < EINS10YesNoConditionOrResponseCode > createSINSDependentRelationshipEINS10YesNoConditionOrResponseCode ( EINS10YesNoConditionOrResponseCode value ) { return new JAXBElement < EINS10YesNoConditionOrResponseCode > ( _SINSSubscriberRelationshipEINS10YesNoConditionOrResponseCode_QNAME , EINS10YesNoConditionOrResponseCode . class , SINSDependentRelationship . class , value ) ; } 
public int borrowSpareRegister ( int category ) { int result = spareRegisterBase + borrowedSpareRegisters ; borrowedSpareRegisters += category ; registerCount = Math . max ( registerCount , result + category ) ; return result ; } 
public boolean isServiceDeployed ( String serviceName ) throws RemoteException , NullPointerException { boolean isServiceDeployed = false ; Calendar startTime = Calendar . getInstance ( ) ; while ( Calendar . getInstance ( ) . getTimeInMillis ( ) - startTime . getTimeInMillis ( ) < SERVICE_DEPLOYMENT_DELAY ) { if ( isServiceExists ( serviceName ) ) { isServiceDeployed = true ; break ; } try { Thread . sleep ( 2000 ) ; } catch ( InterruptedException ignored ) { } } return isServiceDeployed ; } 
private void resetNextInetSocketAddress ( Proxy proxy ) throws UnknownHostException { socketAddresses = null ; String socketHost ; if ( proxy . type ( ) == Proxy . Type . DIRECT ) { socketHost = uri . getHost ( ) ; socketPort = getEffectivePort ( uri ) ; } else { SocketAddress proxyAddress = proxy . address ( ) ; if ( ! ( proxyAddress instanceof InetSocketAddress ) ) { throw new IllegalArgumentException ( "Proxy.address()-is-not-an-" + "InetSocketAddress:-" + proxyAddress . getClass ( ) ) ; } InetSocketAddress proxySocketAddress = ( InetSocketAddress ) proxyAddress ; socketHost = proxySocketAddress . getHostName ( ) ; socketPort = proxySocketAddress . getPort ( ) ; } socketAddresses = dns . getAllByName ( socketHost ) ; nextSocketAddressIndex = 0 ; } 
protected void UnaryExpr ( ) throws javax . xml . transform . TransformerException { int opPos = m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) ; boolean isNeg = false ; if ( m_tokenChar == '-' ) { nextToken ( ) ; appendOp ( 2 , OpCodes . OP_NEG ) ; isNeg = true ; } UnionExpr ( ) ; if ( isNeg ) m_ops . setOp ( opPos + OpMap . MAPINDEX_LENGTH , m_ops . getOp ( OpMap . MAPINDEX_LENGTH ) - opPos ) ; } 
public void removeAllUpdateListeners ( ) { if ( mUpdateListeners == null ) { return ; } mUpdateListeners . clear ( ) ; mUpdateListeners = null ; } 
public void set ( String key , int value ) { mMap . put ( key , Integer . toString ( value ) ) ; } 
public static void println ( short x ) { out . println ( x ) ; } 
protected boolean isPrototypeCurrentlyInCreation ( String beanName ) { Object curVal = this . prototypesCurrentlyInCreation . get ( ) ; return ( curVal != null && ( curVal . equals ( beanName ) || ( curVal instanceof Set && ( ( Set < ? > ) curVal ) . contains ( beanName ) ) ) ) ; } 
public static List < URI > getSharedEditsDirs ( Configuration conf ) { Collection < String > dirNames = conf . getTrimmedStringCollection ( DFS_NAMENODE_SHARED_EDITS_DIR_KEY ) ; return Util . stringCollectionAsURIs ( dirNames ) ; } 
public AttributeSet getValue ( ) { final SimpleAttributeSet attributeSet = new SimpleAttributeSet ( ) ; Util . styleSheet ( ) . addCSSAttribute ( attributeSet , ( CSS . Attribute ) getAttributeName ( ) , attributeValue . toString ( ) ) ; return attributeSet ; } 
public String getMessage ( ) { String message = super . getMessage ( ) ; if ( message == null && cause != null ) { return cause . getMessage ( ) ; } else { return message ; } } 
public void setDisplayTabs ( boolean disptabs ) { field_5_options = tabs . setShortBoolean ( field_5_options , disptabs ) ; } 
private HTTPExchange nextExchange ( ) { assertUnlocked ( ) ; final Thread thread = Thread . currentThread ( ) ; HTTPExchange exch = null ; lock . lock ( ) ; try { do { if ( ! thread . equals ( procThread ) ) { break ; } exch = exchanges . peek ( ) ; if ( exch == null ) { try { notEmpty . await ( ) ; } catch ( InterruptedException intx ) { LOG . log ( Level . FINEST , INTERRUPTED , intx ) ; } } } while ( exch == null ) ; } finally { lock . unlock ( ) ; } return exch ; } 
public Border getBorder ( Object key , Locale locale ) { Object o = get ( key , locale ) ; return o instanceof Border ? ( Border ) o : null ; } 
final ActivityRecord topRunningActivityLocked ( IBinder token , int taskId ) { for ( int taskNdx = mTaskHistory . size ( ) - 1 ; taskNdx >= 0 ; -- taskNdx ) { TaskRecord task = mTaskHistory . get ( taskNdx ) ; if ( task . taskId == taskId ) { continue ; } ArrayList < ActivityRecord > activities = task . mActivities ; for ( int i = activities . size ( ) - 1 ; i >= 0 ; -- i ) { final ActivityRecord r = activities . get ( i ) ; if ( ! r . finishing && ( token != r . appToken ) && okToShow ( r ) ) { return r ; } } } return null ; } 
private String nextAT ( ) throws IOException { hasQE = false ; for ( ; pos < chars . length && chars [ pos ] == '-' ; pos ++ ) { } if ( pos == chars . length ) { return null ; } beg = pos ; pos ++ ; for ( ; pos < chars . length && chars [ pos ] != '=' && chars [ pos ] != '-' ; pos ++ ) { } if ( pos >= chars . length ) { throw new IOException ( "Invalid-distinguished-name-string" ) ; } end = pos ; if ( chars [ pos ] == '-' ) { for ( ; pos < chars . length && chars [ pos ] != '=' && chars [ pos ] == '-' ; pos ++ ) { } if ( chars [ pos ] != '=' || pos == chars . length ) { throw new IOException ( "Invalid-distinguished-name-string" ) ; } } pos ++ ; for ( ; pos < chars . length && chars [ pos ] == '-' ; pos ++ ) { } if ( ( end - beg > 4 ) && ( chars [ beg + 3 ] == '.' ) && ( chars [ beg ] == 'O' || chars [ beg ] == 'o' ) && ( chars [ beg + 1 ] == 'I' || chars [ beg + 1 ] == 'i' ) && ( chars [ beg + 2 ] == 'D' || chars [ beg + 2 ] == 'd' ) ) { beg += 4 ; } return new String ( chars , beg , end - beg ) ; } 
public void waitForPaxosToFinish ( ) { proposeLock . lock ( ) ; canPropose . awaitUninterruptibly ( ) ; proposeLock . unlock ( ) ; } 
public void containsTest ( ) { for ( int i = 100 ; i < MAX_ELEMENTS + 100 ; i ++ ) { h1 . contains ( new Integer ( i ) ) ; } } 
public void setOptions ( String [ ] options ) throws Exception { String bagSize = Utils . getOption ( 'P' , options ) ; if ( bagSize . length ( ) != 0 ) { setBagSizePercent ( Integer . parseInt ( bagSize ) ) ; } else { setBagSizePercent ( 100 ) ; } setCalcOutOfBag ( Utils . getFlag ( 'O' , options ) ) ; super . setOptions ( options ) ; } 
public static int compare ( float a , float b ) { return Float . compare ( a , b ) ; } 
public int getLineBreakIndex ( int start , float maxAdvance ) { int localStart = start - fStart ; if ( ! haveLayoutWindow || localStart < fComponentStart || localStart >= fComponentLimit ) { makeLayoutWindow ( localStart ) ; } return calcLineBreak ( localStart , maxAdvance ) + fStart ; } 
public static String getDirectoryPath ( String ... components ) { StringBuilder dirNameBuilder = new StringBuilder ( ) ; dirNameBuilder . append ( Environment . getExternalStorageDirectory ( ) ) ; dirNameBuilder . append ( getDirectoryDisplayName ( components ) ) ; return dirNameBuilder . toString ( ) ; } 
public static Set < AttributeNamespaceValue > getCommonAttributes ( Set < Element > elements ) { Set < AttributeNamespaceValue > commonAttributeValueSet = null ; for ( Element element : elements ) { Set < AttributeNamespaceValue > elementAttributeValueSet = new HashSet < AttributeNamespaceValue > ( ) ; NamedNodeMap attributes = element . getAttributes ( ) ; for ( int i = 0 ; i < attributes . getLength ( ) ; ++ i ) { Attr attribute = ( Attr ) attributes . item ( i ) ; if ( ! attribute . getLocalName ( ) . equals ( "xmlns" ) && ! ( attribute . getNamespaceURI ( ) != null && attribute . getNamespaceURI ( ) . equals ( "http://www.w3.org/2000/xmlns/" ) ) ) { AttributeNamespaceValue attributeNSValue = new AttributeNamespaceValue ( ) ; attributeNSValue . setName ( attribute . getLocalName ( ) ) ; attributeNSValue . setNamespace ( attribute . getNamespaceURI ( ) ) ; attributeNSValue . setValue ( attribute . getValue ( ) ) ; elementAttributeValueSet . add ( attributeNSValue ) ; } } if ( commonAttributeValueSet == null ) { commonAttributeValueSet = elementAttributeValueSet ; } else { commonAttributeValueSet . retainAll ( elementAttributeValueSet ) ; } if ( commonAttributeValueSet . isEmpty ( ) ) { return commonAttributeValueSet ; } } return commonAttributeValueSet ; } 
public static final Token newToken ( int ofKind ) { switch ( ofKind ) { default : return new Token ( ) ; } } 
@ Override public boolean hasAttribute ( String name ) { return DTM . NULL != dtm . getAttributeNode ( node , null , name ) ; } 
protected Map < HttpRoute , RouteSpecificPool > createRouteToPoolMap ( ) { return new HashMap < HttpRoute , RouteSpecificPool > ( ) ; } 
public String getMessage ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( getReason ( ) ) ; if ( index > - 1 ) { sb . append ( "-at-index-" ) ; sb . append ( index ) ; } sb . append ( ":-" ) ; sb . append ( input ) ; return sb . toString ( ) ; } 
public static void writeContent ( CharSequence content , File file , String encoding ) { OutputStream os = null ; try { os = new FileOutputStream ( file ) ; PrintWriter printWriter = new PrintWriter ( new OutputStreamWriter ( os , encoding ) ) ; printWriter . println ( content ) ; printWriter . flush ( ) ; os . flush ( ) ; } catch ( IOException e ) { throw new UnexpectedException ( e ) ; } finally { try { if ( os != null ) os . close ( ) ; } catch ( Exception e ) { } } } 
public boolean isVariableBitRate ( ) { return ( ( Boolean ) content . get ( FIELD_VBR ) ) . booleanValue ( ) ; } 
public void writeStringSet ( Set < String > set ) throws IOException { if ( set == null ) { writeInt ( 0 ) ; } else { writeInt ( set . size ( ) ) ; for ( String value : set ) { writeString ( value ) ; } } } 
private static TreeMap < Integer , Long > loadWorkspaceScreensDb ( Context context ) { final ContentResolver contentResolver = context . getContentResolver ( ) ; final Uri screensUri = LauncherSettings . WorkspaceScreens . CONTENT_URI ; final Cursor sc = contentResolver . query ( screensUri , null , null , null , null ) ; TreeMap < Integer , Long > orderedScreens = new TreeMap < Integer , Long > ( ) ; try { final int idIndex = sc . getColumnIndexOrThrow ( LauncherSettings . WorkspaceScreens . _ID ) ; final int rankIndex = sc . getColumnIndexOrThrow ( LauncherSettings . WorkspaceScreens . SCREEN_RANK ) ; while ( sc . moveToNext ( ) ) { try { long screenId = sc . getLong ( idIndex ) ; int rank = sc . getInt ( rankIndex ) ; orderedScreens . put ( rank , screenId ) ; } catch ( Exception e ) { Launcher . addDumpLog ( TAG , "Desktop-items-loading-interrupted---invalid-screens:-" + e , true ) ; } } } finally { sc . close ( ) ; } Launcher . addDumpLog ( TAG , "11683562---loadWorkspaceScreensDb()" , true ) ; ArrayList < String > orderedScreensPairs = new ArrayList < String > ( ) ; for ( Integer i : orderedScreens . keySet ( ) ) { orderedScreensPairs . add ( "{-" + i + ":-" + orderedScreens . get ( i ) + "-}" ) ; } Launcher . addDumpLog ( TAG , "11683562---screens:-" + TextUtils . join ( ",-" , orderedScreensPairs ) , true ) ; return orderedScreens ; } 
private Rectangle2D getSvgDocBounds ( Document doc ) { NodeList list = doc . getElementsByTagName ( "svg" ) ; Node svgNode = list . item ( 0 ) ; NamedNodeMap attrbiutes = svgNode . getAttributes ( ) ; Node widthNode = attrbiutes . getNamedItem ( "width" ) ; Node heightNode = attrbiutes . getNamedItem ( "height" ) ; if ( widthNode != null && heightNode != null ) { double width = Double . parseDouble ( widthNode . getNodeValue ( ) ) ; double height = Double . parseDouble ( heightNode . getNodeValue ( ) ) ; return new Rectangle2D . Double ( 0.0 , 0.0 , width , height ) ; } return null ; } 
public static String toString ( byte [ ] transactionID ) { StringBuilder idStr = new StringBuilder ( ) ; idStr . append ( "0x" ) ; for ( int i = 0 ; i < transactionID . length ; i ++ ) { if ( ( transactionID [ i ] & 0xFF ) <= 15 ) idStr . append ( "0" ) ; idStr . append ( Integer . toHexString ( transactionID [ i ] & 0xFF ) . toUpperCase ( ) ) ; } return idStr . toString ( ) ; } 
@ Override public void reboot ( boolean confirm , String reason , boolean wait ) { mContext . enforceCallingOrSelfPermission ( android . Manifest . permission . REBOOT , null ) ; final long ident = Binder . clearCallingIdentity ( ) ; try { shutdownOrRebootInternal ( false , confirm , reason , wait ) ; } finally { Binder . restoreCallingIdentity ( ident ) ; } } 
void addUndoAction ( UndoAction action ) { int iAction = m_undoStack . size ( ) - 1 ; while ( iAction > m_nCurrentEditAction ) { m_undoStack . remove ( iAction -- ) ; } if ( m_nSavedPointer > m_nCurrentEditAction ) { m_nSavedPointer = - 2 ; } m_undoStack . add ( action ) ; m_nCurrentEditAction ++ ; } 
public ArrayList < AgentCommissionsDto > getAgentCommissionsOfaWeekByAgent ( Integer week , String agent , Integer year ) throws AgentCommissionNotFoundException { log . info ( "inside-getAgentCommissionsOfaWeekByAgent()" ) ; ArrayList < AgentCommissions > commissions = this . adminDao . getCommissionsBetweenDaysWithCriteria ( week , agent , year ) ; ArrayList < AgentCommissionsDto > commissionDtos = new ArrayList < AgentCommissionsDto > ( ) ; for ( AgentCommissions commission : commissions ) { AgentCommissionsDto commissionDto = AgentCommissionsDto . populateAgentCommissions ( commission ) ; commissionDtos . add ( commissionDto ) ; } if ( commissionDtos . isEmpty ( ) || commissionDtos . size ( ) == 0 ) { throw new AgentCommissionNotFoundException ( ) ; } else { return commissionDtos ; } } 
public synchronized void addCookie ( Cookie cookie ) { if ( cookie != null ) { cookies . remove ( cookie ) ; if ( ! cookie . isExpired ( new Date ( ) ) ) { cookies . add ( cookie ) ; } } } 
public static String getRemoteAddress ( ) { InetAddress addr = getRemoteIp ( ) ; return ( addr == null ) ? null : addr . getHostAddress ( ) ; } 
public Writer ( Configuration conf , FileSystem fs , String dirName , WritableComparator comparator , Class valClass , MySequenceFile . CompressionType compress , CompressionCodec codec , Progressable progress ) throws IOException { this . indexInterval = conf . getInt ( INDEX_INTERVAL , this . indexInterval ) ; this . comparator = comparator ; this . lastKey = comparator . newKey ( ) ; Path dir = new Path ( dirName ) ; if ( ! fs . mkdirs ( dir ) ) { throw new IOException ( "Mkdirs-failed-to-create-directory-" + dir . toString ( ) ) ; } Path dataFile = new Path ( dir , DATA_FILE_NAME ) ; Path indexFile = new Path ( dir , INDEX_FILE_NAME ) ; Class keyClass = comparator . getKeyClass ( ) ; this . data = MySequenceFile . createWriter ( fs , conf , dataFile , keyClass , valClass , compress , codec , progress ) ; this . index = MySequenceFile . createWriter ( fs , conf , indexFile , keyClass , LongWritable . class , CompressionType . BLOCK , progress ) ; } 
public static < T > Response < T > error ( VolleyError error ) { return new Response < T > ( error ) ; } 
public static List < Tree > pathFromRoot ( Tree t , Tree root ) { if ( t == root ) { List < Tree > l = new ArrayList < Tree > ( 1 ) ; l . add ( t ) ; return l ; } else if ( root == null ) { return null ; } return root . dominationPath ( t ) ; } 
void doNumberLine1 ( StringTokenizer tokens ) throws SyntaxError { if ( ! tokens . hasMoreTokens ( ) ) { throw new SyntaxError ( "Elección-del-número-de-líneas-no-especificada" ) ; } String tmp = tokens . nextToken ( ) ; while ( ! tmp . equals ( "=" ) ) { tmp = tokens . nextToken ( ) ; } tmp = tokens . nextToken ( ) ; numberLine1 = Integer . parseInt ( tmp ) ; } 
public JarFile ( File file , boolean verify , int mode ) throws IOException { super ( file , mode ) ; if ( verify ) { verifier = new JarVerifier ( file . getPath ( ) ) ; } readMetaEntries ( ) ; } 
void bytesRecvFlowControl ( ChannelHandlerContext ctx , long recv ) { currentReadBytes . addAndGet ( recv ) ; cumulativeReadBytes . addAndGet ( recv ) ; } 
public Scrollbar ( int orientation ) throws IllegalArgumentException { this ( orientation , 0 , 10 , 0 , 100 ) ; } 
public void removeListener ( NetworkSpaceListener listener ) { listeners . remove ( listener ) ; } 
public static void buildLinkedMentionsFromEntities ( Document doc ) { int mentionID = 0 ; Vector entities = doc . annotationsOfType ( "entity" ) ; for ( int i = 0 ; i < entities . size ( ) ; i ++ ) { Annotation entity = ( Annotation ) entities . get ( i ) ; Vector mentions = ( Vector ) entity . get ( "mentions" ) ; int antecedent = 0 ; for ( int j = 0 ; j < mentions . size ( ) ; j ++ ) { Annotation mention = ( Annotation ) mentions . get ( j ) ; Annotation mentionHead = Resolve . getHeadC ( mention ) ; if ( mentionHead . type ( ) != "COREF" ) { mentionHead = new Annotation ( "COREF" , mentionHead . span ( ) , null ) ; doc . addAnnotation ( mentionHead ) ; } mentionHead . put ( "ID" , new Integer ( ++ mentionID ) ) ; if ( antecedent > 0 ) mentionHead . put ( "REF" , new Integer ( antecedent ) ) ; antecedent = mentionID ; } } } 
public static boolean isAnnotation ( String inputLine ) { inputLine = inputLine . trim ( ) ; if ( ! inputLine . startsWith ( "@" ) ) { return false ; } String possibleAnnotation = ( inputLine . contains ( "-" ) ) ? inputLine . substring ( 1 , inputLine . indexOf ( "-" ) ) : inputLine . substring ( 1 ) ; for ( ESQDevFileAnnotation current : ESQDevFileAnnotation . values ( ) ) { if ( current . toString ( ) . equals ( possibleAnnotation ) ) { return true ; } } return false ; } 
public static String stripEnd ( String str , String stripChars ) { int end ; if ( str == null || ( end = str . length ( ) ) == 0 ) { return str ; } if ( stripChars == null ) { while ( ( end != 0 ) && Character . isWhitespace ( str . charAt ( end - 1 ) ) ) { end -- ; } } else if ( stripChars . length ( ) == 0 ) { return str ; } else { while ( ( end != 0 ) && ( stripChars . indexOf ( str . charAt ( end - 1 ) ) != INDEX_NOT_FOUND ) ) { end -- ; } } return str . substring ( 0 , end ) ; } 
public List < Float > getFixed3X2 ( ) { if ( fixed3X2 == null ) { fixed3X2 = new ArrayList < Float > ( ) ; } return this . fixed3X2 ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
private void startAnimation ( ) { initAnimation ( ) ; sAnimations . get ( ) . add ( this ) ; if ( mStartDelay > 0 && mListeners != null ) { ArrayList < AnimatorListener > tmpListeners = ( ArrayList < AnimatorListener > ) mListeners . clone ( ) ; int numListeners = tmpListeners . size ( ) ; for ( int i = 0 ; i < numListeners ; ++ i ) { tmpListeners . get ( i ) . onAnimationStart ( this ) ; } } } 
protected int getExperiencePoints ( EntityPlayer p_70693_1_ ) { if ( this . experienceValue > 0 ) { int var2 = this . experienceValue ; ItemStack [ ] var3 = this . getInventory ( ) ; for ( int var4 = 0 ; var4 < var3 . length ; ++ var4 ) { if ( var3 [ var4 ] != null && this . equipmentDropChances [ var4 ] <= 1.0F ) { var2 += 1 + this . rand . nextInt ( 3 ) ; } } return var2 ; } else { return this . experienceValue ; } } 
public void registerEndpoint ( String key ) { template . put ( key , 0 ) ; map . put ( key , 0 ) ; } 
public void register ( Class cls ) { if ( ORB . ORBInitDebug ) dprint ( "Registering-service-context-class-" + cls ) ; ServiceContextData scd = new ServiceContextData ( cls ) ; if ( findServiceContextData ( scd . getId ( ) ) == null ) scCollection . addElement ( scd ) ; else throw new BAD_PARAM ( "Tried-to-register-duplicate-service-context" ) ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public String [ ] getOptions ( ) { Vector < String > result ; result = new Vector < String > ( ) ; if ( m_AttributeType != Attribute . NUMERIC ) { result . add ( "-T" ) ; result . add ( "" + getAttributeType ( ) ) ; } result . add ( "-N" ) ; result . add ( Utils . backQuoteChars ( getAttributeName ( ) ) ) ; if ( m_AttributeType == Attribute . NOMINAL ) { result . add ( "-L" ) ; result . add ( getNominalLabels ( ) ) ; } else if ( m_AttributeType == Attribute . NOMINAL ) { result . add ( "-F" ) ; result . add ( getDateFormat ( ) ) ; } result . add ( "-C" ) ; result . add ( "" + getAttributeIndex ( ) ) ; return result . toArray ( new String [ result . size ( ) ] ) ; } 
public short readShortFromXML ( Element node ) throws Exception { if ( DEBUG ) trace ( new Throwable ( ) , node . getAttribute ( ATT_NAME ) ) ; m_CurrentNode = node ; return ( ( Short ) getPrimitive ( node ) ) . shortValue ( ) ; } 
public static Message obtain ( Handler h ) { Message m = obtain ( ) ; m . target = h ; return m ; } 
public String getSystemId ( ) { if ( needsSyncData ( ) ) { synchronizeData ( ) ; } return systemId ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; javax . xml . namespace . NamespaceContext nsContext = xmlWriter . getNamespaceContext ( ) ; while ( true ) { java . lang . String uri = nsContext . getNamespaceURI ( prefix ) ; if ( uri == null || uri . length ( ) == 0 ) { break ; } prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public static StreamPrintServiceFactory [ ] lookupStreamPrintServices ( String mimeType ) { return StreamPrintServiceFactory . lookupStreamPrintServiceFactories ( DocFlavor . SERVICE_FORMATTED . PAGEABLE , mimeType ) ; } 
public final T pop ( ) { if ( size > 0 ) { T result = heap [ 1 ] ; heap [ 1 ] = heap [ size ] ; heap [ size ] = null ; size -- ; downHeap ( 1 ) ; return result ; } else { return null ; } } 
public static byte [ ] longToByteArray ( long value ) { ByteBuffer buf = ByteBuffer . allocate ( 8 ) ; buf . putLong ( value ) ; return buf . array ( ) ; } 
public void codeRef ( PrintStream s ) { s . print ( CgenSupport . BOOLCONST_PREFIX + ( val ? "1" : "0" ) ) ; } 
public void accept ( Visitor v ) { v . visitPushInstruction ( this ) ; v . visitStackProducer ( this ) ; v . visitTypedInstruction ( this ) ; v . visitConstantPushInstruction ( this ) ; v . visitLCONST ( this ) ; } 
private void addNewAlgorithm ( Classifier newScheme ) { if ( ! m_Editing ) m_AlgorithmListModel . addElement ( newScheme ) ; else m_AlgorithmListModel . setElementAt ( newScheme , m_List . getSelectedIndex ( ) ) ; updateExperiment ( ) ; m_Editing = false ; } 
public static byte [ ] decodeFromFile ( String filename ) throws java . io . IOException { byte [ ] decodedData = null ; Base64 . InputStream bis = null ; try { java . io . File file = new java . io . File ( filename ) ; byte [ ] buffer = null ; int length = 0 ; int numBytes = 0 ; if ( file . length ( ) > Integer . MAX_VALUE ) { throw new java . io . IOException ( "File-is-too-big-for-this-convenience-method-(" + file . length ( ) + "-bytes)." ) ; } buffer = new byte [ ( int ) file . length ( ) ] ; bis = new Base64 . InputStream ( new java . io . BufferedInputStream ( new java . io . FileInputStream ( file ) ) , Base64 . DECODE ) ; while ( ( numBytes = bis . read ( buffer , length , 4096 ) ) >= 0 ) { length += numBytes ; } decodedData = new byte [ length ] ; System . arraycopy ( buffer , 0 , decodedData , 0 , length ) ; } catch ( java . io . IOException e ) { throw e ; } finally { try { bis . close ( ) ; } catch ( Exception e ) { } } return decodedData ; } 
public String getNodeName ( int level ) { return ( String ) nodeMap . get ( new Integer ( level ) ) ; } 
public List < COSObject > getObjects ( ) { return new ArrayList < COSObject > ( objectPool . values ( ) ) ; } 
public Descriptor getDescriptor ( ) { return ( Descriptor ) ImmutableDescriptor . nonNullDescriptor ( descriptor ) . clone ( ) ; } 
public void setRgncode ( String rgncode ) { this . rgncode = rgncode == null ? null : rgncode . trim ( ) ; } 
public static String asString ( InputStream pStream ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; copy ( pStream , baos , true ) ; return baos . toString ( ) ; } 
private void zzScanError ( int errorCode ) { String message ; try { message = ZZ_ERROR_MSG [ errorCode ] ; } catch ( ArrayIndexOutOfBoundsException e ) { message = ZZ_ERROR_MSG [ ZZ_UNKNOWN_ERROR ] ; } throw new Error ( message ) ; } 
private void startMonitoring ( ) { if ( timer != null ) { timer . cancel ( ) ; } timer = new Timer ( true ) ; TimerTask timerTask = new TimerTask ( ) { @ Override public void run ( ) { try { updatesActiveJvms ( ) ; } catch ( Throwable t ) { Activator . log ( IStatus . ERROR , Messages . updateTimerCanceledMsg , t ) ; timer . cancel ( ) ; } } } ; long period = Activator . getDefault ( ) . getPreferenceStore ( ) . getLong ( IConstants . UPDATE_PERIOD ) ; timer . schedule ( timerTask , 0 , period ) ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public Dimension getMinimumSize ( JComponent a ) { Dimension returnValue = ( ( ComponentUI ) ( uis . elementAt ( 0 ) ) ) . getMinimumSize ( a ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . getMinimumSize ( a ) ; } return returnValue ; } 
public void accept ( Visitor v ) { v . visitExceptionThrower ( this ) ; v . visitTypedInstruction ( this ) ; v . visitStackConsumer ( this ) ; v . visitReturnInstruction ( this ) ; v . visitFRETURN ( this ) ; } 
protected void addCapabilities ( final Collection caps ) { caps . addAll ( HttpFileProvider . capabilities ) ; } 
public void removePropertyChangeListener ( PropertyChangeListener l ) { AccessibleContext ac = getCurrentAccessibleContext ( ) ; if ( ac != null ) { ac . removePropertyChangeListener ( l ) ; } else { super . removePropertyChangeListener ( l ) ; } } 
public void removeTerrain ( TerrainQuad tq ) { removedTerrains . remove ( tq ) ; } 
List < GraphNode > layer ( int i ) { if ( i >= 0 && i < layerlist . size ( ) ) return Collections . unmodifiableList ( layerlist . get ( i ) ) ; return emptyListOfNodes ; } 
public void setIssuingDistributionPoint ( byte [ ] issuingDistributionPoint ) { this . issuingDistributionPoint = Arrays . clone ( issuingDistributionPoint ) ; } 
public boolean inTransaction ( ) { return mLock . getHoldCount ( ) > 0 ; } 
public void update ( float T ) { SceneGraph graph = this . game . getGraph ( ) ; HashMap < String , Spatial > sceneObjects = graph . getRootNode ( ) . getChildren ( ) ; Iterator it = sceneObjects . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry pairs = ( Map . Entry ) it . next ( ) ; Spatial spatial = ( Spatial ) pairs . getValue ( ) ; spatial . update ( T ) ; } } 
public void startAnimation ( Animation animation ) { animation . setStartTime ( Animation . START_ON_FIRST_FRAME ) ; setAnimation ( animation ) ; invalidateParentCaches ( ) ; invalidate ( true ) ; } 
protected void fireDataRead ( NMEAEvent e ) { for ( int i = 0 ; i < NMEAListeners . size ( ) ; i ++ ) { NMEAListener l = NMEAListeners . get ( i ) ; l . dataRead ( e ) ; } } 
private void signalAllWaiters ( ) { for ( Guard guard = activeGuards ; guard != null ; guard = guard . next ) { guard . condition . signalAll ( ) ; } } 
public void setLayout ( LayoutManager layout ) throws JellyTagException { Component component = getComponent ( ) ; if ( component != null ) { if ( component instanceof RootPaneContainer ) { RootPaneContainer rpc = ( RootPaneContainer ) component ; component = rpc . getContentPane ( ) ; } try { BeanUtils . setProperty ( component , "layout" , layout ) ; } catch ( IllegalAccessException e ) { throw new JellyTagException ( e ) ; } catch ( InvocationTargetException e ) { throw new JellyTagException ( e ) ; } } } 
public void setTexture ( Texture texture ) { this . texture = texture ; reinit ( ) ; } 
private HashMap getColumnValues ( ResultSet rs ) throws SQLException { ResultSetMetaData mdata = rs . getMetaData ( ) ; int count = mdata . getColumnCount ( ) ; HashMap tableItems = new HashMap ( count ) ; for ( int i = 1 ; i <= count ; ++ i ) { String fieldName = new StringBuffer ( ) . append ( mdata . getTableName ( i ) ) . append ( "." ) . append ( mdata . getColumnName ( i ) ) . toString ( ) ; tableItems . put ( fieldName , rs . getObject ( i ) ) ; if ( debug ) System . out . println ( fieldName + "=" + tableItems . get ( fieldName ) ) ; } return tableItems ; } 
public static < T > Iterator < T > consumingIterator ( final Iterator < T > iterator ) { checkNotNull ( iterator ) ; return new UnmodifiableIterator < T > ( ) { @ Override public boolean hasNext ( ) { return iterator . hasNext ( ) ; } @ Override public T next ( ) { T next = iterator . next ( ) ; iterator . remove ( ) ; return next ; } @ Override public String toString ( ) { return "Iterators.consumingIterator(...)" ; } } ; } 
public List < Configuration > getConfigurations ( String envName , String configType ) { List < Configuration > configurations = getConfigByEnv ( envName ) ; List < Configuration > filterConfigs = new ArrayList < Configuration > ( configurations . size ( ) ) ; for ( Configuration configuration : configurations ) { if ( configuration . getType ( ) . equals ( configType ) ) { filterConfigs . add ( configuration ) ; } } return filterConfigs ; } 
final public Tree ifStmt ( ) throws ParseException { trace_call ( "ifStmt" ) ; try { Tree cond , thenBody , elseBody = null ; int pos ; t = jj_consume_token ( IF ) ; pos = position ( ) ; jj_consume_token ( 54 ) ; cond = expr ( ) ; jj_consume_token ( 59 ) ; thenBody = statement ( ) ; switch ( ( jj_ntk == - 1 ) ? jj_ntk_f ( ) : jj_ntk ) { case ELSE : { jj_consume_token ( ELSE ) ; elseBody = statement ( ) ; break ; } default : jj_la1 [ 21 ] = jj_gen ; } { return F . at ( pos ) . If ( cond , thenBody , elseBody ) ; } } finally { trace_return ( "ifStmt" ) ; } } 
public void clear ( ) { keyed . clear ( ) ; ordered . clear ( ) ; } 
static String cidFromCodePath ( String fullCodePath ) { int eidx = fullCodePath . lastIndexOf ( "/" ) ; String subStr1 = fullCodePath . substring ( 0 , eidx ) ; int sidx = subStr1 . lastIndexOf ( "/" ) ; return subStr1 . substring ( sidx + 1 , eidx ) ; } 
@ Override public int compareTo ( ResourceItem other ) { return mName . compareTo ( other . mName ) ; } 
public Dimension getMaximumSize ( JComponent jc ) { if ( splitPane != null ) return layoutManager . maximumLayoutSize ( splitPane ) ; return new Dimension ( 0 , 0 ) ; } 
public String toString ( ) { try { Iterator keys = keys ( ) ; StringBuffer sb = new StringBuffer ( "{" ) ; while ( keys . hasNext ( ) ) { if ( sb . length ( ) > 1 ) { sb . append ( ',' ) ; } Object o = keys . next ( ) ; sb . append ( quote ( o . toString ( ) ) ) ; sb . append ( ':' ) ; sb . append ( valueToString ( this . map . get ( o ) ) ) ; } sb . append ( '}' ) ; return sb . toString ( ) ; } catch ( Exception e ) { return null ; } } 
public FileStatus [ ] listStatus ( Path f , PathFilter filter ) throws AccessControlException , FileNotFoundException , UnsupportedFileSystemException , IOException { ArrayList < FileStatus > results = new ArrayList < FileStatus > ( ) ; listStatus ( results , f , filter ) ; return results . toArray ( new FileStatus [ results . size ( ) ] ) ; } 
private static void addFile ( ZipOutputStream os , File current , String storedPath ) throws IOException { Log . i ( TAG , "Adding-" + current . getAbsolutePath ( ) + "-..." ) ; final InputStream is = new FileInputStream ( current ) ; os . putNextEntry ( new ZipEntry ( storedPath ) ) ; final byte [ ] buf = new byte [ 32 * 1024 ] ; int totalLen = 0 ; while ( true ) { int len = is . read ( buf ) ; if ( len <= 0 ) { break ; } os . write ( buf , 0 , len ) ; totalLen += len ; } os . closeEntry ( ) ; Log . i ( TAG , "Added-" + current . getAbsolutePath ( ) + "-as-" + storedPath + "-(" + totalLen + "-bytes)" ) ; } 
public Vector3f unprojectInv ( float winX , float winY , float winZ , IntBuffer viewport , Vector3f dest ) { int pos = viewport . position ( ) ; float ndcX = ( winX - viewport . get ( pos ) ) / viewport . get ( pos + 2 ) * 2.0f - 1.0f ; float ndcY = ( winY - viewport . get ( pos + 1 ) ) / viewport . get ( pos + 3 ) * 2.0f - 1.0f ; float ndcZ = 2.0f * winZ - 1.0f ; dest . x = m00 * ndcX + m10 * ndcY + m20 * ndcZ + m30 ; dest . y = m01 * ndcX + m11 * ndcY + m21 * ndcZ + m31 ; dest . z = m02 * ndcX + m12 * ndcY + m22 * ndcZ + m32 ; float w = m03 * ndcX + m13 * ndcY + m23 * ndcZ + m33 ; dest . div ( w ) ; return dest ; } 
public byte [ ] getAuthorityKeyIdentifier ( ) { if ( authorityKeyIdentifier == null ) { return null ; } byte [ ] res = new byte [ authorityKeyIdentifier . length ] ; System . arraycopy ( authorityKeyIdentifier , 0 , res , 0 , res . length ) ; return res ; } 
private static List < Challenge > parseChallenges ( RawHeaders responseHeaders , String challengeHeader ) { List < Challenge > result = new ArrayList < Challenge > ( ) ; for ( int h = 0 ; h < responseHeaders . length ( ) ; h ++ ) { if ( ! challengeHeader . equalsIgnoreCase ( responseHeaders . getFieldName ( h ) ) ) { continue ; } String value = responseHeaders . getValue ( h ) ; int pos = 0 ; while ( pos < value . length ( ) ) { int tokenStart = pos ; pos = HeaderParser . skipUntil ( value , pos , "-" ) ; String scheme = value . substring ( tokenStart , pos ) . trim ( ) ; pos = HeaderParser . skipWhitespace ( value , pos ) ; if ( ! value . regionMatches ( pos , "realm="" , 0 , "realm="" . length ( ) ) ) { break ; } pos += "realm="" . length ( ) ; int realmStart = pos ; pos = HeaderParser . skipUntil ( value , pos , """ ) ; String realm = value . substring ( realmStart , pos ) ; pos ++ ; pos = HeaderParser . skipUntil ( value , pos , "," ) ; pos ++ ; pos = HeaderParser . skipWhitespace ( value , pos ) ; result . add ( new Challenge ( scheme , realm ) ) ; } } return result ; } 
public void broadcast ( Message msg ) { synchronized ( this ) { if ( mReg == null ) { return ; } int senderWhat = msg . what ; Registration start = mReg ; Registration r = start ; do { if ( r . senderWhat >= senderWhat ) { break ; } r = r . next ; } while ( r != start ) ; if ( r . senderWhat == senderWhat ) { Handler [ ] targets = r . targets ; int [ ] whats = r . targetWhats ; int n = targets . length ; for ( int i = 0 ; i < n ; i ++ ) { Handler target = targets [ i ] ; Message m = Message . obtain ( ) ; m . copyFrom ( msg ) ; m . what = whats [ i ] ; target . sendMessage ( m ) ; } } } } 
public void startTest ( Test test ) { mTimingValid = true ; mStartTime = System . currentTimeMillis ( ) ; } 
public Iterator getCollectionIterator ( ) { sort ( ) ; if ( cachedCollections == null ) { cachedCollections = new HashSet < Collection > ( ) ; for ( int i = 0 ; i < documentCount ; i ++ ) { DocumentImpl doc = nodes [ documentOffsets [ i ] ] . getDocument ( ) ; if ( ! cachedCollections . contains ( doc . getCollection ( ) ) ) cachedCollections . add ( doc . getCollection ( ) ) ; } } return cachedCollections . iterator ( ) ; } 
@ XmlElementDecl ( namespace = "http://www.xbrl.org/tw/fr/gaap/tw-gaap-basi-2010-03-31" , name = "ProceedsDisposalRentalAssetsIdleAssets" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < MonetaryItemType > createProceedsDisposalRentalAssetsIdleAssets ( MonetaryItemType value ) { return new JAXBElement < MonetaryItemType > ( _ProceedsDisposalRentalAssetsIdleAssets_QNAME , MonetaryItemType . class , null , value ) ; } 
public void close ( ) { final BroadcastReceiver receiver = mReceiver . getAndSet ( null ) ; if ( receiver != null ) { mContext . unregisterReceiver ( receiver ) ; } } 
static boolean shortcutExists ( Context context , String title , Intent intent ) { final ContentResolver cr = context . getContentResolver ( ) ; Cursor c = cr . query ( LauncherSettings . Favorites . CONTENT_URI , new String [ ] { "title" , "intent" } , "title=?-and-intent=?" , new String [ ] { title , intent . toUri ( 0 ) } , null ) ; boolean result = false ; try { result = c . moveToFirst ( ) ; } finally { c . close ( ) ; } return result ; } 
@ Before public void createTempFile ( ) throws DocumentException , MalformedURLException , IOException { Rectangle page = new Rectangle ( 280f , 360f ) ; aux = new Document ( page , 0f , 0f , 221f , 0f ) ; PdfWriter . getInstance ( aux , new FileOutputStream ( "/home/luca" + "/" + "Luca" + "Bellettati" + 50 + ".pdf" ) ) ; aux . open ( ) ; Paragraph container = new Paragraph ( ) ; Paragraph event = new Paragraph ( "Snowdays-2014" , subFont ) ; Paragraph data = new Paragraph ( "Luca" + "Bellettati" , catFont ) ; Paragraph group = new Paragraph ( String . valueOf ( 50 ) , smallBold ) ; container . add ( event ) ; container . add ( data ) ; container . add ( group ) ; container . setAlignment ( Paragraph . ALIGN_RIGHT ) ; aux . add ( container ) ; QRGenerator aQR = QRGenerator . from ( "Luca" + "Bellettati" + String . valueOf ( 50 ) ) ; aQR . to ( ImageType . PNG ) ; File qrFile = aQR . file ( ) ; Image qrImage = Image . getInstance ( qrFile . getPath ( ) ) ; qrImage . scaleAbsolute ( 80f , 80f ) ; qrImage . setAbsolutePosition ( 200f , 280f ) ; aux . add ( qrImage ) ; Image anImage = Image . getInstance ( "/home/luca/emlogo.png" ) ; anImage . scaleAbsolute ( 100f , 70f ) ; anImage . setAbsolutePosition ( 20f , 270f ) ; aux . add ( anImage ) ; aux . close ( ) ; } 
public void error ( XPathContext xctxt , String msg , Object args [ ] ) throws javax . xml . transform . TransformerException { String formattedMsg = XSLMessages . createMessage ( msg , args ) ; ErrorListener errHandler = xctxt . getErrorListener ( ) ; TransformerException spe = new TransformerException ( formattedMsg , ( SourceLocator ) xctxt . getSAXLocator ( ) ) ; if ( null != errHandler ) errHandler . error ( spe ) ; else System . out . println ( formattedMsg ) ; } 
public boolean contains ( double x , double y , double w , double h ) { if ( npoints <= 0 || ! bounds . intersects ( x , y , w , h ) ) { return false ; } updateComputingPath ( ) ; return closedPath . contains ( x , y , w , h ) ; } 
public static int getWindowCount ( ) { int count = imageList . size ( ) ; return count ; } 
public BigInteger max ( BigInteger value ) { return this . compareTo ( value ) == 1 ? this : value ; } 
public LongValue createLongValue ( long value ) { return createLongValue ( ) ; } 
public void setAlbumID ( JAXBElement < String > value ) { this . albumID = ( ( JAXBElement < String > ) value ) ; } 
public Attribute ( String value ) throws IllegalArgumentException { if ( 0 != value . trim ( ) . length ( ) ) throw new IllegalArgumentException ( "non-whitespace-value" ) ; else { setName ( null ) ; setAssignment ( null ) ; setValue ( value ) ; setQuote ( ( char ) 0 ) ; } } 
public void addListener ( InputDialogListener listener ) { if ( items == null ) { items = new ArrayList < InputDialogListener > ( ) ; } items . add ( listener ) ; } 
public static List < String > extractTechMd ( Item item ) throws Exception { List < String > techMd = new ArrayList < String > ( ) ; URI uri = item . getFullImageUrl ( ) ; String imageUrl = uri . toURL ( ) . toString ( ) ; StorageController sc = new StorageController ( ) ; ByteArrayOutputStream bous = new ByteArrayOutputStream ( ) ; sc . read ( imageUrl , bous , true ) ; InputStream input = new ByteArrayInputStream ( bous . toByteArray ( ) ) ; ImageInputStream iis = ImageIO . createImageInputStream ( input ) ; Iterator < ImageReader > readers = ImageIO . getImageReaders ( iis ) ; if ( readers . hasNext ( ) ) { ImageReader reader = readers . next ( ) ; reader . setInput ( iis , true ) ; IIOMetadata metadata = reader . getImageMetadata ( 0 ) ; String [ ] names = metadata . getMetadataFormatNames ( ) ; int length = names . length ; for ( int i = 0 ; i < length ; i ++ ) { displayMetadata ( techMd , metadata . getAsTree ( names [ i ] ) ) ; } } return techMd ; } 
public void serialize ( Document doc , OutputStream out ) throws IOException { Writer writer = new OutputStreamWriter ( out , encoding ) ; write ( doc , writer , 0 ) ; writer . flush ( ) ; } 
public int getPort ( ) { if ( ! isConnected ( ) ) return 0 ; try { return getImpl ( ) . getPort ( ) ; } catch ( SocketException e ) { } return 0 ; } 
@ Override public void flush ( ) throws IOException { OutputStream output = m_streams . get ( ) ; if ( null != output ) { output . flush ( ) ; } } 
public void saveToFile ( ) { try { if ( filename == null ) return ; PrintWriter writer = new PrintWriter ( new FileWriter ( new File ( filename ) ) ) ; for ( int i = 0 ; i < fields . size ( ) ; i ++ ) { String fieldname = ( String ) fields . get ( i ) ; String fieldguiname = ( String ) fieldguinames . get ( fieldname ) ; Object fieldvalue = fieldvalues . get ( fieldname ) ; String fieldtype = ( String ) fieldtypes . get ( fieldname ) ; writer . println ( fieldname + "-" + fieldguiname + "-" + fieldtype + "-" + fieldvalue ) ; } writer . close ( ) ; } catch ( IOException e ) { throw new JGameError ( "Error-writing-file-'" + filename + "'." , false ) ; } } 
public void dontReconnect ( ) throws Exception { java . lang . reflect . Field f = cnxn . getClass ( ) . getDeclaredField ( "closing" ) ; f . setAccessible ( true ) ; f . setBoolean ( cnxn , true ) ; } 
private char scanSurrogates ( ) { if ( surrogatesSupported && Character . isHighSurrogate ( ch ) ) { char high = ch ; scanChar ( ) ; if ( Character . isLowSurrogate ( ch ) ) { return high ; } ch = high ; } return 0 ; } 
public JButton add ( Action a ) { JButton b = createActionComponent ( a ) ; b . setAction ( a ) ; add ( b ) ; return b ; } 
@ RequestMapping ( value = "/getPlatformUnitSubtypesForDisplay" , method = RequestMethod . GET ) public @ ResponseBody String getAllPlatformUnitSubtypes ( @ RequestParam String str ) { Map < String , String > queryMap = new HashMap < String , String > ( ) ; queryMap . put ( "sampleType.iName" , "platformunit" ) ; List < String > orderByList = new ArrayList < String > ( ) ; orderByList . add ( "name" ) ; List < SampleSubtype > sampleSubtypeList = sampleSubtypeDao . findByMapDistinctOrderBy ( queryMap , null , orderByList , "asc" ) ; String jsonString = new String ( ) ; jsonString = jsonString + "{"source":-[" ; for ( SampleSubtype ss : sampleSubtypeList ) { if ( ss . getName ( ) . indexOf ( str ) > - 1 ) { jsonString = jsonString + """ + ss . getName ( ) + ""," ; } } jsonString = jsonString . replaceAll ( ",$" , "" ) + "]}" ; return jsonString ; } 
public static KeyEvent obtain ( long downTime , long eventTime , int action , int code , int repeat , int metaState , int deviceId , int scancode , int flags , int source , String characters ) { KeyEvent ev = obtain ( ) ; ev . mDownTime = downTime ; ev . mEventTime = eventTime ; ev . mAction = action ; ev . mKeyCode = code ; ev . mRepeatCount = repeat ; ev . mMetaState = metaState ; ev . mDeviceId = deviceId ; ev . mScanCode = scancode ; ev . mFlags = flags ; ev . mSource = source ; ev . mCharacters = characters ; return ev ; } 
public int getMinY ( ) { return ( ( RenderedImage ) getList ( ) . get ( 0 ) ) . getMinY ( ) ; } 
private void enableActions ( ) { restoreAction . setEnabled ( frame . isMaximum ( ) || frame . isIcon ( ) ) ; maximizeAction . setEnabled ( ( frame . isMaximizable ( ) && ! frame . isMaximum ( ) && ! frame . isIcon ( ) ) || ( frame . isMaximizable ( ) && frame . isIcon ( ) ) ) ; iconifyAction . setEnabled ( frame . isIconifiable ( ) && ! frame . isIcon ( ) ) ; closeAction . setEnabled ( frame . isClosable ( ) ) ; sizeAction . setEnabled ( false ) ; moveAction . setEnabled ( false ) ; } 
@ XmlElementDecl ( namespace = EbxmlNamespaces . ADDRESSING_URI , name = "Action" ) public JAXBElement < AttributedURIType > createAction ( AttributedURIType value ) { return new JAXBElement < AttributedURIType > ( _Action_QNAME , AttributedURIType . class , null , value ) ; } 
public static void clear ( ) { threadLocal . set ( null ) ; } 
public static boolean mkdirsWithExistsCheck ( File dir ) { if ( dir . mkdir ( ) || dir . exists ( ) ) { return true ; } File canonDir = null ; try { canonDir = dir . getCanonicalFile ( ) ; } catch ( IOException e ) { return false ; } String parent = canonDir . getParent ( ) ; return ( parent != null ) && ( mkdirsWithExistsCheck ( new File ( parent ) ) && ( canonDir . mkdir ( ) || canonDir . exists ( ) ) ) ; } 
private static HsqlSocketFactory newFactory ( String implClass ) throws Exception { Class clazz ; Constructor ctor ; Class [ ] ctorParm ; Object [ ] ctorArg ; Object factory ; clazz = Class . forName ( implClass ) ; ctorParm = new Class [ 0 ] ; ctor = clazz . getDeclaredConstructor ( ctorParm ) ; ctorArg = new Object [ 0 ] ; try { factory = ctor . newInstance ( ctorArg ) ; } catch ( InvocationTargetException e ) { Throwable t = e . getTargetException ( ) ; throw ( t instanceof Exception ) ? ( ( Exception ) t ) : new RuntimeException ( t . toString ( ) ) ; } return ( HsqlSocketFactory ) factory ; } 
public static String readAsciiLine ( InputStream in ) throws IOException { StringBuilder result = new StringBuilder ( 80 ) ; while ( true ) { int c = in . read ( ) ; if ( c == - 1 ) { throw new EOFException ( ) ; } else if ( c == '|n' ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > 0 && result . charAt ( length - 1 ) == '|r' ) { result . setLength ( length - 1 ) ; } return result . toString ( ) ; } 
public void addEnvironmentVar ( String varName , String varValue ) { environment . put ( varName , varValue ) ; } 
public Iterator keyIterator ( ) { return treeMap . keySet ( ) . iterator ( ) ; } 
public static byte [ ] decodeWebSafe ( byte [ ] source ) throws Base64DecoderException { return decodeWebSafe ( source , 0 , source . length ) ; } 
public int cardinality ( ) { if ( ! needClear ) { return 0 ; } int count = 0 ; int length = bits . length ; for ( int idx = 0 ; idx < length ; idx ++ ) { count += pop ( bits [ idx ] & 0xffffffffL ) ; count += pop ( bits [ idx ] >>> 32 ) ; } return count ; } 
public void pickStemmer ( String language ) { stemmerName = language ; if ( stemmerName != null ) { if ( ! allowedStemmers . matcher ( stemmerName ) . matches ( ) ) { throw new IllegalArgumentException ( "SnowballAnalyzer-configured-for-unavailable-stemmer-" + stemmerName ) ; } if ( defaultStopWordMap . containsKey ( stemmerName ) ) { stopSet = defaultStopWordMap . get ( stemmerName ) ; } } } 
public boolean offer ( E e ) { return offerLast ( e ) ; } 
public Object validateValue ( ) throws Throwable { if ( tag == ERROR ) { rethrowError ( ) ; } if ( value == NO_VALUE ) { return null ; } if ( elementType == value . getClass ( ) || elementType . isInstance ( value ) ) { return copyValue ( ) ; } else { throw new AnnotationTypeMismatchException ( definingMethod , value . getClass ( ) . getName ( ) ) ; } } 
public void parse ( final SetCookie cookie , String domain ) throws MalformedCookieException { if ( cookie == null ) { throw new IllegalArgumentException ( "Cookie-may-not-be-null" ) ; } if ( domain == null ) { throw new MalformedCookieException ( "Missing-value-for-domain-attribute" ) ; } if ( domain . trim ( ) . length ( ) == 0 ) { throw new MalformedCookieException ( "Blank-value-for-domain-attribute" ) ; } domain = domain . toLowerCase ( Locale . ENGLISH ) ; if ( ! domain . startsWith ( "." ) ) { domain = '.' + domain ; } cookie . setDomain ( domain ) ; } 
public static synchronized CatalogResolver getCatalogResolver ( ) { if ( catalogResolver == null ) { final CatalogManager manager = new CatalogManager ( ) ; manager . setIgnoreMissingProperties ( true ) ; manager . setUseStaticCatalog ( false ) ; manager . setPreferPublic ( true ) ; catalogResolver = new CatalogResolver ( manager ) ; final String catalogFilePath = getDitaDir ( ) + FILE_NAME_CATALOG ; final Catalog catalog = catalogResolver . getCatalog ( ) ; try { catalog . parseCatalog ( catalogFilePath ) ; } catch ( final Exception e ) { logger . logException ( e ) ; } } return catalogResolver ; } 
public int enumerate ( ThreadGroup [ ] groups , boolean recurse ) { return enumerateGeneric ( groups , recurse , 0 , false ) ; } 
public boolean add ( E e ) { addLast ( e ) ; return true ; } 
protected final void serialize ( ObjectOutputStream oos , Collection coll ) throws IOException { int count = 0 ; Object [ ] objects = coll . toArray ( ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { if ( objects [ i ] instanceof Serializable ) count ++ ; else objects [ i ] = null ; } oos . writeInt ( count ) ; for ( int i = 0 ; count > 0 ; i ++ ) { Object o = objects [ i ] ; if ( o != null ) { oos . writeObject ( o ) ; count -- ; } } } 
public final void removeCaretListener ( CaretListener listener ) { listenerList . remove ( CaretListener . class , listener ) ; } 
public int getCloseButtonState ( JComponent c , int tabIndex , boolean tabIsMousedOver ) { if ( ! c . isEnabled ( ) ) { return DISABLED ; } else if ( tabIndex == closeButtonArmedIndex ) { return PRESSED ; } else if ( tabIndex == closeButtonHoverIndex ) { return FOCUSED ; } else if ( tabIsMousedOver ) { return MOUSE_OVER ; } return ENABLED ; } 
public List < ActivityExpenseType > getActivityExpense ( ) { if ( activityExpense == null ) { activityExpense = new ArrayList < ActivityExpenseType > ( ) ; } return this . activityExpense ; } 
@ XmlElementDecl ( namespace = "" , name = "flexiblesearchcronjob" ) public JAXBElement < FlexibleSearchCronJobDTO > createFlexiblesearchcronjob ( FlexibleSearchCronJobDTO value ) { return new JAXBElement < FlexibleSearchCronJobDTO > ( new QName ( "" , "flexiblesearchcronjob" ) , FlexibleSearchCronJobDTO . class , null , value ) ; } 
public static boolean savedWorldHasForcedChunkTickets ( File chunkDir ) { File chunkLoaderData = new File ( chunkDir , "forcedchunks.dat" ) ; if ( chunkLoaderData . exists ( ) && chunkLoaderData . isFile ( ) ) { ; try { NBTTagCompound forcedChunkData = CompressedStreamTools . read ( chunkLoaderData ) ; return forcedChunkData . getTagList ( "TicketList" ) . tagCount ( ) > 0 ; } catch ( IOException e ) { } } return false ; } 
public static int getNumberType ( Number number ) { if ( number instanceof Integer ) { return IntegerType ; } if ( number instanceof Double ) { return DoubleType ; } if ( number instanceof Long ) { return LongType ; } if ( number instanceof Float ) { return FloatType ; } if ( number instanceof Byte ) { return ByteType ; } if ( number instanceof Short ) { return ShortType ; } if ( number instanceof BigDecimal ) { return BigDecimalType ; } if ( number instanceof BigInteger ) { return BigIntegerType ; } return 0 ; } 
private static StringBuffer buildNetworkInterfaceDescriptor ( ) { Enumeration e1 ; try { e1 = NetworkInterface . getNetworkInterfaces ( ) ; } catch ( Throwable t ) { return null ; } StringBuffer b = new StringBuffer ( ) ; while ( e1 . hasMoreElements ( ) ) { NetworkInterface ni = ( NetworkInterface ) e1 . nextElement ( ) ; StringBuffer b1 = getMACAddressDescriptor ( ni ) ; StringBuffer b2 = getInetAddressDescriptor ( ni ) ; StringBuffer b3 = new StringBuffer ( ) ; if ( b1 != null ) { b3 . append ( b1 ) ; } if ( b2 != null ) { if ( b3 . length ( ) > 0 ) { b3 . append ( '=' ) ; } b3 . append ( b2 ) ; } if ( b3 . length ( ) > 0 ) { if ( b . length ( ) > 0 ) { b . append ( ';' ) ; } b . append ( b3 ) ; } } return b ; } 
public StringBuffer appendTail ( StringBuffer sb ) { sb . append ( text , lastAppendPosition , getTextLength ( ) ) ; return sb ; } 
static Package getPackage ( Class < ? > c ) { String name = c . getName ( ) ; int i = name . lastIndexOf ( '.' ) ; if ( i != - 1 ) { name = name . substring ( 0 , i ) ; ClassLoader cl = c . getClassLoader ( ) ; if ( cl != null ) { return cl . getPackage ( name ) ; } else { return getSystemPackage ( name ) ; } } else { return null ; } } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
private String plab ( CNfa state ) { int index ; if ( null == state ) { return ( new String ( "--" ) ) ; } index = m_spec . m_nfa_states . indexOf ( state ) ; return ( ( new Integer ( index ) ) . toString ( ) ) ; } 
private static final int [ ] increase ( int buffer [ ] , int size , int incrementsize ) { int result [ ] = new int [ buffer . length + incrementsize ] ; System . arraycopy ( buffer , 0 , result , 0 , size ) ; return result ; } 
public ValidationManager getValidationManager ( String validationFile ) { return ( ValidationManager ) ObjectFactory . newInstance ( "org.netbeans.modules.j2ee.sun.validation." + "ValidationManager" , validationFile ) ; } 
public void flush ( ) throws IOException { out . flush ( ) ; } 
public void print ( IPresetSet presetSet ) { Printer . printPresetSet ( presetSet ) ; } 
public static String getGiftCertNumbers ( List giftCertList ) { StringBuffer sb = new StringBuffer ( ) ; GiftCertDetails giftCertDetails = null ; for ( int i = 0 ; i < giftCertList . size ( ) ; i ++ ) { giftCertDetails = ( GiftCertDetails ) giftCertList . get ( i ) ; sb . append ( giftCertDetails . getCertNumber ( ) ) ; if ( i != giftCertList . size ( ) - 1 ) { sb . append ( "-" ) ; } } return sb . toString ( ) ; } 
private void cleanupConnections ( boolean force ) { if ( force || numConnections > thresholdIdleConnections ) { long currentTime = System . currentTimeMillis ( ) ; if ( ! force && ( currentTime - lastCleanupRunTime ) < cleanupInterval ) { return ; } int start = 0 ; int end = numConnections - 1 ; if ( ! force ) { start = rand . nextInt ( ) % numConnections ; end = rand . nextInt ( ) % numConnections ; int temp ; if ( end < start ) { temp = start ; start = end ; end = temp ; } } int i = start ; int numNuked = 0 ; while ( i <= end ) { Connection c ; synchronized ( connectionList ) { try { c = connectionList . get ( i ) ; } catch ( Exception e ) { return ; } } if ( c . timedOut ( currentTime ) ) { if ( LOG . isDebugEnabled ( ) ) LOG . debug ( getName ( ) + ":-disconnecting-client-" + c . getHostAddress ( ) ) ; closeConnection ( c ) ; numNuked ++ ; end -- ; c = null ; if ( ! force && numNuked == maxConnectionsToNuke ) break ; } else i ++ ; } lastCleanupRunTime = System . currentTimeMillis ( ) ; } } 
public List < ImageDescription > describeImagesByExecutability ( List < String > users , Map < String , List < String >> filters ) throws EC2Exception { Map < String , String > params = new HashMap < String , String > ( ) ; for ( int i = 0 ; i < users . size ( ) ; i ++ ) { params . put ( "ExecutableBy." + ( i + 1 ) , users . get ( i ) ) ; } return describeImages ( params , filters ) ; } 
public synchronized void addListener ( Class c , Object listener ) { if ( listener == null || c == null ) throw new IllegalArgumentException ( ) ; int oldSize = ( array == null ) ? 0 : array . length ; Object [ ] newArray = new Object [ oldSize + 2 ] ; if ( oldSize != 0 ) System . arraycopy ( array , 0 , newArray , 0 , oldSize ) ; newArray [ oldSize ++ ] = c ; newArray [ oldSize ] = listener ; array = newArray ; } 
private Rectangle getPaintTrackRect ( ) { int trackLeft = 0 , trackRight = 0 , trackTop = 0 , trackBottom = 0 ; if ( slider . getOrientation ( ) == JSlider . HORIZONTAL ) { trackBottom = ( trackRect . height - 1 ) - getThumbOverhang ( ) ; trackTop = trackBottom - ( getTrackWidth ( ) - 1 ) ; trackRight = trackRect . width - 1 ; } else { if ( MetalUtils . isLeftToRight ( slider ) ) { trackLeft = ( trackRect . width - getThumbOverhang ( ) ) - getTrackWidth ( ) ; trackRight = ( trackRect . width - getThumbOverhang ( ) ) - 1 ; } else { trackLeft = getThumbOverhang ( ) ; trackRight = getThumbOverhang ( ) + getTrackWidth ( ) - 1 ; } trackBottom = trackRect . height - 1 ; } return new Rectangle ( trackRect . x + trackLeft , trackRect . y + trackTop , trackRight - trackLeft , trackBottom - trackTop ) ; } 
static byte [ ] discardNonBase64 ( byte [ ] data ) { byte groomedData [ ] = new byte [ data . length ] ; int bytesCopied = 0 ; for ( int i = 0 ; i < data . length ; i ++ ) { if ( isBase64 ( data [ i ] ) ) { groomedData [ bytesCopied ++ ] = data [ i ] ; } } byte packedData [ ] = new byte [ bytesCopied ] ; System . arraycopy ( groomedData , 0 , packedData , 0 , bytesCopied ) ; return packedData ; } 
public void put ( String name , Scriptable start , Object value ) { PageVariable variable = variables . get ( name ) ; if ( variable != null ) { if ( value instanceof Wrapper ) { value = ( ( Wrapper ) value ) . unwrap ( ) ; } variable . setValue ( value ) ; return ; } String errorMessage = "Report-variable"" + name + ""-does-not-exist" ; throw new JavaScriptException ( errorMessage , "<unknown>" , - 1 ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public List < TransportResolverListener . Checker > getListenersList ( ) { synchronized ( listeners ) { return new ArrayList ( listeners ) ; } } 
@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( "StandardServer[" ) ; sb . append ( getPort ( ) ) ; sb . append ( "]" ) ; return ( sb . toString ( ) ) ; } 
public static int getCurrentAnimationsCount ( ) { return sAnimations . get ( ) . size ( ) ; } 
public void prependStep ( int x , int y ) { steps . add ( 0 , new Step ( x , y ) ) ; } 
public void setChannelPosition ( Block b , BlockWriteStreams streams , long dataOffset , long ckOffset ) throws IOException { long size = 0 ; synchronized ( this ) { FSVolume vol = volumeMap . get ( b ) . getVolume ( ) ; size = vol . getTmpFile ( b ) . length ( ) ; } if ( size < dataOffset ) { String msg = "Trying-to-change-block-file-offset-of-block-" + b + "-to-" + dataOffset + "-but-actual-size-of-file-is-" + size ; throw new IOException ( msg ) ; } FileOutputStream file = ( FileOutputStream ) streams . dataOut ; file . getChannel ( ) . position ( dataOffset ) ; file = ( FileOutputStream ) streams . checksumOut ; file . getChannel ( ) . position ( ckOffset ) ; } 
public static Request newCustomAudienceThirdPartyIdRequest ( Session session , Context context , Callback callback ) { return newCustomAudienceThirdPartyIdRequest ( session , context , null , callback ) ; } 
private void informUponSimilarName ( final StringBuffer messageBuffer , final String name , final String candidate ) { if ( name . equals ( candidate ) ) { return ; } if ( name . regionMatches ( true , 0 , candidate , 0 , PKG_LEN + 5 ) ) { messageBuffer . append ( "-Did-you-mean-'" ) ; messageBuffer . append ( candidate ) ; messageBuffer . append ( "'?" ) ; } } 
public Context getCurrentContext ( ) { return contextStack . peek ( ) ; } 
public Collection getFaciesModels ( Collection c ) { if ( c == null ) c = new ArrayList ( ) ; if ( faciesModels != null ) c . addAll ( faciesModels ) ; return c ; } 
ConcreteInstanceType getImplicitPrototype ( ) { if ( ( prototype == null ) && ( instanceType . getImplicitPrototype ( ) != null ) ) { ObjectType proto = instanceType . getImplicitPrototype ( ) ; if ( ( proto != instanceType ) && ! ( proto instanceof UnknownType ) ) { prototype = factory . createConcreteInstance ( proto ) ; } } return prototype ; } 
private final BaseCalendar . Date getGregorianCutoverDate ( ) { return getCalendarDate ( gregorianCutoverDate ) ; } 
public void printStackTrace ( java . io . PrintStream s ) { printStackTrace ( new java . io . PrintWriter ( s ) ) ; } 
public void allocateBuffers ( int [ ] vertices , int [ ] texcoords , int [ ] normals , int [ ] colors , short [ ] indices ) { allocate ( vertices , texcoords , normals , colors ) ; ByteBuffer ibb = ByteBuffer . allocateDirect ( indices . length * SHORT_BYTES ) ; ibb . order ( ByteOrder . nativeOrder ( ) ) ; ShortBuffer shortIndexBuffer = ibb . asShortBuffer ( ) ; shortIndexBuffer . put ( indices ) ; shortIndexBuffer . position ( 0 ) ; this . mIndexBuffer = shortIndexBuffer ; } 
public Object get ( String fieldName ) { Object value = null ; try { Field f = ( Field ) fieldHash . get ( fieldName ) ; if ( f != null ) { value = f . get ( null ) ; } } catch ( IllegalAccessException e ) { System . err . println ( "IllegalAccessException-while-trying-to-access-" + fieldName + ":-" + e . getMessage ( ) ) ; } return value ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public void clearAllResolvers ( ) { resolvers . clear ( ) ; } 
RemoteMatlabProxy ( JMIWrapperRemote internalProxy , RequestReceiver receiver , Identifier id , boolean existingSession ) { super ( id , existingSession ) ; _connectionTimer = new Timer ( "MLC-Connection-Listener-" + id ) ; _jmiWrapper = internalProxy ; _receiver = receiver ; } 
public void updateEmbeddedElement ( E element , int fieldNumber , Object value , boolean makeDirty ) { if ( makeDirty ) { makeDirty ( ) ; } } 
public static int skipUntil ( String input , int pos , String characters ) { for ( ; pos < input . length ( ) ; pos ++ ) { if ( characters . indexOf ( input . charAt ( pos ) ) != - 1 ) { break ; } } return pos ; } 
public static String hashKeyForDisk ( String key ) { String cacheKey ; try { final MessageDigest mDigest = MessageDigest . getInstance ( "MD5" ) ; mDigest . update ( key . getBytes ( ) ) ; cacheKey = bytesToHexString ( mDigest . digest ( ) ) ; } catch ( NoSuchAlgorithmException e ) { cacheKey = String . valueOf ( key . hashCode ( ) ) ; } return cacheKey ; } 
public synchronized Object get ( Object name ) { if ( _initParams == null ) return null ; return _initParams . get ( name ) ; } 
public void setObjectForStatement ( PreparedStatement ps , int index , Object value , int sqlType ) throws SQLException { if ( sqlType == Types . TINYINT ) { ps . setByte ( index , ( ( Byte ) value ) . byteValue ( ) ) ; } else { super . setObjectForStatement ( ps , index , value , sqlType ) ; } } 
public void addManualHangupListener ( ManualHangupListener listener ) { hangupListeners . add ( listener ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public Insets getMargin ( ) { return ( Insets ) margin . clone ( ) ; } 
private URLStreamHandler getJVMClassPathHandler ( final String protocol ) { Debug doDebug = debug ; if ( doDebug != null && ! doDebug . url ) { doDebug = null ; } if ( jvmPkgs != null ) { for ( final String jvmPkg : jvmPkgs ) { final String className = jvmPkg + "." + protocol + ".Handler" ; try { if ( doDebug != null ) { doDebug . println ( "JVMClassPath---trying-URLHandler-class=" + className ) ; } final Class < ? > clazz = Class . forName ( className ) ; final URLStreamHandler handler = ( URLStreamHandler ) clazz . newInstance ( ) ; if ( doDebug != null ) { doDebug . println ( "JVMClassPath---created-URLHandler-class=" + className ) ; } return handler ; } catch ( final Throwable t ) { if ( doDebug != null ) { doDebug . println ( "JVMClassPath---no-URLHandler-class-" + className ) ; } } } } if ( doDebug != null ) { doDebug . println ( "JVMClassPath---no-URLHandler-for-" + protocol ) ; } return null ; } 
protected final void deinitialize ( ) { if ( isInitialized ( ) ) { window = null ; setState ( State . INITIALIZED , false ) ; setDirtyRegion ( Rectangle . EMPTY ) ; deinitializeComponent ( ) ; } for ( int i = getComponentCount ( ) ; i -- > 0 ; ) { getComponentAt ( i ) . deinitialize ( ) ; } } 
public synchronized int getSendBufferSize ( ) throws SocketException { checkOpen ( ) ; return ( ( Integer ) impl . getOption ( SocketOptions . SO_SNDBUF ) ) . intValue ( ) ; } 
public void add ( DynamicLeveragedSegment p_segment ) { m_leverageResults . add ( p_segment ) ; } 
@ XmlElementDecl ( namespace = "http://www.xbrl.org/tw/fr/gaap/tw-gaap-ins-2010-03-31-cr" , name = "ProceedsSaleLongTermInvestmentStock" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < MonetaryItemType > createProceedsSaleLongTermInvestmentStock ( MonetaryItemType value ) { return new JAXBElement < MonetaryItemType > ( _ProceedsSaleLongTermInvestmentStock_QNAME , MonetaryItemType . class , null , value ) ; } 
public final int sign ( byte [ ] outbuf , int offset , int len ) throws SignatureException { if ( outbuf == null || offset < 0 || len < 0 || offset + len > outbuf . length ) { throw new IllegalArgumentException ( ) ; } if ( state != SIGN ) { throw new SignatureException ( "Signature-object-is-not-initialized-properly" ) ; } return engineSign ( outbuf , offset , len ) ; } 
String getNextLine ( boolean ctrlZ ) { int i = 0 ; try { for ( ; ; ) { int result ; result = inStream . read ( ) ; if ( result < 0 ) { return null ; } if ( ctrlZ && result == 0x1a ) { break ; } else if ( result == '|r' || result == '|n' ) { if ( i == 0 ) { continue ; } else { break ; } } buffer [ i ++ ] = ( byte ) result ; } } catch ( IOException ex ) { return null ; } catch ( IndexOutOfBoundsException ex ) { System . err . println ( "ATChannel:-buffer-overflow" ) ; } try { return new String ( buffer , 0 , i , "US-ASCII" ) ; } catch ( UnsupportedEncodingException ex ) { System . err . println ( "ATChannel:-implausable-UnsupportedEncodingException" ) ; return null ; } } 
public boolean hasClearCache ( ) { return ( ( Boolean ) getValue ( GLOBAL_FLAG_VERB , NO_VERB_OBJECT , KEY_CLEAR_CACHE ) ) . booleanValue ( ) ; } 
public Closure < V > ncurry ( int n , final Object argument ) { return ncurry ( n , new Object [ ] { argument } ) ; } 
public Matrix4f readFloatBuffer ( FloatBuffer fb , boolean columnMajor ) { if ( columnMajor ) { m00 = fb . get ( ) ; m10 = fb . get ( ) ; m20 = fb . get ( ) ; m30 = fb . get ( ) ; m01 = fb . get ( ) ; m11 = fb . get ( ) ; m21 = fb . get ( ) ; m31 = fb . get ( ) ; m02 = fb . get ( ) ; m12 = fb . get ( ) ; m22 = fb . get ( ) ; m32 = fb . get ( ) ; m03 = fb . get ( ) ; m13 = fb . get ( ) ; m23 = fb . get ( ) ; m33 = fb . get ( ) ; } else { m00 = fb . get ( ) ; m01 = fb . get ( ) ; m02 = fb . get ( ) ; m03 = fb . get ( ) ; m10 = fb . get ( ) ; m11 = fb . get ( ) ; m12 = fb . get ( ) ; m13 = fb . get ( ) ; m20 = fb . get ( ) ; m21 = fb . get ( ) ; m22 = fb . get ( ) ; m23 = fb . get ( ) ; m30 = fb . get ( ) ; m31 = fb . get ( ) ; m32 = fb . get ( ) ; m33 = fb . get ( ) ; } return this ; } 
private String getResult ( URL url ) throws IOException { HttpURLConnection conn = ( HttpURLConnection ) url . openConnection ( ) ; conn . setDoInput ( true ) ; conn . setDoOutput ( true ) ; InputStream is = conn . getInputStream ( ) ; String result = toString ( is ) ; return result ; } 
public long transformNumber ( long number ) { return Math . round ( number * denominator ) ; } 
protected static List < String > parseUsernameArray ( Element element ) { List < String > list = new ArrayList < String > ( ) ; @ SuppressWarnings ( "unchecked" ) List < Node > nodes = ( List < Node > ) element . selectNodes ( "return" ) ; for ( Node node : nodes ) { String username = node . getText ( ) ; username = JID . escapeNode ( username ) ; list . add ( username ) ; } return list ; } 
public IIOMetadataFormat getImageMetadataFormat ( String formatName ) { return getMetadataFormat ( formatName , supportsStandardImageMetadataFormat , nativeImageMetadataFormatName , nativeImageMetadataFormatClassName , extraImageMetadataFormatNames , extraImageMetadataFormatClassNames ) ; } 
protected void BuildFDArrayUsed ( int Font ) { int [ ] FDSelect = fonts [ Font ] . FDSelect ; for ( int i = 0 ; i < glyphsInList . size ( ) ; i ++ ) { int glyph = glyphsInList . get ( i ) . intValue ( ) ; int FD = FDSelect [ glyph ] ; FDArrayUsed . add ( Integer . valueOf ( FD ) ) ; } } 
private void delayedHide ( int delayMillis ) { mHideHandler . removeCallbacks ( mHideRunnable ) ; mHideHandler . postDelayed ( mHideRunnable , delayMillis ) ; } 
private void formatLine ( String name , String rentals , String noStock , String timeout , String total ) { System . out . format ( "%tT-%8s-%8s-%8s-%8s-%8s%n" , Calendar . getInstance ( ) , name , rentals , noStock , timeout , total ) ; } 
public Script ( byte [ ] programBytes ) throws ScriptException { program = programBytes ; parse ( programBytes ) ; creationTimeSeconds = Utils . now ( ) . getTime ( ) / 1000 ; } 
public OutputStream newOutputStream ( int index ) throws IOException { synchronized ( DiskLruCache . this ) { if ( entry . currentEditor != this ) { throw new IllegalStateException ( ) ; } if ( ! entry . readable ) { written [ index ] = true ; } File dirtyFile = entry . getDirtyFile ( index ) ; FileOutputStream outputStream ; try { outputStream = new FileOutputStream ( dirtyFile ) ; } catch ( FileNotFoundException e ) { directory . mkdirs ( ) ; try { outputStream = new FileOutputStream ( dirtyFile ) ; } catch ( FileNotFoundException e2 ) { return NULL_OUTPUT_STREAM ; } } return new FaultHidingOutputStream ( outputStream ) ; } } 
public int getSideGap ( ) { if ( isScrollableY ( ) && isScrollVisible ( ) ) { return getUIManager ( ) . getLookAndFeel ( ) . getVerticalScrollWidth ( ) ; } return 0 ; } 
boolean clearPackagePreferredActivitiesLPw ( String packageName , int userId ) { ArrayList < PreferredActivity > removed = null ; boolean changed = false ; for ( int i = 0 ; i < mSettings . mPreferredActivities . size ( ) ; i ++ ) { final int thisUserId = mSettings . mPreferredActivities . keyAt ( i ) ; PreferredIntentResolver pir = mSettings . mPreferredActivities . valueAt ( i ) ; if ( userId != UserHandle . USER_ALL && userId != thisUserId ) { continue ; } Iterator < PreferredActivity > it = pir . filterIterator ( ) ; while ( it . hasNext ( ) ) { PreferredActivity pa = it . next ( ) ; if ( packageName == null || ( pa . mPref . mComponent . getPackageName ( ) . equals ( packageName ) && pa . mPref . mAlways ) ) { if ( removed == null ) { removed = new ArrayList < PreferredActivity > ( ) ; } removed . add ( pa ) ; } } if ( removed != null ) { for ( int j = 0 ; j < removed . size ( ) ; j ++ ) { PreferredActivity pa = removed . get ( j ) ; pir . removeFilter ( pa ) ; } changed = true ; } } return changed ; } 
protected Map getDispatchTable ( ) { Map table = super . getDispatchTable ( ) ; table . put ( EjbTagNames . ROLE_NAME , "setRoleName" ) ; return table ; } 
private static Object doEventAccess ( final ExceptionAction run ) throws MutexException { if ( isDispatchThread ( ) ) { try { return run . run ( ) ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new MutexException ( e ) ; } catch ( LinkageError e ) { throw new MutexException ( new InvocationTargetException ( e ) ) ; } catch ( StackOverflowError e ) { throw new MutexException ( new InvocationTargetException ( e ) ) ; } } final Throwable [ ] arr = new Throwable [ 1 ] ; try { final Object [ ] res = new Object [ 1 ] ; EventQueue . invokeAndWait ( new Runnable ( ) { public void run ( ) { try { res [ 0 ] = run . run ( ) ; } catch ( Exception e ) { arr [ 0 ] = e ; } catch ( LinkageError e ) { arr [ 0 ] = e ; } catch ( StackOverflowError e ) { arr [ 0 ] = e ; } } } ) ; if ( arr [ 0 ] == null ) { return res [ 0 ] ; } } catch ( InterruptedException e ) { arr [ 0 ] = e ; } catch ( InvocationTargetException e ) { arr [ 0 ] = e ; } if ( arr [ 0 ] instanceof RuntimeException ) { throw ( RuntimeException ) arr [ 0 ] ; } throw notifyException ( ErrorManager . EXCEPTION , arr [ 0 ] ) ; } 
public void remove ( int index ) { strategies . removeElementAt ( index ) ; } 
private boolean _removeActivity ( Activity a ) { boolean r ; synchronized ( this ) { r = m_activities . remove ( a ) ; if ( r ) { if ( m_activities . size ( ) == 0 ) { m_nextTime = Long . MAX_VALUE ; } } } if ( r ) { a . setScheduled ( false ) ; } return r ; } 
void setEnterKeyResources ( Resources res , int previewId , int iconId , int labelId ) { if ( mEnterKey != null ) { mEnterKey . popupCharacters = null ; mEnterKey . popupResId = 0 ; mEnterKey . text = null ; mEnterKey . iconPreview = res . getDrawable ( previewId ) ; mEnterKey . icon = res . getDrawable ( iconId ) ; mEnterKey . label = res . getText ( labelId ) ; if ( mEnterKey . iconPreview != null ) { mEnterKey . iconPreview . setBounds ( 0 , 0 , mEnterKey . iconPreview . getIntrinsicWidth ( ) , mEnterKey . iconPreview . getIntrinsicHeight ( ) ) ; } } } 
public final Object getContent ( ) throws IOException { return openConnection ( ) . getContent ( ) ; } 
@ Override public synchronized int hashCode ( ) { int hashCode = getID ( ) . hashCode ( ) + rawOffset ; if ( useDaylight ) { hashCode += startYear + startMonth + startDay + startDayOfWeek + startTime + startMode + endMonth + endDay + endDayOfWeek + endTime + endMode + dstSavings ; } return hashCode ; } 
public void multiplexerAvailable ( String connectionManagerName ) { Map < String , LocalClientSession > sessions = sessionsByManager . get ( connectionManagerName ) ; if ( sessions == null ) { synchronized ( connectionManagerName . intern ( ) ) { sessions = sessionsByManager . get ( connectionManagerName ) ; if ( sessions == null ) { sessions = new ConcurrentHashMap < String , LocalClientSession > ( ) ; sessionsByManager . put ( connectionManagerName , sessions ) ; } } } } 
public static NinePatchChunk getChunk ( byte [ ] array ) { SoftReference < NinePatchChunk > chunkRef = sChunkCache . get ( array ) ; NinePatchChunk chunk = chunkRef . get ( ) ; if ( chunk == null ) { ByteArrayInputStream bais = new ByteArrayInputStream ( array ) ; ObjectInputStream ois = null ; try { ois = new ObjectInputStream ( bais ) ; chunk = ( NinePatchChunk ) ois . readObject ( ) ; if ( chunk != null ) { sChunkCache . put ( array , new SoftReference < NinePatchChunk > ( chunk ) ) ; } } catch ( IOException e ) { Bridge . getLog ( ) . error ( LayoutLog . TAG_BROKEN , "Failed-to-deserialize-NinePatchChunk-content." , e , null ) ; return null ; } catch ( ClassNotFoundException e ) { Bridge . getLog ( ) . error ( LayoutLog . TAG_BROKEN , "Failed-to-deserialize-NinePatchChunk-class." , e , null ) ; return null ; } finally { if ( ois != null ) { try { ois . close ( ) ; } catch ( IOException e ) { } } } } return chunk ; } 
public byte get_octet ( ) throws TypeMismatch , InvalidValue { throw new MARSHAL ( _DynAnyStub . NOT_APPLICABLE ) ; } 
private void computePortList ( ) { mMap = new HashMap < String , Map < String , Integer >> ( ) ; IPreferenceStore store = DdmsPlugin . getDefault ( ) . getPreferenceStore ( ) ; String value = store . getString ( PREFS_STATIC_PORT_LIST ) ; if ( value != null && value . length ( ) > 0 ) { String [ ] portSegments = value . split ( "||" ) ; for ( String seg : portSegments ) { String [ ] entry = seg . split ( ":" ) ; String deviceName = null ; if ( entry . length == 3 ) { deviceName = entry [ 2 ] ; } else { deviceName = IDevice . FIRST_EMULATOR_SN ; } Map < String , Integer > deviceMap = mMap . get ( deviceName ) ; if ( deviceMap == null ) { deviceMap = new HashMap < String , Integer > ( ) ; mMap . put ( deviceName , deviceMap ) ; } deviceMap . put ( entry [ 0 ] , Integer . valueOf ( entry [ 1 ] ) ) ; } } } 
private void verifyTimestamp ( X509Certificate cert , Date date ) throws CertPathValidatorException { String msg = "timestamp" ; if ( debug != null ) debug . println ( "---checking-" + msg + ":" + date . toString ( ) + "..." ) ; try { cert . checkValidity ( date ) ; } catch ( CertificateExpiredException e ) { throw new CertPathValidatorException ( msg + "-check-failed" , e , null , - 1 , BasicReason . EXPIRED ) ; } catch ( CertificateNotYetValidException e ) { throw new CertPathValidatorException ( msg + "-check-failed" , e , null , - 1 , BasicReason . NOT_YET_VALID ) ; } if ( debug != null ) debug . println ( msg + "-verified." ) ; } 
private void mergeSortURL ( String action , String primarySortKey ) throws XServerException { if ( primarySortKey == null ) { primarySortKey = "rank" ; } StringBuilder query = new StringBuilder ( xserverBaseUrl ) ; query . append ( "?op=merge_sort_request" + "&group_number=" + foundGroupNumber + "&action=" + action + "&primary_sort_key=" + primarySortKey + "&session_id=" + sessionId + "&fetch_more_records=" + XSERVER_RECORDS_TO_FETCH ) ; java . io . ByteArrayOutputStream xml = doURLConnection ( query . toString ( ) ) ; if ( printXML ) { LOG . debug ( xml . toString ( ) ) ; } try { saxParseXML ( new java . io . ByteArrayInputStream ( xml . toByteArray ( ) ) ) ; } catch ( SAXException sxe ) { Exception x = sxe ; if ( sxe . getException ( ) != null ) { x = sxe . getException ( ) ; } LOG . warn ( "mergeSortURL()-SAX-exception:-" + sxe . getMessage ( ) , x ) ; } catch ( IOException ioe ) { LOG . warn ( "mergeSortURL()-IO-exception" , ioe ) ; } } 
public ColorChooserUI getUI ( ) { return ( ColorChooserUI ) ui ; } 
public synchronized void println ( String text ) { display . append ( text + "-" ) ; } 
private Object writeReplace ( ) throws ObjectStreamException { return new LinkedHashMap < K , V > ( this ) ; } 
public boolean supportsIntegrityEnhancementFacility ( ) throws SQLException { if ( ! this . conn . getOverrideSupportsIntegrityEnhancementFacility ( ) ) { return false ; } return true ; } 
private void parseDocument ( Document document ) { NodeList environmentList = document . getElementsByTagName ( "environment" ) ; ENV_MAP . clear ( ) ; for ( int i = 0 ; i < environmentList . getLength ( ) ; i ++ ) { Element environment = ( Element ) environmentList . item ( i ) ; String envName = environment . getAttribute ( "name" ) ; boolean defaultEnv = Boolean . parseBoolean ( environment . getAttribute ( "default" ) ) ; if ( defaultEnv ) { defaultEnvironment = envName ; } ENV_MAP . put ( envName , environment ) ; } } 
public static String escape ( String name ) { initInvalidChars ( ) ; int len = name . length ( ) ; StringBuffer buf = new StringBuffer ( len ) ; char [ ] chars = name . toCharArray ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = chars [ i ] ; if ( invalidChars . get ( c ) == Boolean . TRUE ) { buf . append ( "_" ) ; } else { buf . append ( c ) ; } } return buf . toString ( ) ; } 
boolean needsOtaServiceProvisioning ( ) { String cdmaMin = getCdmaMin ( ) ; boolean needsProvisioning ; if ( cdmaMin == null || ( cdmaMin . length ( ) < 6 ) ) { if ( DBG ) Log . d ( LOG_TAG , "needsOtaServiceProvisioning:-illegal-cdmaMin='" + cdmaMin + "'-assume-provisioning-needed." ) ; needsProvisioning = true ; } else { needsProvisioning = ( cdmaMin . equals ( UNACTIVATED_MIN_VALUE ) || cdmaMin . substring ( 0 , 6 ) . equals ( UNACTIVATED_MIN2_VALUE ) ) || SystemProperties . getBoolean ( "test_cdma_setup" , false ) ; } if ( DBG ) Log . d ( LOG_TAG , "needsOtaServiceProvisioning:-ret=" + needsProvisioning ) ; return needsProvisioning ; } 
public static Node . OfInt flattenInt ( Node . OfInt node ) { if ( node . getChildCount ( ) > 0 ) { long size = node . count ( ) ; if ( size >= MAX_ARRAY_SIZE ) throw new IllegalArgumentException ( BAD_SIZE ) ; int [ ] array = new int [ ( int ) size ] ; new ToArrayTask . OfInt ( node , array , 0 ) . invoke ( ) ; return node ( array ) ; } else { return node ; } } 
public static final Object handleNewInstance ( Constructor < ? > ctor , Object [ ] args , ExceptionInterceptor exceptionInterceptor ) throws SQLException { try { return ctor . newInstance ( args ) ; } catch ( IllegalArgumentException e ) { throw SQLError . createSQLException ( "Can't-instantiate-required-class" , SQLError . SQL_STATE_GENERAL_ERROR , e , exceptionInterceptor ) ; } catch ( InstantiationException e ) { throw SQLError . createSQLException ( "Can't-instantiate-required-class" , SQLError . SQL_STATE_GENERAL_ERROR , e , exceptionInterceptor ) ; } catch ( IllegalAccessException e ) { throw SQLError . createSQLException ( "Can't-instantiate-required-class" , SQLError . SQL_STATE_GENERAL_ERROR , e , exceptionInterceptor ) ; } catch ( InvocationTargetException e ) { Throwable target = e . getTargetException ( ) ; if ( target instanceof SQLException ) { throw ( SQLException ) target ; } if ( target instanceof ExceptionInInitializerError ) { target = ( ( ExceptionInInitializerError ) target ) . getException ( ) ; } throw SQLError . createSQLException ( target . toString ( ) , SQLError . SQL_STATE_GENERAL_ERROR , exceptionInterceptor ) ; } } 
public String getValueOrNull ( String name ) throws InvalidXmlException { if ( ! subtrees . containsKey ( name ) ) { return null ; } LinkedList < Stanza > l = subtrees . get ( name ) ; if ( l . size ( ) != 1 ) { throw new InvalidXmlException ( "More-than-one-value-found-for-" + name ) ; } return l . get ( 0 ) . getValue ( ) ; } 
public E poll ( ) { return transferer . transfer ( null , true , 0 ) ; } 
@ FindBugsSuppressWarnings ( "ES_COMPARING_PARAMETER_STRING_WITH_EQ" ) public boolean equalsIgnoreCase ( String string ) { if ( string == this ) { return true ; } if ( string == null || count != string . count ) { return false ; } int o1 = offset , o2 = string . offset ; int end = offset + count ; char [ ] target = string . value ; while ( o1 < end ) { char c1 = value [ o1 ++ ] ; char c2 = target [ o2 ++ ] ; if ( c1 != c2 && foldCase ( c1 ) != foldCase ( c2 ) ) { return false ; } } return true ; } 
private String sanitizeUri ( String uri ) { if ( uri == null || uri . length ( ) == 0 ) { return null ; } try { return new URI ( uri ) . toString ( ) ; } catch ( URISyntaxException e ) { return null ; } } 
public static String localizePath ( String path ) { return customizePath ( path , '/' , File . separatorChar ) ; } 
@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public void setParameter ( String name , Enum value ) { conf . setEnum ( name , value ) ; } 
public void setAdminDN ( String adminDN ) { this . adminDN = adminDN ; properties . put ( "ldap.adminDN" , adminDN ) ; } 
private E unlinkFirst ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; notFull . signal ( ) ; return item ; } 
public void highScore ( View view ) { final Dialog highScoreDialog = new FadeDialog ( new Dialog ( this ) , R . layout . dialog_high_score ) . getDialog ( ) ; if ( ! highScoreDialog . isShowing ( ) ) { ( ( TextView ) highScoreDialog . findViewById ( R . id . textView_dialogHSInfo ) ) . setText ( String . valueOf ( getSharedPreferences ( "highScores" , Context . MODE_PRIVATE ) . getInt ( "highScore" , 0 ) ) ) ; ( ( Button ) highScoreDialog . findViewById ( R . id . button_dialogHSBack ) ) . setOnClickListener ( new OnClickListener ( ) { @ Override public void onClick ( View v ) { highScoreDialog . dismiss ( ) ; } } ) ; highScoreDialog . show ( ) ; } } 
@ XmlElementDecl ( namespace = "http://www.omg.org/spec/BPMN/20100524/MODEL" , name = "baseElementWithMixedContent" ) public JAXBElement < TBaseElementWithMixedContent > createBaseElementWithMixedContent ( TBaseElementWithMixedContent value ) { return new JAXBElement < TBaseElementWithMixedContent > ( _BaseElementWithMixedContent_QNAME , TBaseElementWithMixedContent . class , null , value ) ; } 
public String lookupNamespace ( String prefix ) { final Stack stack = ( Stack ) m_namespaces . get ( prefix ) ; return stack != null && ! stack . isEmpty ( ) ? ( ( MappingRecord ) stack . peek ( ) ) . m_uri : null ; } 
@ SuppressWarnings ( "deprecation" ) @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( 29 ) ; format ( ( getYear ( ) + 1900 ) , 4 , sb ) ; sb . append ( '-' ) ; format ( ( getMonth ( ) + 1 ) , 2 , sb ) ; sb . append ( '-' ) ; format ( getDate ( ) , 2 , sb ) ; sb . append ( '-' ) ; format ( getHours ( ) , 2 , sb ) ; sb . append ( ':' ) ; format ( getMinutes ( ) , 2 , sb ) ; sb . append ( ':' ) ; format ( getSeconds ( ) , 2 , sb ) ; sb . append ( '.' ) ; if ( nanos == 0 ) { sb . append ( '0' ) ; } else { format ( nanos , 9 , sb ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == '0' ) { sb . setLength ( sb . length ( ) - 1 ) ; } } return sb . toString ( ) ; } 
public static void addAlloy ( Alloy alloy , int harvestLevel , int durability , int [ ] armorPieceValues , float efficiency , float damage , int enchantability ) { alloy . armorMaterialStorage . put ( alloy . alloyName , EnumHelper . addArmorMaterial ( alloy . alloyName . toUpperCase ( ) , durability , armorPieceValues , enchantability ) ) ; alloy . toolMaterialStorage . put ( alloy . alloyName , EnumHelper . addToolMaterial ( alloy . alloyName . toUpperCase ( ) , harvestLevel , durability , efficiency , damage , enchantability ) ) ; } 
static public Object deserialize ( InputStream in ) throws IOException { if ( in == null ) throw new NullPointerException ( "in" ) ; ObjectInputStream objIn = new ObjectInputStream ( in ) ; Object obj ; try { obj = objIn . readObject ( ) ; } catch ( ClassNotFoundException ex ) { throw new InvalidClassException ( ex . toString ( ) ) ; } return obj ; } 
void doReps ( ObjectOutputStream oout , ObjectInputStream oin , StreamBuffer sbuf , long [ ] [ ] arrays , int nbatches ) throws Exception { int ncycles = arrays . length ; for ( int i = 0 ; i < nbatches ; i ++ ) { sbuf . reset ( ) ; oout . reset ( ) ; for ( int j = 0 ; j < ncycles ; j ++ ) { oout . writeObject ( arrays [ j ] ) ; } oout . flush ( ) ; for ( int j = 0 ; j < ncycles ; j ++ ) { oin . readObject ( ) ; } } } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; elementList . add ( new javax . xml . namespace . QName ( "urn:partner.soap.sforce.com" , "username" ) ) ; if ( localUsername != null ) { elementList . add ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( localUsername ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "username-cannot-be-null!!" ) ; } elementList . add ( new javax . xml . namespace . QName ( "urn:partner.soap.sforce.com" , "password" ) ) ; if ( localPassword != null ) { elementList . add ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( localPassword ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "password-cannot-be-null!!" ) ; } return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
public int nextInt ( int radix ) { if ( ( typeCache != null ) && ( typeCache instanceof Integer ) && this . radix == radix ) { int val = ( ( Integer ) typeCache ) . intValue ( ) ; useTypeCache ( ) ; return val ; } setRadix ( radix ) ; clearCaches ( ) ; try { String s = next ( integerPattern ( ) ) ; if ( matcher . group ( SIMPLE_GROUP_INDEX ) == null ) s = processIntegerToken ( s ) ; return Integer . parseInt ( s , radix ) ; } catch ( NumberFormatException nfe ) { position = matcher . start ( ) ; throw new InputMismatchException ( nfe . getMessage ( ) ) ; } } 
public void remove ( LibraryItem item ) throws LibraryException { boolean found = false ; int indexOfItemToRemove = - 1 ; if ( item == null ) { throw new IllegalArgumentException ( "Arguement-must-not-be-null" ) ; } else { for ( int i = 0 ; i < items . size ( ) ; i ++ ) { if ( item == items . get ( i ) ) { found = true ; indexOfItemToRemove = i ; } } } if ( found ) { items . remove ( indexOfItemToRemove ) ; } else { throw new LibraryException ( item ) ; } } 
void removeValue ( String value ) { if ( value == null ) { throw new NullPointerException ( "parameter-value-is-null" ) ; } if ( this . value != null ) { if ( this . value . equals ( value ) ) { this . value = null ; } } else { values . remove ( value ) ; if ( values . size ( ) == 1 ) { this . value = ( String ) values . get ( 0 ) ; values . clear ( ) ; } } } 
boolean equals ( Token that ) { if ( this . type == that . type ) if ( this . name == null ) return that . name == null ; else return this . name . equals ( that . name ) ; return false ; } 
public void setThrown ( Throwable thrown ) { if ( thrown == null ) { return ; } _thrown = thrown ; StringWriter sw = new StringWriter ( ) ; PrintWriter out = new PrintWriter ( sw ) ; thrown . printStackTrace ( out ) ; out . flush ( ) ; _thrownStackTrace = sw . toString ( ) ; try { out . close ( ) ; sw . close ( ) ; } catch ( IOException e ) { } out = null ; sw = null ; } 
public void setLocale ( Locale locale ) { fLocale = locale ; fErrorReporter . setLocale ( locale ) ; } 
public void finish ( ) throws IOException { if ( ! deflater . finished ( ) ) { deflater . finish ( ) ; while ( ! deflater . finished ( ) ) { deflate ( ) ; } } } 
public void uninstallUI ( JComponent a ) { for ( int i = 0 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . uninstallUI ( a ) ; } } 
final PasswordAuthentication requestPasswordAuthentication ( InetAddress addr , int port , String protocol , String prompt , String defaultUserName ) { reset ( ) ; requestingSite = addr ; requestingPort = port ; requestingProtocol = protocol ; requestingPrompt = prompt ; requestingUserName = defaultUserName ; return getPasswordAuthentication ( ) ; } 
public boolean hasNext ( Pattern pattern ) { ensureOpen ( ) ; if ( pattern == null ) throw new NullPointerException ( ) ; hasNextPattern = null ; saveState ( ) ; while ( true ) { if ( getCompleteTokenInBuffer ( pattern ) != null ) { matchValid = true ; cacheResult ( ) ; return revertState ( true ) ; } if ( needInput ) readInput ( ) ; else return revertState ( false ) ; } } 
public static String getStoredProcedureVersion ( String datasourceName ) throws IllegalArgumentException { if ( datasourceName == null ) { throw new IllegalArgumentException ( "datasourceName-not-specified!" ) ; } logger . debug ( "Begin-getStoredProcedureVersion-for-" + datasourceName ) ; String storedProcedureVersion = null ; Connection connection = null ; PreparedStatement selectPreparedStatement = null ; try { connection = DatasourceManager . getConnection ( datasourceName ) ; selectPreparedStatement = connection . prepareStatement ( DBInfoManager . getSelectStoredProcedureVersionQuery ( ) ) ; ResultSet resultSet = selectPreparedStatement . executeQuery ( ) ; if ( resultSet . next ( ) ) { storedProcedureVersion = resultSet . getString ( DBInfoManager . STORED_PROCEDURE_VERSION_FIELD ) ; } } catch ( Exception e ) { logger . error ( e . getMessage ( ) ) ; storedProcedureVersion = null ; } finally { if ( selectPreparedStatement != null ) { try { selectPreparedStatement . close ( ) ; } catch ( SQLException sqle1 ) { logger . error ( sqle1 ) ; } } if ( connection != null ) { try { connection . close ( ) ; } catch ( SQLException sqle ) { logger . error ( sqle ) ; } } } logger . info ( "Stored-Procedure-Version-=-" + storedProcedureVersion + "-for-" + datasourceName ) ; logger . debug ( "End-getStoredProcedureVersion-for-" + datasourceName ) ; return storedProcedureVersion ; } 
private Set < CompletionProposalCategory > getCategoriesToNotify ( ) { Set < CompletionProposalCategory > currentCategories = new HashSet < CompletionProposalCategory > ( fCategories . size ( ) ) ; if ( fCategoryIteration != null ) { Iterator < List < CompletionProposalCategory >> it = fCategoryIteration . iterator ( ) ; while ( it . hasNext ( ) ) currentCategories . addAll ( it . next ( ) ) ; } for ( CompletionProposalCategory cat : fCategories ) { if ( cat . getEnablementExpression ( ) == null ) currentCategories . add ( cat ) ; } return currentCategories ; } 
public void setMousePosition ( int x , int y ) { mousePositionLabel . setText ( "Position:-(" + x + "-,-" + y + ")" ) ; } 
public static void setSpaceAbove ( MutableAttributeSet a , float i ) { a . addAttribute ( SpaceAbove , new Float ( i ) ) ; } 
public static Preferences getPrefObject ( ) { if ( _reference == null ) _reference = new Preferences ( ) ; return _reference ; } 
public final static VersionInfo [ ] loadVersionInfo ( String [ ] pckgs , ClassLoader clsldr ) { if ( pckgs == null ) { throw new IllegalArgumentException ( "Package-identifier-list-must-not-be-null." ) ; } ArrayList vil = new ArrayList ( pckgs . length ) ; for ( int i = 0 ; i < pckgs . length ; i ++ ) { VersionInfo vi = loadVersionInfo ( pckgs [ i ] , clsldr ) ; if ( vi != null ) vil . add ( vi ) ; } return ( VersionInfo [ ] ) vil . toArray ( new VersionInfo [ vil . size ( ) ] ) ; } 
public static List < Response > executeConnectionAndWait ( HttpURLConnection connection , RequestBatch requests ) { List < Response > responses = Response . fromHttpConnection ( connection , requests ) ; Utility . disconnectQuietly ( connection ) ; int numRequests = requests . size ( ) ; if ( numRequests != responses . size ( ) ) { throw new FacebookException ( String . format ( "Received-%d-responses-while-expecting-%d" , responses . size ( ) , numRequests ) ) ; } runCallbacks ( requests , responses ) ; HashSet < Session > sessions = new HashSet < Session > ( ) ; for ( Request request : requests ) { if ( request . session != null ) { sessions . add ( request . session ) ; } } for ( Session session : sessions ) { session . extendAccessTokenIfNeeded ( ) ; } return responses ; } 
private ElementValue [ ] addElementValue ( int elementValuesCount , ElementValue [ ] elementValues , ElementValue elementValue ) { if ( elementValues . length <= elementValuesCount ) { ElementValue [ ] newElementValues = new ElementValue [ elementValuesCount + 1 ] ; System . arraycopy ( elementValues , 0 , newElementValues , 0 , elementValuesCount ) ; elementValues = newElementValues ; } elementValues [ elementValuesCount ] = elementValue ; return elementValues ; } 
public static String getHostname ( ) { try { return "" + InetAddress . getLocalHost ( ) ; } catch ( UnknownHostException uhe ) { return "" + uhe ; } } 
public synchronized void setParams ( HashMap p ) throws OptimizerException { if ( _f != null ) throw new OptimizerException ( "cannot-modify-parameters-while-running" ) ; _params = null ; _params = new HashMap ( p ) ; } 
public AccessibleText getAccessibleText ( ) { if ( getNoteLabelAccessibleText ( ) != null ) { return this ; } return null ; } 
@ Override public void map ( ImmutableBytesWritable row , Result values , Context context ) throws IOException { context . getCounter ( Counters . ROWS ) . increment ( 1 ) ; } 
public static Transformer chainedTransformer ( Transformer [ ] transformers ) { return ChainedTransformer . getInstance ( transformers ) ; } 
public boolean equals ( final Object other ) { if ( other == this ) { return true ; } if ( other == null ) { return false ; } if ( other instanceof Filter ) { @ SuppressWarnings ( "unchecked" ) Filter < ConcreteFilterType , FilteredObjectType > otherType = ( Filter < ConcreteFilterType , FilteredObjectType > ) other ; if ( description ( ) . equals ( otherType . description ( ) ) ) { return true ; } Set < FilteredObjectType > left = new HashSet < FilteredObjectType > ( allMatches ( ) ) ; Set < FilteredObjectType > right = new HashSet < FilteredObjectType > ( otherType . allMatches ( ) ) ; return left . equals ( right ) ; } else { return quantify . evaluate ( new Predicate < FilteredObjectType > ( ) { public boolean isSatisfiedBy ( FilteredObjectType object ) { return other . equals ( object ) ; } } ) ; } } 
@ Override public int read ( byte [ ] buffer , int byteOffset , int byteCount ) throws IOException { if ( mEntry != null ) { return - 1 ; } int r = super . read ( buffer , byteOffset , byteCount ) ; if ( verStream != null && ! eos ) { if ( r == - 1 ) { eos = true ; if ( verifier != null ) { if ( isMeta ) { verifier . addMetaEntry ( jarEntry . getName ( ) , ( ( ByteArrayOutputStream ) verStream ) . toByteArray ( ) ) ; try { verifier . readCertificates ( ) ; } catch ( SecurityException e ) { verifier = null ; throw e ; } } else { ( ( JarVerifier . VerifierEntry ) verStream ) . verify ( ) ; } } } else { verStream . write ( buffer , byteOffset , r ) ; } } return r ; } 
public Locale [ ] getAvailableLocales ( ) { if ( availableLocales == null ) { return null ; } else { return ( Locale [ ] ) availableLocales . clone ( ) ; } } 
protected void copyResponseHeaders ( Message message , HttpServletResponse response ) { String ct = ( String ) message . get ( Message . CONTENT_TYPE ) ; String enc = ( String ) message . get ( Message . ENCODING ) ; if ( null != ct && null != enc && ct . indexOf ( "charset=" ) == - 1 && ! ct . toLowerCase ( ) . contains ( "multipart/related" ) ) { ct = ct + ";-charset=" + enc ; } Map < ? , ? > headers = ( Map < ? , ? > ) message . get ( Message . PROTOCOL_HEADERS ) ; if ( null != headers ) { if ( ! headers . containsKey ( Message . CONTENT_TYPE ) ) { response . setContentType ( ct ) ; } for ( Iterator < ? > iter = headers . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String header = ( String ) iter . next ( ) ; List < ? > headerList = ( List < ? > ) headers . get ( header ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < headerList . size ( ) ; i ++ ) { sb . append ( headerList . get ( i ) ) ; if ( i + 1 < headerList . size ( ) ) { sb . append ( ',' ) ; } } response . addHeader ( header , sb . toString ( ) ) ; } } else { response . setContentType ( ct ) ; } } 
public void unregisterForContextMenu ( View view ) { view . setOnCreateContextMenuListener ( null ) ; } 
public ClassNode getOriginType ( ) { if ( accessedVariable != null && accessedVariable != this ) return accessedVariable . getOriginType ( ) ; return originType ; } 
public Class < ? > getListenerType ( ) { return ( this . listenerTypeRef != null ) ? this . listenerTypeRef . get ( ) : null ; } 
public static String format ( Date date ) { Calendar c = new GregorianCalendar ( TimeZone . getTimeZone ( "UTC" ) ) ; StringBuffer sb = new StringBuffer ( ) ; c . setTime ( date ) ; sb . append ( w4 . format ( c . get ( Calendar . YEAR ) ) ) ; sb . append ( w2 . format ( c . get ( Calendar . MONTH ) + 1 ) ) ; sb . append ( w2 . format ( c . get ( Calendar . DAY_OF_MONTH ) ) ) ; sb . append ( w2 . format ( c . get ( Calendar . HOUR_OF_DAY ) ) ) ; sb . append ( w2 . format ( c . get ( Calendar . MINUTE ) ) ) ; sb . append ( w2 . format ( c . get ( Calendar . SECOND ) ) ) ; return sb . toString ( ) ; } 
public Date get2DigitYearStart ( ) { return ( Date ) defaultCenturyStart . clone ( ) ; } 
static boolean isSet ( ) { PolicyInfo pi = policy . get ( ) ; return pi . policy != null && pi . initialized == true ; } 
public Enumeration enumerateMeasures ( ) { Vector newVector = new Vector ( 3 ) ; newVector . addElement ( "measureTreeSize" ) ; newVector . addElement ( "measureNumLeaves" ) ; newVector . addElement ( "measureNumRules" ) ; return newVector . elements ( ) ; } 
public static Well1024a setupSeedsForRand ( long seed ) { long lSeed = ( seed == DataGenOp . UNSPECIFIED_SEED ? DataGenOp . generateRandomSeed ( ) : seed ) ; LOG . trace ( "Setting-up-RandSeeds-with-initial-seed-=-" + lSeed + "." ) ; Random random = new Random ( lSeed ) ; Well1024a bigrand = new Well1024a ( ) ; int [ ] seeds = new int [ 32 ] ; for ( int s = 0 ; s < seeds . length ; s ++ ) seeds [ s ] = random . nextInt ( ) ; bigrand . setSeed ( seeds ) ; return bigrand ; } 
public JSeparator getJSeparatorS83121 ( ) { if ( jSeparatorS83121 == null ) { jSeparatorS83121 = new JSeparator ( ) ; jSeparatorS83121 . setLocation ( new Point ( 212 , 210 ) ) ; jSeparatorS83121 . setOrientation ( SwingConstants . VERTICAL ) ; jSeparatorS83121 . setSize ( new Dimension ( 10 , 22 ) ) ; } return jSeparatorS83121 ; } 
public void update ( byte [ ] input ) { algorithm . update ( input ) ; } 
public boolean requiresTunnel ( ) { return route . address . sslSocketFactory != null && route . proxy . type ( ) == Proxy . Type . HTTP ; } 
@ Override protected void drawNeedle ( Graphics2D g2 , Rectangle2D plotArea , Point2D rotate , double angle ) { super . drawNeedle ( g2 , plotArea , rotate , angle ) ; if ( ( rotate != null ) && ( plotArea != null ) ) { int spacing = getSize ( ) * 3 ; Rectangle2D newArea = new Rectangle2D . Double ( ) ; Point2D newRotate = rotate ; newArea . setRect ( plotArea . getMinX ( ) - spacing , plotArea . getMinY ( ) , plotArea . getWidth ( ) , plotArea . getHeight ( ) ) ; super . drawNeedle ( g2 , newArea , newRotate , angle ) ; newArea . setRect ( plotArea . getMinX ( ) + spacing , plotArea . getMinY ( ) , plotArea . getWidth ( ) , plotArea . getHeight ( ) ) ; super . drawNeedle ( g2 , newArea , newRotate , angle ) ; } } 
public static CtClass getReturnType ( String desc , ClassPool cp ) throws NotFoundException { int i = desc . indexOf ( ')' ) ; if ( i < 0 ) return null ; else { CtClass [ ] type = new CtClass [ 1 ] ; toCtClass ( cp , desc , i + 1 , type , 0 ) ; return type [ 0 ] ; } } 
public void replaceSelection ( String content ) { ensureLegalCaretPosition ( ) ; String [ ] lines = content . split ( "-" ) ; super . replaceSelection ( lines [ 0 ] ) ; for ( int i = 1 ; i < lines . length ; i ++ ) { softReturnAction . actionPerformed ( null ) ; super . replaceSelection ( lines [ i ] ) ; } } 
final public Expression conditionalOrExpression ( ) throws ParseException { Expression exp ; Expression exp2 ; exp = conditionalAndExpression ( ) ; label_25 : while ( true ) { switch ( this . jj_ntk == - 1 ? jj_ntk ( ) : this . jj_ntk ) { case CONDITIONAL_OR : ; break ; default : this . jj_la1 [ 71 ] = this . jj_gen ; break label_25 ; } jj_consume_token ( CONDITIONAL_OR ) ; exp2 = conditionalAndExpression ( ) ; exp = new OrExpression ( exp , exp2 , this . filename , exp . getBeginLine ( ) , exp . getBeginColumn ( ) , exp2 . getEndLine ( ) , exp2 . getEndColumn ( ) ) ; } { if ( true ) { return exp ; } } throw new Error ( "Missing-return-statement-in-function" ) ; } 
public static String getProviderIcon ( Class < ? > clazz ) { String ret = null ; if ( clazz . isAnnotationPresent ( Provider . class ) ) { Provider provider = clazz . getAnnotation ( Provider . class ) ; if ( provider != null && ! provider . icon ( ) . equals ( "" ) ) { ret = provider . icon ( ) ; } } return ret ; } 
public final boolean isSubTypeOf ( Class type ) { return type . isAssignableFrom ( clazz ) ; } 
private void setDiscLable ( JLabel jl , int count , int value ) { String [ ] [ ] disc ; int uperCut = 5 ; int lowerCut = - 5 ; if ( ability ) { disc = DISC_ABILITY ; uperCut = 7 ; lowerCut = 3 ; } else { disc = DISC_PERS ; uperCut = 5 ; lowerCut = - 5 ; } if ( value <= lowerCut ) { jl . setText ( disc [ count ] [ 2 ] ) ; jl . setForeground ( Color . red ) ; } else if ( value >= uperCut ) { jl . setText ( disc [ count ] [ 0 ] ) ; jl . setForeground ( Color . green ) ; } else { jl . setText ( disc [ count ] [ 1 ] ) ; jl . setForeground ( Color . orange ) ; } } 
public ResolverUtil < T > find ( Test test , String packageName ) { packageName = packageName . replace ( '.' , '/' ) ; ClassLoader loader = getClassLoader ( ) ; Enumeration < URL > urls ; try { urls = loader . getResources ( packageName ) ; } catch ( IOException ioe ) { return this ; } while ( urls . hasMoreElements ( ) ) { String urlPath = urls . nextElement ( ) . getFile ( ) ; try { urlPath = URLDecoder . decode ( urlPath , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } if ( urlPath . startsWith ( "file:" ) ) { urlPath = urlPath . substring ( 5 ) ; } if ( urlPath . indexOf ( '!' ) > 0 ) { urlPath = urlPath . substring ( 0 , urlPath . indexOf ( '!' ) ) ; } File file = new File ( urlPath ) ; if ( file . isDirectory ( ) ) { loadImplementationsInDirectory ( test , packageName , file ) ; } else { loadImplementationsInJar ( test , packageName , file ) ; } } return this ; } 
private LivenessAnalyzer ( SsaMethod ssaMeth , int reg , InterferenceGraph interference ) { int blocksSz = ssaMeth . getBlocks ( ) . size ( ) ; this . ssaMeth = ssaMeth ; this . regV = reg ; visitedBlocks = new BitSet ( blocksSz ) ; liveOutBlocks = new BitSet ( blocksSz ) ; this . interference = interference ; } 
public synchronized void clear ( ) { rrs . clear ( ) ; position = 0 ; nsigs = 0 ; } 
protected void checkAndMarshall ( XMLObject xmlObject ) throws DecryptionException { Element targetElement = xmlObject . getDOM ( ) ; if ( targetElement == null ) { Marshaller marshaller = Configuration . getMarshallerFactory ( ) . getMarshaller ( xmlObject ) ; try { targetElement = marshaller . marshall ( xmlObject ) ; } catch ( MarshallingException e ) { log . error ( "Error-marshalling-target-XMLObject" , e ) ; throw new DecryptionException ( "Error-marshalling-target-XMLObject" , e ) ; } } } 
public static < T > List < T > subList ( List < T > base , int maxSize ) { if ( maxSize < base . size ( ) ) return base . subList ( 0 , maxSize ) ; else return base ; } 
public void setProviders ( Object ... theProviders ) { myPlainProviders = Arrays . asList ( theProviders ) ; } 
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; for ( Item item : this ) s . append ( item + "-" ) ; return s . toString ( ) ; } 
private void createScrollPane ( ) { AttributeSet attributes = getElement ( ) . getAttributes ( ) ; String scrolling = ( String ) attributes . getAttribute ( HTML . Attribute . SCROLLING ) ; if ( scrolling == null ) { scrolling = "auto" ; } if ( ! scrolling . equals ( "no" ) ) { if ( scrolling . equals ( "yes" ) ) { scroller = new JScrollPane ( JScrollPane . VERTICAL_SCROLLBAR_ALWAYS , JScrollPane . HORIZONTAL_SCROLLBAR_ALWAYS ) ; } else { scroller = new JScrollPane ( ) ; } } else { scroller = new JScrollPane ( JScrollPane . VERTICAL_SCROLLBAR_NEVER , JScrollPane . HORIZONTAL_SCROLLBAR_NEVER ) ; } JViewport vp = scroller . getViewport ( ) ; vp . add ( htmlPane ) ; vp . setBackingStoreEnabled ( true ) ; scroller . setMinimumSize ( new Dimension ( 5 , 5 ) ) ; scroller . setMaximumSize ( new Dimension ( Integer . MAX_VALUE , Integer . MAX_VALUE ) ) ; } 
public static byte [ ] gzip ( String input ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gzos = null ; try { gzos = new GZIPOutputStream ( baos ) ; gzos . write ( input . getBytes ( "UTF-8" ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( gzos != null ) try { gzos . close ( ) ; } catch ( IOException ignore ) { } } return baos . toByteArray ( ) ; } 
public static < S > ServiceLoader < S > load ( Class < S > service ) { return ServiceLoader . load ( service , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } 
public Edge reverse ( ) { Edge re ; try { re = new Edge ( this . headNodeConnector , this . tailNodeConnector ) ; } catch ( ConstructionException e ) { re = null ; } return re ; } 
public List < Token > getTokens ( int start , int stop , Set < Integer > types ) { lazyInit ( ) ; if ( start < 0 || stop >= tokens . size ( ) || stop < 0 || start >= tokens . size ( ) ) { throw new IndexOutOfBoundsException ( "start-" + start + "-or-stop-" + stop + "-not-in-0.." + ( tokens . size ( ) - 1 ) ) ; } if ( start > stop ) return null ; List < Token > filteredTokens = new ArrayList < Token > ( ) ; for ( int i = start ; i <= stop ; i ++ ) { Token t = tokens . get ( i ) ; if ( types == null || types . contains ( t . getType ( ) ) ) { filteredTokens . add ( t ) ; } } if ( filteredTokens . isEmpty ( ) ) { filteredTokens = null ; } return filteredTokens ; } 
public static final float toJulian ( Date date ) { Calendar c = Calendar . getInstance ( ) ; c . setTime ( date ) ; return toJulian ( c ) ; } 
public void setScope ( String aScopeName ) { mScope = Scope . getInstance ( aScopeName ) ; } 
public List < JWBUID > getShapeMapping ( Guid id ) { return itemToShape . get ( id ) ; } 
@ XmlElementDecl ( namespace = "http://maven.apache.org/POM/4.0.0" , name = "project" ) public JAXBElement < Model > createProject ( Model value ) { return new JAXBElement < Model > ( _Project_QNAME , Model . class , null , value ) ; } 
public static Border getBorder ( String title , Color titleColor ) { Border linedBorder , titledBorder ; linedBorder = BorderFactory . createLineBorder ( Color . WHITE ) ; titledBorder = BorderFactory . createTitledBorder ( linedBorder , title , TitledBorder . CENTER , TitledBorder . TOP , Resources . DOS . deriveFont ( 16f ) , titleColor ) ; return titledBorder ; } 
private int matchGreedy ( Matcher m , ReaderBuffer buffer , int start , int skip ) throws IOException { if ( skip == 0 ) { return matchPossessive ( m , buffer , start , 0 ) ; } if ( matchStart != start ) { matchStart = start ; matches = new BitSet ( ) ; findMatches ( m , buffer , start , 0 , 0 , 0 ) ; } for ( int i = matches . size ( ) ; i >= 0 ; i -- ) { if ( matches . get ( i ) ) { if ( skip == 0 ) { return i ; } skip -- ; } } return - 1 ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public String readAll ( ) { if ( ! scanner . hasNextLine ( ) ) { return null ; } return scanner . useDelimiter ( "|A" ) . next ( ) ; } 
private synchronized void removeRange ( int fromIndex , int toIndex ) { Object [ ] elements = getArray ( ) ; int len = elements . length ; if ( fromIndex < 0 || fromIndex >= len || toIndex > len || toIndex < fromIndex ) throw new IndexOutOfBoundsException ( ) ; int newlen = len - ( toIndex - fromIndex ) ; int numMoved = len - toIndex ; if ( numMoved == 0 ) setArray ( copyOf ( elements , newlen ) ) ; else { Object [ ] newElements = new Object [ newlen ] ; System . arraycopy ( elements , 0 , newElements , 0 , fromIndex ) ; System . arraycopy ( elements , toIndex , newElements , fromIndex , numMoved ) ; setArray ( newElements ) ; } } 
public String toString ( ) { if ( filterConfig == null ) return ( "RequestDumperFilter()" ) ; StringBuffer sb = new StringBuffer ( "RequestDumperFilter(" ) ; sb . append ( filterConfig ) ; sb . append ( ")" ) ; return ( sb . toString ( ) ) ; } 
public void setPadding ( int left , int top , int right , int bottom ) { mUserPaddingStart = - 1 ; mUserPaddingEnd = - 1 ; mUserPaddingRelative = false ; internalSetPadding ( left , top , right , bottom ) ; } 
private static void parseDN ( String dn , List rdn ) { int startIndex = 0 ; char c = '|0' ; List nameValues = new ArrayList ( ) ; while ( startIndex < dn . length ( ) ) { int endIndex ; for ( endIndex = startIndex ; endIndex < dn . length ( ) ; endIndex ++ ) { c = dn . charAt ( endIndex ) ; if ( c == ',' || c == '+' ) { break ; } if ( c == '|' ) { endIndex ++ ; } } if ( endIndex > dn . length ( ) ) { throw new IllegalArgumentException ( "unterminated-escape-" + dn ) ; } nameValues . add ( dn . substring ( startIndex , endIndex ) ) ; if ( c != '+' ) { rdn . add ( nameValues ) ; if ( endIndex != dn . length ( ) ) { nameValues = new ArrayList ( ) ; } else { nameValues = null ; } } startIndex = endIndex + 1 ; } if ( nameValues != null ) { throw new IllegalArgumentException ( "improperly-terminated-DN-" + dn ) ; } } 
public void printModel ( ) { for ( Map . Entry < String , Set < ConfigurableComponent >> entry : _groups . entrySet ( ) ) { System . out . println ( "Group-:-" + entry . getKey ( ) ) ; for ( ConfigurableComponent groupmember : entry . getValue ( ) ) { System . out . println ( '-' + groupmember . getName ( ) ) ; } } for ( ConfigurableComponent cc : _classes . values ( ) ) { System . out . print ( cc ) ; } System . out . println ( ) ; System . out . flush ( ) ; } 
public void Print ( String nFile ) { String contents ; contents = "Chromosome:-" ; for ( int i = 0 ; i < num_genes ; i ++ ) contents += cromosoma [ i ] + "-" ; contents += "-" ; if ( nFile == "" ) System . out . print ( contents ) ; else Files . addToFile ( nFile , contents ) ; } 
public void startDocument ( ) throws SAXException { if ( contentHandler != null ) { contentHandler . startDocument ( ) ; } } 
public String [ ] getArray ( String key ) { try { String s = get ( key ) ; StringTokenizer tokenizer = new StringTokenizer ( s , "[-,;]" ) ; int len = tokenizer . countTokens ( ) ; String [ ] res = new String [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { res [ i ] = tokenizer . nextToken ( ) ; } return res ; } catch ( Exception e ) { System . out . println ( "Key-not-available-in-" + _fileName + ":-" + key + "-" ) ; } return null ; } 
public final Date getTime ( ) { return new Date ( getTimeInMillis ( ) ) ; } 
public void setCancelable ( boolean cancelable ) { mCancelable = cancelable ; if ( mDialog != null ) mDialog . setCancelable ( cancelable ) ; } 
public Object nextEntity ( char ampersand ) throws JSONException { StringBuilder sb = new StringBuilder ( ) ; for ( ; ; ) { char c = next ( ) ; if ( Character . isLetterOrDigit ( c ) || c == '#' ) { sb . append ( Character . toLowerCase ( c ) ) ; } else if ( c == ';' ) { break ; } else { throw syntaxError ( "Missing-';'-in-XML-entity:-&" + sb ) ; } } String string = sb . toString ( ) ; Object object = entity . get ( string ) ; return object != null ? object : ampersand + string + ";" ; } 
private Result pCIdentifier$Word$1 ( final int yyStart ) throws IOException { Result yyResult ; String yyValue ; ParseError yyError = ParseError . DUMMY ; yyResult = pCIdentifier$WordCharacters ( yyStart ) ; yyError = yyResult . select ( yyError ) ; if ( yyResult . hasValue ( ) ) { yyValue = yyResult . semanticValue ( ) ; yyResult = pSpacing ( yyResult . index ) ; yyError = yyResult . select ( yyError ) ; if ( yyResult . hasValue ( ) ) { return yyResult . createValue ( yyValue , yyError ) ; } } return yyError ; } 
public IntBuffer put ( int [ ] src , int off , int len ) { int length = src . length ; if ( off < 0 || len < 0 || ( long ) len + ( long ) off > length ) { throw new IndexOutOfBoundsException ( ) ; } if ( len > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = off ; i < off + len ; i ++ ) { put ( src [ i ] ) ; } return this ; } 
public String getRandomPhotoFromAlbum ( String idAlbum ) { int position = 0 ; ArrayList < Photo > photos = downloadPhotosFromAlbum ( idAlbum ) ; if ( photos . size ( ) > 0 ) { position = Utils . getRandomInt ( photos . size ( ) ) ; return photos . get ( position ) . getId ( ) ; } return null ; } 
protected void timerTic ( ) { mTime -= TIMER_TIC ; if ( mHandler != null ) { Message msg = new Message ( ) ; msg . arg1 = mTime ; mHandler . sendMessage ( msg ) ; } } 
@ Override public Element wrap ( String html ) { return ( Element ) super . wrap ( html ) ; } 
public void moveDot ( int dot , Position . Bias dotBias ) { if ( dotBias == null ) { throw new IllegalArgumentException ( "null-bias" ) ; } if ( ! component . isEnabled ( ) ) { setDot ( dot , dotBias ) ; return ; } if ( dot != this . dot ) { NavigationFilter filter = component . getNavigationFilter ( ) ; if ( filter != null ) { filter . moveDot ( getFilterBypass ( ) , dot , dotBias ) ; } else { handleMoveDot ( dot , dotBias ) ; } } } 
public void flagActionItems ( ) { if ( ! mIsActionItemsStale ) { return ; } boolean flagged = false ; for ( WeakReference < MenuPresenter > ref : mPresenters ) { final MenuPresenter presenter = ref . get ( ) ; if ( presenter == null ) { mPresenters . remove ( ref ) ; } else { flagged |= presenter . flagActionItems ( ) ; } } if ( flagged ) { mActionItems . clear ( ) ; mNonActionItems . clear ( ) ; ArrayList < MenuItemImpl > visibleItems = getVisibleItems ( ) ; final int itemsSize = visibleItems . size ( ) ; for ( int i = 0 ; i < itemsSize ; i ++ ) { MenuItemImpl item = visibleItems . get ( i ) ; if ( item . isActionButton ( ) ) { mActionItems . add ( item ) ; } else { mNonActionItems . add ( item ) ; } } } else { mActionItems . clear ( ) ; mNonActionItems . clear ( ) ; mNonActionItems . addAll ( getVisibleItems ( ) ) ; } mIsActionItemsStale = false ; } 
private TransformerFactory getFactory ( ) throws BuildException { if ( tfactory != null ) { return tfactory ; } if ( factoryName == null ) { tfactory = TransformerFactory . newInstance ( ) ; } else { try { Class clazz = Class . forName ( factoryName ) ; tfactory = ( TransformerFactory ) clazz . newInstance ( ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } } tfactory . setErrorListener ( this ) ; for ( int i = 0 ; i < attributes . size ( ) ; i ++ ) { final Object [ ] pair = ( Object [ ] ) attributes . elementAt ( i ) ; tfactory . setAttribute ( ( String ) pair [ 0 ] , pair [ 1 ] ) ; } if ( uriResolver != null ) { tfactory . setURIResolver ( uriResolver ) ; } return tfactory ; } 
public void setMetaTo ( Buffer that ) { this . flags = EnumSet . copyOf ( that . flags ) ; this . track = that . track ; this . sampleDuration = that . sampleDuration ; this . timeStamp = that . timeStamp ; this . format = that . format ; this . sampleCount = that . sampleCount ; this . format = that . format ; this . sequenceNumber = that . sequenceNumber ; } 
public String toString ( ) { return getClassName ( ) + "[" + getObjectName ( ) + "]" ; } 
public Task forgetAsync ( Connection c ) throws BadServerResponse , XenAPIException , XmlRpcException , Types . PifTunnelStillExists { String method_call = "Async.PIF.forget" ; String session = c . getSessionReference ( ) ; Object [ ] method_params = { Marshalling . toXMLRPC ( session ) , Marshalling . toXMLRPC ( this . ref ) } ; Map response = c . dispatch ( method_call , method_params ) ; Object result = response . get ( "Value" ) ; return Types . toTask ( result ) ; } 
protected SimpleIdentifier parseSimpleIdentifier ( ) { if ( matchesIdentifier ( ) ) { return new SimpleIdentifier ( getAndAdvance ( ) ) ; } reportErrorForCurrentToken ( ParserErrorCode . MISSING_IDENTIFIER ) ; return createSyntheticIdentifier ( ) ; } 
public static void main ( String [ ] args ) { if ( args . length > 1 ) { printUsage ( ) ; } if ( args . length == 0 || ( args . length == 1 && args [ 0 ] . equals ( "--full" ) ) ) { System . out . println ( getFullVersion ( ) ) ; System . exit ( 0 ) ; } if ( args [ 0 ] . equals ( "--short" ) ) System . out . println ( getVersion ( ) ) ; else if ( args [ 0 ] . equals ( "--revision" ) ) System . out . println ( getVersionRevision ( ) ) ; else printUsage ( ) ; System . exit ( 0 ) ; } 
private void initResources ( ) { Locale locale = Locale . getDefault ( ) ; imagePath = "." ; } 
public int showOpenDialog ( Component parent ) { setDialogType ( OPEN_DIALOG ) ; return showDialog ( parent , null ) ; } 
@ Override public Thread newThread ( Runnable r ) { final Thread t = new Thread ( group , r , String . format ( Locale . ROOT , "%s-%d" , this . threadNamePrefix , threadNumber . getAndIncrement ( ) ) , 0 ) ; t . setDaemon ( false ) ; t . setPriority ( Thread . NORM_PRIORITY ) ; return t ; } 
public void validate ( ) throws org . exolab . castor . xml . ValidationException { org . exolab . castor . xml . Validator validator = new org . exolab . castor . xml . Validator ( ) ; validator . validate ( this ) ; } 
public static Expression concatExpression ( final Collection < Expression > expressions , final String expression ) { return new ExpressionAdapter ( ) { public Object evaluate ( Exchange exchange ) { StringBuilder buffer = new StringBuilder ( ) ; for ( Expression expression : expressions ) { String text = expression . evaluate ( exchange , String . class ) ; if ( text != null ) { buffer . append ( text ) ; } } return buffer . toString ( ) ; } @ Override public String toString ( ) { if ( expression != null ) { return expression ; } else { return "concat" + expressions ; } } } ; } 
public synchronized int getSoTimeout ( ) throws IOException { checkOpen ( ) ; return ( ( Integer ) impl . getOption ( SocketOptions . SO_TIMEOUT ) ) . intValue ( ) ; } 
public static String joinFiles ( String ... files ) { final StringBuilder res = new StringBuilder ( ) ; for ( String file : files ) { res . append ( file ) . append ( File . separatorChar ) ; } return res . substring ( 0 , res . length ( ) - 1 ) ; } 
public List < CatalogVersionSyncJobDTO > getCatalogversionsyncjob ( ) { if ( catalogversionsyncjob == null ) { catalogversionsyncjob = new ArrayList < CatalogVersionSyncJobDTO > ( ) ; } return this . catalogversionsyncjob ; } 
public void addFocusables ( ArrayList < View > views , int direction , int focusableMode ) { if ( views == null ) { return ; } if ( ! isFocusable ( ) ) { return ; } if ( ( focusableMode & FOCUSABLES_TOUCH_MODE ) == FOCUSABLES_TOUCH_MODE && isInTouchMode ( ) && ! isFocusableInTouchMode ( ) ) { return ; } views . add ( this ) ; } 
public boolean getBoolean ( String key ) throws JSONException { Object object = this . get ( key ) ; if ( object . equals ( Boolean . FALSE ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( Boolean . TRUE ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "]-is-not-a-Boolean." ) ; } 
public QueryCommand setFilterList ( Query f ) { if ( filter != null ) { throw new IllegalArgumentException ( "Either-filter-or-filterList-may-be-set-in-the-QueryCommand,-but-not-both." ) ; } filterList = null ; if ( f != null ) { filterList = new ArrayList < Query > ( 2 ) ; filterList . add ( f ) ; } return this ; } 
public static double copySign ( double magnitude , double sign ) { long magnitudeBits = Double . doubleToRawLongBits ( magnitude ) ; long signBits = Double . doubleToRawLongBits ( ( sign != sign ) ? 1.0 : sign ) ; magnitudeBits = ( magnitudeBits & ~ Double . SIGN_MASK ) | ( signBits & Double . SIGN_MASK ) ; return Double . longBitsToDouble ( magnitudeBits ) ; } 
final public static double sphericalDistance ( double phi1 , double lambda0 , double phi , double lambda ) { double pdiff = Math . sin ( ( ( phi - phi1 ) / 2.0 ) ) ; double ldiff = Math . sin ( ( lambda - lambda0 ) / 2.0 ) ; double rval = Math . sqrt ( ( pdiff * pdiff ) + Math . cos ( phi1 ) * Math . cos ( phi ) * ( ldiff * ldiff ) ) ; return 2.0 * Math . asin ( rval ) ; } 
public final void writeDouble ( double val ) throws IOException { writeLong ( Double . doubleToLongBits ( val ) ) ; } 
private int getPopupMenuItem ( JPopupMenu menu , String text ) { int index = - 1 ; for ( int i = 0 ; ( index == - 1 ) && ( i < menu . getComponentCount ( ) ) ; i ++ ) { Component comp = menu . getComponent ( i ) ; if ( comp instanceof JMenuItem ) { JMenuItem item = ( JMenuItem ) comp ; if ( text . equals ( item . getText ( ) ) ) { index = i ; } } } return index ; } 
private void writeAttribute ( final java . lang . String prefix , final java . lang . String namespace , final java . lang . String attName , final java . lang . String attValue , final javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public static String getExtension ( String name ) { int i = name . lastIndexOf ( '.' ) ; if ( i == - 1 ) { return "" ; } return name . substring ( i + 1 , name . length ( ) ) ; } 
public static int writeToCache ( Vector avTransCacheData ) { try { if ( ! isCurrentCacheValid ( ) ) { return FAILURE ; } Map laMap = cacheIO ( WRITE , avTransCacheData , null ) ; return ( ( Integer ) laMap . get ( "INT" ) ) . intValue ( ) ; } catch ( RTSException aeRTSEx ) { aeRTSEx . writeExceptionToLog ( ) ; return FAILURE ; } } 
protected void addBooleanAttribute ( String elementName , String attrName , boolean hasDefaultValue , boolean defaultValue ) { List values = new ArrayList ( ) ; values . add ( "TRUE" ) ; values . add ( "FALSE" ) ; String dval = null ; if ( hasDefaultValue ) { dval = defaultValue ? "TRUE" : "FALSE" ; } addAttribute ( elementName , attrName , DATATYPE_BOOLEAN , true , dval , values ) ; } 
public Builder setRecipeApiRequestInitializer ( RecipeApiRequestInitializer recipeapiRequestInitializer ) { return ( Builder ) super . setGoogleClientRequestInitializer ( recipeapiRequestInitializer ) ; } 
public void print ( IndentedWriter writer ) { for ( Iterator < Class < ? >> iter = classes . iterator ( ) ; iter . hasNext ( ) ; ) { Class < ? > c = iter . next ( ) ; String x = Utils . classShortName ( c ) ; fields ( writer , x , c ) ; } } 
public final Thread getFirstQueuedThread ( ) { return ( head == tail ) ? null : fullGetFirstQueuedThread ( ) ; } 
public static String toHexString ( final byte [ ] block , final int columnWidth ) { if ( block == null ) { return "null" ; } final StringBuffer buf = new StringBuffer ( 4 * ( block . length + 2 ) ) ; for ( int i = 0 ; i < block . length ; i ++ ) { if ( i > 0 ) { buf . append ( ':' ) ; if ( i % ( columnWidth / 3 ) == 0 ) { buf . append ( '|n' ) ; } } buf . append ( HEX_LOOKUP [ block [ i ] & 0xff ] ) ; } return buf . toString ( ) ; } 
private void ensureCapacity ( int minCapacity ) { if ( minCapacity - buf . length > 0 ) grow ( minCapacity ) ; } 
public void setBankSerial ( String bankSerial ) { this . bankSerial = bankSerial == null ? null : bankSerial . trim ( ) ; } 
String [ ] getUnsentAcks ( String host , int port ) { synchronized ( unsentAcks ) { Set set = ( Set ) unsentAcks . get ( new ServerKey ( host , port ) ) ; return ( set != null ) ? ( String [ ] ) set . toArray ( new String [ set . size ( ) ] ) : new String [ 0 ] ; } } 
public void quadTo ( float x1 , float y1 , float x2 , float y2 ) { isSimplePath = false ; native_quadTo ( mNativePath , x1 , y1 , x2 , y2 ) ; } 
public static String downloadContent ( String s ) throws IOException { URL url = new URL ( s ) ; Util . log ( "Downloading-content-from-url:-" + url . toString ( ) ) ; InputStream in = url . openStream ( ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( in , Charset . forName ( "UTF-8" ) ) ) ; String textContent = Util . read ( reader ) ; in . close ( ) ; return textContent ; } 
public float measureText ( char [ ] text , int index , int count ) { char [ ] text2 = TextUtils . reshapeArabic ( text , index , index + count ) ; if ( ! mHasCompatScaling ) return native_measureText ( text2 , index , count ) ; final float oldSize = getTextSize ( ) ; setTextSize ( oldSize * mCompatScaling ) ; float w = native_measureText ( text2 , index , count ) ; setTextSize ( oldSize ) ; return w * mInvCompatScaling ; } 
public synchronized Object get ( ) { Object object = peek ( ) ; if ( object != null ) vector . removeElementAt ( 0 ) ; return object ; } 
void cleanup ( ) { mMessages . clear ( ) ; } 
@ XmlElementDecl ( namespace = "http://www.xbrl.org/tw/fr/gaap/tw-gaap-bd-2010-03-31-cr" , name = "OptionTradingGainAbstract" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < StringItemType > createOptionTradingGainAbstract ( StringItemType value ) { return new JAXBElement < StringItemType > ( _OptionTradingGainAbstract_QNAME , StringItemType . class , null , value ) ; } 
public static void execCommand ( HashMap < String , String > input ) throws Exception { String command = input . get ( "command" ) . toString ( ) ; logger . debug ( "execUnixCommand-command:" + command ) ; try { Runtime rt = Runtime . getRuntime ( ) ; rt . exec ( command ) ; } catch ( Exception e ) { logger . error ( "execCommand-return1-:" + e . getMessage ( ) ) ; throw new Exception ( "execCommand-command-error-1!!!:" + command ) ; } } 
public int totalSize ( ) { int total = 0 ; for ( Map . Entry < K , Counter < V >> entry : counterMap . entrySet ( ) ) { Counter < V > counter = entry . getValue ( ) ; total += counter . size ( ) ; } return total ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public ComplexFormat ( String imaginaryCharacter ) throws NullArgumentException , NoDataException { this ( imaginaryCharacter , CompositeFormat . getDefaultNumberFormat ( ) ) ; } 
static public boolean equal ( Date date1 , Date date2 ) { boolean retValue ; if ( date1 == null && date2 == null ) { retValue = true ; } else if ( ( date1 == null && date2 != null ) || ( date1 != null && date2 == null ) ) { retValue = false ; } else { retValue = ( date1 . compareTo ( date2 ) == 0 ) ; } return retValue ; } 
public void execute ( TransformerImpl transformer ) throws TransformerException { int sourceNode = transformer . getXPathContext ( ) . getCurrentNode ( ) ; XObject var = getValue ( transformer , sourceNode ) ; transformer . getXPathContext ( ) . getVarStack ( ) . setLocalVariable ( m_index , var ) ; } 
public String getString ( final String key , final Object ... args ) { String value = getString ( key ) ; if ( value == null ) { value = key ; } MessageFormat mf = new MessageFormat ( value ) ; mf . setLocale ( locale ) ; return mf . format ( args , new StringBuffer ( ) , null ) . toString ( ) ; } 
public static DateTime findFirstDuration ( DateTime date , Period period , DateTime offset ) { DateTime startD = new DateTime ( ) ; DateTime fistPeriod = offset ; while ( fistPeriod . isBefore ( date ) || fistPeriod . isEqual ( date ) ) { fistPeriod = fistPeriod . plus ( period ) ; } fistPeriod = fistPeriod . minus ( period ) ; System . out . println ( "finding-date-in:-" + ( ( new DateTime ( ) ) . getMillis ( ) - startD . getMillis ( ) ) + "ms" ) ; System . out . println ( "first-offset-date:-offset:" + offset + "-for-period:-" + period + "-input-date:-" + date + "-fistPeriod:-" + fistPeriod ) ; return fistPeriod ; } 
public Poller getPoller0 ( ) { int idx = Math . abs ( pollerRotater . incrementAndGet ( ) ) % pollers . length ; return pollers [ idx ] ; } 
static public Object stringToValue ( String s ) { if ( s . equals ( "" ) ) { return s ; } if ( s . equalsIgnoreCase ( "true" ) ) { return Boolean . TRUE ; } if ( s . equalsIgnoreCase ( "false" ) ) { return Boolean . FALSE ; } if ( s . equalsIgnoreCase ( "null" ) ) { return JSONObject . NULL ; } char b = s . charAt ( 0 ) ; if ( ( b >= '0' && b <= '9' ) || b == '.' || b == '-' || b == '+' ) { if ( b == '0' && s . length ( ) > 2 && ( s . charAt ( 1 ) == 'x' || s . charAt ( 1 ) == 'X' ) ) { try { return new Integer ( Integer . parseInt ( s . substring ( 2 ) , 16 ) ) ; } catch ( Exception ignore ) { } } try { if ( s . indexOf ( '.' ) > - 1 || s . indexOf ( 'e' ) > - 1 || s . indexOf ( 'E' ) > - 1 ) { return Double . valueOf ( s ) ; } else { Long myLong = new Long ( s ) ; if ( myLong . longValue ( ) == myLong . intValue ( ) ) { return new Integer ( myLong . intValue ( ) ) ; } else { return myLong ; } } } catch ( Exception ignore ) { } } return s ; } 
public Dimension preferredLayoutSize ( Container parent ) { synchronized ( parent . getTreeLock ( ) ) { Insets insets = parent . getInsets ( ) ; int ncomponents = parent . getComponentCount ( ) ; int nrows = rows ; int ncols = cols ; if ( nrows > 0 ) { ncols = ( ncomponents + nrows - 1 ) / nrows ; } else { nrows = ( ncomponents + ncols - 1 ) / ncols ; } int w = 0 ; int h = 0 ; for ( int i = 0 ; i < ncomponents ; i ++ ) { Component comp = parent . getComponent ( i ) ; Dimension d = comp . getPreferredSize ( ) ; if ( w < d . width ) { w = d . width ; } if ( h < d . height ) { h = d . height ; } } return new Dimension ( insets . left + insets . right + ncols * w + ( ncols - 1 ) * hgap , insets . top + insets . bottom + nrows * h + ( nrows - 1 ) * vgap ) ; } } 
protected void deregisterStatement ( Statement s ) throws ObjectStoreException { Object id = requestId . get ( ) ; if ( id != null ) { synchronized ( cancelRegistry ) { Object statement = cancelRegistry . get ( id ) ; if ( ( statement != BLACKLISTED ) && ( statement != s ) ) { throw new ObjectStoreException ( "The-current-thread-does-not-have-this-statement" + "-registered" ) ; } else if ( statement == s ) { cancelRegistry . remove ( id ) ; } } } } 
public static String getBody ( HttpEntity e ) { LOGGER . entering ( FetcherUtilities . class . getName ( ) , "getBody" , e ) ; StringBuilder sb = null ; try { Reader reader = new BufferedReader ( new InputStreamReader ( e . getContent ( ) ) ) ; sb = new StringBuilder ( ) ; final char [ ] buffer = new char [ 0x10000 ] ; int read = reader . read ( buffer , 0 , buffer . length ) ; while ( read >= 0 ) { if ( read > 0 ) { sb . append ( buffer , 0 , read ) ; } read = reader . read ( buffer , 0 , buffer . length ) ; } } catch ( IOException ex ) { LOGGER . log ( Level . SEVERE , null , ex ) ; } catch ( IllegalStateException ex ) { LOGGER . log ( Level . SEVERE , null , ex ) ; } LOGGER . exiting ( FetcherUtilities . class . getName ( ) , "getBody" , sb . toString ( ) ) ; return sb . toString ( ) ; } 
public final Object getContent ( ) throws java . io . IOException { return openConnection ( ) . getContent ( ) ; } 
public static void setTempCurrentImage ( Thread thread , ImagePlus img ) { if ( thread == null ) throw new RuntimeException ( "thread==null" ) ; if ( img == null ) tempImageTable . remove ( thread ) ; else tempImageTable . put ( thread , img ) ; } 
public int getColorSpaceType ( ) { return csFromSignature ( getIntFromHeader ( icHdrColorSpace ) ) ; } 
public ToStringHelper addValue ( final long value ) { return addHolder ( String . valueOf ( value ) ) ; } 
public Iterable < Integer > pathTo ( int v ) { if ( ! hasPathTo ( v ) ) return null ; Stack < Integer > path = new Stack < Integer > ( ) ; int x ; for ( x = v ; distTo [ x ] != 0 ; x = edgeTo [ x ] ) path . push ( x ) ; path . push ( x ) ; return path ; } 
public UserBindingInfo removeContact ( String url ) { if ( contact_list . containsKey ( url ) ) contact_list . remove ( url ) ; return this ; } 
public void installUI ( JComponent c ) { Iterator iterator = uis . iterator ( ) ; while ( iterator . hasNext ( ) ) { ComponentUI ui = ( ComponentUI ) iterator . next ( ) ; ui . installUI ( c ) ; } } 
protected boolean shouldIncludeHeader ( String name , Object value ) { return ( value instanceof Boolean || value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double || value instanceof String ) && ( ! isNeedJavaIdentifiers ( ) || isJavaIdentifier ( name ) ) ; } 
public BigTextStyle setBigContentTitle ( CharSequence title ) { internalSetBigContentTitle ( title ) ; return this ; } 
public String getGroovyOptions ( ) { return Utils . joinOptions ( m_GroovyOptions ) ; } 
public boolean getSheared ( ) { return ( this . dataWatcher . getWatchableObjectByte ( 16 ) & 16 ) != 0 ; } 
private int getRowCount ( int column ) { if ( column < 0 || column >= columnCount ) { return - 1 ; } if ( layoutOrientation == JList . VERTICAL || ( column == 0 && columnCount == 1 ) ) { return list . getModel ( ) . getSize ( ) ; } if ( column >= columnCount ) { return - 1 ; } if ( layoutOrientation == JList . VERTICAL_WRAP ) { if ( column < ( columnCount - 1 ) ) { return rowsPerColumn ; } return list . getModel ( ) . getSize ( ) - ( columnCount - 1 ) * rowsPerColumn ; } int diff = columnCount - ( columnCount * rowsPerColumn - list . getModel ( ) . getSize ( ) ) ; if ( column >= diff ) { return Math . max ( 0 , rowsPerColumn - 1 ) ; } return rowsPerColumn ; } 
public void clear ( ) { al . clear ( ) ; } 
public boolean isCompatibleWith ( String version ) throws NumberFormatException { String [ ] requested = version . split ( "|." ) ; String [ ] provided = specVersion . split ( "|." ) ; for ( int i = 0 ; i < Math . min ( requested . length , provided . length ) ; i ++ ) { int reqNum = Integer . parseInt ( requested [ i ] ) ; int provNum = Integer . parseInt ( provided [ i ] ) ; if ( reqNum > provNum ) { return false ; } else if ( reqNum < provNum ) { return true ; } } if ( requested . length > provided . length ) { return false ; } return true ; } 
public void playTogether ( Collection < Animator > items ) { if ( items != null && items . size ( ) > 0 ) { mNeedsSort = true ; Builder builder = null ; for ( Animator anim : items ) { if ( builder == null ) { builder = play ( anim ) ; } else { builder . with ( anim ) ; } } } } 
public XMLSignatureInput getReferencedContentBeforeTransformsItem ( int i ) throws XMLSecurityException { return this . item ( i ) . getContentsBeforeTransformation ( ) ; } 
public void update ( byte [ ] b , int off , int len ) { if ( b == null ) { throw new NullPointerException ( ) ; } if ( off < 0 || len < 0 || off > b . length - len ) { throw new ArrayIndexOutOfBoundsException ( ) ; } adler = updateBytes ( adler , b , off , len ) ; } 
protected String resolveSystemProperty ( String key ) { try { String value = System . getProperty ( key ) ; if ( value == null && this . searchSystemEnvironment ) { value = System . getenv ( key ) ; } return value ; } catch ( Throwable ex ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Could-not-access-system-property-'" + key + "':-" + ex ) ; } return null ; } } 
public static boolean isFormEncoded ( String contentType ) { if ( contentType == null ) { return false ; } int semi = contentType . indexOf ( ";" ) ; if ( semi >= 0 ) { contentType = contentType . substring ( 0 , semi ) ; } return OAuthConstants . ContentType . URL_ENCODED . equalsIgnoreCase ( contentType . trim ( ) ) ; } 
public Formula invariants ( ) { final Variable t = Variable . unary ( "t" ) ; final Expression losAtT = lineOfSight . join ( t ) ; final Expression satAtT = satellite . join ( t ) ; final Formula symNonRefl = symmNonRefl ( losAtT ) . and ( symmNonRefl ( satAtT ) ) ; final Formula noSatAndLos = satAtT . intersection ( losAtT ) . no ( ) ; final Variable r1 = Variable . unary ( "r1" ) ; final Variable r2 = Variable . unary ( "r2" ) ; final Expression productUnion = r1 . product ( r2 ) . union ( r2 . product ( r1 ) ) ; final Formula someSatAtT = productUnion . eq ( satAtT ) . forSome ( r1 . oneOf ( Router ) . and ( r2 . oneOf ( Router ) ) ) ; final Formula loneSatAtT = satellite . no ( ) . or ( someSatAtT ) ; return symNonRefl . and ( noSatAndLos ) . and ( loneSatAtT ) . forAll ( t . oneOf ( Time ) ) ; } 
public void refresh ( ) { try { int i = mySlider . getValue ( ) ; if ( i > myMax ) i = myMax ; if ( mySlider . getValue ( ) < myMin ) mySlider . setValue ( myMin ) ; myDisplay . setText ( myText . substring ( myMin , i ) ) ; myLengthDisplay . setText ( "" + ( mySlider . getValue ( ) - myMin ) ) ; repaint ( ) ; } catch ( StringIndexOutOfBoundsException e ) { } } 
public static < R > R executeInDefaultExecutorServiceAndWaitTillReturn ( Callable < R > callable ) throws Throwable { List < Callable < R >> list = new ArrayList < Callable < R >> ( ) ; list . add ( callable ) ; try { List < Future < R >> futures = getDefaultExecutorServiceForScanning ( ) . invokeAll ( list ) ; Future < R > returned = futures . get ( 0 ) ; return returned . get ( ) ; } catch ( Throwable e ) { if ( e instanceof ExecutionException ) { throw ( ( ExecutionException ) e ) . getCause ( ) ; } else { throw e ; } } } 
public synchronized ConnectionInfo getConnectionInfo ( ) throws IOException { synchronized ( state ) { if ( state . tm == null ) throw new IllegalStateException ( "Cannot-get-details-of-connection,-you-need-to-start-the-key-exchange-first." ) ; } return state . tm . getConnectionInfo ( 1 ) ; } 
public void setStatusLine ( String statusLine ) throws IOException { if ( this . responseMessage != null ) { throw new IllegalStateException ( "statusLine-is-already-set" ) ; } boolean hasMessage = statusLine . length ( ) > 13 ; if ( ! statusLine . startsWith ( "HTTP/1." ) || statusLine . length ( ) < 12 || statusLine . charAt ( 8 ) != '-' || ( hasMessage && statusLine . charAt ( 12 ) != '-' ) ) { throw new ProtocolException ( "Unexpected-status-line:-" + statusLine ) ; } int httpMinorVersion = statusLine . charAt ( 7 ) - '0' ; if ( httpMinorVersion < 0 || httpMinorVersion > 9 ) { throw new ProtocolException ( "Unexpected-status-line:-" + statusLine ) ; } int responseCode ; try { responseCode = Integer . parseInt ( statusLine . substring ( 9 , 12 ) ) ; } catch ( NumberFormatException e ) { throw new ProtocolException ( "Unexpected-status-line:-" + statusLine ) ; } this . responseMessage = hasMessage ? statusLine . substring ( 13 ) : "" ; this . responseCode = responseCode ; this . statusLine = statusLine ; this . httpMinorVersion = httpMinorVersion ; } 
private void addReference ( final int sourcePosition , final int referencePosition ) { if ( srcAndRefPositions == null ) { srcAndRefPositions = new int [ 6 ] ; } if ( referenceCount >= srcAndRefPositions . length ) { int [ ] a = new int [ srcAndRefPositions . length + 6 ] ; System . arraycopy ( srcAndRefPositions , 0 , a , 0 , srcAndRefPositions . length ) ; srcAndRefPositions = a ; } srcAndRefPositions [ referenceCount ++ ] = sourcePosition ; srcAndRefPositions [ referenceCount ++ ] = referencePosition ; } 
boolean isExpired ( ReferenceEntry < K , V > entry , long now ) { return now - entry . getExpirationTime ( ) > 0 ; } 
protected int computeGraphicNodeHeight ( int index ) { if ( ( index < 0 ) || ( index >= graphicNodes . size ( ) ) || ( graphicNodes . get ( index ) == null ) ) { return - 1 ; } else { return Math . max ( computeGraphicNodeHeight ( 2 * index + 1 ) , computeGraphicNodeHeight ( 2 * index + 2 ) ) + 1 ; } } 
public SimpleResolver ( String hostname ) throws UnknownHostException { if ( hostname == null ) { hostname = ResolverConfig . getCurrentConfig ( ) . server ( ) ; if ( hostname == null ) hostname = defaultResolver ; } InetAddress addr ; if ( hostname . equals ( "0" ) ) addr = InetAddress . getLocalHost ( ) ; else addr = InetAddress . getByName ( hostname ) ; address = new InetSocketAddress ( addr , DEFAULT_PORT ) ; } 
public Iterator < DiscoverItems . Item > getItems ( ) { synchronized ( items ) { return Collections . unmodifiableList ( items ) . iterator ( ) ; } } 
@ XmlElementDecl ( namespace = "urn:objects.ws.rightnow.com/v1_2" , name = "TypedAddress" ) public JAXBElement < TypedAddress > createTypedAddress ( TypedAddress value ) { return new JAXBElement < TypedAddress > ( _TypedAddress_QNAME , TypedAddress . class , null , value ) ; } 
protected Map < String , String > getParameters ( ) { if ( this . params == null ) { this . params = new HashMap < String , String > ( ) ; } return this . params ; } 
public Map < String , String > readStringMap ( DataInput in ) throws IOException { int propertyCount = in . readInt ( ) ; if ( propertyCount == - 1 ) { return null ; } else { Map < String , String > stringMap = new HashMap < String , String > ( ) ; for ( int i = 0 ; i < propertyCount ; i ++ ) { stringMap . put ( ExternalizableHelper . readSafeUTF ( in ) , ExternalizableHelper . readSafeUTF ( in ) ) ; } return stringMap ; } } 
public boolean isClassname ( String partial ) { return ( partial . replaceAll ( "[a-zA-Z0-9|-|.]*" , "" ) . length ( ) == 0 ) ; } 
public final CertPath generateCertPath ( InputStream inStream , String encoding ) throws CertificateException { return ( certFacSpi . engineGenerateCertPath ( inStream , encoding ) ) ; } 
public static ValueDouble get ( double d ) { if ( d == 1.0 ) { return ONE ; } else if ( d == 0.0 ) { if ( Double . doubleToLongBits ( d ) == ZERO_BITS ) { return ZERO ; } } else if ( Double . isNaN ( d ) ) { return NAN ; } return ( ValueDouble ) Value . cache ( new ValueDouble ( d ) ) ; } 
public static String format ( Date value ) { return STANDARD_DATE_FORMAT . get ( ) . format ( value ) ; } 
public void closeStatements ( ) { try { releasing = true ; try { if ( batchUpdate != null ) { batchUpdate . close ( ) ; } } catch ( SQLException sqle ) { log . warn ( "Could-not-close-a-JDBC-prepared-statement" , sqle ) ; } batchUpdate = null ; batchUpdateSQL = null ; Iterator iter = resultSetsToClose . iterator ( ) ; while ( iter . hasNext ( ) ) { try { logCloseResults ( ) ; ( ( ResultSet ) iter . next ( ) ) . close ( ) ; } catch ( SQLException e ) { log . warn ( "Could-not-close-a-JDBC-result-set" , e ) ; } catch ( ConcurrentModificationException e ) { log . info ( "encountered-CME-attempting-to-release-batcher;-assuming-cause-is-tx-timeout-scenario-and-ignoring" ) ; break ; } catch ( Throwable e ) { log . warn ( "Could-not-close-a-JDBC-result-set" , e ) ; } } resultSetsToClose . clear ( ) ; iter = statementsToClose . iterator ( ) ; while ( iter . hasNext ( ) ) { try { closeQueryStatement ( ( PreparedStatement ) iter . next ( ) ) ; } catch ( ConcurrentModificationException e ) { log . info ( "encountered-CME-attempting-to-release-batcher;-assuming-cause-is-tx-timeout-scenario-and-ignoring" ) ; break ; } catch ( SQLException e ) { log . warn ( "Could-not-close-a-JDBC-statement" , e ) ; } } statementsToClose . clear ( ) ; } finally { releasing = false ; } } 
String read ( File f ) throws IOException { byte [ ] bytes = new byte [ ( int ) f . length ( ) ] ; DataInputStream in = new DataInputStream ( new FileInputStream ( f ) ) ; try { in . readFully ( bytes ) ; } finally { in . close ( ) ; } return new String ( bytes ) ; } 
private final void fireContextChanged ( final ContextEvent event ) { org . simonme . tracer . logger . Tracer . traceMethodInvoke ( event ) ; if ( event == null ) { throw new NullPointerException ( "Cannot-send-a-null-event-to-listeners." ) ; } if ( listeners == null ) { return ; } final Iterator listenerItr = listeners . iterator ( ) ; while ( listenerItr . hasNext ( ) ) { final IContextListener listener = ( IContextListener ) listenerItr . next ( ) ; listener . contextChanged ( event ) ; } } 
private boolean validateDisplayName ( Preference p , Object v ) { if ( v != null && v instanceof String && ! v . equals ( "" ) ) { this . collectionData . put ( DavCollections . DISPLAYNAME , ( String ) v ) ; return true ; } else { return false ; } } 
private boolean childNeedHandleTouchEvent ( View v , MotionEvent event ) { if ( v == null ) return false ; int [ ] loc = new int [ 2 ] ; v . getLocationOnScreen ( loc ) ; int left = loc [ 0 ] , top = loc [ 1 ] ; if ( event . getRawX ( ) > left && event . getRawX ( ) < left + v . getWidth ( ) && event . getRawY ( ) > top && event . getRawY ( ) < top + v . getHeight ( ) ) { return v . onTouchEvent ( event ) ; } return false ; } 
protected String getAuthorizationCodeString ( byte [ ] verifierBytes ) { char [ ] chars = new char [ verifierBytes . length ] ; for ( int i = 0 ; i < verifierBytes . length ; i ++ ) { chars [ i ] = DEFAULT_CODEC [ ( ( verifierBytes [ i ] & 0xFF ) % DEFAULT_CODEC . length ) ] ; } return new String ( chars ) ; } 
public Color getBackground ( ) { return table . getBackground ( ) ; } 
private String getPreviousTokenMapping ( String token , boolean hasNewMapping ) { String result = new String ( "" ) ; int scope = replacedTokens . size ( ) - 1 ; if ( scope < 0 ) { return result ; } if ( hasNewMapping ) { Map tokens = ( Map ) ( replacedTokens . get ( scope ) ) ; if ( tokens . containsKey ( token ) ) { result = ( String ) tokens . get ( token ) ; return result ; } } else { for ( int i = scope ; i > - 1 ; i -- ) { Map tokens = ( Map ) ( replacedTokens . get ( i ) ) ; if ( tokens . containsKey ( token ) ) { result = ( String ) tokens . get ( token ) ; return result ; } } } return result ; } 
public final void interrupt ( ) { synchronized ( threadRefs ) { for ( Thread thread : threads ) { thread . interrupt ( ) ; } } synchronized ( groups ) { for ( ThreadGroup group : groups ) { group . interrupt ( ) ; } } } 
public static String getUTCDate ( Date date ) { return ( ( SimpleDateFormat ) UTC_DATE_FORMAT_OBJECT . get ( ) ) . format ( date ) ; } 
MysqlSavepoint ( String name , ExceptionInterceptor exceptionInterceptor ) throws SQLException { if ( name == null || name . length ( ) == 0 ) { throw SQLError . createSQLException ( "Savepoint-name-can-not-be-NULL-or-empty" , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , exceptionInterceptor ) ; } this . savepointName = name ; this . exceptionInterceptor = exceptionInterceptor ; } 
public void insert_typecode ( TypeCode _0 ) throws TypeMismatch , InvalidValue { throw new MARSHAL ( _DynAnyStub . NOT_APPLICABLE ) ; } 
public Color cellColor ( ) { return new Color ( 0xFC1100 ) ; } 
public static TickUnitSource createStandardDateTickUnits ( ) { return createStandardDateTickUnits ( TimeZone . getDefault ( ) , Locale . getDefault ( ) ) ; } 
private List parseEmoticons ( String emoticons ) { List list = new ArrayList ( ) ; StringTokenizer tok = new StringTokenizer ( emoticons , "-,;-" ) ; while ( tok . hasMoreTokens ( ) ) { list . add ( tok . nextToken ( ) ) ; } return list ; } 
public static MouseEvent toAwtMouseEvent ( org . eclipse . swt . events . MouseEvent event ) { int button = MouseEvent . NOBUTTON ; switch ( event . button ) { case 1 : button = MouseEvent . BUTTON1 ; break ; case 2 : button = MouseEvent . BUTTON2 ; break ; case 3 : button = MouseEvent . BUTTON3 ; break ; } int modifiers = 0 ; if ( ( event . stateMask & SWT . CTRL ) != 0 ) { modifiers |= InputEvent . CTRL_DOWN_MASK ; } if ( ( event . stateMask & SWT . SHIFT ) != 0 ) { modifiers |= InputEvent . SHIFT_DOWN_MASK ; } if ( ( event . stateMask & SWT . ALT ) != 0 ) { modifiers |= InputEvent . ALT_DOWN_MASK ; } MouseEvent awtMouseEvent = new MouseEvent ( DUMMY_PANEL , event . hashCode ( ) , event . time , modifiers , event . x , event . y , 1 , false , button ) ; return awtMouseEvent ; } 
private synchronized void setState ( int state ) { if ( D ) Log . d ( TAG , "setState()-" + mState + "-->-" + state ) ; mState = state ; mHandler . obtainMessage ( BluetoothChat . MESSAGE_STATE_CHANGE , state , - 1 ) . sendToTarget ( ) ; } 
public void setDateAttributes ( String value ) { m_dateAttributes . setRanges ( value ) ; } 
public Iterator < Attribute > iterator ( ) { return entry . iterator ( ) ; } 
public void setNumberFormat ( String numberFormat ) { NullArgumentException . check ( "numberFormat" , numberFormat ) ; this . numberFormat = numberFormat ; properties . setProperty ( NUMBER_FORMAT_KEY , numberFormat ) ; } 
public synchronized void removeListener ( TestListener listener ) { fListeners . removeElement ( listener ) ; } 
public void setColumnScrolling ( boolean columnScrolling ) { checkWidget ( ) ; if ( rowHeaderVisible && ! columnScrolling ) { return ; } this . columnScrolling = columnScrolling ; scrollValuesObsolete = true ; redraw ( ) ; } 
public static void write ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) write ( s . charAt ( i ) ) ; } 
@ RolesAllowed ( "user" ) @ Transactional ( readOnly = true ) public Long countSpecifiedAnnotations ( @ NotNull Class type , Set < String > include , Set < String > exclude , Parameters options ) { List list = getAnnotation ( type , include , exclude , options ) ; if ( list != null ) return new Long ( list . size ( ) ) ; return - 1L ; } 
public JVar [ ] listParams ( ) { return params . toArray ( new JVar [ params . size ( ) ] ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public void setClasspath ( Path src ) { if ( classpath == null ) { classpath = src ; } else { classpath . append ( src ) ; } } 
@ Override public boolean containsAttribute ( final String propertyName ) { return attributes . containsKey ( propertyName ) ; } 
public void moveLeadSelectionIndex ( int leadIndex ) { if ( leadIndex == - 1 ) { if ( this . anchorIndex != - 1 ) { return ; } } updateLeadAnchorIndices ( this . anchorIndex , leadIndex ) ; fireValueChanged ( ) ; } 
private String mapDistCacheFilePath ( String file , String timeStamp , boolean isPublic , String user ) { String id = file + timeStamp ; if ( ! isPublic ) { id = id . concat ( user ) ; } return new Path ( distCachePath , MD5Hash . digest ( id ) . toString ( ) ) . toUri ( ) . getPath ( ) ; } 
public static boolean makeAdvisorChainAspectJCapableIfNecessary ( List < Advisor > advisors ) { if ( ! advisors . isEmpty ( ) ) { boolean foundAspectJAdvice = false ; for ( Advisor advisor : advisors ) { if ( isAspectJAdvice ( advisor ) ) { foundAspectJAdvice = true ; } } if ( foundAspectJAdvice && ! advisors . contains ( ExposeInvocationInterceptor . ADVISOR ) ) { advisors . add ( 0 , ExposeInvocationInterceptor . ADVISOR ) ; return true ; } } return false ; } 
public static String nullStrToEmpty ( Object str ) { return ( str == null ? "" : ( str instanceof String ? ( String ) str : str . toString ( ) ) ) ; } 
public void setText ( String text ) { ( ( JTextField ) swingComponent . getJComponent ( ) ) . setText ( text ) ; } 
private void erzeugeMedienAnzeiger ( ) { JScrollPane medienAnzeigerScrollPane = new JScrollPane ( ) ; medienAnzeigerScrollPane . setPreferredSize ( new Dimension ( - 1 , 160 ) ) ; medienAnzeigerScrollPane . setSize ( - 1 , - 1 ) ; medienAnzeigerScrollPane . setBorder ( BorderFactory . createTitledBorder ( null , "AusgewÃ¤hlte-Medien" , TitledBorder . LEADING , TitledBorder . DEFAULT_POSITION , UIConstants . HEADER_FONT ) ) ; medienAnzeigerScrollPane . setBackground ( UIConstants . BACKGROUND_COLOR ) ; medienAnzeigerScrollPane . getVerticalScrollBar ( ) . setBackground ( UIConstants . BACKGROUND_COLOR ) ; medienAnzeigerScrollPane . getHorizontalScrollBar ( ) . setBackground ( UIConstants . BACKGROUND_COLOR ) ; _medienAnzeigerTextArea = new JTextArea ( ) ; _medienAnzeigerTextArea . setBackground ( UIConstants . BACKGROUND_COLOR ) ; medienAnzeigerScrollPane . setViewportView ( _medienAnzeigerTextArea ) ; _medienAnzeigerTextArea . setEditable ( false ) ; _medienAnzeigerTextArea . setFont ( UIConstants . TEXT_FONT ) ; _hauptPanel . add ( medienAnzeigerScrollPane , BorderLayout . CENTER ) ; } 
public long toDays ( long duration ) { throw new AbstractMethodError ( ) ; } 
@ Deprecated public static void publishInstallAsync ( final Context context , final String applicationId , final Request . Callback callback ) { final Context applicationContext = context . getApplicationContext ( ) ; Settings . getExecutor ( ) . execute ( new Runnable ( ) { @ Override public void run ( ) { final Response response = Settings . publishInstallAndWaitForResponse ( applicationContext , applicationId ) ; if ( callback != null ) { Handler handler = new Handler ( Looper . getMainLooper ( ) ) ; handler . post ( new Runnable ( ) { @ Override public void run ( ) { callback . onCompleted ( response ) ; } } ) ; } } } ) ; } 
static Method findMethod ( Class cls , String methodName , int argCount ) { return findMethod ( cls , methodName , argCount , null ) ; } 
public int read ( byte [ ] b , int off , int len ) { if ( b == null ) { throw new NullPointerException ( ) ; } if ( ( off < 0 ) || ( len < 0 ) || ( off + len > b . length ) ) { throw new IndexOutOfBoundsException ( ) ; } if ( len == 0 ) { return 0 ; } int oldPointer = pointer ; pointer = Math . min ( pointer + len , length + offset ) ; if ( pointer == oldPointer ) { return - 1 ; } else { System . arraycopy ( src , oldPointer , b , off , pointer - oldPointer ) ; return pointer - oldPointer ; } } 
@ Override public int hashCode ( ) { return Objects . hash ( hash ) ; } 
String transformName ( String className ) { String newName = mRenameClasses . get ( className ) ; if ( newName != null ) { return newName ; } int pos = className . indexOf ( '$' ) ; if ( pos > 0 ) { String base = className . substring ( 0 , pos ) ; newName = mRenameClasses . get ( base ) ; if ( newName != null ) { return newName + className . substring ( pos ) ; } } return className ; } 
private JMenuItem getMnuExportPDFGraphics ( ) { if ( mnuExportPDFGraphics == null ) { mnuExportPDFGraphics = new JMenuItem ( ) ; mnuExportPDFGraphics . setActionCommand ( "PDF-(using-ps2pdf)..." ) ; mnuExportPDFGraphics . setText ( "PDF-(using-ps2pdf)..." ) ; mnuExportPDFGraphics . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent e ) { exportPDFGraphics ( ) ; } } ) ; } return mnuExportPDFGraphics ; } 
public void flip ( int index ) { if ( index < 0 ) { checkIndex ( index ) ; } int arrayIndex = index / 64 ; if ( arrayIndex >= bits . length ) { ensureCapacity ( arrayIndex + 1 ) ; } bits [ arrayIndex ] ^= ( 1L << index ) ; longCount = Math . max ( longCount , arrayIndex + 1 ) ; shrinkSize ( ) ; } 
public < T extends EventListener > T [ ] getListeners ( Class < T > listenerType ) { EventListener l = null ; if ( listenerType == ContainerListener . class ) { l = containerListener ; } else { return super . getListeners ( listenerType ) ; } return AWTEventMulticaster . getListeners ( l , listenerType ) ; } 
protected boolean haveOption ( String optName ) { return allOptions . contains ( optName ) ; } 
public Enumeration listOptions ( ) { Vector newVector = new Vector ( 4 ) ; newVector . addElement ( new Option ( "-Specify-shrinkage-rate.-" + "(default-=-1.0,-ie.-no-shrinkage)-" , "S" , 1 , "-S" ) ) ; Enumeration enu = super . listOptions ( ) ; while ( enu . hasMoreElements ( ) ) { newVector . addElement ( enu . nextElement ( ) ) ; } return newVector . elements ( ) ; } 
private static KeyStore loadKeystore ( InputStream keyStream , String passphrase , String keystoreFormat ) throws GeneralSecurityException , IOException { final KeyStore ks = KeyStore . getInstance ( keystoreFormat ) ; if ( passphrase != null ) { final char [ ] passChars = passphrase . toCharArray ( ) ; try { ks . load ( keyStream , passChars ) ; } finally { Arrays . fill ( passChars , ( char ) 0 ) ; } } else { ks . load ( keyStream , null ) ; } return ks ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public Object get ( String key ) { return attributes . get ( key ) ; } 
static void setArchiveTimestamps ( Configuration conf , String timestamps ) { conf . set ( MRJobConfig . CACHE_ARCHIVES_TIMESTAMPS , timestamps ) ; } 
public static boolean isVariable ( String expression ) { final int len = expression == null ? 0 : expression . length ( ) ; return len > 2 && expression . charAt ( 0 ) == '{' && expression . charAt ( len - 1 ) == '}' ; } 
public static void main ( String [ ] argv ) { try { int seed = 42 ; if ( argv . length > 0 ) { seed = Integer . parseInt ( argv [ 0 ] ) ; } NNConditionalEstimator newEst = new NNConditionalEstimator ( ) ; Random r = new Random ( seed ) ; int numPoints = 50 ; if ( argv . length > 2 ) { numPoints = Integer . parseInt ( argv [ 2 ] ) ; } for ( int i = 0 ; i < numPoints ; i ++ ) { int x = Math . abs ( r . nextInt ( ) % 100 ) ; int y = Math . abs ( r . nextInt ( ) % 100 ) ; System . out . println ( "#-" + x + "-" + y ) ; newEst . addValue ( x , y , 1 ) ; } int cond ; if ( argv . length > 1 ) { cond = Integer . parseInt ( argv [ 1 ] ) ; } else cond = Math . abs ( r . nextInt ( ) % 100 ) ; System . out . println ( "##-Conditional-=-" + cond ) ; Estimator result = newEst . getEstimator ( cond ) ; for ( int i = 0 ; i <= 100 ; i += 5 ) { System . out . println ( "-" + i + "-" + result . getProbability ( i ) ) ; } } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } } 
@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( "<role-rolename="" ) ; sb . append ( rolename ) ; sb . append ( """ ) ; if ( description != null ) { sb . append ( "-description="" ) ; sb . append ( description ) ; sb . append ( """ ) ; } sb . append ( "/>" ) ; return ( sb . toString ( ) ) ; } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; if ( localLaunchPermissionTracker ) { elementList . add ( new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2010-11-15/" , "launchPermission" ) ) ; if ( localLaunchPermission == null ) { throw new org . apache . axis2 . databinding . ADBException ( "launchPermission-cannot-be-null!!" ) ; } elementList . add ( localLaunchPermission ) ; } if ( localProductCodesTracker ) { elementList . add ( new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2010-11-15/" , "productCodes" ) ) ; if ( localProductCodes == null ) { throw new org . apache . axis2 . databinding . ADBException ( "productCodes-cannot-be-null!!" ) ; } elementList . add ( localProductCodes ) ; } if ( localDescriptionTracker ) { elementList . add ( new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2010-11-15/" , "description" ) ) ; if ( localDescription == null ) { throw new org . apache . axis2 . databinding . ADBException ( "description-cannot-be-null!!" ) ; } elementList . add ( localDescription ) ; } return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
public void setInitialValue ( Object newInitialValue ) { Object oldIV = initialValue ; initialValue = newInitialValue ; firePropertyChange ( INITIAL_VALUE_PROPERTY , oldIV , initialValue ) ; } 
public Iterator findMemberGroups ( IEntityGroup group ) throws GroupsException { java . sql . Connection conn = null ; Collection groups = new ArrayList ( ) ; IEntityGroup eg = null ; String serviceName = group . getServiceName ( ) . toString ( ) ; String localKey = group . getLocalKey ( ) ; try { conn = RDBMServices . getConnection ( ) ; String sql = getFindMemberGroupsSql ( ) ; PreparedStatement ps = conn . prepareStatement ( sql ) ; try { ps . setString ( 1 , localKey ) ; ps . setString ( 2 , serviceName ) ; if ( log . isDebugEnabled ( ) ) log . debug ( "RDBMEntityGroupStore.findMemberGroups():-" + ps + "-(" + localKey + ",-" + serviceName + ")" ) ; java . sql . ResultSet rs = ps . executeQuery ( ) ; try { while ( rs . next ( ) ) { eg = instanceFromResultSet ( rs ) ; groups . add ( eg ) ; } } finally { rs . close ( ) ; } } finally { ps . close ( ) ; } } catch ( Exception sqle ) { log . error ( "RDBMEntityGroupStore.findMemberGroups():-" + sqle ) ; throw new GroupsException ( "Problem-retrieving-member-groups:-" + sqle ) ; } finally { RDBMServices . releaseConnection ( conn ) ; } return groups . iterator ( ) ; } 
public int preceding ( int offset ) { CharacterIterator text = getText ( ) ; checkOffset ( offset , text ) ; text . setIndex ( offset ) ; return previous ( ) ; } 
public static String toUpperCase ( CharSequence chars ) { if ( chars instanceof String ) { return toUpperCase ( ( String ) chars ) ; } int length = chars . length ( ) ; StringBuilder builder = new StringBuilder ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { builder . append ( toUpperCase ( chars . charAt ( i ) ) ) ; } return builder . toString ( ) ; } 
public static CodonState getState ( String code ) { code = code . toUpperCase ( ) . replace ( 'U' , 'T' ) ; return statesByCode . get ( code ) ; } 
public boolean isEmpty ( ) { return extOrdering . isEmpty ( ) ; } 
public int getSessionCreateRate ( ) { long now = System . currentTimeMillis ( ) ; List < SessionTiming > copy = new ArrayList < SessionTiming > ( ) ; synchronized ( sessionCreationTiming ) { copy . addAll ( sessionCreationTiming ) ; } long oldest = now ; int counter = 0 ; int result = 0 ; Iterator < SessionTiming > iter = copy . iterator ( ) ; while ( iter . hasNext ( ) ) { SessionTiming timing = iter . next ( ) ; if ( timing != null ) { counter ++ ; if ( timing . getTimestamp ( ) < oldest ) { oldest = timing . getTimestamp ( ) ; } } } if ( counter > 0 ) { if ( oldest < now ) { result = ( int ) ( ( 1000 * 60 * counter ) / ( now - oldest ) ) ; } else { result = Integer . MAX_VALUE ; } } return result ; } 
StreamHandler ( OutputStream os ) { this ( ) ; this . os = os ; } 
public void setCellBroadcastSmsConfig ( int [ ] configValuesArray , Message response ) { Log . e ( LOG_TAG , "[CDMAPhone]-setCellBroadcastSmsConfig()-is-obsolete;-use-SmsManager" ) ; response . sendToTarget ( ) ; } 
public void setSystemId ( File f ) { this . systemId = f . toURI ( ) . toASCIIString ( ) ; } 
private String decodeString ( String in ) throws Exception { byte [ ] out = Base64 . decode ( in , 0 ) ; return new String ( out ) ; } 
public void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; BufferedImage image = new BufferedImage ( getWidth ( ) / myScale , getHeight ( ) / myScale , BufferedImage . TYPE_INT_RGB ) ; Graphics gr = image . getGraphics ( ) ; drawRealPicture ( gr ) ; g . drawImage ( image , 0 , 0 , image . getWidth ( ) * myScale , image . getHeight ( ) * myScale , null ) ; } 
public void close ( ) throws IOException { if ( dataFile != null ) dataFile . close ( ) ; dataFile = null ; super . close ( ) ; } 
void callHierarchyViewActivated ( CallHierarchyViewPart view ) { fLRUCallHierarchyViews . remove ( view ) ; fLRUCallHierarchyViews . add ( 0 , view ) ; } 
void unsetMaxRows ( Statement stmt ) throws SQLException { synchronized ( this . mutex ) { if ( this . statementsUsingMaxRows != null ) { Object found = this . statementsUsingMaxRows . remove ( stmt ) ; if ( ( found != null ) && ( this . statementsUsingMaxRows . size ( ) == 0 ) ) { execSQL ( "SET-OPTION-SQL_SELECT_LIMIT=DEFAULT" , - 1 , this . database ) ; this . maxRowsChanged = false ; } } } } 
public boolean awaitNewPublisher ( long timeout , TimeUnit unit ) throws InterruptedException { return newPublisherLatch . await ( timeout , unit ) ; } 
public static String toBinaryString ( long i ) { return toUnsignedString0 ( i , 1 ) ; } 
public void fireIndexedPropertyChange ( String propertyName , int index , Object oldValue , Object newValue ) { firePropertyChange ( new IndexedPropertyChangeEvent ( sourceBean , propertyName , oldValue , newValue , index ) ) ; } 
private void startIfReady ( Animator dependencyAnimation ) { if ( mAnimatorSet . mTerminated ) { return ; } Dependency dependencyToRemove = null ; int numDependencies = mNode . tmpDependencies . size ( ) ; for ( int i = 0 ; i < numDependencies ; ++ i ) { Dependency dependency = mNode . tmpDependencies . get ( i ) ; if ( dependency . rule == mRule && dependency . node . animation == dependencyAnimation ) { dependencyToRemove = dependency ; dependencyAnimation . removeListener ( this ) ; break ; } } mNode . tmpDependencies . remove ( dependencyToRemove ) ; if ( mNode . tmpDependencies . size ( ) == 0 ) { mNode . animation . start ( ) ; mAnimatorSet . mPlayingSet . add ( mNode . animation ) ; } } 
public int size ( ) { return delegate . size ( ) ; } 
private boolean handlePost ( URI uri , String mime , InputStream source , Callback callback ) { HttpURLConnection connection = null ; try { URL url = new URL ( _any23Endpoint + "/nquads" ) ; connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setRequestMethod ( "POST" ) ; connection . setDoOutput ( true ) ; connection . setRequestProperty ( "Content-Type" , mime ) ; OutputStream outputStream = connection . getOutputStream ( ) ; byte [ ] buffer = new byte [ 128 ] ; while ( true ) { int c = source . read ( buffer ) ; if ( c != - 1 ) outputStream . write ( buffer , 0 , c ) ; else break ; } outputStream . close ( ) ; return _responseHandler . handle ( uri , "text/x-nquads" , connection . getInputStream ( ) , callback ) ; } catch ( IOException e ) { _log . log ( Level . WARNING , "Could-not-issue-request-to-any23-for-" + uri , e ) ; return false ; } finally { if ( connection != null ) { connection . disconnect ( ) ; } } } 
public int declaringClassIndexFromMethodIndex ( int methodIndex ) { checkBounds ( methodIndex , tableOfContents . methodIds . size ) ; int position = tableOfContents . methodIds . off + ( SizeOf . MEMBER_ID_ITEM * methodIndex ) ; return data . getShort ( position ) & 0xFFFF ; } 
public List < HierarchicalRequirement > getHierarchicalRequirement ( ) { if ( hierarchicalRequirement == null ) { hierarchicalRequirement = new ArrayList < HierarchicalRequirement > ( ) ; } return this . hierarchicalRequirement ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; javax . xml . namespace . NamespaceContext nsContext = xmlWriter . getNamespaceContext ( ) ; while ( true ) { java . lang . String uri = nsContext . getNamespaceURI ( prefix ) ; if ( uri == null || uri . length ( ) == 0 ) { break ; } prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public deleteAllRowTs_args setRow ( byte [ ] row ) { setRow ( row == null ? ( ByteBuffer ) null : ByteBuffer . wrap ( row ) ) ; return this ; } 
public void accept ( final AnnotationVisitor av ) { if ( av != null ) { if ( values != null ) { for ( int i = 0 ; i < values . size ( ) ; i += 2 ) { String name = ( String ) values . get ( i ) ; Object value = values . get ( i + 1 ) ; accept ( av , name , value ) ; } } av . visitEnd ( ) ; } } 
protected DragSourceContext createDragSourceContext ( DragSourceContextPeer dscp , DragGestureEvent dgl , Cursor dragCursor , Image dragImage , Point imageOffset , Transferable t , DragSourceListener dsl ) { return new DragSourceContext ( dscp , dgl , dragCursor , dragImage , imageOffset , t , dsl ) ; } 
public static String getPropertyName ( Method setter ) { return Introspector . decapitalize ( setter . getName ( ) . substring ( 3 ) ) ; } 
public static String repeat ( String str , int repeat ) { StringBuilder buffer = new StringBuilder ( repeat * str . length ( ) ) ; for ( int i = 0 ; i < repeat ; i ++ ) { buffer . append ( str ) ; } return buffer . toString ( ) ; } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; if ( localItem != null ) { for ( int i = 0 ; i < localItem . length ; i ++ ) { if ( localItem [ i ] != null ) { elementList . add ( new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2010-11-15/" , "item" ) ) ; elementList . add ( localItem [ i ] ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "item-cannot-be-null-!!" ) ; } } } else { throw new org . apache . axis2 . databinding . ADBException ( "item-cannot-be-null!!" ) ; } return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
public static Node selectSingleNode ( Node contextNode , String str , Node namespaceNode ) throws TransformerException { NodeIterator nl = selectNodeIterator ( contextNode , str , namespaceNode ) ; return nl . nextNode ( ) ; } 
public List < SmsRawData > getAllMessagesFromIccEf3GPP2 ( ) { mContext . enforceCallingPermission ( "android.permission.RECEIVE_SMS" , "Reading-messages-from-SIM" ) ; if ( DBG ) log ( "getAllMessagesFromIccEf3GPP2()" ) ; synchronized ( mLock ) { IccFileHandler fh = mPhone . getIccFileHandler ( ) ; if ( fh == null ) { LGSmsLog . e ( "getAllMessagesFromIccEf3GPP2(),-Cannot-load-Sms-records.-No-icc-card?" ) ; if ( mSms != null ) { mSms . clear ( ) ; } return mSms ; } else { Message response = mHandler . obtainMessage ( EVENT_LOAD_DONE ) ; fh . loadEFLinearFixedAll ( IccConstants . EF_SMS , response ) ; try { mLock . wait ( ) ; } catch ( InterruptedException e ) { log ( "interrupted-while-trying-to-load-from-the-UIcc" ) ; } } return mSms ; } } 
public static String getTempDirectoryPath ( Context ctx ) { File cache = null ; if ( Environment . getExternalStorageState ( ) . equals ( Environment . MEDIA_MOUNTED ) ) { cache = new File ( Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) + "/Android/data/" + ctx . getPackageName ( ) + "/cache/" ) ; } else { cache = ctx . getCacheDir ( ) ; } if ( ! cache . exists ( ) ) { cache . mkdirs ( ) ; } return cache . getAbsolutePath ( ) ; } 
public Enumeration listOptions ( ) { Vector newVector = new Vector ( 4 ) ; newVector . addElement ( new Option ( "-Specify-list-of-columns-to-transform.-First-and-last-are-" + "-valid-indexes-(default-none).-Non-numeric-columns-are-" + "-skipped." , "R" , 1 , "-R-<index1,index2-index4,...>" ) ) ; newVector . addElement ( new Option ( "-Invert-matching-sense." , "V" , 0 , "-V" ) ) ; newVector . addElement ( new Option ( "-Sets-the-class-containing-transformation-method.-" + "-(default-java.lang.Math)" , "C" , 1 , "-C-<string>" ) ) ; newVector . addElement ( new Option ( "-Sets-the-method.-(default-abs)" , "M" , 1 , "-M-<string>" ) ) ; return newVector . elements ( ) ; } 
public boolean applyOptions ( ) throws IOException { final String save = _saveField . getText ( ) ; Set newDirs = new HashSet ( ) ; if ( ! save . equals ( _saveDirectory ) ) { try { File saveDir = new File ( save ) ; if ( ! saveDir . isDirectory ( ) ) { if ( ! saveDir . mkdirs ( ) ) throw new IOException ( ) ; } if ( ! _shareData . isGoingToBeShared ( saveDir ) ) newDirs . add ( saveDir ) ; SharingSettings . setSaveDirectory ( saveDir ) ; _saveDirectory = save ; } catch ( IOException ioe ) { GUIMediator . showError ( "ERROR_INVALID_SAVE_DIRECTORY" ) ; _saveField . setText ( _saveDirectory ) ; throw new IOException ( ) ; } catch ( NullPointerException npe ) { GUIMediator . showError ( "ERROR_INVALID_SAVE_DIRECTORY" ) ; _saveField . setText ( _saveDirectory ) ; throw new IOException ( ) ; } } boolean restart = _mtddMediator . applyOptions ( newDirs ) ; if ( ! newDirs . isEmpty ( ) ) { String format = "" ; for ( Iterator i = newDirs . iterator ( ) ; i . hasNext ( ) ; ) format += GUIUtils . convertToNonBreakingSpaces ( 4 , i . next ( ) . toString ( ) ) + "-" ; int response = GUIMediator . showYesNoMessage ( "OPTIONS_SHARED_NEW_SAVE_FOLDERS" , format ) ; if ( response == GUIMediator . YES_OPTION ) { for ( Iterator i = newDirs . iterator ( ) ; i . hasNext ( ) ; ) _shareData . addAndKeepDirtyStatus ( ( File ) i . next ( ) ) ; } } return restart ; } 
public static String [ ] getFaces ( File f ) { ArrayList surfaceData = readSurfaceFile ( f ) ; int numOfVertices = Integer . parseInt ( ( String ) surfaceData . get ( 4 ) ) ; int numOfFaces = Integer . parseInt ( ( String ) surfaceData . get ( 5 ) ) ; int verticesStartIndex = 6 ; int verticesEndIndex = ( verticesStartIndex + ( numOfVertices * 3 ) - 1 ) ; int facesStartIndex = verticesEndIndex + 1 ; int facesEndIndex = ( facesStartIndex + ( numOfFaces * 3 ) - 1 ) ; String [ ] faces = new String [ numOfFaces ] ; for ( int i = facesStartIndex ; i <= facesEndIndex ; i += 3 ) { faces [ i / 3 ] = surfaceData . get ( i ) + "-" + surfaceData . get ( i + 1 ) + "-" + surfaceData . get ( i + 2 ) ; } return faces ; } 
public static ResourceBundle getBundle ( String bundleName ) throws MissingResourceException { ClassLoader classLoader = VMStack . getCallingClassLoader ( ) ; if ( classLoader == null ) { classLoader = getLoader ( ) ; } return getBundle ( bundleName , Locale . getDefault ( ) , classLoader ) ; } 
private String getName ( Object object ) throws Throwable { if ( FONT_CLASS . equals ( object . getClass ( ) . getName ( ) ) ) { if ( fontClass == null || fontDataClass == null ) { searchFontClass ( ) ; } if ( fontClass != null && fontDataClass != null ) { return getFontName ( object ) ; } } else if ( COLOR_CLASS . equals ( object . getClass ( ) . getName ( ) ) ) { if ( colorClass == null ) { searchColorClass ( ) ; } if ( colorClass != null ) { return getColorName ( object ) ; } } return object . getClass ( ) . getSimpleName ( ) + "-{hashCode=" + System . identityHashCode ( object ) + "}" ; } 
protected Expression union ( int opPos ) throws TransformerException { locPathDepth ++ ; try { return UnionPathIterator . createUnionIterator ( this , opPos ) ; } finally { locPathDepth -- ; } } 
private void initEntityMenu ( ) { entitiesMenu = new JMenu ( "Entities" ) ; } 
private Proxy nextProxy ( ) { if ( userSpecifiedProxy != null ) { hasNextProxy = false ; return userSpecifiedProxy ; } if ( proxySelectorProxies != null ) { while ( proxySelectorProxies . hasNext ( ) ) { Proxy candidate = proxySelectorProxies . next ( ) ; if ( candidate . type ( ) != Proxy . Type . DIRECT ) { return candidate ; } } } hasNextProxy = false ; return Proxy . NO_PROXY ; } 
public static void switchOffConsole ( ) { original = new PrintStream ( System . out ) ; try { System . setOut ( new PrintStream ( new FileOutputStream ( "NUL:" ) ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } 
public String getAlertDateStringLongYear ( ) { String tmp = "" ; try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( DateFormat . LONG ) ; formatter . applyPattern ( "M/d/yyyy" ) ; return formatter . format ( dueDate ) ; } catch ( NullPointerException e ) { } return tmp ; } 
static void setNextPartition ( int newValue ) { cache . set ( newValue ) ; } 
public static String [ ] getNames ( Object object ) { if ( object == null ) { return null ; } Class klass = object . getClass ( ) ; Field [ ] fields = klass . getFields ( ) ; int length = fields . length ; if ( length == 0 ) { return null ; } String [ ] names = new String [ length ] ; for ( int i = 0 ; i < length ; i += 1 ) { names [ i ] = fields [ i ] . getName ( ) ; } return names ; } 
public void setTimestamp ( int parameterIndex , java . sql . Timestamp x , Calendar cal ) throws SQLException { setTimestampInternal ( parameterIndex , x , cal , cal . getTimeZone ( ) , true ) ; } 
public static Remote register ( ActivationDesc desc ) throws UnknownGroupException , ActivationException , RemoteException { ActivationID id = ActivationGroup . getSystem ( ) . registerObject ( desc ) ; return sun . rmi . server . ActivatableRef . getStub ( desc , id ) ; } 
public void updateProfileAddTopic ( String owner ) throws Exception { SessionProvider sProvider = SessionProvider . createSystemProvider ( ) ; try { Node profileHomeNode = getUserProfileHome ( sProvider ) ; if ( profileHomeNode . hasNode ( owner ) ) { Node profileNode = profileHomeNode . getNode ( owner ) ; long totalTopicByUser = profileNode . getProperty ( EXO_TOTAL_TOPIC ) . getLong ( ) ; profileNode . setProperty ( EXO_TOTAL_TOPIC , totalTopicByUser + 1 ) ; } else if ( Utils . isEmpty ( owner ) == false ) { Node newProfileNode = profileHomeNode . addNode ( owner , EXO_FORUM_USER_PROFILE ) ; newProfileNode . setProperty ( EXO_USER_ID , owner ) ; newProfileNode . setProperty ( EXO_USER_TITLE , Utils . USER ) ; if ( isAdminRole ( sProvider , owner ) ) { newProfileNode . setProperty ( EXO_USER_TITLE , Utils . ADMIN ) ; } newProfileNode . setProperty ( EXO_TOTAL_TOPIC , 1 ) ; } profileHomeNode . getSession ( ) . save ( ) ; } catch ( Exception e ) { LOG . warn ( "Failed-to-update-user-profile-when-add-topic" , e ) ; } finally { sProvider . close ( ) ; } } 
public Map < Integer , AionConnection > getLoggedInAccounts ( ) { return Collections . unmodifiableMap ( loggedInAccounts ) ; } 
public boolean isSpecified ( String uri , String localName ) { int index = getIndex ( uri , localName ) ; if ( index < 0 ) throw new IllegalArgumentException ( "No-such-attribute:-local=" + localName + ",-namespace=" + uri ) ; return specified [ index ] ; } 
public static void setActionProperties ( int action , String name , Integer mnemonic , KeyStroke accelerator ) { Action tempAction = null ; switch ( action ) { case CUT_ACTION : tempAction = cutAction ; break ; case COPY_ACTION : tempAction = copyAction ; break ; case PASTE_ACTION : tempAction = pasteAction ; break ; case DELETE_ACTION : tempAction = deleteAction ; break ; case SELECT_ALL_ACTION : tempAction = selectAllAction ; break ; case UNDO_ACTION : case REDO_ACTION : default : return ; } tempAction . putValue ( Action . NAME , name ) ; tempAction . putValue ( Action . SHORT_DESCRIPTION , name ) ; tempAction . putValue ( Action . ACCELERATOR_KEY , accelerator ) ; tempAction . putValue ( Action . MNEMONIC_KEY , mnemonic ) ; } 
public Set < Object > getEdgeLabels ( Object from , Object to ) { return edgeLabels . get ( Pair . make ( from , to ) ) ; } 
public static Location locationFor ( final String name ) { if ( locations . isEmpty ( ) ) { for ( Location location : values ( ) ) locations . putIfAbsent ( location . getName ( ) , location ) ; } locations . putIfAbsent ( name . toString ( ) , new Location ( ) { public String getName ( ) { return name ; } public boolean isOutputLocation ( ) { return name . endsWith ( "_OUTPUT" ) ; } } ) ; return locations . get ( name ) ; } 
public static boolean referenceToBoolean ( Object obj ) { if ( obj instanceof Boolean ) { return ( ( Boolean ) obj ) . booleanValue ( ) ; } else { final String className = obj . getClass ( ) . getName ( ) ; runTimeError ( DATA_CONVERSION_ERR , className , Boolean . TYPE ) ; return false ; } } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public static void println ( ) { out . println ( ) ; } 
public void setMinimumSize ( Dimension minSize ) { support . firePropertyChange ( "minimumSize" , this . minSize , minSize ) ; this . minSize = minSize ; } 
public static boolean moveToAppropriateTrash ( FileSystem fs , Path p , Configuration conf ) throws IOException { Path fullyResolvedPath = fs . resolvePath ( p ) ; FileSystem fullyResolvedFs = FileSystem . get ( fullyResolvedPath . toUri ( ) , conf ) ; try { long trashInterval = fullyResolvedFs . getServerDefaults ( fullyResolvedPath ) . getTrashInterval ( ) ; if ( 0 != trashInterval ) { Configuration confCopy = new Configuration ( conf ) ; confCopy . setLong ( CommonConfigurationKeysPublic . FS_TRASH_INTERVAL_KEY , trashInterval ) ; conf = confCopy ; } } catch ( Exception e ) { LOG . warn ( "Failed-to-get-server-trash-configuration" , e ) ; throw new IOException ( "Failed-to-get-server-trash-configuration" , e ) ; } Trash trash = new Trash ( fullyResolvedFs , conf ) ; boolean success = trash . moveToTrash ( fullyResolvedPath ) ; if ( success ) { System . out . println ( "Moved:-'" + p + "'-to-trash-at:-" + trash . getCurrentTrashDir ( ) ) ; } return success ; } 
public static int countDots ( final String s ) { int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '.' ) { count ++ ; } } return count ; } 
public void parent ( String name , String parentName ) { ElementType child = getElementType ( name ) ; ElementType parent = getElementType ( parentName ) ; if ( child == null ) { throw new Error ( "No-child-" + name + "-for-parent-" + parentName ) ; } if ( parent == null ) { throw new Error ( "No-parent-" + parentName + "-for-child-" + name ) ; } child . setParent ( parent ) ; } 
private String multiplyString ( String str , int times ) { StringBuilder result = new StringBuilder ( ) ; for ( int i = 0 ; i < times ; i ++ ) result . append ( str ) ; return result . toString ( ) ; } 
public static AffineTransform getRotateInstance ( double vecx , double vecy ) { AffineTransform Tx = new AffineTransform ( ) ; Tx . setToRotation ( vecx , vecy ) ; return Tx ; } 
public static void setEnabledRecursively ( Container c , boolean enabled ) { for ( Component child : c . getComponents ( ) ) { if ( child instanceof Container ) setEnabledRecursively ( ( Container ) child , enabled ) ; else child . setEnabled ( enabled ) ; } c . setEnabled ( enabled ) ; } 
public String toString ( ) { StringBuilder buffer = new StringBuilder ( 800 ) ; buffer . append ( getClass ( ) . getName ( ) ) . append ( '[' ) ; appendValue ( buffer , "time" , isTimeSet , time ) ; buffer . append ( ",areFieldsSet=" ) . append ( areFieldsSet ) ; buffer . append ( ",areAllFieldsSet=" ) . append ( areAllFieldsSet ) ; buffer . append ( ",lenient=" ) . append ( lenient ) ; buffer . append ( ",zone=" ) . append ( zone ) ; appendValue ( buffer , ",firstDayOfWeek" , true , ( long ) firstDayOfWeek ) ; appendValue ( buffer , ",minimalDaysInFirstWeek" , true , ( long ) minimalDaysInFirstWeek ) ; for ( int i = 0 ; i < FIELD_COUNT ; ++ i ) { buffer . append ( ',' ) ; appendValue ( buffer , FIELD_NAME [ i ] , isSet ( i ) , ( long ) fields [ i ] ) ; } buffer . append ( ']' ) ; return buffer . toString ( ) ; } 
public void setBaseOrigBranchName ( String baseOrigBranchName ) { this . baseOrigBranchName = baseOrigBranchName == null ? null : baseOrigBranchName . trim ( ) ; } 
private static byte [ ] streamToBytes ( InputStream in , int length ) throws IOException { byte [ ] bytes = new byte [ length ] ; int count ; int pos = 0 ; while ( pos < length && ( ( count = in . read ( bytes , pos , length - pos ) ) != - 1 ) ) { pos += count ; } if ( pos != length ) { throw new IOException ( "Expected-" + length + "-bytes,-read-" + pos + "-bytes" ) ; } return bytes ; } 
public static EntityConfig getEntityConfig ( ) throws GenericEntityConfException { EntityConfig instance = configRef . get ( ) ; if ( instance == null ) { Element entityConfigElement = getXmlDocument ( ) . getDocumentElement ( ) ; instance = new EntityConfig ( entityConfigElement ) ; if ( ! configRef . compareAndSet ( null , instance ) ) { instance = configRef . get ( ) ; } } return instance ; } 
public List < POCDMT000040Reference > getReference ( ) { if ( reference == null ) { reference = new ArrayList < POCDMT000040Reference > ( ) ; } return this . reference ; } 
public Request build ( ) { return new RequestImpl ( mBuilder , mAllocations , new ResponseListenerBroadcaster ( new ArrayList < > ( mResponseListeners ) ) ) ; } 
public int getDisplayColor ( ) { return ( name . hashCode ( ) & 0xaaaaaa ) + 0x444444 ; } 
public final Array < JsDate > minutes ( final JsDate start , final JsDate stop , final double step ) { return minute ( ) . range ( start , stop , step ) ; } 
public String getStubName ( String fullName ) { return Utility . stubName ( fullName ) ; } 
private void processSingleWayAreas ( ) { AREA : for ( OSMWay way : singleWayAreas ) { if ( processedAreas . contains ( way ) ) { continue ; } for ( Long nodeRef : way . getNodeRefs ( ) ) { if ( ! nodesById . containsKey ( nodeRef ) ) { continue AREA ; } } try { newArea ( new Area ( way , Arrays . asList ( way ) , Collections . < OSMWay > emptyList ( ) , nodesById ) ) ; } catch ( Area . AreaConstructionException e ) { } catch ( IllegalArgumentException iae ) { } processedAreas . add ( way ) ; } } 
public boolean hasCorrectHeight ( ) { if ( this == sentinel ) return true ; return Math . max ( this . getRight ( ) . height , this . getLeft ( ) . height ) + 1 == this . height ; } 
public void warning ( SourcePosition pos , String key , String a1 , String a2 , String a3 , String a4 ) { printWarning ( pos , getText ( key , a1 , a2 , a3 , a4 ) ) ; } 
public int getDepth ( ) { if ( ( ! allowsChildren ) || children . size ( ) == 0 ) return 0 ; Stack < Integer > stack = new Stack < Integer > ( ) ; stack . push ( new Integer ( 0 ) ) ; TreeNode node = getChildAt ( 0 ) ; int depth = 0 ; int current = 1 ; while ( ! stack . empty ( ) ) { if ( node . getChildCount ( ) != 0 ) { node = node . getChildAt ( 0 ) ; stack . push ( new Integer ( 0 ) ) ; current ++ ; } else { if ( current > depth ) depth = current ; int size ; int index ; do { node = node . getParent ( ) ; size = node . getChildCount ( ) ; index = stack . pop ( ) . intValue ( ) + 1 ; current -- ; } while ( index >= size && node != this ) ; if ( index < size ) { node = node . getChildAt ( index ) ; stack . push ( new Integer ( index ) ) ; current ++ ; } } } return depth ; } 
public static void lpt ( StringBuffer t ) { lpt ( t . toString ( ) ) ; } 
public Extension getExtensionByOID ( String oid ) { if ( extensions == null ) { return null ; } HashMap < String , Extension > localOidMap = oidMap ; if ( localOidMap == null ) { localOidMap = new HashMap < String , Extension > ( ) ; for ( Extension extension : extensions ) { localOidMap . put ( extension . getExtnID ( ) , extension ) ; } this . oidMap = localOidMap ; } return localOidMap . get ( oid ) ; } 
public static void runJavadoc ( String [ ] javadocArgs ) { if ( com . sun . tools . javadoc . Main . execute ( javadocArgs ) != 0 ) { throw new Error ( "Javadoc-failed-to-execute" ) ; } } 
public String getSentBy ( ) { SipParser par = new SipParser ( value ) ; par . goTo ( '/' ) . skipChar ( ) . goTo ( '/' ) . skipString ( ) . skipWSP ( ) ; if ( ! par . hasMore ( ) ) return null ; String sentby = value . substring ( par . getPos ( ) , par . indexOfSeparator ( ) ) ; return sentby ; } 
public static String encodeBytes ( byte [ ] source , int options ) { return encodeBytes ( source , 0 , source . length , options ) ; } 
public void updateUI ( ) { setUI ( ( ButtonUI ) UIManager . getUI ( this ) ) ; } 
public String findWithinHorizon ( Pattern pattern , int horizon ) { ensureOpen ( ) ; if ( pattern == null ) throw new NullPointerException ( ) ; if ( horizon < 0 ) throw new IllegalArgumentException ( "horizon-<-0" ) ; clearCaches ( ) ; while ( true ) { String token = findPatternInBuffer ( pattern , horizon ) ; if ( token != null ) { matchValid = true ; return token ; } if ( needInput ) readInput ( ) ; else break ; } return null ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public String GetImage ( ) { if ( bufpos >= tokenBegin ) return new String ( buffer , tokenBegin , bufpos - tokenBegin + 1 ) ; else return new String ( buffer , tokenBegin , bufsize - tokenBegin ) + new String ( buffer , 0 , bufpos + 1 ) ; } 
public void receiveEvent ( InputEvent event ) { this . dispatchInputEvent ( event ) ; } 
@ Override public int hashCode ( ) { HashCode hash = new HashCode ( ) ; hash . append ( width ) ; hash . append ( height ) ; return hash . hashCode ( ) ; } 
public static void closeAll ( Closeable a , Closeable b ) throws IOException { Throwable thrown = null ; try { a . close ( ) ; } catch ( Throwable e ) { thrown = e ; } try { b . close ( ) ; } catch ( Throwable e ) { if ( thrown == null ) thrown = e ; } if ( thrown == null ) return ; if ( thrown instanceof IOException ) throw ( IOException ) thrown ; if ( thrown instanceof RuntimeException ) throw ( RuntimeException ) thrown ; if ( thrown instanceof Error ) throw ( Error ) thrown ; throw new AssertionError ( thrown ) ; } 
public int getSize ( ) { return fElements . size ( ) ; } 
public void setIdent ( String ident ) { String xpath = basePath ; List list = this . selectNodes ( xpath ) ; if ( list . size ( ) > 0 ) { Element element = ( Element ) list . get ( 0 ) ; element . setAttribute ( identity , ident ) ; } } 
@ XmlElementDecl ( namespace = "http://www.xbrl.org/tw/fr/gaap/tw-gaap-ins-2010-03-31-cr" , name = "ReserveOperationsLiabilities" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < MonetaryItemType > createReserveOperationsLiabilities ( MonetaryItemType value ) { return new JAXBElement < MonetaryItemType > ( _ReserveOperationsLiabilities_QNAME , MonetaryItemType . class , null , value ) ; } 
public void setReshowDelay ( int milliseconds ) { exitTimer . setInitialDelay ( milliseconds ) ; } 
public static CreateInternetGateway parse ( javax . xml . stream . XMLStreamReader reader ) throws java . lang . Exception { CreateInternetGateway object = new CreateInternetGateway ( ) ; int event ; java . lang . String nillableValue = null ; java . lang . String prefix = "" ; java . lang . String namespaceuri = "" ; try { while ( ! reader . isStartElement ( ) && ! reader . isEndElement ( ) ) reader . next ( ) ; java . util . Vector handledAttributes = new java . util . Vector ( ) ; while ( ! reader . isEndElement ( ) ) { if ( reader . isStartElement ( ) ) { if ( reader . isStartElement ( ) && new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2012-08-15/" , "CreateInternetGateway" ) . equals ( reader . getName ( ) ) ) { object . setCreateInternetGateway ( com . amazon . ec2 . CreateInternetGatewayType . Factory . parse ( reader ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "Unexpected-subelement-" + reader . getLocalName ( ) ) ; } } else { reader . next ( ) ; } } } catch ( javax . xml . stream . XMLStreamException e ) { throw new java . lang . Exception ( e ) ; } return object ; } 
public void removePropertyChangeListener ( PropertyChangeListener pcl ) { m_pcSupport . removePropertyChangeListener ( pcl ) ; } 
private static int doParseTrieToBuilder ( List < CharSequence > stack , CharSequence encoded , ImmutableMap . Builder < String , PublicSuffixType > builder ) { int encodedLen = encoded . length ( ) ; int idx = 0 ; char c = '|0' ; for ( ; idx < encodedLen ; idx ++ ) { c = encoded . charAt ( idx ) ; if ( c == '&' || c == '?' || c == '!' || c == ':' || c == ',' ) { break ; } } stack . add ( 0 , reverse ( encoded . subSequence ( 0 , idx ) ) ) ; if ( c == '!' || c == '?' || c == ':' || c == ',' ) { String domain = PREFIX_JOINER . join ( stack ) ; if ( domain . length ( ) > 0 ) { builder . put ( domain , PublicSuffixType . fromCode ( c ) ) ; } } idx ++ ; if ( c != '?' && c != ',' ) { while ( idx < encodedLen ) { idx += doParseTrieToBuilder ( stack , encoded . subSequence ( idx , encodedLen ) , builder ) ; if ( encoded . charAt ( idx ) == '?' || encoded . charAt ( idx ) == ',' ) { idx ++ ; break ; } } } stack . remove ( 0 ) ; return idx ; } 
public int readLine ( Text str ) throws IOException { return readLine ( str , Integer . MAX_VALUE , Integer . MAX_VALUE ) ; } 
public static DBData resolveDB ( InputStream is ) throws Exception { Stack loadStack = new Stack ( ) ; ArrayList loadList = new ArrayList ( ) ; return resolveDB ( is , loadStack , loadList ) ; } 
public void setRowCount ( int rowCount ) { mVerticalAxis . setCount ( rowCount ) ; invalidateStructure ( ) ; requestLayout ( ) ; } 
public final TextImpl minimize ( ) { if ( getLength ( ) == 0 ) { parent . removeChild ( this ) ; return null ; } Node previous = getPreviousSibling ( ) ; if ( previous == null || previous . getNodeType ( ) != Node . TEXT_NODE ) { return this ; } TextImpl previousText = ( TextImpl ) previous ; previousText . buffer . append ( buffer ) ; parent . removeChild ( this ) ; return previousText ; } 
public void paint ( Graphics2D g2D , Rectangle paintArea , WMSMapContent mapContent ) throws MalformedURLException , ClassCastException , IOException { BufferedImage logo = getLogo ( ) ; if ( logo != null ) { Composite oldComposite = g2D . getComposite ( ) ; g2D . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , opacity ) ) ; AffineTransform tx = AffineTransform . getTranslateInstance ( paintArea . getX ( ) , paintArea . getY ( ) ) ; tx . scale ( paintArea . getWidth ( ) / logo . getWidth ( ) , paintArea . getHeight ( ) / logo . getHeight ( ) ) ; g2D . drawImage ( logo , tx , null ) ; g2D . setComposite ( oldComposite ) ; } } 
private ArrayList < Account > getAcceptableAccountChoices ( AccountManager accountManager ) { final Account [ ] accounts = accountManager . getAccounts ( ) ; ArrayList < Account > accountsToPopulate = new ArrayList < Account > ( accounts . length ) ; for ( Account account : accounts ) { if ( mSetOfAllowableAccounts != null && ! mSetOfAllowableAccounts . contains ( account ) ) { continue ; } if ( mSetOfRelevantAccountTypes != null && ! mSetOfRelevantAccountTypes . contains ( account . type ) ) { continue ; } accountsToPopulate . add ( account ) ; } return accountsToPopulate ; } 
protected final Object replaceObject ( Object obj ) throws IOException { try { if ( ( obj instanceof java . rmi . Remote ) && ! ( StubAdapter . isStub ( obj ) ) ) { return Utility . autoConnect ( obj , orb , true ) ; } } catch ( Exception e ) { IOException ie = new IOException ( "replaceObject-failed" ) ; ie . initCause ( e ) ; throw ie ; } return obj ; } 
public static boolean sync ( FileOutputStream stream ) { try { if ( stream != null ) { stream . getFD ( ) . sync ( ) ; } return true ; } catch ( IOException e ) { } return false ; } 
protected void assertLongTermMean ( RandomSeries series , final int numberOfSamples , final double expectedLongTermMean ) { final Mean mean = new Mean ( ) ; for ( int i = 0 ; i < numberOfSamples ; ++ i ) mean . increment ( series . next ( ) ) ; Assert . assertEquals ( mean . getResult ( ) , expectedLongTermMean , 1.e-2 ) ; } 
public void showTip ( String tipText , Point pt ) { if ( getRootPane ( ) == null ) return ; if ( glassPane == null ) { getRootPane ( ) . setGlassPane ( glassPane = new JPanel ( ) ) ; glassPane . setOpaque ( false ) ; glassPane . setLayout ( null ) ; glassPane . add ( tip = new JToolTip ( ) ) ; tipTimer = new Timer ( TIP_DELAY , new ActionListener ( ) { public void actionPerformed ( ActionEvent evt ) { glassPane . setVisible ( false ) ; } } ) ; tipTimer . setRepeats ( false ) ; } if ( tipText == null ) return ; tip . setTipText ( tipText ) ; tip . setLocation ( SwingUtilities . convertPoint ( this , pt , glassPane ) ) ; tip . setSize ( tip . getPreferredSize ( ) ) ; glassPane . setVisible ( true ) ; glassPane . repaint ( ) ; tipTimer . restart ( ) ; } 
@ SuppressWarnings ( "unchecked" ) public void restore ( String fileName ) throws IOException , ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream ( new FileInputStream ( fileName ) ) ; map = ( Map ) ois . readObject ( ) ; ois . close ( ) ; initializeLocations ( ) ; locked = true ; fireStateChanged ( ) ; } 
private void growByOne ( ) { int adding = 0 ; if ( capacityIncrement <= 0 ) { if ( ( adding = elementData . length ) == 0 ) { adding = 1 ; } } else { adding = capacityIncrement ; } E [ ] newData = newElementArray ( elementData . length + adding ) ; System . arraycopy ( elementData , 0 , newData , 0 , elementCount ) ; elementData = newData ; } 
public boolean batchLogin ( ) { return batchLogin ( new java . sql . Timestamp ( System . currentTimeMillis ( ) ) ) ; } 
private byte [ ] readBlockData ( ) throws IOException { byte [ ] result = new byte [ input . readByte ( ) & 0xff ] ; input . readFully ( result ) ; return result ; } 
public String [ ] getWeekdays ( ) { return weekdays . clone ( ) ; } 
public String toString ( ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( Constants . INDENT ) ; buffer . append ( "ulEffectiveBits:-" ) ; buffer . append ( ulEffectiveBits ) ; buffer . append ( Constants . NEWLINE ) ; buffer . append ( Constants . INDENT ) ; buffer . append ( "ulEffectiveBits:-" ) ; buffer . append ( ulEffectiveBits ) ; return buffer . toString ( ) ; } 
public List < String > getNames ( ) { if ( names == null ) { names = new ArrayList < String > ( ) ; } return this . names ; } 
protected String trimString ( String s , int length ) { if ( ( length > 0 ) && ( s . length ( ) > length ) ) { return s . substring ( 0 , length ) ; } else { return s ; } } 
public boolean replaceIn ( StrBuilder source ) { if ( source == null ) { return false ; } return substitute ( source , 0 , source . length ( ) ) ; } 
public Vector decodeEvents ( final String document ) { if ( document != null ) { if ( document . equals ( "" ) ) { return null ; } String newDoc ; String newPartialEvent = null ; if ( document . lastIndexOf ( RECORD_END ) == - 1 ) { partialEvent = partialEvent + document ; return null ; } if ( document . lastIndexOf ( RECORD_END ) + RECORD_END . length ( ) < document . length ( ) ) { newDoc = document . substring ( 0 , document . lastIndexOf ( RECORD_END ) + RECORD_END . length ( ) ) ; newPartialEvent = document . substring ( document . lastIndexOf ( RECORD_END ) + RECORD_END . length ( ) ) ; } else { newDoc = document ; } if ( partialEvent != null ) { newDoc = partialEvent + newDoc ; } partialEvent = newPartialEvent ; Document doc = parse ( newDoc ) ; if ( doc == null ) { return null ; } return decodeEvents ( doc ) ; } return null ; } 
public final boolean hasDataPath ( String data ) { if ( mDataPaths == null ) { return false ; } final int numDataPaths = mDataPaths . size ( ) ; for ( int i = 0 ; i < numDataPaths ; i ++ ) { final PatternMatcher pe = mDataPaths . get ( i ) ; if ( pe . match ( data ) ) { return true ; } } return false ; } 
public static String getUrlOverview ( Context context ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( context . getString ( R . string . usaid_server_url ) ) ; sb . append ( context . getString ( R . string . usaid_server_overview ) ) ; sb . append ( context . getString ( R . string . usaid_server_flag ) ) ; return sb . toString ( ) ; } 
public void setGroupSearchFilter ( String groupSearchFilter ) { this . groupSearchFilter = groupSearchFilter ; properties . put ( "ldap.groupSearchFilter" , groupSearchFilter ) ; } 
private void mergeForceCollapse ( ) { while ( stackSize > 1 ) { int n = stackSize - 2 ; if ( n > 0 && runLen [ n - 1 ] < runLen [ n + 1 ] ) n -- ; mergeAt ( n ) ; } } 
public long getLastModified ( ) { if ( isReference ( ) ) { return ( ( Resource ) getCheckedRef ( ) ) . getLastModified ( ) ; } if ( ! isExists ( ) || lastmodified == null ) { return UNKNOWN_DATETIME ; } long result = lastmodified . longValue ( ) ; return result < UNKNOWN_DATETIME ? UNKNOWN_DATETIME : result ; } 
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { uid = ( UID ) in . readObject ( ) ; try { Class < ? extends RemoteRef > refClass = Class . forName ( RemoteRef . packagePrefix + "." + in . readUTF ( ) ) . asSubclass ( RemoteRef . class ) ; RemoteRef ref = refClass . newInstance ( ) ; ref . readExternal ( in ) ; activator = ( Activator ) Proxy . newProxyInstance ( null , new Class < ? > [ ] { Activator . class } , new RemoteObjectInvocationHandler ( ref ) ) ; } catch ( InstantiationException e ) { throw ( IOException ) new InvalidObjectException ( "Unable-to-create-remote-reference" ) . initCause ( e ) ; } catch ( IllegalAccessException e ) { throw ( IOException ) new InvalidObjectException ( "Unable-to-create-remote-reference" ) . initCause ( e ) ; } } 
public void finalize ( ) { end ( ) ; } 
@ Override public boolean connectionAllowed ( EventSetDescriptor esd ) { return connectionAllowed ( esd . getName ( ) ) ; } 
protected static PreparedStatement getInstance ( MySQLConnection conn , String sql , String catalog ) throws SQLException { if ( ! Util . isJdbc4 ( ) ) { return new PreparedStatement ( conn , sql , catalog ) ; } return ( PreparedStatement ) Util . handleNewInstance ( JDBC_4_PSTMT_3_ARG_CTOR , new Object [ ] { conn , sql , catalog } , conn . getExceptionInterceptor ( ) ) ; } 
protected void setQName ( String uri , String prefix , String localname ) { _qname = new QName ( uri , prefix , localname ) ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; javax . xml . namespace . NamespaceContext nsContext = xmlWriter . getNamespaceContext ( ) ; while ( true ) { java . lang . String uri = nsContext . getNamespaceURI ( prefix ) ; if ( uri == null || uri . length ( ) == 0 ) { break ; } prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public static DescribeVolumeAttributesGroup parse ( javax . xml . stream . XMLStreamReader reader ) throws java . lang . Exception { DescribeVolumeAttributesGroup object = new DescribeVolumeAttributesGroup ( ) ; int event ; java . lang . String nillableValue = null ; java . lang . String prefix = "" ; java . lang . String namespaceuri = "" ; try { while ( ! reader . isStartElement ( ) && ! reader . isEndElement ( ) ) reader . next ( ) ; java . util . Vector handledAttributes = new java . util . Vector ( ) ; if ( reader . isStartElement ( ) && new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2012-08-15/" , "autoEnableIO" ) . equals ( reader . getName ( ) ) ) { object . setAutoEnableIO ( com . amazon . ec2 . EmptyElementType . Factory . parse ( reader ) ) ; reader . next ( ) ; } else if ( reader . isStartElement ( ) && new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2012-08-15/" , "productCodes" ) . equals ( reader . getName ( ) ) ) { object . setProductCodes ( com . amazon . ec2 . EmptyElementType . Factory . parse ( reader ) ) ; reader . next ( ) ; } } catch ( javax . xml . stream . XMLStreamException e ) { throw new java . lang . Exception ( e ) ; } return object ; } 
public static String sql ( int value ) { return Integer . toString ( value ) ; } 
private int tokenSizeOfString ( String str ) { StringTokenizer tokens = new StringTokenizer ( str , this . delimiter ) ; return tokens . countTokens ( ) ; } 
protected final Token lookahead ( int index ) throws ScanException , ParseException { if ( lookahead . isEmpty ( ) ) { lookahead = new LinkedList < LookaheadToken > ( ) ; } while ( index >= lookahead . size ( ) ) { lookahead . add ( new LookaheadToken ( scanner . next ( ) , scanner . getPosition ( ) ) ) ; } return lookahead . get ( index ) . token ; } 
public void setOperatoruserid ( String operatoruserid ) { this . operatoruserid = operatoruserid == null ? null : operatoruserid . trim ( ) ; } 
protected void bindWithTableMeta ( ) { if ( meta == null ) return ; registrationRequired = meta . isRegistrationRequired ( ) ; meta . registerEntryFactory ( this ) ; } 
public boolean domainMatch ( String host , String domain ) { boolean match = host . equals ( domain ) || ( domain . startsWith ( "." ) && host . endsWith ( domain ) ) ; return match ; } 
public void setVastexpenseReason ( String vastexpenseReason ) { this . vastexpenseReason = vastexpenseReason == null ? null : vastexpenseReason . trim ( ) ; } 
public static br . com . produban . openbus . model . avro . CommElement . Builder newBuilder ( ) { return new br . com . produban . openbus . model . avro . CommElement . Builder ( ) ; } 
public static boolean isIdentifierIgnorable ( char c ) { return ( c <= 8 ) || ( c >= 0xe && c <= 0x1b ) || ( c >= 0x7f && c <= 0x9f ) || getType ( c ) == FORMAT ; } 
public void removeAttribute ( int index ) { if ( index >= 0 && index < length ) { if ( index < length - 1 ) { System . arraycopy ( data , ( index + 1 ) * 5 , data , index * 5 , ( length - index - 1 ) * 5 ) ; } length -- ; } else { badIndex ( index ) ; } } 
public static Type getReturnType ( final String methodDescriptor ) { char [ ] buf = methodDescriptor . toCharArray ( ) ; return getType ( buf , methodDescriptor . indexOf ( ')' ) + 1 ) ; } 
protected String integralPrintName ( long n ) { if ( - MaxIntegral <= n && n <= MaxIntegral ) { return String . valueOf ( n ) ; } Long l = new Long ( n ) ; String name = ( String ) integralPrintNames . get ( l ) ; if ( name != null ) { return name ; } if ( n == - n ) { name = "neg" + String . valueOf ( n ) . substring ( 1 ) ; } else if ( n < 0 ) { name = "neg" + String . valueOf ( - n ) ; } else { name = "pos" + String . valueOf ( n ) ; } integralPrintNames . put ( l , name ) ; return name ; } 
public static String readAsciiLine ( InputStream in ) throws IOException { StringBuilder result = new StringBuilder ( 80 ) ; while ( true ) { int c = in . read ( ) ; if ( c == - 1 ) { throw new EOFException ( ) ; } else if ( c == '|n' ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > 0 && result . charAt ( length - 1 ) == '|r' ) { result . setLength ( length - 1 ) ; } return result . toString ( ) ; } 
public void setReuseAddress ( boolean reuse ) throws SocketException { checkOpenAndCreate ( true ) ; impl . setOption ( SocketOptions . SO_REUSEADDR , Boolean . valueOf ( reuse ) ) ; } 
public boolean containsNull ( ) { for ( Iterator ii = entrySet ( ) . iterator ( ) ; ii . hasNext ( ) ; ) { Map . Entry e = ( Map . Entry ) ii . next ( ) ; if ( e . getValue ( ) == null ) return true ; } return false ; } 
public int read ( byte [ ] buf , int off , int len ) throws IOException { ensureOpen ( ) ; if ( eos ) { return - 1 ; } int n = super . read ( buf , off , len ) ; if ( n == - 1 ) { if ( readTrailer ( ) ) eos = true ; else return this . read ( buf , off , len ) ; } else { crc . update ( buf , off , n ) ; } return n ; } 
public static boolean isIsomorphic ( String w1 , String w2 ) { if ( w1 == null || w2 == null ) { return false ; } if ( w1 . length ( ) != w2 . length ( ) ) { return false ; } if ( w1 . equals ( w2 ) ) { return true ; } HashMap < Character , Character > map1 = new HashMap < Character , Character > ( ) ; for ( int i = 0 ; i < w1 . length ( ) ; i ++ ) { char c = w1 . charAt ( i ) ; if ( ! map1 . containsKey ( c ) ) { } } return true ; } 
public Card getCardByValue ( int value ) { Iterator < Card > scan = inHand . iterator ( ) ; while ( scan . hasNext ( ) ) { Card chkCard = scan . next ( ) ; if ( chkCard . getValue ( ) == value ) return chkCard ; } return null ; } 
public void setInputStream ( DataInputStream in ) { this . in = in ; if ( in . markSupported ( ) ) { in . mark ( Integer . MAX_VALUE ) ; hasMark = true ; } } 
public void addObj ( SpaceObj obj ) { synchronized ( objectsCache ) { objectsCache . add ( obj ) ; objectsCache . notify ( ) ; } } 
public void flagActionItems ( ) { if ( ! mIsActionItemsStale ) { return ; } boolean flagged = false ; for ( WeakReference < MenuPresenter > ref : mPresenters ) { final MenuPresenter presenter = ref . get ( ) ; if ( presenter == null ) { mPresenters . remove ( ref ) ; } else { flagged |= presenter . flagActionItems ( ) ; } } if ( flagged ) { mActionItems . clear ( ) ; mNonActionItems . clear ( ) ; ArrayList < MenuItemImpl > visibleItems = getVisibleItems ( ) ; final int itemsSize = visibleItems . size ( ) ; for ( int i = 0 ; i < itemsSize ; i ++ ) { MenuItemImpl item = visibleItems . get ( i ) ; if ( item . isActionButton ( ) ) { mActionItems . add ( item ) ; } else { mNonActionItems . add ( item ) ; } } } else { mActionItems . clear ( ) ; mNonActionItems . clear ( ) ; mNonActionItems . addAll ( getVisibleItems ( ) ) ; } mIsActionItemsStale = false ; } 
public boolean isAllSpace ( ) { boolean isAllSpace = true ; for ( int i = 0 ; i < text . length ( ) ; i ++ ) { if ( ! Character . isWhitespace ( text . charAt ( i ) ) ) { isAllSpace = false ; break ; } } return isAllSpace ; } 
public synchronized void addMessageChangedListener ( MessageChangedListener l ) { if ( messageChangedListeners == null ) messageChangedListeners = new Vector ( ) ; messageChangedListeners . addElement ( l ) ; } 
public BigDecimal getBigDecimalFromDB ( ResultSet arsRS , String asColumn ) throws RTSException { BigDecimal laResult = null ; try { laResult = arsRS . getBigDecimal ( asColumn ) ; } catch ( SQLException aeSQLEx ) { throw new RTSException ( RTSException . DB_ERROR , aeSQLEx ) ; } return laResult ; } 
public List < java . lang . Object > getPOrH1OrH2 ( ) { if ( pOrH1OrH2 == null ) { pOrH1OrH2 = new ArrayList < java . lang . Object > ( ) ; } return this . pOrH1OrH2 ; } 
public boolean existsDialog ( long id ) { return dialogs . containsKey ( id ) ; } 
private static void generateShortAndLongWeekdaysIfNeeded ( ) { if ( sShortWeekdays != null && sLongWeekdays != null && ! localeHasChanged ( ) ) { return ; } if ( sShortWeekdays == null ) { sShortWeekdays = new String [ DaysOfWeek . DAYS_IN_A_WEEK ] ; } if ( sLongWeekdays == null ) { sLongWeekdays = new String [ DaysOfWeek . DAYS_IN_A_WEEK ] ; } final SimpleDateFormat shortFormat = new SimpleDateFormat ( DATE_FORMAT_SHORT ) ; final SimpleDateFormat longFormat = new SimpleDateFormat ( DATE_FORMAT_LONG ) ; final long aSunday = new GregorianCalendar ( 2014 , Calendar . JULY , 20 ) . getTimeInMillis ( ) ; for ( int i = 0 ; i < DaysOfWeek . DAYS_IN_A_WEEK ; i ++ ) { final long dayMillis = aSunday + i * DateUtils . DAY_IN_MILLIS ; sShortWeekdays [ i ] = shortFormat . format ( new Date ( dayMillis ) ) ; sLongWeekdays [ i ] = longFormat . format ( new Date ( dayMillis ) ) ; } sLocaleUsedForWeekdays = Locale . getDefault ( ) ; } 
protected String buildDoublePastVerb ( String baseForm ) { String morphology = null ; if ( baseForm != null ) { morphology = baseForm + baseForm . charAt ( baseForm . length ( ) - 1 ) + "ed" ; } return morphology ; } 
public static Document newDocumentFromFile ( String path ) { Document doc = null ; try { doc = getDocumentBuilder ( ) . parse ( new File ( path ) ) ; } catch ( SAXException e ) { log . error ( e ) ; } catch ( IOException e ) { log . error ( e ) ; } return doc ; } 
public Kind getKind ( ) { Opcode opcode = getOpcode ( ) ; return ( opcode != null ? opcode . kind : Kind . UNKNOWN ) ; } 
protected void fireDOMFocusOutEvent ( EventTarget target ) { DocumentEvent docEvt = ( DocumentEvent ) ( ( Element ) target ) . getOwnerDocument ( ) ; UIEvent uiEvt = ( UIEvent ) docEvt . createEvent ( "UIEvents" ) ; uiEvt . initUIEvent ( "DOMFocusOut" , true , false , null , 0 ) ; target . dispatchEvent ( uiEvt ) ; } 
public void openContextMenu ( View view ) { view . showContextMenu ( ) ; } 
public boolean after ( Date when ) { return getMillisOf ( this ) > getMillisOf ( when ) ; } 
public CharSequence subSequence ( int start , int end ) { return substring ( start , end ) ; } 
public Type typeCheck ( SymbolTable stable ) throws TypeCheckError { final Type ftype = _filterExpr . typeCheck ( stable ) ; if ( ftype instanceof NodeSetType == false ) { if ( ftype instanceof ReferenceType ) { _filterExpr = new CastExpr ( _filterExpr , Type . NodeSet ) ; } else if ( ftype instanceof NodeType ) { _filterExpr = new CastExpr ( _filterExpr , Type . NodeSet ) ; } else { throw new TypeCheckError ( this ) ; } } final Type ptype = _path . typeCheck ( stable ) ; if ( ! ( ptype instanceof NodeSetType ) ) { _path = new CastExpr ( _path , Type . NodeSet ) ; } return _type = Type . NodeSet ; } 
private SqlFile ( Reader reader , String inputStreamLabel , File baseDir ) { logger . privlog ( Level . FINER , "<init>ting-SqlFile-instance" , null , 2 , FrameworkLogger . class ) ; if ( reader == null ) throw new IllegalArgumentException ( "'reader'-may-not-be-null" ) ; if ( inputStreamLabel == null ) throw new IllegalArgumentException ( "'inputStreamLabel'-may-not-be-null" ) ; this . reader = reader ; this . inputStreamLabel = inputStreamLabel ; this . baseDir = ( baseDir == null ) ? new File ( "." ) : baseDir ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
@ XmlElementDecl ( namespace = "http://echa.europa.eu/schemas/iuclid5/20130101" , name = "REFERENCE_TESTLAB" , scope = EndpointStudyRecord . ScientificPart . ECSOILMICROTOX . REFERENCE . Set . REFERENCETESTLAB . class ) public JAXBElement < String > createEndpointStudyRecordScientificPartECSOILMICROTOXREFERENCESetREFERENCETESTLABREFERENCETESTLAB ( String value ) { return new JAXBElement < String > ( _EndpointStudyRecordScientificPartECSOILMICROTOXREFERENCESetREFERENCETESTLABREFERENCETESTLAB_QNAME , String . class , EndpointStudyRecord . ScientificPart . ECSOILMICROTOX . REFERENCE . Set . REFERENCETESTLAB . class , value ) ; } 
public boolean isNodeAfter ( int nodeHandle1 , int nodeHandle2 ) { int index1 = makeNodeIdentity ( nodeHandle1 ) ; int index2 = makeNodeIdentity ( nodeHandle2 ) ; return index1 != NULL && index2 != NULL && index1 <= index2 ; } 
private static void walk ( Element element , Set < ElementVisitor > visitors ) throws SpecParserException { NodeList children = element . getChildNodes ( ) ; for ( int i = 0 , j = children . getLength ( ) ; i < j ; ++ i ) { Node child = children . item ( i ) ; String tagName = child . getNodeName ( ) ; if ( ! ( child instanceof Element ) ) continue ; for ( ElementVisitor ev : visitors ) { if ( ev . visit ( tagName , ( Element ) child ) ) break ; } } } 
public void keyPressed ( KeyEvent e ) { if ( e . isConsumed ( ) ) { return ; } keys [ e . getKeyCode ( ) ] = true ; } 
private void waitForRequestToComplete ( ) { synchronized ( mRequestInFlightLock ) { while ( mRequestInFlight ) { try { mRequestInFlightLock . wait ( ) ; } catch ( InterruptedException e ) { Log . e ( LOGTAG , "Interrupted-while-waiting-for-request-to-complete" ) ; } } } } 
public float getOffset ( ) { long now = System . currentTimeMillis ( ) ; if ( timeZone == null ) { timeZone = TimeZone . getTimeZone ( timeZoneID ) ; } return timeZone . getOffset ( now ) / 3600000.0f ; } 
public String trimStringToWidth ( String par1Str , int par2 , boolean par3 ) { StringBuilder var4 = new StringBuilder ( ) ; int var5 = 0 ; int var6 = par3 ? par1Str . length ( ) - 1 : 0 ; int var7 = par3 ? - 1 : 1 ; boolean var8 = false ; boolean var9 = false ; for ( int var10 = var6 ; var10 >= 0 && var10 < par1Str . length ( ) && var5 < par2 ; var10 += var7 ) { char var11 = par1Str . charAt ( var10 ) ; int var12 = this . getCharWidth ( var11 ) ; if ( var8 ) { var8 = false ; if ( var11 != 108 && var11 != 76 ) { if ( var11 == 114 || var11 == 82 ) { var9 = false ; } } else { var9 = true ; } } else if ( var12 < 0 ) { var8 = true ; } else { var5 += var12 ; if ( var9 ) { ++ var5 ; } } if ( var5 > par2 ) { break ; } if ( par3 ) { var4 . insert ( 0 , var11 ) ; } else { var4 . append ( var11 ) ; } } return var4 . toString ( ) ; } 
public JSeparator getJSeparator911122 ( ) { if ( jSeparator911122 == null ) { jSeparator911122 = new JSeparator ( ) ; jSeparator911122 . setSize ( new Dimension ( 134 , 10 ) ) ; jSeparator911122 . setLocation ( new Point ( 476 , 274 ) ) ; } return jSeparator911122 ; } 
private int getDistanceFromSpinner ( ) { switch ( area . getSelectedItem ( ) . toString ( ) ) { case "5-km" : return 5 ; case "10-km" : return 10 ; case "25-km" : return 25 ; case "50-km" : return 50 ; default : return 0 ; } } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
private String buildOptionalCommandLine ( ) { StringBuffer commandLineBuf = new StringBuffer ( ) ; if ( this . serverProps != null ) { for ( Iterator < Object > iter = this . serverProps . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String key = ( String ) iter . next ( ) ; String value = this . serverProps . getProperty ( key ) ; if ( ! isNonCommandLineArgument ( key ) ) { if ( value != null && value . length ( ) > 0 ) { commandLineBuf . append ( "-"" ) ; commandLineBuf . append ( "--" ) ; commandLineBuf . append ( key ) ; commandLineBuf . append ( "=" ) ; commandLineBuf . append ( value ) ; commandLineBuf . append ( """ ) ; } else { commandLineBuf . append ( "---" ) ; commandLineBuf . append ( key ) ; } } } } return commandLineBuf . toString ( ) ; } 
public static String [ ] getClientRuntimesByType ( String clientImplId , String preferredServerFactoryId ) { ArrayList ids = new ArrayList ( ) ; ArrayList idsPreferredByServer = new ArrayList ( ) ; Iterator iter = registry . clientRuntimes_ . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { ClientRuntimeDescriptor desc = ( ClientRuntimeDescriptor ) iter . next ( ) ; if ( desc . getClientImplementationType ( ) . getId ( ) . equals ( clientImplId ) ) { String clientRuntimeId = desc . getId ( ) ; if ( desc . getRuntimePreferredServerType ( ) != null && desc . getRuntimePreferredServerType ( ) . equals ( preferredServerFactoryId ) ) { idsPreferredByServer . add ( clientRuntimeId ) ; } else { ids . add ( clientRuntimeId ) ; } } } String [ ] preferredRuntimeIds = new String [ idsPreferredByServer . size ( ) + ids . size ( ) ] ; Iterator itr1 = idsPreferredByServer . iterator ( ) ; int preferredRTCounter = 0 ; while ( itr1 . hasNext ( ) ) { String runtimeId = ( String ) itr1 . next ( ) ; preferredRuntimeIds [ preferredRTCounter ++ ] = runtimeId ; } Iterator itr2 = ids . iterator ( ) ; while ( itr2 . hasNext ( ) ) { String runtimeId = ( String ) itr2 . next ( ) ; preferredRuntimeIds [ preferredRTCounter ++ ] = runtimeId ; } return preferredRuntimeIds ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; javax . xml . namespace . NamespaceContext nsContext = xmlWriter . getNamespaceContext ( ) ; while ( true ) { java . lang . String uri = nsContext . getNamespaceURI ( prefix ) ; if ( uri == null || uri . length ( ) == 0 ) { break ; } prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public URL toURL ( ) { String scheme = getScheme ( ) ; if ( ARTIFACT . equals ( scheme ) ) { return toURL ( new net . dpml . transit . artifact . Handler ( ) ) ; } else if ( LINK . equals ( scheme ) ) { return toURL ( new net . dpml . transit . link . Handler ( ) ) ; } else if ( LOCAL . equals ( scheme ) ) { return toURL ( new net . dpml . transit . local . Handler ( ) ) ; } else { final String error = "URI-scheme-not-recognized:-" + m_uri ; throw new UnsupportedSchemeException ( error ) ; } } 
public static File getFile ( URI resourceUri , String description ) throws FileNotFoundException { if ( resourceUri == null ) throw new IllegalArgumentException ( "Resource-URL-must-not-be-null" ) ; if ( ! URL_PROTOCOL_FILE . equals ( resourceUri . getScheme ( ) ) ) { throw new FileNotFoundException ( description + "-cannot-be-resolved-to-absolute-file-path-" + "because-it-does-not-reside-in-the-file-system:-" + resourceUri ) ; } return new File ( resourceUri . getSchemeSpecificPart ( ) ) ; } 
protected final String replace ( String input , String search , String replace ) { String fmtstr = input ; int pos = fmtstr . indexOf ( search ) ; while ( pos != - 1 ) { StringBuffer tmp = new StringBuffer ( fmtstr . substring ( 0 , pos ) ) ; tmp . append ( replace ) ; tmp . append ( fmtstr . substring ( pos + search . length ( ) ) ) ; fmtstr = tmp . toString ( ) ; pos = fmtstr . indexOf ( search ) ; } return fmtstr ; } 
public void setEncoding ( EncodingInfo encInfo ) { _encoding = encInfo . getIANAName ( ) ; _encodingInfo = encInfo ; } 
protected void completeDrag ( MouseEvent e ) { finishDraggingTo ( positionForMouseEvent ( e ) ) ; } 
@ Override public boolean findSecurityRole ( String role ) { synchronized ( securityRolesLock ) { for ( int i = 0 ; i < securityRoles . length ; i ++ ) { if ( role . equals ( securityRoles [ i ] ) ) return ( true ) ; } } return ( false ) ; } 
private AMSetupDSConfig ( ) { Map map = ServicesDefaultValues . getDefaultValues ( ) ; dsManager = ( String ) map . get ( SetupConstants . CONFIG_VAR_DS_MGR_DN ) ; suffix = ( String ) map . get ( SetupConstants . CONFIG_VAR_ROOT_SUFFIX ) ; dsHostName = ( String ) map . get ( SetupConstants . CONFIG_VAR_DIRECTORY_SERVER_HOST ) ; dsPort = ( String ) map . get ( SetupConstants . CONFIG_VAR_DIRECTORY_SERVER_PORT ) ; dsAdminPwd = ( String ) map . get ( SetupConstants . CONFIG_VAR_DS_MGR_PWD ) ; basedir = ( String ) map . get ( SetupConstants . CONFIG_VAR_BASE_DIR ) ; deployuri = ( String ) map . get ( SetupConstants . CONFIG_VAR_SERVER_URI ) ; } 
@ VisibleForTesting public static String escapeForSchemeName ( String s ) { s = s . toLowerCase ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( Character . isLetter ( c ) || Character . isDigit ( c ) || ( '-' == c ) || ( '.' == c ) ) { sb . append ( c ) ; } else if ( '+' == c ) { sb . append ( "++" ) ; } else { sb . append ( '+' ) . append ( ( int ) c ) ; } } return sb . toString ( ) ; } 
public Counter asCounter ( ) { PriorityQueue < E > pq = clone ( ) ; Counter < E > counter = new Counter < E > ( ) ; while ( pq . hasNext ( ) ) { double priority = pq . getPriority ( ) ; E element = pq . next ( ) ; counter . incrementCount ( element , priority ) ; } return counter ; } 
public ExternalRecord [ ] toArray ( ) { return subRecords . toArray ( new ExternalRecord [ subRecords . size ( ) ] ) ; } 
public void print ( float f ) { write ( String . valueOf ( f ) ) ; } 
public int getYOffset ( String text ) { DisplayList displayList = null ; if ( displayListCaching ) { displayList = ( DisplayList ) displayLists . get ( text ) ; if ( displayList != null && displayList . yOffset != null ) return displayList . yOffset . intValue ( ) ; } int stopIndex = text . indexOf ( '|n' ) ; if ( stopIndex == - 1 ) stopIndex = text . length ( ) ; int minYOffset = 10000 ; for ( int i = 0 ; i < stopIndex ; i ++ ) { int id = text . charAt ( i ) ; CharDef charDef = chars [ id ] ; if ( charDef == null ) { continue ; } minYOffset = Math . min ( charDef . yoffset , minYOffset ) ; } if ( displayList != null ) displayList . yOffset = new Short ( ( short ) minYOffset ) ; return minYOffset ; } 
public List < BabelImage > getImages ( ) { return new ArrayList < BabelImage > ( images ) ; } 
public DisjunctionSumScorer ( Weight weight , List < Scorer > subScorers , int minimumNrMatchers ) throws IOException { super ( weight , subScorers . toArray ( new Scorer [ subScorers . size ( ) ] ) , subScorers . size ( ) ) ; if ( minimumNrMatchers <= 0 ) { throw new IllegalArgumentException ( "Minimum-nr-of-matchers-must-be-positive" ) ; } if ( numScorers <= 1 ) { throw new IllegalArgumentException ( "There-must-be-at-least-2-subScorers" ) ; } this . minimumNrMatchers = minimumNrMatchers ; } 
public void setGist ( String gist ) { if ( gist == null || gist . trim ( ) . isEmpty ( ) ) { this . gist = null ; } else { this . gist = gist ; } } 
@ Override public void setup ( int numColors ) { maximumColors = numColors ; reduceColors = Math . max ( 512 , numColors * 2 ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public static void readFile ( String fileName ) { if ( fileName == null ) readStandardInput ( ) ; else { BufferedReader newin ; try { newin = new BufferedReader ( new FileReader ( fileName ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Can't-open-file-"" + fileName + ""-for-input.-" + "(Error-:" + e + ")" ) ; } if ( ! readingStandardInput ) { try { in . close ( ) ; } catch ( Exception e ) { } } emptyBuffer ( ) ; in = newin ; readingStandardInput = false ; inputErrorCount = 0 ; inputFileName = fileName ; } } 
public boolean isModified ( ) { if ( isFileDirectlyOnDisk ) { File file = new File ( fullPath ) ; if ( ! file . exists ( ) ) { return true ; } else { return ( lastModTime != file . lastModified ( ) ) ; } } else { return false ; } } 
boolean viewServerListWindows ( Socket client ) { if ( isSystemSecure ( ) ) { return false ; } boolean result = true ; Object [ ] windows ; synchronized ( mWindowMap ) { windows = new Object [ mWindows . size ( ) ] ; windows = mWindows . toArray ( windows ) ; } BufferedWriter out = null ; try { OutputStream clientStream = client . getOutputStream ( ) ; out = new BufferedWriter ( new OutputStreamWriter ( clientStream ) , 8 * 1024 ) ; final int count = windows . length ; for ( int i = 0 ; i < count ; i ++ ) { final WindowState w = ( WindowState ) windows [ i ] ; out . write ( Integer . toHexString ( System . identityHashCode ( w ) ) ) ; out . write ( '-' ) ; out . append ( w . mAttrs . getTitle ( ) ) ; out . write ( '|n' ) ; } out . write ( "DONE.-" ) ; out . flush ( ) ; } catch ( Exception e ) { result = false ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { result = false ; } } } return result ; } 
public int getAD_Reference_ID ( ) { Integer ii = ( Integer ) get_Value ( "AD_Reference_ID" ) ; if ( ii == null ) return 0 ; return ii . intValue ( ) ; } 
public static String getJavaVersion ( ) { if ( javaVersion != null ) { return javaVersion ; } String ver = null ; try { ver = "1.0" ; Class . forName ( "java.lang.Void" ) ; ver = "1.1" ; Class . forName ( "java.lang.ThreadLocal" ) ; ver = "1.2" ; Class . forName ( "java.lang.StrictMath" ) ; ver = "1.3" ; Class . forName ( "java.net.URI" ) ; ver = "1.4" ; Class . forName ( "java.lang.reflect.ParameterizedType" ) ; ver = "1.5" ; } catch ( Throwable t ) { } javaVersion = ver ; return javaVersion ; } 
public void ignorableWhitespace ( char [ ] ch , int start , int length ) throws SAXException { if ( m_firstTagNotEmitted ) { flush ( ) ; } m_handler . ignorableWhitespace ( ch , start , length ) ; } 
public RegularExpression ( String regex , String options ) throws ParseException { this . setPattern ( regex , options ) ; } 
public int getInDegree ( Vertex vertex ) { int counter = 0 ; Set < Vertex > keys = outVertices . keySet ( ) ; for ( Iterator < Vertex > i = keys . iterator ( ) ; i . hasNext ( ) ; ) { HashSet < Vertex > set = outVertices . get ( i . next ( ) ) ; if ( set . contains ( vertex ) ) { counter ++ ; } } return counter ; } 
protected ObjectMatrix1D like1D ( int size , int zero , int stride ) { throw new InternalError ( ) ; } 
private void setBatchSize ( String batchSizeProp ) { if ( batchSizeProp != null ) { batchSize = Integer . parseInt ( batchSizeProp ) ; } else { batchSize = DEFAULT_BATCH_SIZE ; } } 
public TypedTime getTypedTime ( String tokenValue ) { TypedTime typedTime = new TypedTime ( ) ; if ( tokenValue . endsWith ( "d" ) ) { typedTime . setUnit ( "d" ) ; String t = tokenValue . replace ( 'd' , '-' ) ; typedTime . setTime ( Integer . parseInt ( t . trim ( ) ) ) ; } else if ( tokenValue . endsWith ( "h" ) ) { typedTime . setUnit ( "h" ) ; String t = tokenValue . replace ( 'h' , '-' ) ; typedTime . setTime ( Integer . parseInt ( t . trim ( ) ) ) ; } else if ( tokenValue . endsWith ( "m" ) ) { typedTime . setUnit ( "m" ) ; String t = tokenValue . replace ( 'm' , '-' ) ; typedTime . setTime ( Integer . parseInt ( t . trim ( ) ) ) ; } else { typedTime . setUnit ( "s" ) ; if ( tokenValue . endsWith ( "s" ) ) { String t = tokenValue . replace ( 's' , '-' ) ; typedTime . setTime ( Integer . parseInt ( t . trim ( ) ) ) ; } else typedTime . setTime ( Integer . parseInt ( tokenValue . trim ( ) ) ) ; } return typedTime ; } 
public void setLines ( Collection lines ) { m_lines . clear ( ) ; m_lines . addAll ( lines ) ; } 
public Dimension getDimension ( Object key ) { Object value = get ( key ) ; return ( value instanceof Dimension ) ? ( Dimension ) value : null ; } 
public String outerHtml ( ) { StringBuilder accum = new StringBuilder ( 128 ) ; outerHtml ( accum ) ; return accum . toString ( ) ; } 
public void setFileDateFormat ( String fileDateFormat ) { String newFormat ; if ( fileDateFormat == null ) { newFormat = "" ; } else { newFormat = fileDateFormat ; } this . fileDateFormat = newFormat ; synchronized ( this ) { fileDateFormatter = new SimpleDateFormat ( newFormat , Locale . US ) ; fileDateFormatter . setTimeZone ( TimeZone . getDefault ( ) ) ; } } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
private void attemptExit ( ) { int result = JOptionPane . showConfirmDialog ( this , "Are-you-sure-you-want-to-exit?" , "Confirmation..." , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; if ( result == JOptionPane . YES_OPTION ) { dispose ( ) ; System . exit ( 0 ) ; } } 
public static boolean regionMatches ( boolean ignoreCase , Segment text , int offset , char [ ] match ) { int length = offset + match . length ; char [ ] textArray = text . array ; if ( length > text . offset + text . count ) { return false ; } for ( int i = offset , j = 0 ; i < length ; i ++ , j ++ ) { char c1 = textArray [ i ] ; char c2 = match [ j ] ; if ( ignoreCase ) { c1 = Character . toUpperCase ( c1 ) ; c2 = Character . toUpperCase ( c2 ) ; } if ( c1 != c2 ) { return false ; } } return true ; } 
public int getTransportTypeId ( ) { return Integer . parseInt ( transport_type_id ) ; } 
public boolean offer ( E e ) { if ( e == null ) throw new NullPointerException ( ) ; return transferer . transfer ( e , true , 0 ) != null ; } 
@ SuppressWarnings ( "unchecked" ) @ Override public void addToGui ( List guiComps ) { if ( type == HttpFormEntry . TYPE_AREA ) { Dimension minSize = new Dimension ( 500 , 200 ) ; guiComps . add ( LayoutUtil . top ( GuiUtils . rLabel ( getLabel ( ) ) ) ) ; component . setLineWrap ( wrap ) ; component . setWrapStyleWord ( wrap ) ; JScrollPane sp = new JScrollPane ( component ) ; sp . setPreferredSize ( minSize ) ; sp . setMinimumSize ( minSize ) ; guiComps . add ( sp ) ; } else { super . addToGui ( guiComps ) ; } } 
public String toString ( ) { StringBuffer sb = new StringBuffer ( super . toString ( ) ) ; sb . append ( ":-[-Trust-Anchor:-" ) ; sb . append ( trustAnchor . toString ( ) ) ; sb . append ( "-Policy-Tree:-" ) ; sb . append ( policyTree == null ? "no-valid-policy-tree-" : policyTree . toString ( ) ) ; sb . append ( "-Subject-Public-Key:-" ) ; sb . append ( subjectPublicKey . toString ( ) ) ; sb . append ( "-]" ) ; return sb . toString ( ) ; } 
private void initializeLocation ( V v , Point2D coord , Dimension d ) { int level = minLevels . get ( v ) . intValue ( ) ; int minY = ( int ) ( level * d . getHeight ( ) / ( graphHeight * SPACEFACTOR ) ) ; double x = Math . random ( ) * d . getWidth ( ) ; double y = Math . random ( ) * ( d . getHeight ( ) - minY ) + minY ; coord . setLocation ( x , y ) ; } 
public static boolean hasDigit ( String str ) { final Pattern pattern = Pattern . compile ( "[0-9]" ) ; final Matcher matcher = pattern . matcher ( str ) ; while ( matcher . find ( ) ) { return true ; } return false ; } 
public final int getAndDecrement ( ) { for ( ; ; ) { int current = get ( ) ; int next = current - 1 ; if ( compareAndSet ( current , next ) ) return current ; } } 
public List < Fee > getReturn ( ) { if ( _return == null ) { _return = new ArrayList < Fee > ( ) ; } return this . _return ; } 
public void setNullBytes ( byte [ ] nullBytes ) { byte [ ] copy = new byte [ nullBytes . length ] ; System . arraycopy ( nullBytes , 0 , copy , 0 , nullBytes . length ) ; this . nullBytes = copy ; } 
public static final String readFromAsString ( Reader reader ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; char [ ] c = new char [ BUFFER_SIZE ] ; int l ; while ( ( l = reader . read ( c ) ) != - 1 ) { sb . append ( c , 0 , l ) ; } return sb . toString ( ) ; } 
public void close ( ) throws IOException { in . close ( ) ; } 
public DTMIterator createDTMIterator ( int whatToShow , DTMFilter filter , boolean entityReferenceExpansion ) { return m_dtmManager . createDTMIterator ( whatToShow , filter , entityReferenceExpansion ) ; } 
public static void deleteDatabasesDir ( Context context ) { deleteFile ( new File ( context . getApplicationInfo ( ) . dataDir + "/databases" ) ) ; } 
public boolean isLockSupported ( int idx ) throws IOException { StorageDirectory sd = storageDirs . get ( idx ) ; FileLock firstLock = null ; FileLock secondLock = null ; try { firstLock = sd . lock ; if ( firstLock == null ) { firstLock = sd . tryLock ( ) ; if ( firstLock == null ) return true ; } secondLock = sd . tryLock ( ) ; if ( secondLock == null ) return true ; } finally { if ( firstLock != null && firstLock != sd . lock ) { firstLock . release ( ) ; firstLock . channel ( ) . close ( ) ; } if ( secondLock != null ) { secondLock . release ( ) ; secondLock . channel ( ) . close ( ) ; } } return false ; } 
@ XmlElementDecl ( namespace = "" , name = "rsquo" , scope = DocParaType . class ) public JAXBElement < DocEmptyType > createDocParaTypeRsquo ( DocEmptyType value ) { return new JAXBElement < DocEmptyType > ( _DocCaptionTypeRsquo_QNAME , DocEmptyType . class , DocParaType . class , value ) ; } 
static public String numberToString ( Number n ) throws JSONException { if ( n == null ) { throw new JSONException ( "Null-pointer" ) ; } testValidity ( n ) ; String s = n . toString ( ) ; if ( s . indexOf ( '.' ) > 0 && s . indexOf ( 'e' ) < 0 && s . indexOf ( 'E' ) < 0 ) { while ( s . endsWith ( "0" ) ) { s = s . substring ( 0 , s . length ( ) - 1 ) ; } if ( s . endsWith ( "." ) ) { s = s . substring ( 0 , s . length ( ) - 1 ) ; } } return s ; } 
private void setViewDrawable ( ImageView v , Drawable drawable , int nullVisibility ) { v . setImageDrawable ( drawable ) ; if ( drawable == null ) { v . setVisibility ( nullVisibility ) ; } else { v . setVisibility ( View . VISIBLE ) ; drawable . setVisible ( false , false ) ; drawable . setVisible ( true , false ) ; } } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
@ Override public String toString ( ) { return this . doToString ( KEY ) ; } 
public static ByteBuffer blockToByteBuffer ( HashMap < Integer , Node > n , HashMap < Integer , ArrayList < Edge >> i , HashMap < Integer , ArrayList < Edge >> o ) { int innerEdgeCount = 0 ; for ( ArrayList < Edge > ae : i . values ( ) ) innerEdgeCount += ae . size ( ) ; int outerEdgeCount = 0 ; for ( ArrayList < Edge > ae : o . values ( ) ) { outerEdgeCount += ae . size ( ) ; } ByteBuffer b = ByteBuffer . allocate ( 1 + 4 + ( 4 + 4 + 4 ) * n . size ( ) + 8 * innerEdgeCount + 8 * outerEdgeCount + 8 ) ; b . put ( CONST . ENTIRE_BLOCK_DATA_MARKER ) ; b . putInt ( n . size ( ) ) ; for ( Node nn : n . values ( ) ) { b . putInt ( nn . id ) ; b . putInt ( nn . edges ( ) ) ; b . putFloat ( nn . getPR ( ) ) ; } b . putInt ( innerEdgeCount ) ; for ( ArrayList < Edge > ae : i . values ( ) ) { for ( Edge e : ae ) { b . putInt ( e . from ) ; b . putInt ( e . to ) ; } } b . putInt ( outerEdgeCount ) ; for ( ArrayList < Edge > ae : o . values ( ) ) { for ( Edge e : ae ) { b . putInt ( e . from ) ; b . putInt ( e . to ) ; } } return b ; } 
private Map getPluginDescriptors2 ( Map < String , DescriptorParser > parserMap ) { Map allDescriptors = new HashMap ( ) ; try { Enumeration resurces = PluginManager . class . getClassLoader ( ) . getResources ( "trackplus-plugin.xml" ) ; if ( resurces != null ) { while ( resurces . hasMoreElements ( ) ) { URL url = ( URL ) resurces . nextElement ( ) ; LOGGER . debug ( "trackplus-plugin.xml-at-" + url . toString ( ) ) ; InputStream is = url . openStream ( ) ; Map < String , List < PluginDescriptor >> currentFileDescriptors = PluginParser . parseDocument ( is , parserMap ) ; is . close ( ) ; Iterator it = parserMap . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Object key = it . next ( ) ; List allPluginsOfType = ( List ) allDescriptors . get ( key ) ; List currentDescriptorsOfType = currentFileDescriptors . get ( key ) ; if ( allPluginsOfType == null ) { allPluginsOfType = new ArrayList ( ) ; } if ( currentDescriptorsOfType != null ) { LOGGER . debug ( "Found-plug-in-with-key-" + key ) ; allPluginsOfType . addAll ( currentDescriptorsOfType ) ; } allDescriptors . put ( key , allPluginsOfType ) ; } } } } catch ( IOException e ) { LOGGER . error ( ExceptionUtils . getStackTrace ( e ) ) ; } return allDescriptors ; } 
public static final String getProperty ( String name ) { String prop = null ; if ( System . getProperty ( name ) != null ) { prop = System . getProperty ( name ) ; } else { prop = getProperties ( ) . getProperty ( name ) ; } if ( prop == null ) throw new RuntimeException ( "Simulation-property-'" + name + "'-not-found" ) ; return prop ; } 
public final int saveACL ( DataBuffer buf ) throws SaveException { int startPos = buf . getPosition ( ) ; buf . putShort ( m_revision ) ; buf . putShort ( 0 ) ; buf . putInt ( m_aceList != null ? m_aceList . size ( ) : 0 ) ; if ( m_aceList != null && m_aceList . size ( ) > 0 ) { for ( int i = 0 ; i < m_aceList . size ( ) ; i ++ ) { ACE curAce = getACE ( i ) ; curAce . saveACE ( buf ) ; } } int endPos = buf . getPosition ( ) ; buf . setPosition ( startPos + 2 ) ; buf . putShort ( endPos - startPos ) ; buf . setPosition ( endPos ) ; return endPos ; } 
void putAppWidgetItems ( List < AppWidgetProviderInfo > appWidgets , List < Bundle > customExtras , List < Item > items , int categoryFilter , boolean ignoreFilter ) { if ( appWidgets == null ) return ; final int size = appWidgets . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { AppWidgetProviderInfo info = appWidgets . get ( i ) ; if ( ! ignoreFilter && ( info . widgetCategory & categoryFilter ) == 0 ) { continue ; } Item item = mItemConstructor . createItem ( mContext , info , customExtras != null ? customExtras . get ( i ) : null ) ; items . add ( item ) ; } } 
public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector ( 4 ) ; newVector . addElement ( new Option ( "-Ignore-case-when-matching-attribute-" + "names-and-nominal-values." , "I" , 0 , "-I" ) ) ; newVector . addElement ( new Option ( "-Suppress-the-output-of-the-mapping-report." , "M" , 0 , "-M" ) ) ; newVector . addElement ( new Option ( "-Trim-white-space-from-either-end-of-names-" + "before-matching." , "trim" , 0 , "-trim" ) ) ; newVector . addElement ( new Option ( "-Path-to-a-model-to-load.-If-set,-this-model" + "-will-be-used-for-prediction-and-any-base-classifier" + "-specification-will-be-ignored.-Environment-variables" + "-may-be-used-in-the-path-(e.g.-${HOME}/myModel.model)" , "L" , 1 , "-L-<path-to-model-to-load>" ) ) ; Enumeration < Option > enu = super . listOptions ( ) ; while ( enu . hasMoreElements ( ) ) { newVector . addElement ( enu . nextElement ( ) ) ; } return newVector . elements ( ) ; } 
private void handleOrgValue ( final int type , List < String > orgList , Map < String , Collection < String >> paramMap , boolean isPrimary ) { final String phoneticName = buildSinglePhoneticNameFromSortAsParam ( paramMap ) ; if ( orgList == null ) { orgList = sEmptyList ; } final String companyName ; final String departmentName ; final int size = orgList . size ( ) ; switch ( size ) { case 0 : { companyName = "" ; departmentName = null ; break ; } case 1 : { companyName = orgList . get ( 0 ) ; departmentName = null ; break ; } default : { companyName = orgList . get ( 0 ) ; StringBuilder builder = new StringBuilder ( ) ; for ( int i = 1 ; i < size ; i ++ ) { if ( i > 1 ) { builder . append ( '-' ) ; } builder . append ( orgList . get ( i ) ) ; } departmentName = builder . toString ( ) ; } } if ( mOrganizationList == null ) { addNewOrganization ( type , companyName , departmentName , null , phoneticName , isPrimary ) ; return ; } for ( OrganizationData organizationData : mOrganizationList ) { if ( organizationData . companyName == null && organizationData . departmentName == null ) { organizationData . companyName = companyName ; organizationData . departmentName = departmentName ; organizationData . isPrimary = isPrimary ; return ; } } addNewOrganization ( type , companyName , departmentName , null , phoneticName , isPrimary ) ; } 
public Elements toggleClass ( String className ) { for ( Element element : contents ) { element . toggleClass ( className ) ; } return this ; } 
public static double Contrast ( double [ ] [ ] coocurrenceMatrix ) { double r = 0 ; for ( int i = 0 ; i < coocurrenceMatrix . length ; i ++ ) { for ( int j = 0 ; j < coocurrenceMatrix [ 0 ] . length ; j ++ ) { r += Math . abs ( i - j ) * coocurrenceMatrix [ i ] [ j ] ; } } return r ; } 
public synchronized void addActionListener ( ActionListener l ) { if ( l == null ) { return ; } actionListener = AWTEventMulticaster . add ( actionListener , l ) ; newEventsOnly = true ; } 
public static Path getNamespaceDir ( Path rootdir , final String namespace ) { return new Path ( rootdir , new Path ( HConstants . BASE_NAMESPACE_DIR , new Path ( namespace ) ) ) ; } 
protected void invalidateParentIfNeeded ( ) { if ( isHardwareAccelerated ( ) && mParent instanceof View ) { ( ( View ) mParent ) . invalidate ( true ) ; } } 
protected static String peekName ( RandomAccessFile file ) throws DescriptorException { try { long filepos = file . getFilePointer ( ) ; byte [ ] nameBytes = new byte [ 4 ] ; if ( file . read ( nameBytes ) == - 1 ) return null ; file . seek ( filepos ) ; return new String ( nameBytes ) ; } catch ( Exception ex ) { throw new DescriptorException ( ex ) ; } } 
public void start ( ) { thread = new Thread ( this ) ; thread . setName ( getName ( ) + "-" + ( ++ curThreads ) ) ; thread . setDaemon ( true ) ; thread . setPriority ( getThreadPriority ( ) ) ; thread . start ( ) ; } 
public static long writeFile ( String path , byte [ ] jpeg , ExifInterface exif ) throws IOException { if ( ! createDirectoryIfNeeded ( path ) ) { Log . e ( TAG , "Failed-to-create-parent-directory-for-file:-" + path ) ; return - 1 ; } if ( exif != null ) { exif . writeExif ( jpeg , path ) ; File f = new File ( path ) ; return f . length ( ) ; } else { return writeFile ( path , jpeg ) ; } } 
public static int Save_pkts ( byte [ ] content ) throws IOException { if ( content == null ) { if ( Debug_Mode ) System . err . println ( "Exit-before-receiving-anything!" ) ; return 2 ; } else { File temp = new File ( file_name ) ; if ( temp . exists ( ) ) temp . delete ( ) ; IOUtil . WriteFile ( temp , content ) ; } return 0 ; } 
private int getLineLength ( int line ) { Element lineEl = getElement ( ) . getElement ( line ) ; Segment buffer = getLineBuffer ( ) ; try { Document doc = getDocument ( ) ; doc . getText ( lineEl . getStartOffset ( ) , lineEl . getEndOffset ( ) - lineEl . getStartOffset ( ) - 1 , buffer ) ; } catch ( BadLocationException ex ) { AssertionError err = new AssertionError ( "Unexpected-bad-location" ) ; err . initCause ( ex ) ; throw err ; } return Utilities . getTabbedTextWidth ( buffer , metrics , tabBase , this , lineEl . getStartOffset ( ) ) ; } 
public final void initColumnNumber ( int columnNumber ) { if ( columnNumber <= 0 ) throw new IllegalArgumentException ( String . valueOf ( columnNumber ) ) ; if ( this . columnNumber > 0 ) throw new IllegalStateException ( ) ; this . columnNumber = columnNumber ; } 
@ Override public boolean accept ( File pathname ) { if ( pathname == null ) return false ; if ( ! pathname . isDirectory ( ) ) return false ; try { return ( Integer . parseInt ( pathname . getName ( ) ) >= 1 ) ; } catch ( NumberFormatException ex ) { } return false ; } 
public boolean isCellEditable ( java . util . EventObject anEvent ) { if ( anEvent instanceof java . awt . event . MouseEvent ) { return ( ( java . awt . event . MouseEvent ) anEvent ) . getClickCount ( ) >= clickToStartEditing ; } return true ; } 
void finish ( Request < ? > request ) { synchronized ( mCurrentRequests ) { mCurrentRequests . remove ( request ) ; } if ( request . shouldCache ( ) ) { synchronized ( mWaitingRequests ) { String cacheKey = request . getCacheKey ( ) ; Queue < Request < ? >> waitingRequests = mWaitingRequests . remove ( cacheKey ) ; if ( waitingRequests != null ) { if ( VolleyLog . DEBUG ) { VolleyLog . v ( "Releasing-%d-waiting-requests-for-cacheKey=%s." , waitingRequests . size ( ) , cacheKey ) ; } mCacheQueue . addAll ( waitingRequests ) ; } } } } 
public static boolean isHAEnabled ( Configuration conf ) { return conf . getBoolean ( YarnConfiguration . RM_HA_ENABLED , YarnConfiguration . DEFAULT_RM_HA_ENABLED ) ; } 
public boolean decodeExtensionMedia ( int startIndex ) { int index = startIndex ; mDataLength = 0 ; mStringValue = null ; int length = mWspData . length ; boolean rtrn = index < length ; while ( index < length && mWspData [ index ] != 0 ) { index ++ ; } mDataLength = index - startIndex + 1 ; mStringValue = new String ( mWspData , startIndex , mDataLength - 1 ) ; return rtrn ; } 
public double evaluate ( double x , double epsilon ) throws ConvergenceException { return evaluate ( x , epsilon , Integer . MAX_VALUE ) ; } 
public synchronized void setFlavorsForNative ( String nat , DataFlavor [ ] flavors ) { if ( nat == null || flavors == null ) { throw new NullPointerException ( "null-arguments-not-permitted" ) ; } getNativeToFlavor ( ) . remove ( nat ) ; for ( int i = 0 ; i < flavors . length ; i ++ ) { addFlavorForUnencodedNative ( nat , flavors [ i ] ) ; } disabledMappingGenerationKeys . add ( nat ) ; getFlavorsForNativeCache . remove ( nat ) ; getFlavorsForNativeCache . remove ( null ) ; } 
public static List < String > run ( File dir , String ... cmd ) { List < String > list = new ArrayList < > ( ) ; try { ProcessBuilder pb = new ProcessBuilder ( cmd ) ; pb . directory ( dir ) ; pb . redirectErrorStream ( true ) ; Process p = pb . start ( ) ; InputStream is = p . getInputStream ( ) ; try ( BufferedReader br = new BufferedReader ( new InputStreamReader ( is ) ) ) { String l ; while ( ( l = br . readLine ( ) ) != null ) { list . add ( l ) ; } } p . waitFor ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; list . add ( e . toString ( ) ) ; } return list ; } 
public final Message obtainMessage ( ) { return Message . obtain ( this ) ; } 
public static String charsToEscapes ( String str , String toEscape ) { StringBuilder buf = new StringBuilder ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( toEscape . indexOf ( c ) != - 1 ) { if ( c == '|n' ) buf . append ( "|n" ) ; else if ( c == '|t' ) buf . append ( "|t" ) ; else { buf . append ( '|' ) ; buf . append ( c ) ; } } else buf . append ( c ) ; } return buf . toString ( ) ; } 
public synchronized boolean disableNetwork ( int netId ) { if ( mWifiState . get ( ) != WIFI_STATE_ENABLED ) { return false ; } mIsAnyNetworkDisabled . set ( true ) ; return WifiNative . disableNetworkCommand ( netId ) ; } 
public Collection < EventNotifier > getNotifiers ( ) { return Collections . unmodifiableSet ( _group ) ; } 
public static TodoItem loadTodoItemById ( SQLiteDatabase database , long rowId ) { final Cursor todoListCursor = database . query ( "todolist" , new String [ ] { "ROWID" , "text" , "updated_on" , "added_on" , "completed" } , "ROWID-=-?" , new String [ ] { Long . toString ( rowId ) } , null , null , null ) ; final List < TodoItem > todos = loadFromCursor ( todoListCursor ) ; todoListCursor . close ( ) ; return todos . get ( 0 ) ; } 
public JSONArray put ( boolean value ) { values . add ( value ) ; return this ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public final byte [ ] getBytes ( ) { final int length = bytes . length ; final byte [ ] result = new byte [ length ] ; System . arraycopy ( bytes , 0 , result , 0 , length ) ; return result ; } 
public static boolean pingGoogleSynchronous ( ) { try { Process p1 = java . lang . Runtime . getRuntime ( ) . exec ( "ping--c-1-www.google.com" ) ; int returnVal = p1 . waitFor ( ) ; BufferedReader r = new BufferedReader ( new InputStreamReader ( p1 . getInputStream ( ) ) ) ; StringBuilder total = new StringBuilder ( ) ; String line ; while ( ( line = r . readLine ( ) ) != null ) { total . append ( line ) ; } Log . d ( "DEBUG" , total . toString ( ) ) ; boolean reachable = ( returnVal == 0 ) ; return reachable ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return false ; } 
public static URLConnection openURLConnection ( final String url ) { try { final URL tspUrl = new URL ( url ) ; return tspUrl . openConnection ( ) ; } catch ( IOException e ) { throw new DSSException ( e ) ; } } 
protected Class findClass ( String name ) throws ClassNotFoundException { String classFile = name . replace ( '.' , '/' ) + ".class" ; InputStream classInputStream = null ; if ( this . extensionJars != null ) { for ( int i = 0 ; i < this . extensionJars . length ; i ++ ) { JarFile extensionJar = this . extensionJars [ i ] ; JarEntry jarEntry = extensionJar . getJarEntry ( classFile ) ; if ( jarEntry != null ) { try { classInputStream = extensionJar . getInputStream ( jarEntry ) ; } catch ( IOException ex ) { throw new ClassNotFoundException ( "Couldn't-read-class-" + name , ex ) ; } } } } if ( classInputStream == null ) { URL url = getResource ( classFile ) ; if ( url == null ) { throw new ClassNotFoundException ( "Class-" + name ) ; } try { classInputStream = url . openStream ( ) ; } catch ( IOException ex ) { throw new ClassNotFoundException ( "Couldn't-read-class-" + name , ex ) ; } } try { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; BufferedInputStream in = new BufferedInputStream ( classInputStream ) ; byte [ ] buffer = new byte [ 8096 ] ; int size ; while ( ( size = in . read ( buffer ) ) != - 1 ) { out . write ( buffer , 0 , size ) ; } in . close ( ) ; return defineClass ( name , out . toByteArray ( ) , 0 , out . size ( ) , this . protectionDomain ) ; } catch ( IOException ex ) { throw new ClassNotFoundException ( "Class-" + name , ex ) ; } } 
public static String uuid ( ) { char [ ] uuid = new char [ 36 ] ; int r ; uuid [ 8 ] = uuid [ 13 ] = uuid [ 18 ] = uuid [ 23 ] = '-' ; uuid [ 14 ] = '4' ; for ( int i = 0 ; i < 36 ; i ++ ) { if ( uuid [ i ] == 0 ) { r = ( int ) ( Math . random ( ) * 16 ) ; uuid [ i ] = CHARS [ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r & 0xf ] ; } } return new String ( uuid ) ; } 
@ Override public Object encode ( Object obj ) throws EncoderException { if ( ! ( obj instanceof String ) ) { throw new EncoderException ( "DoubleMetaphone-encode-parameter-is-not-of-type-String" ) ; } return doubleMetaphone ( ( String ) obj ) ; } 
static String getParenthesizedArg ( String str , int num ) { String [ ] args = str . split ( "|s*[,()]|s*" ) ; if ( args . length <= num ) { return null ; } return args [ num ] ; } 
public float getFloat ( String name , float defaultValue ) { String valueString = get ( name ) ; if ( valueString == null ) return defaultValue ; try { return Float . parseFloat ( valueString ) ; } catch ( NumberFormatException e ) { return defaultValue ; } } 
private static String buildSelectLatestQuery ( ) { final StringBuilder sql = new StringBuilder ( ) ; sql . append ( "SELECT-r.rip_request_id,-r.start_date,-r.finish_date,-l.rip_request_log_id,-l.date,-l.value-" ) ; sql . append ( "FROM-mtgpricer.rip_request-r-LEFT-OUTER-JOIN-mtgpricer.rip_request_log-l-ON-(r.rip_request_id-=-l.rip_request_id)-" ) ; sql . append ( "ORDER-BY-r.start_date-DESC-" ) ; sql . append ( "LIMIT-1" ) ; return sql . toString ( ) ; } 
@ Override public DataSetRow next ( ) { if ( ! bufferIterator . hasNext ( ) ) { this . loadNextBuffer ( ) ; } currentFileLineNumber ++ ; return bufferIterator . next ( ) ; } 
public void write ( byte [ ] bytes ) throws IOException { data . write ( bytes ) ; } 
public static void writeXml ( @ Nonnull final File xmlFile , @ Nonnull final Document document ) throws IOException { FileUtil . executeIoOperation ( new ThreadUtil . Operation < Void > ( ) { @ Nullable @ Override public Void run ( ) throws IOException { try { internalWriteXml ( new FileOutputStream ( xmlFile ) , document ) ; } catch ( FileNotFoundException e ) { throw new IOException ( "Can't-find-file-'" + xmlFile . getName ( ) + "'-while-writing-XML-document." , e ) ; } return null ; } } ) ; } 
public boolean isSelectionEnabled ( ) { Boolean value = ( Boolean ) get ( PROPERTY_SELECTION_ENABLED ) ; return value == null ? false : value . booleanValue ( ) ; } 
@ Override public void processAttribute ( String namespace , String localName , String value ) throws ParseException { if ( namespace . equals ( Namespaces . xml ) && localName . equals ( "lang" ) ) { lang = xmlLang ; } } 
public void wakeup ( ) { synchronized ( lock ) { lock . notifyAll ( ) ; } } 
public JSONArray ( Object array ) throws JSONException { this ( ) ; if ( array . getClass ( ) . isArray ( ) ) { int length = Array . getLength ( array ) ; for ( int i = 0 ; i < length ; i += 1 ) { this . put ( Array . get ( array , i ) ) ; } } else { throw new JSONException ( "JSONArray-initial-value-should-be-a-string-or-collection-or-array." ) ; } } 
protected void measureChild ( View child , int parentWidthMeasureSpec , int parentHeightMeasureSpec ) { final LayoutParams lp = child . getLayoutParams ( ) ; final int childWidthMeasureSpec = getChildMeasureSpec ( parentWidthMeasureSpec , mPaddingLeft + mPaddingRight , lp . width ) ; final int childHeightMeasureSpec = getChildMeasureSpec ( parentHeightMeasureSpec , mPaddingTop + mPaddingBottom , lp . height ) ; child . measure ( childWidthMeasureSpec , childHeightMeasureSpec ) ; } 
public void initialize ( Subject subject , CallbackHandler callbackHandler , Map < String , ? > sharedState , Map < String , ? > options ) { this . subject = subject ; this . callbackHandler = callbackHandler ; this . sharedState = Util . cast ( sharedState ) ; this . options = options ; tryFirstPass = "true" . equalsIgnoreCase ( ( String ) options . get ( "tryFirstPass" ) ) ; useFirstPass = "true" . equalsIgnoreCase ( ( String ) options . get ( "useFirstPass" ) ) ; storePass = "true" . equalsIgnoreCase ( ( String ) options . get ( "storePass" ) ) ; clearPass = "true" . equalsIgnoreCase ( ( String ) options . get ( "clearPass" ) ) ; passwordFile = ( String ) options . get ( "passwordFile" ) ; passwordFileDisplayName = passwordFile ; userSuppliedPasswordFile = true ; if ( passwordFile == null ) { passwordFile = DEFAULT_PASSWORD_FILE_NAME ; userSuppliedPasswordFile = false ; try { System . getProperty ( "java.home" ) ; hasJavaHomePermission = true ; passwordFileDisplayName = passwordFile ; } catch ( SecurityException e ) { hasJavaHomePermission = false ; passwordFileDisplayName = ConnectorBootstrap . DefaultValues . PASSWORD_FILE_NAME ; } } } 
@ Override public String toString ( ) { StringBuilder output = new StringBuilder ( ) ; if ( hasLabels ( ) ) { output . append ( ArrayUtil . toString ( labels , ",-" ) + "-" ) ; } for ( int item = 0 ; item < itemCount ; item ++ ) { output . append ( nf . format ( data [ 0 ] [ item ] ) ) ; for ( int series = 1 ; series < seriesCount ; series ++ ) { output . append ( ",-" + nf . format ( data [ series ] [ item ] ) ) ; } output . append ( "-" ) ; } return output . toString ( ) ; } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; elementList . add ( new javax . xml . namespace . QName ( "" , "header" ) ) ; elementList . add ( localHeader == null ? null : localHeader ) ; return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
public static CamelCxfNamespace fromUri ( String uri ) { return Util . fromUri ( CamelCxfNamespace . class , uri ) ; } 
void checkOpen ( ) throws SQLException { if ( closed ) { throw new SQLException ( Messages . get ( "error.generic.closed" , "Connection" ) , "HY010" ) ; } } 
public boolean update ( String addLog ) { String dateString = new SimpleDateFormat ( "yyyy/MM/dd/-" ) . format ( new Date ( ) ) ; this . log = new StringBuilder ( this . log ) . append ( System . getProperty ( "line.separator" ) ) . append ( dateString ) . append ( addLog ) . toString ( ) ; return PersistItems . PLAY_LOG . save ( this ) ; } 
public void popFunction ( ) { if ( stkFunction != null ) { stkFunction . pop ( ) ; } } 
public boolean postMortem ( PostMortem pm ) { Node that = ( Node ) pm ; if ( that == null ) { JSONzip . log ( "-Misalign" ) ; return false ; } if ( this . integer != that . integer ) { JSONzip . log ( "-Integer-" + this . integer + "-<>-" + that . integer ) ; return false ; } if ( this . next == null ) { if ( that . next == null ) { return true ; } JSONzip . log ( "-Next-is-null-" + this . integer ) ; return false ; } for ( int i = 0 ; i < 256 ; i += 1 ) { Node node = this . next [ i ] ; if ( node != null ) { if ( ! node . postMortem ( that . next [ i ] ) ) { return false ; } } else if ( that . next [ i ] != null ) { JSONzip . log ( "-Misalign-" + i ) ; return false ; } } return true ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
static void appendReducedApostrophes ( String s , int start , int limit , StringBuilder sb ) { int doubleApos = - 1 ; for ( ; ; ) { int i = s . indexOf ( '|'' , start ) ; if ( i < 0 || i >= limit ) { sb . append ( s , start , limit ) ; break ; } if ( i == doubleApos ) { sb . append ( '|'' ) ; ++ start ; doubleApos = - 1 ; } else { sb . append ( s , start , i ) ; doubleApos = start = i + 1 ; } } } 
public Writer newDecoder ( final OutputStream pStream ) { return new Writer ( ) { private final Decoder decoder = new Decoder ( 1024 ) { protected void writeBuffer ( byte [ ] pBytes , int pOffset , int pLen ) throws IOException { pStream . write ( pBytes , pOffset , pLen ) ; } } ; public void close ( ) throws IOException { flush ( ) ; } public void flush ( ) throws IOException { decoder . flush ( ) ; pStream . flush ( ) ; } public void write ( char [ ] cbuf , int off , int len ) throws IOException { decoder . write ( cbuf , off , len ) ; } } ; } 
public AlertDialog create ( ) { final AlertDialog dialog = new AlertDialog ( P . mContext , mTheme , false ) ; P . apply ( dialog . mAlert ) ; dialog . setCancelable ( P . mCancelable ) ; if ( P . mCancelable ) { dialog . setCanceledOnTouchOutside ( true ) ; } dialog . setOnCancelListener ( P . mOnCancelListener ) ; dialog . setOnDismissListener ( P . mOnDismissListener ) ; if ( P . mOnKeyListener != null ) { dialog . setOnKeyListener ( P . mOnKeyListener ) ; } return dialog ; } 
private void parseKey ( String line , int keyStartPos ) { int endKeyPos = line . indexOf ( '=' , keyStartPos ) ; if ( endKeyPos != - 1 ) { mCurrentKey = line . substring ( keyStartPos , endKeyPos ) . trim ( ) ; parseValue ( line , endKeyPos + 1 ) ; } } 
public final int getCurrentExpressionNode ( ) { return m_currentExpressionNodes . peek ( ) ; } 
public boolean containsValue ( Object value ) { if ( value == null ) { for ( LinkedEntry e = header . after ; e != header ; e = e . after ) if ( e . value == null ) return true ; } else { for ( LinkedEntry e = header . after ; e != header ; e = e . after ) if ( value . equals ( e . value ) ) return true ; } return false ; } 
@ Override public double getSum ( ) { return sumImpl . getResult ( ) ; } 
public void setApproveButtonMnemonic ( int mnemonic ) { if ( approveButtonMnemonic == mnemonic ) { return ; } int oldValue = approveButtonMnemonic ; approveButtonMnemonic = mnemonic ; firePropertyChange ( APPROVE_BUTTON_MNEMONIC_CHANGED_PROPERTY , oldValue , approveButtonMnemonic ) ; } 
@ Override public long skip ( long count ) throws IOException { if ( count <= 0 ) { return 0 ; } for ( int i = 0 ; i < count ; i ++ ) { int currentChar = read ( ) ; if ( currentChar == - 1 ) { return i ; } } return count ; } 
protected void dropFewItems ( boolean par1 , int par2 ) { int var3 = this . rand . nextInt ( 3 ) + this . rand . nextInt ( 1 + par2 ) ; int var4 ; for ( var4 = 0 ; var4 < var3 ; ++ var4 ) { this . dropItem ( Item . leather . itemID , 1 ) ; } var3 = this . rand . nextInt ( 3 ) + 1 + this . rand . nextInt ( 1 + par2 ) ; for ( var4 = 0 ; var4 < var3 ; ++ var4 ) { if ( this . isBurning ( ) ) { this . dropItem ( Item . beefCooked . itemID , 1 ) ; } else { this . dropItem ( Item . beefRaw . itemID , 1 ) ; } } } 
public int indexOf ( String namespace , String name , int startIndex ) { int len = getChildCount ( ) ; for ( int i = startIndex ; i < len ; i ++ ) { Element child = getElement ( i ) ; if ( child != null && name . equals ( child . getName ( ) ) && ( namespace == null || namespace . equals ( child . getNamespace ( ) ) ) ) return i ; } return - 1 ; } 
public static boolean isSolarisOS ( ) { String osName = System . getProperty ( "os.name" ) ; return osName != null && osName . toLowerCase ( ) . contains ( "solaris" ) ; } 
public List < CurvePropertyType > getCurveMember ( ) { if ( curveMember == null ) { curveMember = new ArrayList < CurvePropertyType > ( ) ; } return this . curveMember ; } 
protected FloatBuffer createFloatBuffer ( float [ ] data ) { FloatBuffer temp = BufferUtils . createFloatBuffer ( data . length ) . put ( data ) ; temp . flip ( ) ; return temp ; } 
public boolean pop ( String key , Object expectedValue ) { synchronized ( contextMap ) { Object o = contextMap . get ( key ) ; if ( o == null ) { return false ; } if ( o instanceof List ) { if ( ( ( List ) o ) . size ( ) == 0 ) { return false ; } Object top = ( ( List ) o ) . get ( 0 ) ; if ( ! top . equals ( expectedValue ) ) { return false ; } ( ( List ) o ) . remove ( 0 ) ; return true ; } else { throw new RuntimeException ( "Cannot-pop-from-non-List-object-" + o ) ; } } } 
public void delete ( cia . common . db . orm . po . ViwBkeRelationTransLog viwBkeRelationTransLog ) throws org . hibernate . HibernateException { super . delete ( ( Object ) viwBkeRelationTransLog ) ; } 
protected synchronized void resetChecksumChunk ( int size ) { sum . reset ( ) ; this . buf = new byte [ size ] ; this . count = 0 ; } 
public Response serve ( String uri , String method , Properties header , Properties parms , Properties files ) { System . out . println ( method + "-'" + uri + "'-" ) ; Enumeration e = header . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String value = ( String ) e . nextElement ( ) ; System . out . println ( "-HDR:-'" + value + "'-=-'" + header . getProperty ( value ) + "'" ) ; } e = parms . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String value = ( String ) e . nextElement ( ) ; System . out . println ( "-PRM:-'" + value + "'-=-'" + parms . getProperty ( value ) + "'" ) ; } e = files . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { String value = ( String ) e . nextElement ( ) ; System . out . println ( "-UPLOADED:-'" + value + "'-=-'" + files . getProperty ( value ) + "'" ) ; } return serveFile ( uri , header , myRootDir , true ) ; } 
public ArrayList < String > getUsers ( ) throws OHException { ArrayList < String > userIds = null ; String query = "SELECT-DISTINCT(BLP_USR_ID_A)-FROM-BILLPAYMENTS-ORDER-BY-BLP_USR_ID_A-ASC" ; DbQueryLogger dbQuery = new DbQueryLogger ( ) ; try { ResultSet resultSet = dbQuery . getData ( query , true ) ; userIds = new ArrayList < String > ( resultSet . getFetchSize ( ) ) ; while ( resultSet . next ( ) ) { userIds . add ( resultSet . getString ( "BLP_USR_ID_A" ) ) ; } } catch ( SQLException e ) { throw new OHException ( MessageBundle . getMessage ( "angal.sql.problemsoccurredwiththesqlistruction" ) , e ) ; } finally { dbQuery . releaseConnection ( ) ; } return userIds ; } 
public Node getNode ( int index ) { if ( index < 0 || index >= listSize ) throw new IndexOutOfBoundsException ( "Index-out-of-bounds." ) ; Node currentNode ; int startPosition ; int accessIndex ; int step ; if ( index % accessInterval < 5 ) { startPosition = ( index - ( index % accessInterval ) ) ; accessIndex = startPosition / accessInterval ; step = index - startPosition ; currentNode = al . get ( accessIndex ) ; while ( currentNode . hasNext ( ) && step > 0 ) { currentNode = currentNode . next ; -- step ; } } else { startPosition = ( ( index / accessInterval ) + 1 ) * accessInterval ; if ( startPosition == al . size ( ) * accessInterval ) { currentNode = tail ; step = startPosition - index - 1 ; } else { accessIndex = ( startPosition / accessInterval ) ; step = startPosition - index ; currentNode = al . get ( accessIndex ) ; } while ( currentNode . hasPrevious ( ) && step > 0 ) { currentNode = currentNode . previous ; -- step ; } } return currentNode ; } 
@ XmlElement ( name = "exportgroup" ) public List < ExportGroupRestRep > getExports ( ) { if ( exports == null ) { exports = new ArrayList < ExportGroupRestRep > ( ) ; } return exports ; } 
public void clear ( ) { final Object [ ] items = this . items ; final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { for ( int i = takeIndex , k = count ; k > 0 ; i = inc ( i ) , k -- ) items [ i ] = null ; count = 0 ; putIndex = 0 ; takeIndex = 0 ; notFull . signalAll ( ) ; } finally { lock . unlock ( ) ; } } 
private int getLowerDomain ( int n , int m , int k ) { return Math . max ( 0 , m - ( n - k ) ) ; } 
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || this . getClass ( ) != o . getClass ( ) ) { return false ; } return Arrays . equals ( oid , ( ( ObjectIdentifier ) o ) . oid ) ; } 
private HttpMethod getRequestMethod ( String methodName ) { return Enum . valueOf ( HttpMethod . class , methodName . toUpperCase ( ) ) ; } 
private boolean propertyMustBeInitializedByFullName ( Name name ) { if ( name . parent == null ) { return false ; } boolean parentIsAliased = false ; if ( name . parent . aliasingGets > 0 ) { for ( Ref ref : name . parent . getRefs ( ) ) { if ( ref . type == Ref . Type . ALIASING_GET ) { Node aliaser = ref . getNode ( ) . getParent ( ) ; boolean isKnownAlias = aliaser . isCall ( ) && ( convention . getClassesDefinedByCall ( aliaser ) != null || convention . getSingletonGetterClassName ( aliaser ) != null ) ; if ( ! isKnownAlias ) { parentIsAliased = true ; } } } } if ( parentIsAliased ) { return false ; } if ( objectPrototypeProps . contains ( name . getBaseName ( ) ) ) { return false ; } if ( name . parent . type == Name . Type . OBJECTLIT || name . parent . type == Name . Type . CLASS ) { return true ; } return name . parent . type == Name . Type . FUNCTION && name . parent . isDeclaredType ( ) && ! functionPrototypeProps . contains ( name . getBaseName ( ) ) ; } 
public CompositeComponentType addService ( ProvidedService es ) { m_provided . add ( es ) ; return this ; } 
public long getCompletedTaskCount ( ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { long n = completedTaskCount ; for ( Worker w : workers ) n += w . completedTasks ; return n ; } finally { mainLock . unlock ( ) ; } } 
public List < Employee > getEmployee ( ) { if ( employee == null ) { employee = new ArrayList < Employee > ( ) ; } return this . employee ; } 
@ Deprecated public static RequestAsyncTask executeMeRequestAsync ( Session session , GraphUserCallback callback ) { return newMeRequest ( session , callback ) . executeAsync ( ) ; } 
public final void addCallback ( StatusCallback callback ) { synchronized ( callbacks ) { if ( callback != null && ! callbacks . contains ( callback ) ) { callbacks . add ( callback ) ; } } } 
public MockResponse setChunkedBody ( String body , int maxChunkSize ) { try { return setChunkedBody ( body . getBytes ( "UTF-8" ) , maxChunkSize ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( ) ; } } 
static String getPassword ( Configuration conf , String alias ) { String password = null ; try { char [ ] passchars = conf . getPassword ( alias ) ; if ( passchars != null ) { password = new String ( passchars ) ; } } catch ( IOException ioe ) { password = null ; } return password ; } 
protected void parseConfiguration ( ) { DataInputStream in = null ; String host = null ; int port = - 1 ; String http = null ; File file = props . getFile ( CONFIG_P , new File ( "icp.conf" ) ) ; try { in = ( new DataInputStream ( new BufferedInputStream ( new FileInputStream ( file ) ) ) ) ; } catch ( IOException ex ) { System . out . println ( "***-ICP,-unable-to-read-config-file-" + file . getAbsolutePath ( ) ) ; return ; } try { edu . hkust . clap . monitor . Monitor . loopBegin ( 549 ) ; for ( String line = null ; ( line = in . readLine ( ) ) != null ; ) { edu . hkust . clap . monitor . Monitor . loopInc ( 549 ) ; { if ( line . startsWith ( "#" ) || line . length ( ) == 0 ) continue ; StringTokenizer st = new StringTokenizer ( line , "-" ) ; host = st . nextToken ( ) ; port = Integer . parseInt ( st . nextToken ( ) ) ; http = st . nextToken ( ) ; createICPSender ( host , port , http ) ; } } edu . hkust . clap . monitor . Monitor . loopEnd ( 549 ) ; } catch ( Exception ex ) { System . out . println ( "***-ICP,-unable-to-create-" + host + "@" + port + "[" + http + "]:-" + ex . getMessage ( ) ) ; } finally { try { if ( in != null ) in . close ( ) ; } catch ( IOException ex ) { } } } 
public String [ ] getDatabaseColumnNames ( String tableName ) { String [ ] columns = null ; query = "SELECT-*-FROM-`" + tableName + "`" ; long startTime , endTime ; startTime = System . currentTimeMillis ( ) ; endTime = 0 ; try { Statement firstStatement = databaseConnection . createStatement ( ) ; ResultSet answers = firstStatement . executeQuery ( query ) ; ResultSetMetaData answerData = answers . getMetaData ( ) ; columns = new String [ answerData . getColumnCount ( ) ] ; for ( int column = 0 ; column < answerData . getColumnCount ( ) ; column ++ ) { columns [ column ] = answerData . getColumnName ( column + 1 ) ; } answers . close ( ) ; firstStatement . close ( ) ; endTime = System . currentTimeMillis ( ) ; } catch ( SQLException currentException ) { endTime = System . currentTimeMillis ( ) ; columns = new String [ ] { "empty" } ; displayErrors ( currentException ) ; } baseController . getQueryList ( ) . add ( new QueryInfo ( currentQuery , endTime - startTime ) ) ; return columns ; } 
private Date convertStringToDate ( String cp_strQuery ) throws IllegalArgumentException { SimpleDateFormat formatter = new SimpleDateFormat ( this . dateFormats [ DB_Generic_DAO . sqltimestampformat ] ) ; ParsePosition pos = new ParsePosition ( 0 ) ; Date validDate = formatter . parse ( cp_strQuery , pos ) ; if ( validDate == null ) { formatter = new SimpleDateFormat ( "yyyy-MM-dd-HH:mm:ss.S" ) ; pos = new ParsePosition ( 0 ) ; validDate = formatter . parse ( cp_strQuery , pos ) ; } if ( validDate == null ) { formatter = new SimpleDateFormat ( this . dateFormats [ DB_Generic_DAO . guitimestampformat ] ) ; pos = new ParsePosition ( 0 ) ; validDate = formatter . parse ( cp_strQuery , pos ) ; } if ( validDate == null ) { formatter = new SimpleDateFormat ( this . dateFormats [ DB_Generic_DAO . guidateformat ] ) ; pos = new ParsePosition ( 0 ) ; validDate = formatter . parse ( cp_strQuery , pos ) ; if ( validDate == null ) { throw new IllegalArgumentException ( "resolveDate:-DATE-null;-not-a-valid-query-string:-" + cp_strQuery ) ; } } return validDate ; } 
public PathEffect setPathEffect ( PathEffect effect ) { int effectNative = 0 ; if ( effect != null ) { effectNative = effect . native_instance ; } native_setPathEffect ( mNativePaint , effectNative ) ; mPathEffect = effect ; return effect ; } 
public void processingInstruction ( String target , String data ) throws SAXException { super . processingInstruction ( target , data ) ; handleTextEscaping ( ) ; } 
private int [ ] getDateLocal ( ) { if ( hours == - 1 ) { return new int [ ] { year , month , day , - 1 , - 1 , - 1 } ; } if ( localGC == null ) { GregorianCalendar utcGC = new GregorianCalendar ( TimeZone . getTimeZone ( "UTC" ) ) ; utcGC . set ( year , month - 1 , day , hours , minutes , seconds ) ; localGC = new GregorianCalendar ( ) ; localGC . setTime ( utcGC . getTime ( ) ) ; } return new int [ ] { localGC . get ( Calendar . YEAR ) , localGC . get ( Calendar . MONTH ) + 1 , localGC . get ( Calendar . DAY_OF_MONTH ) , localGC . get ( Calendar . HOUR_OF_DAY ) , localGC . get ( Calendar . MINUTE ) , localGC . get ( Calendar . SECOND ) } ; } 
public com . google . protobuf . ByteString getClass_Bytes ( ) { java . lang . Object ref = class__ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; class__ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public static String toHexString ( int i , int pad ) { String result = Integer . toHexString ( i ) . toUpperCase ( ) ; while ( result . length ( ) < pad ) result = "0" + result ; return result ; } 
public void setBytes ( int parameterIndex , byte [ ] x ) throws SQLException { setBytes ( parameterIndex , x , true , true ) ; } 
public MulticastSocket ( SocketAddress localAddress ) throws IOException { super ( localAddress ) ; setReuseAddress ( true ) ; } 
public String distributionList ( ) { System . out . println ( "Enter-Distribution-List-(type-END-on-a-seperate-line-to-stop):-" ) ; String distributionList = "" ; String textLine = "" ; while ( textLine . equalsIgnoreCase ( "End" ) == false ) { textLine = input . nextLine ( ) ; distributionList += textLine + "-" ; } return "-" + distributionList . substring ( 0 , distributionList . length ( ) - 4 ) ; } 
@ Override public void onBackup ( ParcelFileDescriptor oldState , BackupDataOutput data , ParcelFileDescriptor newState ) throws IOException { long savedFileSize = - 1 ; long savedCrc = - 1 ; int savedVersion = - 1 ; DataInputStream in = new DataInputStream ( new FileInputStream ( oldState . getFileDescriptor ( ) ) ) ; try { savedFileSize = in . readLong ( ) ; savedCrc = in . readLong ( ) ; savedVersion = in . readInt ( ) ; } catch ( EOFException e ) { return ; } finally { if ( in != null ) { in . close ( ) ; } } writeBackupState ( savedFileSize , savedCrc , newState ) ; } 
public static final String createWarning ( String msgKey , Object args [ ] ) { return createMsg ( XSLTBundle , msgKey , args ) ; } 
public static Subject getSubject ( final AccessControlContext context ) { checkPermission ( _SUBJECT ) ; if ( context == null ) { throw new NullPointerException ( "auth.09" ) ; } PrivilegedAction < DomainCombiner > action = new PrivilegedAction < DomainCombiner > ( ) { public DomainCombiner run ( ) { return context . getDomainCombiner ( ) ; } } ; DomainCombiner combiner = AccessController . doPrivileged ( action ) ; if ( ( combiner == null ) || ! ( combiner instanceof SubjectDomainCombiner ) ) { return null ; } return ( ( SubjectDomainCombiner ) combiner ) . getSubject ( ) ; } 
public long getN ( ) { return eDA . getNumElements ( ) ; } 
public static Rectangle2D ensureExtent ( Rectangle2D itemEnv , double minExtent ) { double minx = itemEnv . getMinX ( ) ; double maxx = itemEnv . getMaxX ( ) ; double miny = itemEnv . getMinY ( ) ; double maxy = itemEnv . getMaxY ( ) ; if ( minx != maxx && miny != maxy ) return itemEnv ; if ( minx == maxx ) { minx = minx - minExtent / 2.0 ; maxx = minx + minExtent / 2.0 ; } if ( miny == maxy ) { miny = miny - minExtent / 2.0 ; maxy = miny + minExtent / 2.0 ; } Rectangle2D rec = new Rectangle2D . Double ( ) ; rec . setFrameFromDiagonal ( minx , miny , maxx , maxy ) ; return rec ; } 
private void calcFollowList ( CMNode nodeCur ) { if ( nodeCur . type ( ) == XSModelGroupImpl . MODELGROUP_CHOICE ) { calcFollowList ( ( ( XSCMBinOp ) nodeCur ) . getLeft ( ) ) ; calcFollowList ( ( ( XSCMBinOp ) nodeCur ) . getRight ( ) ) ; } else if ( nodeCur . type ( ) == XSModelGroupImpl . MODELGROUP_SEQUENCE ) { calcFollowList ( ( ( XSCMBinOp ) nodeCur ) . getLeft ( ) ) ; calcFollowList ( ( ( XSCMBinOp ) nodeCur ) . getRight ( ) ) ; final CMStateSet last = ( ( XSCMBinOp ) nodeCur ) . getLeft ( ) . lastPos ( ) ; final CMStateSet first = ( ( XSCMBinOp ) nodeCur ) . getRight ( ) . firstPos ( ) ; for ( int index = 0 ; index < fLeafCount ; index ++ ) { if ( last . getBit ( index ) ) fFollowList [ index ] . union ( first ) ; } } else if ( nodeCur . type ( ) == XSParticleDecl . PARTICLE_ZERO_OR_MORE || nodeCur . type ( ) == XSParticleDecl . PARTICLE_ONE_OR_MORE ) { calcFollowList ( ( ( XSCMUniOp ) nodeCur ) . getChild ( ) ) ; final CMStateSet first = nodeCur . firstPos ( ) ; final CMStateSet last = nodeCur . lastPos ( ) ; for ( int index = 0 ; index < fLeafCount ; index ++ ) { if ( last . getBit ( index ) ) fFollowList [ index ] . union ( first ) ; } } else if ( nodeCur . type ( ) == XSParticleDecl . PARTICLE_ZERO_OR_ONE ) { calcFollowList ( ( ( XSCMUniOp ) nodeCur ) . getChild ( ) ) ; } } 
public static VCProjectHolder getVCProjectHolder ( File inputFile , boolean isSolution ) { VCProjectHolder vcProjectHolder = VCPROJECT_HOLDERS . get ( inputFile ) ; if ( vcProjectHolder == null ) { vcProjectHolder = new VCProjectHolder ( inputFile , isSolution , new HashMap < String , String > ( ) ) ; VCPROJECT_HOLDERS . put ( inputFile , vcProjectHolder ) ; } return vcProjectHolder ; } 
public void push ( E element ) { elements . addFirst ( element ) ; } 
private final void loadPattern ( String pattern ) { if ( ! TextUtils . isEmpty ( pattern ) ) { final int hashCode = pattern . hashCode ( ) ; if ( hashCode != mProfilePatternLastHash ) { mProfilePatternLastHash = hashCode ; mMatcher = Pattern . compile ( pattern ) ; mVeiledMatchingEnabled = true ; } } } 
public void testPowNegativeNumToZeroExp ( ) { byte aBytes [ ] = { 50 , - 26 , 90 , 69 , 120 , 32 , 63 , - 103 , - 14 , 35 } ; int aSign = - 1 ; int exp = 0 ; byte rBytes [ ] = { 1 } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . pow ( exp ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = 0 ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( "incorrect-sign" , 1 , result . signum ( ) ) ; } 
public void write ( char cbuf [ ] ) throws IOException { write ( cbuf , 0 , cbuf . length ) ; } 
private boolean compareAndIncrementWorkerCount ( int expect ) { return ctl . compareAndSet ( expect , expect + 1 ) ; } 
ExecutionSummarizer ( String [ ] args ) { startTime = System . currentTimeMillis ( ) ; commandLineArgs = org . apache . commons . lang . StringUtils . join ( args , '-' ) ; } 
public List < Neuron > getNeuron ( ) { if ( neuron == null ) { neuron = new ArrayList < Neuron > ( ) ; } return this . neuron ; } 
public static double roundTo ( double value , double scale ) { return Math . round ( value / scale ) * scale ; } 
public char [ ] getNewLine ( ) { return ( fNewLine != null ) ? fNewLine . toCharArray ( ) : null ; } 
private E awaitMatch ( Node s , Node pred , E e , boolean timed , long nanos ) { final long deadline = timed ? System . nanoTime ( ) + nanos : 0L ; Thread w = Thread . currentThread ( ) ; int spins = - 1 ; ThreadLocalRandom randomYields = null ; for ( ; ; ) { Object item = s . item ; if ( item != e ) { s . forgetContents ( ) ; return LinkedTransferQueue . < E > cast ( item ) ; } if ( ( w . isInterrupted ( ) || ( timed && nanos <= 0 ) ) && s . casItem ( e , s ) ) { unsplice ( pred , s ) ; return e ; } if ( spins < 0 ) { if ( ( spins = spinsFor ( pred , s . isData ) ) > 0 ) randomYields = ThreadLocalRandom . current ( ) ; } else if ( spins > 0 ) { -- spins ; if ( randomYields . nextInt ( CHAINED_SPINS ) == 0 ) Thread . yield ( ) ; } else if ( s . waiter == null ) { s . waiter = w ; } else if ( timed ) { nanos = deadline - System . nanoTime ( ) ; if ( nanos > 0L ) LockSupport . parkNanos ( this , nanos ) ; } else { LockSupport . park ( this ) ; } } } 
public static String convertKeypadLettersToDigits ( String input ) { if ( input == null ) { return input ; } int len = input . length ( ) ; if ( len == 0 ) { return input ; } char [ ] out = input . toCharArray ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = out [ i ] ; out [ i ] = ( char ) KEYPAD_MAP . get ( c , c ) ; } return new String ( out ) ; } 
public static < E extends Comparable < E >> MinMaxPriorityQueue < E > create ( ) { return new Builder < Comparable > ( Ordering . natural ( ) ) . create ( ) ; } 
public ArrayList < Location > getPath ( ) { MoveLocation stepBefore = parent ; ArrayList < Location > path = new ArrayList < Location > ( ) ; path . add ( new Location ( this ) ) ; do { path . add ( 0 , new Location ( stepBefore ) ) ; stepBefore = stepBefore . parent ; } while ( stepBefore != null ) ; path . remove ( 0 ) ; return path ; } 
public static byte [ ] encode ( final byte [ ] input , final int flags ) { return Base64 . encode ( input , 0 , input . length , flags ) ; } 
public void setSelected ( ButtonModel model , boolean value ) { if ( value ) { if ( model == getSelected ( ) ) return ; selectNewModel ( model ) ; } else { if ( model != getSelected ( ) ) return ; if ( getDefault ( ) == null ) return ; getDefault ( ) . setSelected ( true ) ; } } 
@ Override public void removeGroups ( ) { synchronized ( groups ) { groups . clear ( ) ; } } 
public boolean equals ( Object p_test ) { if ( p_test instanceof URI ) { URI testURI = ( URI ) p_test ; if ( ( ( m_scheme == null && testURI . m_scheme == null ) || ( m_scheme != null && testURI . m_scheme != null && m_scheme . equals ( testURI . m_scheme ) ) ) && ( ( m_userinfo == null && testURI . m_userinfo == null ) || ( m_userinfo != null && testURI . m_userinfo != null && m_userinfo . equals ( testURI . m_userinfo ) ) ) && ( ( m_host == null && testURI . m_host == null ) || ( m_host != null && testURI . m_host != null && m_host . equals ( testURI . m_host ) ) ) && m_port == testURI . m_port && ( ( m_path == null && testURI . m_path == null ) || ( m_path != null && testURI . m_path != null && m_path . equals ( testURI . m_path ) ) ) && ( ( m_queryString == null && testURI . m_queryString == null ) || ( m_queryString != null && testURI . m_queryString != null && m_queryString . equals ( testURI . m_queryString ) ) ) && ( ( m_fragment == null && testURI . m_fragment == null ) || ( m_fragment != null && testURI . m_fragment != null && m_fragment . equals ( testURI . m_fragment ) ) ) ) { return true ; } } return false ; } 
public static DateMidnight parse ( String str , DateTimeFormatter formatter ) { return formatter . parseDateTime ( str ) . toDateMidnight ( ) ; } 
private static List < String > parseAndCompare ( List < String > fileNames , int masterPartitionId ) { List < String > sourceFileNames = new ArrayList < String > ( ) ; for ( String fileName : fileNames ) { String [ ] partitionIdReplicaChunk = fileName . split ( SPLIT_LITERAL ) ; if ( Integer . parseInt ( partitionIdReplicaChunk [ 0 ] ) == masterPartitionId ) { sourceFileNames . add ( fileName ) ; } } return sourceFileNames ; } 
static public void assertBaselineAligned ( View first , View second ) { int [ ] xy = new int [ 2 ] ; first . getLocationOnScreen ( xy ) ; int firstTop = xy [ 1 ] + first . getBaseline ( ) ; second . getLocationOnScreen ( xy ) ; int secondTop = xy [ 1 ] + second . getBaseline ( ) ; assertEquals ( "views-are-not-baseline-aligned" , firstTop , secondTop ) ; } 
protected void eol ( byte [ ] in , int sz ) throws IOException { int next = ConsoleNote . findPreamble ( in , 0 , sz ) ; int written = 0 ; while ( next >= 0 ) { if ( next > written ) { out . write ( in , written , next - written ) ; written = next ; } else { assert next == written ; } int rest = sz - next ; ByteArrayInputStream b = new ByteArrayInputStream ( in , next , rest ) ; ConsoleNote . skip ( new DataInputStream ( b ) ) ; int bytesUsed = rest - b . available ( ) ; written += bytesUsed ; next = ConsoleNote . findPreamble ( in , written , sz - written ) ; } out . write ( in , written , sz - written ) ; } 
@ ConstructorProperties ( { "point1" , "color1" , "point2" , "color2" , "cyclic" } ) public GradientPaint ( Point2D pt1 , Color color1 , Point2D pt2 , Color color2 , boolean cyclic ) { this ( pt1 , color1 , pt2 , color2 ) ; this . cyclic = cyclic ; } 
public double hypot ( double a , double b ) { double r = 0 ; if ( Math . abs ( a ) > Math . abs ( b ) ) { r = b / a ; r = Math . abs ( a ) * Math . sqrt ( 1 + r * r ) ; } else if ( b != 0 ) { r = a / b ; r = Math . abs ( b ) * Math . sqrt ( 1 + r * r ) ; } return r ; } 
public Object becomeRoot ( Object newRoot , Object oldRoot ) { Tree newRootTree = ( Tree ) newRoot ; Tree oldRootTree = ( Tree ) oldRoot ; if ( oldRoot == null ) { return newRoot ; } if ( newRootTree . isNil ( ) ) { int nc = newRootTree . getChildCount ( ) ; if ( nc == 1 ) newRootTree = ( Tree ) newRootTree . getChild ( 0 ) ; else if ( nc > 1 ) { throw new RuntimeException ( "more-than-one-node-as-root-(TODO:-make-exception-hierarchy)" ) ; } } newRootTree . addChild ( oldRootTree ) ; return newRootTree ; } 
public void parse ( InputStream is , HandlerBase hb , String systemId ) throws SAXException , IOException { if ( is == null ) { throw new IllegalArgumentException ( "InputStream-cannot-be-null" ) ; } InputSource input = new InputSource ( is ) ; input . setSystemId ( systemId ) ; this . parse ( input , hb ) ; } 
public static String divide ( int a , int b ) { int real = a / b ; int r = a % b ; String decimal = "" ; HashMap < Integer , Integer > remainders = new HashMap < Integer , Integer > ( ) ; int i = 0 ; while ( r != 0 ) { if ( ! remainders . containsKey ( r ) ) { remainders . put ( r , i ) ; } else { decimal = decimal . substring ( 0 , remainders . get ( r ) ) + '(' + decimal . substring ( remainders . get ( r ) , decimal . length ( ) ) ; break ; } r *= 10 ; int digit = r / b ; r = r % b ; decimal += digit ; i ++ ; } if ( r != 0 ) { decimal += ')' ; } return real + "." + decimal ; } 
protected static void rollFile ( String from , String to ) { File target = new File ( to ) ; if ( target . exists ( ) ) { LogLog . debug ( "deleting-existing-target-file:-" + target ) ; target . delete ( ) ; } File file = new File ( from ) ; file . renameTo ( target ) ; LogLog . debug ( from + "-->-" + to ) ; } 
protected void endNode ( Node node ) throws org . xml . sax . SAXException { switch ( node . getNodeType ( ) ) { case Node . DOCUMENT_NODE : break ; case Node . ELEMENT_NODE : String ns = m_dh . getNamespaceOfNode ( node ) ; if ( null == ns ) ns = "" ; this . m_contentHandler . endElement ( ns , m_dh . getLocalNameOfNode ( node ) , node . getNodeName ( ) ) ; NamedNodeMap atts = ( ( Element ) node ) . getAttributes ( ) ; int nAttrs = atts . getLength ( ) ; for ( int i = 0 ; i < nAttrs ; i ++ ) { Node attr = atts . item ( i ) ; String attrName = attr . getNodeName ( ) ; if ( attrName . equals ( "xmlns" ) || attrName . startsWith ( "xmlns:" ) ) { int index ; String prefix = ( index = attrName . indexOf ( ":" ) ) < 0 ? "" : attrName . substring ( index + 1 ) ; this . m_contentHandler . endPrefixMapping ( prefix ) ; } } break ; case Node . CDATA_SECTION_NODE : break ; case Node . ENTITY_REFERENCE_NODE : { EntityReference eref = ( EntityReference ) node ; if ( m_contentHandler instanceof LexicalHandler ) { LexicalHandler lh = ( ( LexicalHandler ) this . m_contentHandler ) ; lh . endEntity ( eref . getNodeName ( ) ) ; } } break ; default : } } 
public Rectangle getPathBounds ( JTree a , TreePath b ) { Rectangle returnValue = ( ( TreeUI ) ( uis . elementAt ( 0 ) ) ) . getPathBounds ( a , b ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( TreeUI ) ( uis . elementAt ( i ) ) ) . getPathBounds ( a , b ) ; } return returnValue ; } 
public boolean isPruefungBis ( ) { if ( pruefung == null ) return false ; if ( pruefung . length ( ) <= 0 ) return false ; if ( pruefung . charAt ( 0 ) == '<' ) return true ; return false ; } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; elementList . add ( new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2010-11-15/" , "vpnConnectionId" ) ) ; if ( localVpnConnectionId != null ) { elementList . add ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( localVpnConnectionId ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "vpnConnectionId-cannot-be-null!!" ) ; } return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
public String getBoundary ( ) { try { return new String ( _boundary , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { System . err . println ( "UTF-8-not-supported?!-" + e ) ; return null ; } } 
public static File normalize ( String name , File input ) { File outputFile ; if ( Options . getDir ( ) == null ) if ( input == null || input . getParent ( ) == null ) outputFile = new File ( name ) ; else outputFile = new File ( input . getParent ( ) , name ) ; else outputFile = new File ( Options . getDir ( ) , name ) ; if ( outputFile . exists ( ) && ! Options . no_backup ) { File backup = new File ( outputFile . toString ( ) + "~" ) ; if ( backup . exists ( ) ) backup . delete ( ) ; if ( outputFile . renameTo ( backup ) ) Out . println ( "Old-file-"" + outputFile + ""-saved-as-"" + backup + """ ) ; else Out . println ( "Couldn't-save-old-file-"" + outputFile + "",-overwriting!" ) ; } return outputFile ; } 
public boolean isOp ( ) { return _prefix . indexOf ( '@' ) >= 0 ; } 
public String getString ( String key , String backup ) { String value = get ( key ) ; return value == null ? backup : value ; } 
ByteBuffer put ( float [ ] src , int off , int len ) { int length = src . length ; if ( off < 0 || len < 0 || ( long ) off + ( long ) len > length ) { throw new IndexOutOfBoundsException ( ) ; } if ( len << 2 > remaining ( ) ) { throw new BufferOverflowException ( ) ; } if ( isReadOnly ( ) ) { throw new ReadOnlyBufferException ( ) ; } boolean swap = order ( ) != ByteOrder . nativeOrder ( ) ; getBaseAddress ( ) . setFloatArray ( offset + position , src , off , len , swap ) ; position += len << 2 ; return this ; } 
private StringBuilder appendIfNotNull ( StringBuilder source , String addStr , String delimiter ) { if ( addStr != null ) { if ( addStr . length ( ) == 0 ) { delimiter = "" ; } return source . append ( addStr ) . append ( delimiter ) ; } return source ; } 
@ Nullable protected < T > GridFuture < T > asyncOpAcquire ( ) { try { if ( asyncOpsSem != null ) asyncOpsSem . acquire ( ) ; return null ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; return new GridFinishedFutureEx < > ( new GridInterruptedException ( "Failed-to-wait-for-asynchronous-" + "operation-permit-(thread-got-interrupted)." , e ) ) ; } } 
public static boolean isValidName ( String name ) { if ( name == null ) { return false ; } return name . length ( ) > 3 ; } 
public void setFG ( Graphics g , Component c ) { Style s = c . getStyle ( ) ; g . setFont ( s . getFont ( ) ) ; if ( c . isEnabled ( ) ) { g . setColor ( s . getFgColor ( ) ) ; } else { g . setColor ( disableColor ) ; } } 
@ Override protected Byte _get ( ByteBuffer buffer , int index ) { return buffer . get ( index ) ; } 
public void initializeFromDOM ( ResourceCollection resourceCollection , Element source , String group ) { this . resourceCollection = resourceCollection ; name = source . getAttribute ( ResourceItem . ATTRIBUTE_PROPERTY_NAME ) ; if ( group != null ) { name = group + ResourceItem . GROUP_DELIMITER + name ; } } 
public void setDocument ( File file ) { if ( file == null ) { throw new IllegalArgumentException ( "Null-file" ) ; } if ( ! file . isFile ( ) ) { String msg = "Input-document-not-found:-" + file ; LOG . error ( msg ) ; throw new IllegalStateException ( msg ) ; } documentFile = file ; LOG . debug ( String . format ( "Input-document-set-to-'%s'" , documentFile ) ) ; retrieveNamespaces ( ) ; } 
public static int binarySearch ( short [ ] array , int startIndex , int endIndex , short value ) { checkBinarySearchBounds ( startIndex , endIndex , array . length ) ; int lo = startIndex ; int hi = endIndex - 1 ; while ( lo <= hi ) { int mid = ( lo + hi ) >>> 1 ; short midVal = array [ mid ] ; if ( midVal < value ) { lo = mid + 1 ; } else if ( midVal > value ) { hi = mid - 1 ; } else { return mid ; } } return ~ lo ; } 
private static SparseBooleanArray parseColumns ( String sequence ) { SparseBooleanArray columns = new SparseBooleanArray ( ) ; Pattern pattern = Pattern . compile ( "|s*,|s*" ) ; String [ ] columnDefs = pattern . split ( sequence ) ; for ( String columnIdentifier : columnDefs ) { try { int columnIndex = Integer . parseInt ( columnIdentifier ) ; if ( columnIndex >= 0 ) { columns . put ( columnIndex , true ) ; } } catch ( NumberFormatException e ) { } } return columns ; } 
public static void copyFromZipFile ( File src , File dst ) throws IOException { ZipInputStream in = new ZipInputStream ( new BufferedInputStream ( new FileInputStream ( src ) , 4096 ) ) ; ZipEntry entry = in . getNextEntry ( ) ; copyStream ( in , - 1 , dst ) ; in . close ( ) ; } 
public boolean isBlock ( ) { return tag . isBlock ( ) ; } 
public Map < String , String > getHeaders ( ) throws AuthFailureError { return Collections . emptyMap ( ) ; } 
public static void main ( String args [ ] ) { int [ ] input = { 1 , 2 , 3 } ; System . out . println ( "Input:-" + Arrays . toString ( input ) ) ; System . out . println ( "Permutations:-" + permute ( input ) . toString ( ) ) ; } 
public void lockInterruptibly ( ) throws InterruptedException { sync . acquireInterruptibly ( 1 ) ; } 
public String getToolTipText ( MouseEvent evt ) { String tip = null ; final TreePath path = getPathForLocation ( evt . getX ( ) , evt . getY ( ) ) ; if ( path != null ) { tip = path . getLastPathComponent ( ) . toString ( ) ; } else { tip = super . getToolTipText ( ) ; } return tip ; } 
public Rectangle getBounds ( ) { return getCachedBounds ( ) . getBounds ( ) ; } 
public DTM getRTFDTM ( ) { SAX2RTFDTM rtfdtm ; if ( m_rtfdtm_stack == null ) { m_rtfdtm_stack = new Vector ( ) ; rtfdtm = ( SAX2RTFDTM ) m_dtmManager . getDTM ( null , true , null , false , false ) ; m_rtfdtm_stack . addElement ( rtfdtm ) ; ++ m_which_rtfdtm ; } else if ( m_which_rtfdtm < 0 ) { rtfdtm = ( SAX2RTFDTM ) m_rtfdtm_stack . elementAt ( ++ m_which_rtfdtm ) ; } else { rtfdtm = ( SAX2RTFDTM ) m_rtfdtm_stack . elementAt ( m_which_rtfdtm ) ; if ( rtfdtm . isTreeIncomplete ( ) ) { if ( ++ m_which_rtfdtm < m_rtfdtm_stack . size ( ) ) rtfdtm = ( SAX2RTFDTM ) m_rtfdtm_stack . elementAt ( m_which_rtfdtm ) ; else { rtfdtm = ( SAX2RTFDTM ) m_dtmManager . getDTM ( null , true , null , false , false ) ; m_rtfdtm_stack . addElement ( rtfdtm ) ; } } } return rtfdtm ; } 
public final CharBuffer decode ( ByteBuffer buffer ) { try { return newDecoder ( ) . onMalformedInput ( CodingErrorAction . REPLACE ) . onUnmappableCharacter ( CodingErrorAction . REPLACE ) . decode ( buffer ) ; } catch ( CharacterCodingException ex ) { throw new Error ( ex . getMessage ( ) , ex ) ; } } 
public void mousePressed ( MouseEvent event ) { int modifiers = event . getModifiers ( ) ; int buttonEvent ; if ( modifiers == event . BUTTON1_MASK ) buttonEvent = GWindow . BUTTON1_DOWN ; else if ( modifiers == event . BUTTON2_MASK ) buttonEvent = GWindow . BUTTON2_DOWN ; else buttonEvent = GWindow . BUTTON3_DOWN ; window_ . mousePressed ( buttonEvent , event . getX ( ) , event . getY ( ) ) ; } 
public void pushTransform ( ) { predraw ( ) ; FloatBuffer buffer ; if ( stackIndex >= stack . size ( ) ) { buffer = BufferUtils . createFloatBuffer ( 18 ) ; stack . add ( buffer ) ; } else { buffer = ( FloatBuffer ) stack . get ( stackIndex ) ; } GL . glGetFloat ( SGL . GL_MODELVIEW_MATRIX , buffer ) ; buffer . put ( 16 , sx ) ; buffer . put ( 17 , sy ) ; stackIndex ++ ; postdraw ( ) ; } 
public void setIcon ( Icon newIcon ) { Object oldIcon = icon ; icon = newIcon ; firePropertyChange ( ICON_PROPERTY , oldIcon , icon ) ; } 
public RelType getRelation ( Interval < E > other ) { if ( other == null ) return RelType . NONE ; int comp11 = this . first . compareTo ( other . first ( ) ) ; int comp22 = this . second . compareTo ( other . second ( ) ) ; if ( comp11 == 0 ) { if ( comp22 == 0 ) { return RelType . EQUAL ; } if ( comp22 < 0 ) { return RelType . INSIDE ; } else { return RelType . CONTAIN ; } } else if ( comp22 == 0 ) { if ( comp11 < 0 ) { return RelType . CONTAIN ; } else { return RelType . INSIDE ; } } else if ( comp11 > 0 && comp22 < 0 ) { return RelType . INSIDE ; } else if ( comp11 < 0 && comp22 > 0 ) { return RelType . CONTAIN ; } else { int comp12 = this . first . compareTo ( other . second ( ) ) ; int comp21 = this . second . compareTo ( other . first ( ) ) ; if ( comp12 > 0 ) { return RelType . AFTER ; } else if ( comp21 < 0 ) { return RelType . BEFORE ; } else if ( comp12 == 0 ) { return RelType . BEGIN_MEET_END ; } else if ( comp21 == 0 ) { return RelType . END_MEET_BEGIN ; } else { return RelType . OVERLAP ; } } } 
public static double getStandardDeviation ( ArrayList < Integer > list ) { double average = getArithmeticAverage ( list ) ; double result = 0.0 ; Iterator < Integer > iterator = list . iterator ( ) ; while ( iterator . hasNext ( ) ) { int item = iterator . next ( ) ; result += ( item - average ) * ( item - average ) ; } result = result / ( list . size ( ) - 1 ) ; result = Math . sqrt ( result ) ; return result ; } 
void sendDatagram ( byte [ ] data ) throws Exception { if ( data == null || data . length == 0 ) throw new IllegalArgumentException ( "data-must-not-be-null-or-empty" ) ; try { final InetAddress ipAddress = InetAddress . getByName ( host ) ; final DatagramPacket packet = new DatagramPacket ( data , data . length , ipAddress , sendPort ) ; final DatagramSocket socket = new DatagramSocket ( ) ; socket . send ( packet ) ; socket . close ( ) ; } catch ( SocketException e ) { throw new Exception ( e ) ; } catch ( UnknownHostException e ) { throw new Exception ( "Could-not-resolve-host:-" + host , e ) ; } catch ( IOException e ) { throw new Exception ( e ) ; } } 
@ XmlElementDecl ( namespace = "http://www.retailbilling.com" , name = "uniqueid" ) public JAXBElement < String > createUniqueid ( String value ) { return new JAXBElement < String > ( _Uniqueid_QNAME , String . class , null , value ) ; } 
protected Map < String , String > getPostParams ( ) throws AuthFailureError { return getParams ( ) ; } 
@ Path ( "/orders/{orderId}/" ) public Order getOrder ( @ PathParam ( "orderId" ) String orderId ) { LOG . info ( "Invoking-getOrder,-Order-id-is:-{}" , orderId ) ; long idNumber = Long . parseLong ( orderId ) ; Order c = orders . get ( idNumber ) ; return c ; } 
private void pruneIfNeeded ( int neededSpace ) { if ( ( mTotalSize + neededSpace ) < mMaxCacheSizeInBytes ) { return ; } if ( VolleyLog . DEBUG ) { VolleyLog . v ( "Pruning-old-cache-entries." ) ; } long before = mTotalSize ; int prunedFiles = 0 ; long startTime = SystemClock . elapsedRealtime ( ) ; Iterator < Map . Entry < String , CacheHeader >> iterator = mEntries . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , CacheHeader > entry = iterator . next ( ) ; CacheHeader e = entry . getValue ( ) ; boolean deleted = getFileForKey ( e . key ) . delete ( ) ; if ( deleted ) { mTotalSize -= e . size ; } else { VolleyLog . d ( "Could-not-delete-cache-entry-for-key=%s,-filename=%s" , e . key , getFilenameForKey ( e . key ) ) ; } iterator . remove ( ) ; prunedFiles ++ ; if ( ( mTotalSize + neededSpace ) < mMaxCacheSizeInBytes * HYSTERESIS_FACTOR ) { break ; } } if ( VolleyLog . DEBUG ) { VolleyLog . v ( "pruned-%d-files,-%d-bytes,-%d-ms" , prunedFiles , ( mTotalSize - before ) , SystemClock . elapsedRealtime ( ) - startTime ) ; } } 
public String getNegativePrefix ( ) { return ndf . getNegativePrefix ( ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
private static final Configuration getDefaultProvider ( ) { return new Configuration ( ) { @ Override public void refresh ( ) { } @ Override public AppConfigurationEntry [ ] getAppConfigurationEntry ( String applicationName ) { return new AppConfigurationEntry [ 0 ] ; } } ; } 
public void drawLine ( float startX , float startY , float stopX , float stopY , Paint paint ) { native_drawLine ( mNativeCanvas , startX , startY , stopX , stopY , paint . mNativePaint ) ; } 
public int length ( ) { return namesAndValues . size ( ) / 2 ; } 
public void setFileView ( FileView fileView ) { FileView oldValue = this . fileView ; this . fileView = fileView ; firePropertyChange ( FILE_VIEW_CHANGED_PROPERTY , oldValue , fileView ) ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
private void initButtonsPanel ( ) { buttonPanel = new JPanel ( ) ; buttonPanel . setLayout ( new BoxLayout ( buttonPanel , BoxLayout . X_AXIS ) ) ; buttonPanel . add ( Box . createHorizontalGlue ( ) ) ; JButton jbSavePrefs = new JButton ( "Save-Preferences" ) ; jbSavePrefs . addActionListener ( new SavePreferencesAction ( ) ) ; buttonPanel . add ( jbSavePrefs ) ; buttonPanel . add ( Box . createHorizontalGlue ( ) ) ; JButton jbRestoreDefaults = new JButton ( "Restore-Defaults" ) ; jbRestoreDefaults . addActionListener ( new RestoreDefaultsAction ( ) ) ; buttonPanel . add ( jbRestoreDefaults ) ; buttonPanel . add ( Box . createHorizontalGlue ( ) ) ; Border outsideBorder = BorderFactory . createCompoundBorder ( BorderFactory . createRaisedBevelBorder ( ) , BorderFactory . createLoweredBevelBorder ( ) ) ; Border insideBorder = BorderFactory . createEmptyBorder ( 9 , 5 , 5 , 5 ) ; buttonPanel . setBorder ( BorderFactory . createCompoundBorder ( outsideBorder , insideBorder ) ) ; } 
public static void i ( String tag , String s , Object ... args ) { if ( LOG . INFO >= LOGLEVEL ) Log . i ( tag , String . format ( s , args ) ) ; } 
Location getLocationNear ( long offset ) { int blockIndex = readerBCF . getBlockIndexNear ( offset ) ; if ( blockIndex == - 1 ) return end ; return new Location ( blockIndex , 0 ) ; } 
@ Override public Object clone ( ) { try { return super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new InternalError ( ) ; } } 
private void filterCurrentWorkspaceItems ( long currentScreenId , ArrayList < ItemInfo > allWorkspaceItems , ArrayList < ItemInfo > currentScreenItems , ArrayList < ItemInfo > otherScreenItems ) { Iterator < ItemInfo > iter = allWorkspaceItems . iterator ( ) ; while ( iter . hasNext ( ) ) { ItemInfo i = iter . next ( ) ; if ( i == null ) { iter . remove ( ) ; } } Set < Long > itemsOnScreen = new HashSet < Long > ( ) ; Collections . sort ( allWorkspaceItems , new Comparator < ItemInfo > ( ) { @ Override public int compare ( ItemInfo lhs , ItemInfo rhs ) { return ( int ) ( lhs . container - rhs . container ) ; } } ) ; for ( ItemInfo info : allWorkspaceItems ) { if ( info . container == LauncherSettings . Favorites . CONTAINER_DESKTOP ) { if ( info . screenId == currentScreenId ) { currentScreenItems . add ( info ) ; itemsOnScreen . add ( info . id ) ; } else { otherScreenItems . add ( info ) ; } } else if ( info . container == LauncherSettings . Favorites . CONTAINER_HOTSEAT ) { currentScreenItems . add ( info ) ; itemsOnScreen . add ( info . id ) ; } else { if ( itemsOnScreen . contains ( info . container ) ) { currentScreenItems . add ( info ) ; itemsOnScreen . add ( info . id ) ; } else { otherScreenItems . add ( info ) ; } } } } 
public boolean contains ( JComponent a , int b , int c ) { boolean returnValue = ( ( ComponentUI ) ( uis . elementAt ( 0 ) ) ) . contains ( a , b , c ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . contains ( a , b , c ) ; } return returnValue ; } 
public int compare ( Rectangle rect1 , Rectangle rect2 ) { switch ( sortingBy ) { case Area : return rect2 . Area ( ) . compareTo ( rect1 . Area ( ) ) ; case Width : return rect2 . GetWidth ( ) . compareTo ( rect1 . GetWidth ( ) ) ; case Height : return rect2 . GetHeight ( ) . compareTo ( rect1 . GetHeight ( ) ) ; } throw new RuntimeException ( "Natrafilem-na-zly-case-|-DescRectComparator" ) ; } 
public V remove ( Object key1 , Object key2 ) { Entry < E , K , V > e = removeEntry ( key1 , key2 ) ; return null != e ? e . value : null ; } 
public void run ( ) { logger . info ( "{}-thread-started" , Thread . currentThread ( ) . getName ( ) ) ; while ( true ) { try { Socket socket = server . accept ( ) ; initializeConnection ( socket ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } } 
public static < K , V > Map < K , V > removeAll ( Map < K , V > m , Collection < K > itemsToRemove ) { for ( Iterator it = itemsToRemove . iterator ( ) ; it . hasNext ( ) ; ) { Object item = it . next ( ) ; m . remove ( item ) ; } return m ; } 
public void setAttributesToGet ( java . util . Collection < String > attributesToGet ) { if ( attributesToGet == null ) { this . attributesToGet = null ; return ; } java . util . List < String > attributesToGetCopy = new java . util . ArrayList < String > ( attributesToGet . size ( ) ) ; attributesToGetCopy . addAll ( attributesToGet ) ; this . attributesToGet = attributesToGetCopy ; } 
public void put ( Object key , Action action ) { if ( key == null ) { return ; } if ( action == null ) { remove ( key ) ; } else { if ( arrayTable == null ) { arrayTable = new ArrayTable ( ) ; } arrayTable . put ( key , action ) ; } } 
public ZipFile ( String name ) throws IOException { this ( new File ( name ) , OPEN_READ ) ; } 
public Node chooseRandom ( String scope ) { netlock . readLock ( ) . lock ( ) ; try { if ( scope . startsWith ( "~" ) ) { return chooseRandom ( NodeBase . ROOT , scope . substring ( 1 ) ) ; } else { return chooseRandom ( scope , null ) ; } } finally { netlock . readLock ( ) . unlock ( ) ; } } 
public static String oauthDecode ( String value ) throws DecoderException { if ( value == null ) { return "" ; } try { return new String ( URLCodec . decodeUrl ( value . getBytes ( "US-ASCII" ) ) , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } 
private void appendEventData ( final String data ) { EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { eventData . append ( data + '|n' ) ; } } ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
protected void append ( Node newNode ) throws org . xml . sax . SAXException { Node currentNode = m_currentNode ; if ( null != currentNode ) { currentNode . appendChild ( newNode ) ; } else if ( null != m_docFrag ) { m_docFrag . appendChild ( newNode ) ; } else { boolean ok = true ; short type = newNode . getNodeType ( ) ; if ( type == Node . TEXT_NODE ) { String data = newNode . getNodeValue ( ) ; if ( ( null != data ) && ( data . trim ( ) . length ( ) > 0 ) ) { throw new org . xml . sax . SAXException ( "Warning:-can't-output-text-before-document-element!-Ignoring..." ) ; } ok = false ; } else if ( type == Node . ELEMENT_NODE ) { if ( m_doc . getDocumentElement ( ) != null ) { throw new org . xml . sax . SAXException ( "Can't-have-more-than-one-root-on-a-DOM!" ) ; } } if ( ok ) m_doc . appendChild ( newNode ) ; } } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public final void setInteger ( String name , int value ) { mMap . put ( name , Integer . valueOf ( value ) ) ; } 
protected void sendEndOfHeader ( OutputStream out ) throws IOException { LOG . trace ( "enter-sendEndOfHeader(OutputStream-out)" ) ; out . write ( CRLF_BYTES ) ; out . write ( CRLF_BYTES ) ; } 
public static String joinString ( Object [ ] str , String delimiter , int initialIndex ) { if ( str . length == 0 ) { return "" ; } StringBuilder buffer = new StringBuilder ( str [ initialIndex ] . toString ( ) ) ; for ( int i = initialIndex + 1 ; i < str . length ; ++ i ) { buffer . append ( delimiter ) . append ( str [ i ] . toString ( ) ) ; } return buffer . toString ( ) ; } 
@ Override synchronized boolean isComparableTypeValid ( ObjectName object , String attribute , Comparable < ? > value ) { final CounterMonitorObservedObject o = ( CounterMonitorObservedObject ) getObservedObject ( object ) ; if ( o == null ) return false ; if ( value instanceof Integer ) { o . setType ( INTEGER ) ; } else if ( value instanceof Byte ) { o . setType ( BYTE ) ; } else if ( value instanceof Short ) { o . setType ( SHORT ) ; } else if ( value instanceof Long ) { o . setType ( LONG ) ; } else { return false ; } return true ; } 
public static final int getTabbedTextWidth ( Segment s , FontMetrics metrics , int x , TabExpander e , int startOffset ) { return getTabbedTextWidth ( null , s , metrics , x , e , startOffset , null ) ; } 
public static void saveStores ( ) throws IOException { try { File keyStoreDirectory = new File ( keyStoreLocation ) . getParentFile ( ) ; if ( ! keyStoreDirectory . exists ( ) ) keyStoreDirectory . mkdirs ( ) ; keyStore . store ( new FileOutputStream ( keyStoreLocation ) , keypass . toCharArray ( ) ) ; if ( s2sTrustStore != null ) { File s2sTrustStoreDirectory = new File ( s2sTrustStoreLocation ) . getParentFile ( ) ; if ( ! s2sTrustStoreDirectory . exists ( ) ) s2sTrustStoreDirectory . mkdirs ( ) ; s2sTrustStore . store ( new FileOutputStream ( s2sTrustStoreLocation ) , s2sTrustpass . toCharArray ( ) ) ; } if ( c2sTrustStore != null && c2sTrustStore != s2sTrustStore ) { File c2sTrustStoreDirectory = new File ( c2sTrustStoreLocation ) . getParentFile ( ) ; if ( ! c2sTrustStoreDirectory . exists ( ) ) c2sTrustStoreDirectory . mkdirs ( ) ; c2sTrustStore . store ( new FileOutputStream ( c2sTrustStoreLocation ) , c2sTrustpass . toCharArray ( ) ) ; } } catch ( IOException e ) { throw e ; } catch ( Exception e ) { throw new IOException ( e . getMessage ( ) ) ; } } 
public static ComponentUI createUI ( JComponent c ) { return new SynthViewportUI ( ) ; } 
public String nextTo ( char delimiter ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = this . next ( ) ; if ( c == delimiter || c == 0 || c == '|n' || c == '|r' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } } 
protected void playStepSound ( int par1 , int par2 , int par3 , int par4 ) { this . playSound ( "mob.skeleton.step" , 0.15F , 1.0F ) ; } 
PosixSemaphore initPosixSem ( ) { String [ ] key = new String [ 3 ] ; UUID uid ; for ( int i = 0 ; i < 3 ; i ++ ) { uid = UUID . randomUUID ( ) ; key [ i ] = uid . toString ( ) ; } return new PosixSemaphore ( key ) ; } 
public static void saveChartAsPNG ( File file , JFreeChart chart , int width , int height , ChartRenderingInfo info ) throws IOException { ParamChecks . nullNotPermitted ( file , "file" ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; try { ChartUtilities . writeChartAsPNG ( out , chart , width , height , info ) ; } finally { out . close ( ) ; } } 
public void broadcast ( Connection connection , BasePacket message , boolean sendSelf ) { Iterator < Connection > iter = connections . iterator ( ) ; while ( iter . hasNext ( ) ) { Connection con = iter . next ( ) ; if ( ! con . preloading ( ) && ( sendSelf || ! connection . id ( ) . equals ( con . id ( ) ) ) ) { con . send ( message ) ; } } } 
private void register ( Map < String , Class < ? extends SaslClientFactory >> providerMap ) { for ( Map . Entry < String , Class < ? extends SaslClientFactory >> me : providerMap . entrySet ( ) ) { put ( "SaslClientFactory." + me . getKey ( ) , me . getValue ( ) . getName ( ) ) ; } } 
private static String cleanAlias ( String alias ) { char [ ] chars = alias . toCharArray ( ) ; if ( ! Character . isLetter ( chars [ 0 ] ) ) { for ( int i = 1 ; i < chars . length ; i ++ ) { if ( Character . isLetter ( chars [ i ] ) ) { return alias . substring ( i ) ; } } } return alias ; } 
public void nextKey ( ) throws IOException { while ( hasNext ) { readNextKey ( ) ; } ++ ctr ; KEY tmpKey = key ; key = nextKey ; nextKey = tmpKey ; hasNext = more ; } 
private void makeConnection ( ) { try { InitialContext ic = new InitialContext ( ) ; DataSource ds = ( DataSource ) ic . lookup ( dbName ) ; con = ds . getConnection ( ) ; } catch ( Exception ex ) { throw new EJBException ( "Unable-to-connect-to-database.-" + ex . getMessage ( ) ) ; } } 
public void addLiteralResultAttribute ( AVT avt ) { if ( null == m_avts ) m_avts = new ArrayList ( ) ; m_avts . add ( avt ) ; } 
public void addTreeModelListener ( TreeModelListener l ) { if ( ! fModelListeners . contains ( l ) ) fModelListeners . addElement ( l ) ; } 
public static int getMaxVideoDuration ( Context context ) { int duration = 0 ; try { duration = context . getResources ( ) . getInteger ( R . integer . max_video_recording_length ) ; } catch ( Resources . NotFoundException ex ) { } return duration ; } 
public String getNegativePrefix ( ) { return ndf . getNegativePrefix ( ) ; } 
private void scanFile ( File f , Map < String , TimeNSize > scanInfoMap , int depth ) { try { if ( ! f . exists ( ) ) return ; if ( f . isFile ( ) || depth > 0 && _reportDirs && f . isDirectory ( ) ) { if ( ( _filter == null ) || ( ( _filter != null ) && _filter . accept ( f . getParentFile ( ) , f . getName ( ) ) ) ) { String name = f . getCanonicalPath ( ) ; scanInfoMap . put ( name , new TimeNSize ( f . lastModified ( ) , f . length ( ) ) ) ; } } if ( f . isDirectory ( ) && ( depth < _scanDepth || _scanDepth == - 1 || _scanDirs . contains ( f ) ) ) { File [ ] files = f . listFiles ( ) ; if ( files != null ) { for ( int i = 0 ; i < files . length ; i ++ ) scanFile ( files [ i ] , scanInfoMap , depth + 1 ) ; } else LOG . warn ( "Error-listing-files-in-directory-{}" , f ) ; } } catch ( IOException e ) { LOG . warn ( "Error-scanning-watched-files" , e ) ; } } 
protected static String makeOptionString ( Script script ) { StringBuffer result ; Enumeration enm ; Option option ; result = new StringBuffer ( "" ) ; result . append ( "-Help-requested:-" ) ; result . append ( "-h-or--help-" ) ; result . append ( "-Displays-this-help-screen.-" ) ; result . append ( "-s-<file>-" ) ; result . append ( "-The-script-to-execute.-" ) ; enm = script . listOptions ( ) ; while ( enm . hasMoreElements ( ) ) { option = ( Option ) enm . nextElement ( ) ; result . append ( option . synopsis ( ) + '|n' ) ; result . append ( option . description ( ) + "-" ) ; } result . append ( "-" ) ; result . append ( "Any-additional-options-are-passed-on-to-the-script-as-" ) ; result . append ( "command-line-parameters.-" ) ; result . append ( "-" ) ; return result . toString ( ) ; } 
protected Class < ? > loadClass ( String className , boolean resolve ) throws ClassNotFoundException { Class < ? > clazz = findLoadedClass ( className ) ; if ( clazz == null ) { try { clazz = parent . loadClass ( className , false ) ; } catch ( ClassNotFoundException e ) { } if ( clazz == null ) { clazz = findClass ( className ) ; } } return clazz ; } 
public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . out . println ( "-Usage:-" + DataSource . class . getName ( ) + "-<file>-" ) ; System . exit ( 1 ) ; } DataSource loader = new DataSource ( args [ 0 ] ) ; System . out . println ( "Incremental?-" + loader . isIncremental ( ) ) ; System . out . println ( "Loader:-" + loader . getLoader ( ) . getClass ( ) . getName ( ) ) ; System . out . println ( "Data:-" ) ; Instances structure = loader . getStructure ( ) ; System . out . println ( structure ) ; while ( loader . hasMoreElements ( structure ) ) System . out . println ( loader . nextElement ( structure ) ) ; Instances inst = loader . getDataSet ( ) ; loader = new DataSource ( inst ) ; System . out . println ( "-Proxy-Data:-" ) ; System . out . println ( loader . getStructure ( ) ) ; while ( loader . hasMoreElements ( structure ) ) System . out . println ( loader . nextElement ( inst ) ) ; } 
public synchronized void setSendBufferSize ( int size ) throws SocketException { if ( ! ( size > 0 ) ) { throw new IllegalArgumentException ( "negative-send-size" ) ; } if ( isClosed ( ) ) throw new SocketException ( "Socket-is-closed" ) ; getImpl ( ) . setOption ( SocketOptions . SO_SNDBUF , new Integer ( size ) ) ; } 
private Vector < Object > generateDefaultParams ( String methodname ) throws InvalidKeyException , IllegalStateException , NoSuchAlgorithmException { String nonce = generateNonce ( ) ; long timestamp = System . currentTimeMillis ( ) ; String hashString = Long . toString ( timestamp ) + ";" + serviceDomain + ";" + nonce + ";" + methodname ; String hash = generateHmacHash ( hashString ) ; Vector < Object > params = new Vector < Object > ( ) ; params . add ( hash ) ; params . add ( this . serviceDomain ) ; params . add ( Long . toString ( timestamp ) ) ; params . add ( nonce ) ; params . add ( this . sessionID ) ; return params ; } 
public void startPrefixMapping ( String prefix , String uri ) throws org . xml . sax . SAXException { startPrefixMapping ( prefix , uri , true ) ; } 
public void removeMap ( String mapId ) { IndexInformation info = cache . remove ( mapId ) ; if ( info != null ) { totalMemoryUsed . addAndGet ( - info . getSize ( ) ) ; if ( ! queue . remove ( mapId ) ) { LOG . warn ( "Map-ID" + mapId + "-not-found-in-queue!!" ) ; } } else { LOG . info ( "Map-ID-" + mapId + "-not-found-in-cache" ) ; } } 
public Builder setTitle ( int titleId ) { P . mTitle = P . mContext . getText ( titleId ) ; return this ; } 
public static Type < TimeBlockClickHandler < ? >> getType ( ) { if ( TYPE == null ) { TYPE = new Type < TimeBlockClickHandler < ? >> ( ) ; } return TYPE ; } 
public static String extractActivityName ( String fullActivityName , String packageName ) { if ( packageName != null && fullActivityName != null ) { if ( packageName . length ( ) > 0 && fullActivityName . startsWith ( packageName ) ) { String name = fullActivityName . substring ( packageName . length ( ) ) ; if ( name . length ( ) > 0 && name . charAt ( 0 ) == '.' ) { return name ; } } } return fullActivityName ; } 
protected final void sendTraversalRequestLocked ( ) { mHandler . post ( new Runnable ( ) { @ Override public void run ( ) { mListener . onTraversalRequested ( ) ; } } ) ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public List < DataVariable > getDataVariableForRequest ( ) { List < DataVariable > dvs = new ArrayList < DataVariable > ( ) ; for ( Iterator el = dataVariables . iterator ( ) ; el . hasNext ( ) ; ) { DataVariable dv = ( DataVariable ) el . next ( ) ; String keyS = dv . getId ( ) . toString ( ) ; dvs . add ( dv ) ; } return dvs ; } 
public void setSubjectPublicKeyAlgID ( String sigId ) throws IOException { if ( sigId != null ) { try { OID oid = new OID ( sigId ) ; int [ ] comp = oid . getIDs ( ) ; if ( ! checkOid ( comp ) ) throw new IOException ( "malformed-OID:-" + sigId ) ; this . sigId = oid ; } catch ( IllegalArgumentException iae ) { IOException ioe = new IOException ( "malformed-OID:-" + sigId ) ; ioe . initCause ( iae ) ; throw ioe ; } } else this . sigId = null ; } 
public void validate ( ) throws ParseException { for ( Node child : children ) { if ( child instanceof Element ) { Element element = ( Element ) child ; String name = element . getName ( ) ; if ( doctype == null ) { throw new ParseException ( ParseException . Error . DOCTYPE_NOT_SET , name ) ; } if ( doctype . getElementDecl ( name ) == null ) { throw new ParseException ( ParseException . Error . ELEMENT_NOT_DECLARED , name ) ; } element . validate ( ) ; } } } 
public Enumeration getKeys ( ) { ResourceBundle parent = this . parent ; return new ResourceBundleEnumeration ( lookup . keySet ( ) , ( parent != null ) ? parent . getKeys ( ) : null ) ; } 
public void setAsText ( String text ) throws java . lang . IllegalArgumentException { if ( value instanceof String ) { setValue ( text ) ; return ; } throw new java . lang . IllegalArgumentException ( text ) ; } 
private InputStream reset ( InputStream in ) throws IOException { Trace . beginSection ( "create-stream" ) ; if ( in == null ) { in = mKey . createInputStream ( ) ; } else if ( in . markSupported ( ) ) { in . reset ( ) ; } else { try { in . close ( ) ; } catch ( IOException ex ) { } in = mKey . createInputStream ( ) ; } Trace . endSection ( ) ; return in ; } 
@ Override public final int read ( ) throws IOException { return Util . readSingleByte ( this ) ; } 
private synchronized void removeLock ( FileLock lock ) { locks . remove ( lock ) ; } 
public static String printLong ( long val ) { return theConverter . printLong ( val ) ; } 
int select ( SelectableChannel channel , int ops , long timeout ) throws IOException { SelectorInfo info = get ( channel ) ; SelectionKey key = null ; int ret = 0 ; try { while ( true ) { long start = ( timeout == 0 ) ? 0 : Time . now ( ) ; key = channel . register ( info . selector , ops ) ; ret = info . selector . select ( timeout ) ; if ( ret != 0 ) { return ret ; } if ( timeout > 0 ) { timeout -= Time . now ( ) - start ; if ( timeout <= 0 ) { return 0 ; } } if ( Thread . currentThread ( ) . isInterrupted ( ) ) { throw new InterruptedIOException ( "Interruped-while-waiting-for-" + "IO-on-channel-" + channel + ".-" + timeout + "-millis-timeout-left." ) ; } } } finally { if ( key != null ) { key . cancel ( ) ; } try { info . selector . selectNow ( ) ; } catch ( IOException e ) { LOG . info ( "Unexpected-Exception-while-clearing-selector-:-" , e ) ; info . close ( ) ; return ret ; } release ( info ) ; } } 
public void detach ( ) { super . detach ( ) ; m_exprObj . detach ( ) ; m_exprObj = null ; } 
public static boolean testSaveLocationExists ( ) { String sDCardStatus = Environment . getExternalStorageState ( ) ; boolean status ; if ( sDCardStatus . equals ( Environment . MEDIA_MOUNTED ) ) { status = true ; } else { status = false ; } return status ; } 
final public SnmpString getSnmpStringValue ( ) throws ClassCastException { return ( SnmpString ) this . value ; } 
public int getTypedFirstChild ( int nodeHandle , int nodeType ) { int firstChild , eType ; if ( nodeType < DTM . NTYPES ) { for ( firstChild = _firstch ( makeNodeIdentity ( nodeHandle ) ) ; firstChild != DTM . NULL ; firstChild = _nextsib ( firstChild ) ) { eType = _exptype ( firstChild ) ; if ( eType == nodeType || ( eType >= DTM . NTYPES && m_expandedNameTable . getType ( eType ) == nodeType ) ) { return makeNodeHandle ( firstChild ) ; } } } else { for ( firstChild = _firstch ( makeNodeIdentity ( nodeHandle ) ) ; firstChild != DTM . NULL ; firstChild = _nextsib ( firstChild ) ) { if ( _exptype ( firstChild ) == nodeType ) { return makeNodeHandle ( firstChild ) ; } } } return DTM . NULL ; } 
public static String dumpStackTrace ( int level ) { StackTraceElement [ ] elems = Thread . currentThread ( ) . getStackTrace ( ) ; level = ( level == 0 ? elems . length : Math . min ( level + 3 , elems . length ) ) ; String ret = new String ( ) ; for ( int i = 3 ; i < level ; i ++ ) { ret = ret + "-" + elems [ i ] . toString ( ) + '|n' ; } return ret ; } 
private static boolean getBrightnessMode ( Context context ) { try { int brightnessMode = Settings . System . getInt ( context . getContentResolver ( ) , Settings . System . SCREEN_BRIGHTNESS_MODE ) ; return brightnessMode == Settings . System . SCREEN_BRIGHTNESS_MODE_AUTOMATIC ; } catch ( Exception e ) { Log . d ( TAG , "getBrightnessMode:-" + e ) ; } return false ; } 
void makeAbsorbing ( int state ) { LinkedList < Integer > loop = new LinkedList < Integer > ( ) ; loop . add ( state ) ; LinkedList < Function > one = new LinkedList < Function > ( ) ; one . add ( functionFactory . getOne ( ) ) ; transitionTargets . set ( state , loop ) ; transitionProbs . set ( state , one ) ; } 
public synchronized void stopListening ( ) { if ( mListening ) { mContext . unregisterReceiver ( mReceiver ) ; mContext = null ; mNetworkInfo = null ; mOtherNetworkInfo = null ; mIsFailover = false ; mReason = null ; mListening = false ; } } 
public static float swapFloat ( float value ) { return Float . intBitsToFloat ( swapInteger ( Float . floatToIntBits ( value ) ) ) ; } 
@ Nonnull public static Event createEventForCodePointFromUnknownSource ( final int codePoint ) { return new Event ( EVENT_TYPE_INPUT_KEYPRESS , null , codePoint , NOT_A_KEY_CODE , Constants . NOT_A_COORDINATE , Constants . NOT_A_COORDINATE , null , FLAG_NONE , null ) ; } 
private void swap ( int pIndex , int cIndex ) throws IndexOutOfBoundsException { try { Comparable temp = heap . get ( pIndex ) ; heap . set ( pIndex , heap . get ( cIndex ) ) ; heap . set ( cIndex , temp ) ; } catch ( IndexOutOfBoundsException e ) { System . err . println ( e ) ; System . exit ( - 1 ) ; } } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public static Set < TypeElement > typesIn ( Set < ? extends Element > elements ) { return setFilter ( elements , TYPE_KINDS , TypeElement . class ) ; } 
public void reorderListOfAllShapes ( List < String > idsList ) { if ( idsList == null ) throw new IllegalArgumentException ( "list-of-ids-is-null" ) ; else if ( idsList . size ( ) < shapes . size ( ) ) throw new IllegalArgumentException ( "Ordered-list-of-ids-does-not-have-enough-members!-Required:-" + shapes . size ( ) + ",-Given:-" + idsList . size ( ) ) ; List < S > newList = new ArrayList < S > ( shapes . size ( ) ) ; for ( String id : idsList ) { if ( id == null || "" . equals ( id . trim ( ) ) ) continue ; for ( S shape : shapes ) { if ( id . equals ( shape . getResourceId ( ) ) && ! newList . contains ( shape ) ) { newList . add ( shape ) ; break ; } } } if ( newList . size ( ) != shapes . size ( ) ) throw new IllegalArgumentException ( "Number-of-elements-in-new-list-differs-from-number-of-actual-shapes!-New:-" + newList . size ( ) + ",-Old:-" + shapes . size ( ) ) ; shapes = newList ; } 
private void processIoRequest ( ) { statistics . ioOper ++ ; Process p = cpu . getActive ( ) ; p . cpuLeft ( clock ) ; p . ioQS ( clock ) ; if ( io . addProcess ( p ) ) { p . ioS ( clock ) ; eventQueue . insertEvent ( new Event ( END_IO , clock + io . getAvgIo ( ) ) ) ; System . out . println ( "endIO" ) ; } } 
@ XmlElementDecl ( namespace = "http://xmlns.oracle.com/apps/cdm/foundation/parties/personService/" , name = "PersonFirstName" , scope = AdditionalPersonName . class ) public JAXBElement < String > createAdditionalPersonNamePersonFirstName ( String value ) { return new JAXBElement < String > ( _AdditionalPersonNamePersonFirstName_QNAME , String . class , AdditionalPersonName . class , value ) ; } 
public Complex minusReverse ( double x ) { return new Complex ( x - re , - im ) ; } 
public static void print ( char x ) { out . print ( x ) ; out . flush ( ) ; } 
public static Date filetimeToDate ( final long filetime ) { final long ms_since_16010101 = filetime / ( 1000 * 10 ) ; final long ms_since_19700101 = ms_since_16010101 - EPOCH_DIFF ; return new Date ( ms_since_19700101 ) ; } 
public void seekStart ( long offset ) throws IOException { if ( _is != null ) _is . getChannel ( ) . position ( offset ) ; } 
public boolean clipPath ( Path path ) { return clipPath ( path , Region . Op . INTERSECT ) ; } 
public void setLastUpdDate ( String lastUpdDate ) { this . lastUpdDate = lastUpdDate == null ? null : lastUpdDate . trim ( ) ; } 
public void addSubjectAlternativeName ( int tag , byte [ ] name ) throws IOException { GeneralName alt_name = new GeneralName ( tag , name ) ; if ( subjectAltNames == null ) { subjectAltNames = new ArrayList [ 9 ] ; } if ( subjectAltNames [ tag ] == null ) { subjectAltNames [ tag ] = new ArrayList ( ) ; } subjectAltNames [ tag ] . add ( alt_name ) ; } 
public static String encode ( BigInteger big ) { return encode ( getBytes ( big , big . bitLength ( ) ) ) ; } 
public String getFieldDisplayName ( String fieldName ) { for ( Iterator iter = getKeyValues ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { KeyValue klp = ( KeyValue ) iter . next ( ) ; if ( klp . getKey ( ) . equals ( fieldName ) ) { return klp . getValue ( ) ; } } return "Error" ; } 
private static Uri . Builder getProviderUriBuilder ( final String path ) { return new Uri . Builder ( ) . scheme ( ContentResolver . SCHEME_CONTENT ) . authority ( DictionaryPackConstants . AUTHORITY ) . appendPath ( path ) ; } 
public static void appendColumns ( StringBuilder s , String [ ] columns ) { int n = columns . length ; for ( int i = 0 ; i < n ; i ++ ) { String column = columns [ i ] ; if ( column != null ) { if ( i > 0 ) { s . append ( ",-" ) ; } s . append ( column ) ; } } s . append ( '-' ) ; } 
public boolean getReuseAddress ( ) throws SocketException { checkClosedAndCreate ( true ) ; return ( ( Boolean ) impl . getOption ( SocketOptions . SO_REUSEADDR ) ) . booleanValue ( ) ; } 
@ Override public void addSecurityReference ( String name , String link ) { try { referencesLock . writeLock ( ) . lock ( ) ; references . put ( name , link ) ; } finally { referencesLock . writeLock ( ) . unlock ( ) ; } fireContainerEvent ( "addSecurityReference" , name ) ; } 
public XMLGregorianCalendar newXMLGregorianCalendar ( final int year , final int month , final int day , final int hour , final int minute , final int second , final int millisecond , final int timezone ) { BigInteger realYear = ( year != DatatypeConstants . FIELD_UNDEFINED ) ? BigInteger . valueOf ( ( long ) year ) : null ; BigDecimal realMillisecond = null ; if ( millisecond != DatatypeConstants . FIELD_UNDEFINED ) { if ( millisecond < 0 || millisecond > 1000 ) { throw new IllegalArgumentException ( "javax.xml.datatype.DatatypeFactory#newXMLGregorianCalendar(" + "int-year,-int-month,-int-day,-int-hour,-int-minute,-int-second,-int-millisecond,-int-timezone)" + "with-invalid-millisecond:-" + millisecond ) ; } realMillisecond = BigDecimal . valueOf ( ( long ) millisecond ) . movePointLeft ( 3 ) ; } return newXMLGregorianCalendar ( realYear , month , day , hour , minute , second , realMillisecond , timezone ) ; } 
public int getBookOrd ( String sname ) { if ( mBookMap . containsKey ( sname ) ) { return mBookMap . get ( sname ) . getOrd ( ) ; } return - 1 ; } 
public static QName valueOf ( String qNameAsString ) { if ( qNameAsString == null ) { throw new IllegalArgumentException ( "cannot-create-QName-from-"null"-or-""-String" ) ; } if ( qNameAsString . length ( ) == 0 ) { return new QName ( XMLConstants . NULL_NS_URI , qNameAsString , XMLConstants . DEFAULT_NS_PREFIX ) ; } if ( qNameAsString . charAt ( 0 ) != '{' ) { return new QName ( XMLConstants . NULL_NS_URI , qNameAsString , XMLConstants . DEFAULT_NS_PREFIX ) ; } if ( qNameAsString . startsWith ( "{" + XMLConstants . NULL_NS_URI + "}" ) ) { throw new IllegalArgumentException ( "Namespace-URI-.equals(XMLConstants.NULL_NS_URI),-" + ".equals("" + XMLConstants . NULL_NS_URI + ""),-" + "only-the-local-part,-" + """ + qNameAsString . substring ( 2 + XMLConstants . NULL_NS_URI . length ( ) ) + "",-" + "should-be-provided." ) ; } int endOfNamespaceURI = qNameAsString . indexOf ( '}' ) ; if ( endOfNamespaceURI == - 1 ) { throw new IllegalArgumentException ( "cannot-create-QName-from-"" + qNameAsString + "",-missing-closing-"}"" ) ; } return new QName ( qNameAsString . substring ( 1 , endOfNamespaceURI ) , qNameAsString . substring ( endOfNamespaceURI + 1 ) , XMLConstants . DEFAULT_NS_PREFIX ) ; } 
public Column findColumn ( final List < Column > columns , final String column ) { for ( final Column c : columns ) { if ( c . getName ( ) . equals ( column . toLowerCase ( ) ) ) { return c ; } } return null ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public final Object readObject ( ) throws OptionalDataException , ClassNotFoundException , IOException { return readObject ( false ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
protected void printError ( String type , SAXParseException ex ) { System . err . print ( "[" ) ; System . err . print ( type ) ; System . err . print ( "]-" ) ; String systemId = ex . getSystemId ( ) ; if ( systemId != null ) { int index = systemId . lastIndexOf ( '/' ) ; if ( index != - 1 ) systemId = systemId . substring ( index + 1 ) ; System . err . print ( systemId ) ; } System . err . print ( ':' ) ; System . err . print ( ex . getLineNumber ( ) ) ; System . err . print ( ':' ) ; System . err . print ( ex . getColumnNumber ( ) ) ; System . err . print ( ":-" ) ; System . err . print ( ex . getMessage ( ) ) ; System . err . println ( ) ; System . err . flush ( ) ; } 
public Field getFieldByNumber ( int number , String being ) { if ( this . tags == null || this . tags . isEmpty ( ) ) return null ; for ( final Iterator < Tag > it = tags . iterator ( ) ; it . hasNext ( ) ; ) { final Tag t = ( Tag ) it . next ( ) ; if ( t . isNumber ( number ) ) { final Field f = t . getField ( ) ; if ( f == null ) { throw new RuntimeException ( "Unable-to-create-field-for-tagname-" + t . getName ( ) ) ; } else { if ( f . is ( being ) ) { return f ; } } } } return null ; } 
public int getVisibility ( ) { return mView . getVisibility ( ) ; } 
private int externalInterruptibleAwaitDone ( ) throws InterruptedException { int s ; if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; if ( ( s = status ) >= 0 && ( s = ( ( this instanceof CountedCompleter ) ? ForkJoinPool . common . externalHelpComplete ( ( CountedCompleter < ? > ) this , 0 ) : ForkJoinPool . common . tryExternalUnpush ( this ) ? doExec ( ) : 0 ) ) >= 0 ) { while ( ( s = status ) >= 0 ) { if ( U . compareAndSwapInt ( this , STATUS , s , s | SIGNAL ) ) { synchronized ( this ) { if ( status >= 0 ) wait ( 0L ) ; else notifyAll ( ) ; } } } } return s ; } 
public void setEnableDeadlockDetection ( boolean useEagerDeadlockDetection ) { this . deadlockDetection . setEnabled ( useEagerDeadlockDetection ) ; } 
public java . util . ArrayList getAllChildren ( ) { java . util . ArrayList list = new java . util . ArrayList ( ) ; list . add ( _Annotationsopt ) ; list . add ( _package ) ; list . add ( _PackageName ) ; list . add ( _SEMICOLON ) ; return list ; } 
public GoogleDriveService buildService ( ) { if ( ! connected || credential == null ) { return null ; } if ( service == null ) { service = new Drive . Builder ( httpTransport , jsonFactory , credential ) . setApplicationName ( "VideoDescApp" ) . build ( ) ; } return new GoogleDriveService ( this , service ) ; } 
public String nextTo ( String delimiters ) throws JSONException { char c ; StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { c = this . next ( ) ; if ( delimiters . indexOf ( c ) >= 0 || c == 0 || c == '|n' || c == '|r' ) { if ( c != 0 ) { this . back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } } 
public Dimension getMinimumSize ( JComponent a ) { Dimension returnValue = ( ( ComponentUI ) ( uis . elementAt ( 0 ) ) ) . getMinimumSize ( a ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . getMinimumSize ( a ) ; } return returnValue ; } 
protected final void walk ( File startDirectory , Collection results ) throws IOException { if ( startDirectory == null ) { throw new NullPointerException ( "Start-Directory-is-null" ) ; } try { handleStart ( startDirectory , results ) ; walk ( startDirectory , 0 , results ) ; handleEnd ( results ) ; } catch ( CancelException cancel ) { handleCancelled ( startDirectory , results , cancel ) ; } } 
public Collection < Node > adjacentNodes ( ) { if ( adjacentNodes == null ) { adjacentNodes = graph . adjacentNodesFrom ( this ) ; } return adjacentNodes ; } 
public static JComponent createScrollPaneCorner ( ) { return new ImageBasedJComponent ( new ImageIcon ( IAppWidgetFactory . class . getResource ( "/com/explodingpixels/macwidgets/images/iapp_scrollpane_corner.png" ) ) . getImage ( ) ) ; } 
public void drawRoundRect ( int x , int y , int width , int height , int arcWidth , int arcHeight ) { DebugGraphicsInfo info = info ( ) ; if ( debugLog ( ) ) { info ( ) . log ( toShortString ( ) + "-Drawing-round-rect:-" + new Rectangle ( x , y , width , height ) + "-arcWidth:-" + arcWidth + "-archHeight:-" + arcHeight ) ; } if ( isDrawingBuffer ( ) ) { if ( debugBuffered ( ) ) { Graphics debugGraphics = debugGraphics ( ) ; debugGraphics . drawRoundRect ( x , y , width , height , arcWidth , arcHeight ) ; debugGraphics . dispose ( ) ; } } else if ( debugFlash ( ) ) { Color oldColor = getColor ( ) ; int i , count = ( info . flashCount * 2 ) - 1 ; for ( i = 0 ; i < count ; i ++ ) { graphics . setColor ( ( i % 2 ) == 0 ? info . flashColor : oldColor ) ; graphics . drawRoundRect ( x , y , width , height , arcWidth , arcHeight ) ; Toolkit . getDefaultToolkit ( ) . sync ( ) ; sleep ( info . flashTime ) ; } graphics . setColor ( oldColor ) ; } graphics . drawRoundRect ( x , y , width , height , arcWidth , arcHeight ) ; } 
public void characters ( char [ ] ch , int start , int length ) { if ( inDoc ) { String chunk = new String ( ch , start , length ) ; if ( currentText == null ) currentText = chunk ; else currentText += chunk ; } } 
int getFieldWidth ( ) { return currentFormatField . length ( ) ; } 
@ Deprecated public static FileStatus getFileStatus ( Configuration conf , URI cache ) throws IOException { FileSystem fileSystem = FileSystem . get ( cache , conf ) ; return fileSystem . getFileStatus ( new Path ( cache . getPath ( ) ) ) ; } 
public static DetailedState getDetailedStateOf ( SupplicantState suppState ) { return stateMap . get ( suppState ) ; } 
public Short getShort ( String key , Short defaultValue ) { Object value = getKey ( key ) ; if ( value instanceof Short ) return ( Short ) value ; else if ( value instanceof String ) return new Short ( interpolate ( ( String ) value ) ) ; else if ( value == null ) return defaultValue ; else throw new ClassCastException ( "Key-'" + key + "'-doesn't-map-to-a-Short-object" ) ; } 
public static < K , V > SortedMap < K , V > sortedMap ( ) { return new TreeMap < K , V > ( ) ; } 
public void write ( String aString ) { int stringLength = aString . length ( ) ; aString . getChars ( 0 , stringLength , stringChars , 0 ) ; int mod = stringLength % 4 ; int pad = 4 - mod ; for ( int i = 0 ; i < pad ; i ++ ) stringChars [ stringLength ++ ] = 0 ; for ( int i = 0 ; i < stringLength ; i ++ ) { stringBytes [ i ] = ( byte ) ( stringChars [ i ] & 0x00FF ) ; } stream . write ( stringBytes , 0 , stringLength ) ; } 
public void setContent ( Widget content ) { this . content = content ; this . content . addStyleName ( STYLE_CONTENT ) ; this . fireEvent ( new DialogInitializeEvent ( ) ) ; } 
public String [ ] getTrueMetas ( final Properties featureConfig ) { final ArrayList < String > trueMetas = new ArrayList < String > ( ) ; final Enumeration < ? > keys = featureConfig . propertyNames ( ) ; while ( keys . hasMoreElements ( ) ) { final String key = ( String ) keys . nextElement ( ) ; if ( key . matches ( "[a-zA-Z]+_feat_enabled" ) && featureConfig . getProperty ( key ) . equals ( "true" ) ) trueMetas . add ( key . substring ( 0 , key . indexOf ( "_feat_enabled" ) ) ) ; } final String [ ] ret = new String [ trueMetas . size ( ) ] ; trueMetas . toArray ( ret ) ; return ret ; } 
private static String deescape ( String str ) { char [ ] ch = str . toCharArray ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < ch . length ; i ++ ) { if ( ch [ i ] == '/' ) { i ++ ; switch ( ch [ i ] ) { case 'c' : sb . append ( ',' ) ; break ; case 'n' : sb . append ( '|n' ) ; break ; case '/' : sb . append ( '/' ) ; break ; } } else { sb . append ( ch [ i ] ) ; } } return sb . toString ( ) ; } 
@ XmlElementDecl ( namespace = "http://www.devspringsoftware.com" , name = "DropDomainStaticString" ) public JAXBElement < DropDomainStaticStringType > createDropDomainStaticString ( DropDomainStaticStringType value ) { return new JAXBElement < DropDomainStaticStringType > ( _DropDomainStaticString_QNAME , DropDomainStaticStringType . class , null , value ) ; } 
public T visitInstructions ( List < Instruction > instructions ) { int oldIndexInst = indexInst ; T result = null ; for ( indexInst = 0 ; indexInst < instructions . size ( ) && result == null ; indexInst ++ ) { Instruction inst = instructions . get ( indexInst ) ; result = doSwitch ( inst ) ; } indexInst = oldIndexInst ; return result ; } 
public static void setConfiguration ( Configuration configuration ) { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) sm . checkPermission ( new AuthPermission ( "setLoginConfiguration" ) ) ; Configuration . configuration = configuration ; } 
public synchronized void close ( ) throws IOException { if ( journalWriter == null ) { return ; } for ( Entry entry : new ArrayList < Entry > ( lruEntries . values ( ) ) ) { if ( entry . currentEditor != null ) { entry . currentEditor . abort ( ) ; } } trimToSize ( ) ; journalWriter . close ( ) ; journalWriter = null ; } 
public static String checksum ( File file , String algorithm ) throws IOException { InputStream in = null ; String chkSum = null ; try { in = new FileInputStream ( file ) ; chkSum = checksum ( in , algorithm ) ; } finally { if ( in != null ) { in . close ( ) ; } } return chkSum ; } 
public InitialLdapContext ( ) throws NamingException { this ( null , null ) ; } 
public synchronized void connect ( org . omg . CORBA . Object servant ) { checkShutdownState ( ) ; if ( getTOAFactory ( ) == null ) throw wrapper . noToa ( ) ; try { String codebase = javax . rmi . CORBA . Util . getCodebase ( servant . getClass ( ) ) ; getTOAFactory ( ) . getTOA ( codebase ) . connect ( servant ) ; } catch ( Exception ex ) { throw wrapper . orbConnectError ( ex ) ; } } 
public boolean equals ( Object object ) { if ( ! ( object instanceof ObjectInstance ) ) { return false ; } ObjectInstance val = ( ObjectInstance ) object ; if ( ! name . equals ( val . getObjectName ( ) ) ) return false ; if ( className == null ) return ( val . getClassName ( ) == null ) ; return className . equals ( val . getClassName ( ) ) ; } 
public String getText12 ( ) { return ( ( String ) getCachedValue ( ResourceField . TEXT12 ) ) ; } 
public Object [ ] toArray ( ) { Object [ ] rv = new Object [ delegate . size ( ) ] ; delegate . copyInto ( rv ) ; return rv ; } 
private void show ( Cursor cursor ) { this . cursor = cursor ; if ( tempId == cursor . getLong ( cursor . getColumnIndex ( DbHelper . KEY_ROWID ) ) ) { } else { listPhoneBook . add ( new PhoneBook ( BitmapFactory . decodeResource ( getResources ( ) , R . drawable . place_holder ) , cursor . getString ( cursor . getColumnIndex ( DbHelper . KEY_NAME ) ) , cursor . getString ( cursor . getColumnIndex ( DbHelper . KEY_MOBILE_1 ) ) , cursor . getString ( cursor . getColumnIndex ( DbHelper . KEY_GROUP ) ) ) ) ; } } 
public static boolean getCompressOutput ( JobConf conf ) { return conf . getBoolean ( org . apache . hadoop . mapreduce . lib . output . FileOutputFormat . COMPRESS , false ) ; } 
public List < Type > getConstraints ( TypeVar tv , ConstraintKind ck ) { return List . nil ( ) ; } 
public void drawBlackStone ( Graphics2D g , short x , short y ) { Shape c = new Ellipse2D . Double ( x , y , 1 , 1 ) ; g . setPaint ( Color . black ) ; g . draw ( c ) ; g . fill ( c ) ; } 
public void load ( RandomAccessFile f ) { map = new boolean [ 4096 ] ; try { f . seek ( fileOffset ) ; for ( int b = 0 ; b < 512 ; b ++ ) { byte thisByte = f . readByte ( ) ; int offset = b * 8 ; int mask = 128 ; for ( int bit = 0 ; bit < 8 ; bit ++ ) { map [ offset + bit ] = ( ( thisByte & mask ) == mask ) ; mask >>= 1 ; } } loaded = true ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } 
public String getSchema ( ) { return childNode . getAttribute ( "schema" ) ; } 
@ XmlElementDecl ( namespace = "http://www.niso.org/2008/ncip" , name = "ItemDescriptionLevel" ) public JAXBElement < SchemeValuePair > createItemDescriptionLevel ( SchemeValuePair value ) { return new JAXBElement < SchemeValuePair > ( _ItemDescriptionLevel_QNAME , SchemeValuePair . class , null , value ) ; } 
public int getHourOfDay ( ) { return getChronology ( ) . hourOfDay ( ) . get ( getLocalMillis ( ) ) ; } 
public JSONNode addArrayElement ( Object value ) { NodeType type ; if ( getNodeType ( ) != NodeType . ARRAY ) return null ; type = null ; if ( value != null ) { if ( value instanceof Boolean ) type = NodeType . PRIMITIVE ; else if ( value instanceof Integer ) type = NodeType . PRIMITIVE ; else if ( value instanceof Double ) type = NodeType . PRIMITIVE ; else if ( value instanceof String ) type = NodeType . PRIMITIVE ; else if ( value . getClass ( ) . isArray ( ) ) type = NodeType . ARRAY ; else type = NodeType . OBJECT ; } return add ( null , value , type ) ; } 
protected void updateFallState ( double par1 , boolean par3 ) { if ( ! this . isInWater ( ) ) { this . handleWaterMovement ( ) ; } if ( par3 && this . fallDistance > 0.0F ) { int i = MathHelper . floor_double ( this . posX ) ; int j = MathHelper . floor_double ( this . posY - 0.20000000298023224D - ( double ) this . yOffset ) ; int k = MathHelper . floor_double ( this . posZ ) ; int l = this . worldObj . getBlockId ( i , j , k ) ; if ( l == 0 ) { int i1 = this . worldObj . blockGetRenderType ( i , j - 1 , k ) ; if ( i1 == 11 || i1 == 32 || i1 == 21 ) { l = this . worldObj . getBlockId ( i , j - 1 , k ) ; } } if ( l > 0 ) { Block . blocksList [ l ] . onFallenUpon ( this . worldObj , i , j , k , this , this . fallDistance ) ; } } super . updateFallState ( par1 , par3 ) ; } 
private void doublePool ( ) { Object [ ] newpool = new Object [ pool . length * 2 ] ; System . arraycopy ( pool , 0 , newpool , 0 , pool . length ) ; pool = newpool ; } 
protected synchronized void setSetupProgress ( float p ) { this . setupProgress = ( float ) Math . min ( 1.0 , Math . max ( 0.0 , p ) ) ; } 
public static final void copy ( final double [ ] target , final double [ ] source ) { System . arraycopy ( source , 0 , target , 0 , source . length ) ; } 
@ SuppressWarnings ( "unchecked" ) public Map < String , WContainerType > getAllContainerTypes ( ) { Map < String , WContainerType > containerTypes = new LinkedHashMap < String , WContainerType > ( ) ; Query query = em . createQuery ( "Select-CT-From-WContainerType-CT" ) ; for ( WContainerType containerType : ( List < WContainerType > ) query . getResultList ( ) ) { containerTypes . put ( new Integer ( containerType . getContainerTypeId ( ) ) . toString ( ) , containerType ) ; } return containerTypes ; } 
public Collection listIncompletelyDeployed ( ) { List id = new ArrayList ( ) ; List copy ; synchronized ( deploymentList ) { copy = new ArrayList ( deploymentList ) ; } for ( Iterator i = copy . iterator ( ) ; i . hasNext ( ) ; ) { DeploymentInfo di = ( DeploymentInfo ) i . next ( ) ; if ( ! "Deployed" . equals ( di . status ) && ! "Starting" . equals ( di . status ) ) { id . add ( di ) ; } } return id ; } 
public int getMoreTabCount ( ) { return getAttributeAsInt ( "moreTabCount" ) ; } 
@ VisibleForTesting static CharSequence getResourceText ( Context context , String packageName , int resId , String defaultValue ) { if ( resId != - 1 && packageName != null ) { final PackageManager pm = context . getPackageManager ( ) ; return pm . getText ( packageName , resId , null ) ; } else if ( resId != - 1 ) { return context . getText ( resId ) ; } else { return defaultValue ; } } 
protected boolean contains ( SnmpOid oid , Object userData ) { return ( findObject ( oid ) > - 1 ) ; } 
public void set ( int i , Vector values ) { for ( int row = i ; row - i < values . size ( ) ; row ++ ) { set ( row , values . get ( row - i ) ) ; } } 
public void startDocument ( XMLLocator locator , String encoding , NamespaceContext namespaceContext , Augmentations augs ) throws XNIException { fErrorReporter . setDocumentLocator ( locator ) ; if ( ! isRootDocument ( ) && fParentXIncludeHandler . searchForRecursiveIncludes ( locator ) ) { reportFatalError ( "RecursiveInclude" , new Object [ ] { locator . getExpandedSystemId ( ) } ) ; } if ( ! ( namespaceContext instanceof XIncludeNamespaceSupport ) ) { reportFatalError ( "IncompatibleNamespaceContext" ) ; } fNamespaceContext = ( XIncludeNamespaceSupport ) namespaceContext ; fDocLocation = locator ; fCurrentBaseURI . setBaseSystemId ( locator . getBaseSystemId ( ) ) ; fCurrentBaseURI . setExpandedSystemId ( locator . getExpandedSystemId ( ) ) ; fCurrentBaseURI . setLiteralSystemId ( locator . getLiteralSystemId ( ) ) ; saveBaseURI ( ) ; if ( augs == null ) { augs = new AugmentationsImpl ( ) ; } augs . putItem ( CURRENT_BASE_URI , fCurrentBaseURI ) ; fCurrentLanguage = XMLSymbols . EMPTY_STRING ; saveLanguage ( fCurrentLanguage ) ; if ( isRootDocument ( ) && fDocumentHandler != null ) { fDocumentHandler . startDocument ( locator , encoding , namespaceContext , augs ) ; } } 
public String getDocumentTypeDeclarationPublicIdentifier ( ) { error ( XMLMessages . createXMLMessage ( XMLErrorResources . ER_METHOD_NOT_SUPPORTED , null ) ) ; return null ; } 
private ServiceReference [ ] computeServiceReferencesFromBoth ( ServiceReference [ ] refLocal , ServiceReference [ ] refGlobal ) { if ( refLocal == null ) { return refGlobal ; } else if ( refGlobal == null ) { return refLocal ; } else { ServiceReference [ ] refs = new ServiceReference [ refLocal . length + refGlobal . length ] ; System . arraycopy ( refLocal , 0 , refs , 0 , refLocal . length ) ; System . arraycopy ( refGlobal , 0 , refs , refLocal . length , refGlobal . length ) ; return refs ; } } 
@ SuppressWarnings ( "unchecked" ) private void readObject ( ObjectInputStream aStream ) throws IOException , ClassNotFoundException { lock = new Object ( ) ; aStream . defaultReadObject ( ) ; keys = ( Map < CompleteIndexKey , CompleteIndexKey > ) aStream . readObject ( ) ; folderToPersist = ( String ) aStream . readObject ( ) ; suffix = ( String ) aStream . readObject ( ) ; cache = createCache ( ) ; scheduleRemoveStale = new JobRemoveStale ( ) ; if ( DEBUG ) { System . out . println ( "Disk-cache---read:-" + keys . size ( ) + "---" + folderToPersist ) ; } } 
public void defaultReadObject ( ) throws IOException , ClassNotFoundException , NotActiveException { if ( currentObject != null || ! mustResolve ) { readFieldValues ( currentObject , currentClass ) ; } else { throw new NotActiveException ( ) ; } } 
@ Deprecated public Component getComponentAtIndex ( int i ) { if ( i < 0 || i >= getComponentCount ( ) ) { return null ; } return getComponent ( i ) ; } 
private float interpolate ( ) { long currTime = System . currentTimeMillis ( ) ; float elapsed = ( currTime - startTime ) / ZOOM_TIME ; elapsed = Math . min ( 1f , elapsed ) ; return interpolator . getInterpolation ( elapsed ) ; } 
public URI resolve ( String relative ) { return resolve ( create ( relative ) ) ; } 
public XSTypeDefinition getTypeDefinition ( String name , String namespace ) { SchemaGrammar sg = ( SchemaGrammar ) fGrammarMap . get ( null2EmptyString ( namespace ) ) ; if ( sg == null ) { return null ; } return ( XSTypeDefinition ) sg . fGlobalTypeDecls . get ( name ) ; } 
public void setMaxTasksToAssignAfterOffSwitch ( int maxTasksToAssignAfterOffSwitch ) { rmConf . setInt ( "mapred.capacity-scheduler.maximum-tasks-after-offswitch" , maxTasksToAssignAfterOffSwitch ) ; } 
public Color mul ( Color color ) { this . r *= color . r ; this . g *= color . g ; this . b *= color . b ; this . a *= color . a ; return clamp ( ) ; } 
public boolean hasVaryAll ( ) { return varyFields . contains ( "*" ) ; } 
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( 1 ) ; newVector . addElement ( new Option ( "-Specify-list-of-columns-to-take-the-differences-between.-" + "-First-and-last-are-valid-indexes.-" + "-(default-none)" , "R" , 1 , "-R-<index1,index2-index4,...>" ) ) ; return newVector . elements ( ) ; } 
public static String toString ( double d , int nn , int ff ) { String r_ = d + "" ; int ii_ = r_ . indexOf ( "." ) ; String head_ = null , tail_ = null ; if ( ii_ < 0 ) { head_ = r_ ; tail_ = "" ; } else { head_ = r_ . substring ( 0 , ii_ ) ; tail_ = r_ . substring ( ii_ + 1 ) ; } int dot = ff > 0 ? 1 : 0 ; if ( nn < 0 ) nn = head_ . length ( ) + dot + ff ; if ( head_ . length ( ) > nn ) return head_ ; else if ( head_ . length ( ) + ff + dot < nn ) { StringBuffer sb_ = new StringBuffer ( nn - ff - dot - head_ . length ( ) ) ; for ( int i = 0 ; i < sb_ . capacity ( ) ; i ++ ) sb_ . append ( '-' ) ; head_ = sb_ + head_ ; } if ( ff == 0 ) return head_ ; if ( tail_ . length ( ) > ff ) { tail_ = tail_ . substring ( 0 , ff ) ; } else { StringBuffer sb_ = new StringBuffer ( ff - tail_ . length ( ) ) ; for ( int i = 0 ; i < sb_ . capacity ( ) ; i ++ ) sb_ . append ( '0' ) ; tail_ += sb_ . toString ( ) ; } return head_ + "." + tail_ ; } 
public List < KeyValue > getColumn ( byte [ ] family , byte [ ] qualifier ) { List < KeyValue > result = new ArrayList < KeyValue > ( ) ; KeyValue [ ] kvs = raw ( ) ; if ( kvs == null || kvs . length == 0 ) { return result ; } int pos = binarySearch ( kvs , family , qualifier ) ; if ( pos == - 1 ) { return result ; } for ( int i = pos ; i < kvs . length ; i ++ ) { KeyValue kv = kvs [ i ] ; if ( kv . matchingColumn ( family , qualifier ) ) { result . add ( kv ) ; } else { break ; } } return result ; } 
public Set getSymbolsWithReplacements ( ) { return symbolToReplacements . keySet ( ) ; } 
public String getNodeURI ( int nodeIndex ) { return getNodeURI ( nodeIndex , true ) ; } 
public List < String > getMissingFields ( ) { return Collections . unmodifiableList ( missingFields ) ; } 
public int getColor ( ) { return Color . HSVToColor ( mAlpha , new float [ ] { mHue , mSat , mVal } ) ; } 
public static double [ ] normalizeFromLog10 ( double [ ] array , boolean takeLog10OfOutput , boolean keepInLogSpace ) { double maxValue = arrayMax ( array ) ; if ( keepInLogSpace ) { for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] -= maxValue ; } return array ; } double [ ] normalized = new double [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) normalized [ i ] = Math . pow ( 10 , array [ i ] - maxValue ) ; double sum = 0.0 ; for ( int i = 0 ; i < array . length ; i ++ ) sum += normalized [ i ] ; for ( int i = 0 ; i < array . length ; i ++ ) { double x = normalized [ i ] / sum ; if ( takeLog10OfOutput ) { x = Math . log10 ( x ) ; if ( x < LOG10_P_OF_ZERO || Double . isInfinite ( x ) ) x = array [ i ] - maxValue ; } normalized [ i ] = x ; } return normalized ; } 
private boolean delete ( int i ) { checkInvariants ( ) ; final E [ ] elements = this . elements ; final int mask = elements . length - 1 ; final int h = head ; final int t = tail ; final int front = ( i - h ) & mask ; final int back = ( t - i ) & mask ; if ( front >= ( ( t - h ) & mask ) ) throw new ConcurrentModificationException ( ) ; if ( front < back ) { if ( h <= i ) { System . arraycopy ( elements , h , elements , h + 1 , front ) ; } else { System . arraycopy ( elements , 0 , elements , 1 , i ) ; elements [ 0 ] = elements [ mask ] ; System . arraycopy ( elements , h , elements , h + 1 , mask - h ) ; } elements [ h ] = null ; head = ( h + 1 ) & mask ; return false ; } else { if ( i < t ) { System . arraycopy ( elements , i + 1 , elements , i , back ) ; tail = t - 1 ; } else { System . arraycopy ( elements , i + 1 , elements , i , mask - i ) ; elements [ mask ] = elements [ 0 ] ; System . arraycopy ( elements , 1 , elements , 0 , t ) ; tail = ( t - 1 ) & mask ; } return true ; } } 
public synchronized void writeTo ( OutputStream out ) throws IOException { out . write ( buf , 0 , count ) ; } 
protected boolean includeAuthorityInRequestLine ( ) { return connection == null ? policy . usingProxy ( ) : connection . getRoute ( ) . getProxy ( ) . type ( ) == Proxy . Type . HTTP ; } 
final boolean isFirst ( Thread current ) { Node h , s ; return ( ( h = head ) == null || ( ( s = h . next ) != null && s . thread == current ) || fullIsFirst ( current ) ) ; } 
protected void loadExtraProperties ( ) { String filename = coreProperties . getProperty ( CORE_PROPERTIES , DEFAULT_EXTERNAL_PROPERTIES_FILE ) ; File propertiesFile = resolvePaths ( filename ) ; if ( propertiesFile . exists ( ) ) { FileInputStream in = null ; try { in = new FileInputStream ( propertiesFile ) ; Properties externalProps = new Properties ( ) ; externalProps . load ( new InputStreamReader ( in , StandardCharsets . UTF_8 ) ) ; coreProperties . putAll ( externalProps ) ; } catch ( IOException e ) { String message = String . format ( Locale . ROOT , "Could-not-load-properties-from-%s:-%s:" , propertiesFile . getAbsoluteFile ( ) , e . toString ( ) ) ; throw new SolrException ( SolrException . ErrorCode . SERVER_ERROR , message ) ; } finally { IOUtils . closeQuietly ( in ) ; } } } 
public MutableAttributeSet getInputAttributes ( ) { return getStyledEditorKit ( ) . getInputAttributes ( ) ; } 
public boolean containsKey ( Object key ) { Iterator i = entrySet ( ) . iterator ( ) ; if ( key == null ) { while ( i . hasNext ( ) ) { Entry e = ( Entry ) i . next ( ) ; if ( e . getKey ( ) == null ) return true ; } } else { while ( i . hasNext ( ) ) { Entry e = ( Entry ) i . next ( ) ; if ( key . equals ( e . getKey ( ) ) ) return true ; } } return false ; } 
Element get ( String uri , String localName ) { int hash = uri . hashCode ( ) * 31 + localName . hashCode ( ) ; int index = hash & 15 ; Child current = children [ index ] ; if ( current == null ) { return null ; } else { do { if ( current . hash == hash && current . uri . compareTo ( uri ) == 0 && current . localName . compareTo ( localName ) == 0 ) { return current ; } current = current . next ; } while ( current != null ) ; return null ; } } 
private int scale ( SynthContext context , int size ) { if ( context == null || context . getComponent ( ) == null ) { return size ; } String scaleKey = ( String ) context . getComponent ( ) . getClientProperty ( "JComponent.sizeVariant" ) ; if ( scaleKey != null ) { if ( NimbusStyle . LARGE_KEY . equals ( scaleKey ) ) { size *= NimbusStyle . LARGE_SCALE ; } else if ( NimbusStyle . SMALL_KEY . equals ( scaleKey ) ) { size *= NimbusStyle . SMALL_SCALE ; } else if ( NimbusStyle . MINI_KEY . equals ( scaleKey ) ) { size *= NimbusStyle . MINI_SCALE + 0.07 ; } } return size ; } 
public static void copy ( final InputStream in , final OutputStream out ) throws IOException { final int BUF_SIZE = 1000 ; byte [ ] b = new byte [ BUF_SIZE ] ; int read ; boolean eof = false ; while ( ! eof ) { try { read = in . read ( b , 0 , BUF_SIZE ) ; if ( read > 0 ) out . write ( b , 0 , read ) ; else eof = true ; } catch ( EOFException ex ) { eof = true ; } } } 
protected Frame < V > newFrame ( final int nLocals , final int nStack ) { return new Frame < V > ( nLocals , nStack ) ; } 
public void setDateEffet ( String dateEffet ) { String dateEffetUtilisee = dateEffet ; if ( currentFamilleLiee . getIdentifiant ( ) . equals ( idFamilleBonus1 ) ) { final String [ ] tabDate = dateEffetUtilisee . split ( SEPARATEUR_DATE ) ; tabDate [ 2 ] = String . valueOf ( Integer . valueOf ( tabDate [ 2 ] ) . intValue ( ) + nbAnneesBonus1 ) ; dateEffetUtilisee = tabDate [ 0 ] + SEPARATEUR_DATE + tabDate [ 1 ] + SEPARATEUR_DATE + tabDate [ 2 ] ; } if ( currentFamilleLiee . getIdentifiant ( ) . equals ( idFamilleBonus2 ) ) { final String [ ] tabDate = dateEffetUtilisee . split ( SEPARATEUR_DATE ) ; tabDate [ 2 ] = String . valueOf ( Integer . valueOf ( tabDate [ 2 ] ) . intValue ( ) + nbAnneesBonus2 ) ; dateEffetUtilisee = tabDate [ 0 ] + SEPARATEUR_DATE + tabDate [ 1 ] + SEPARATEUR_DATE + tabDate [ 2 ] ; } for ( CalendarAssureSelecteur calendar : listeCalendarDateEffet ) { if ( calendar . getObjSelecteur ( ) . getAllowChangeWithAutoDateEffet ( ) ) { calendar . setDate ( dateEffetUtilisee ) ; } } } 
@ Override protected void removeRange ( int start , int end ) { if ( start >= 0 && start <= end && end <= elementCount ) { if ( start == end ) { return ; } if ( end != elementCount ) { System . arraycopy ( elementData , end , elementData , start , elementCount - end ) ; int newCount = elementCount - ( end - start ) ; Arrays . fill ( elementData , newCount , elementCount , null ) ; elementCount = newCount ; } else { Arrays . fill ( elementData , start , elementCount , null ) ; elementCount = start ; } modCount ++ ; } else { throw new IndexOutOfBoundsException ( ) ; } } 
public static File getConfigFile ( String name ) { return new File ( getConfigDirectory ( ) , name ) ; } 
@ Override public Element text ( String text ) { body ( ) . text ( text ) ; return this ; } 
public static String getKMLTimestamp ( long when ) { TimeZone tz = TimeZone . getTimeZone ( "GMT" ) ; Calendar c = Calendar . getInstance ( tz ) ; c . setTimeInMillis ( when ) ; return String . format ( "%tY-%tm-%tdT%tH:%tM:%tSZ" , c , c , c , c , c , c ) ; } 
public void scrollBy ( int x , int y ) { scrollTo ( mScrollX + x , mScrollY + y ) ; } 
protected TreeCellEditor createTreeCellEditor ( ) { Border aBorder = UIManager . getBorder ( "Tree.editorBorder" ) ; DefaultCellEditor editor = new DefaultCellEditor ( new DefaultTextField ( aBorder ) ) { public boolean shouldSelectCell ( EventObject event ) { boolean retValue = super . shouldSelectCell ( event ) ; return retValue ; } } ; editor . setClickCountToStart ( 1 ) ; return editor ; } 
public boolean containsKey ( String key ) { return mValues . containsKey ( key ) ; } 
public String pennString ( ) { StringWriter sw = new StringWriter ( ) ; pennPrint ( new PrintWriter ( sw ) ) ; return sw . toString ( ) ; } 
@ XmlElementDecl ( namespace = "http://www.xbrl.org/tw/fr/gaap/tw-gaap-bd-2010-03-31-cr" , name = "LossesDerivativeFinancialProductsFutures" , substitutionHeadNamespace = "http://www.xbrl.org/2003/instance" , substitutionHeadName = "item" ) public JAXBElement < MonetaryItemType > createLossesDerivativeFinancialProductsFutures ( MonetaryItemType value ) { return new JAXBElement < MonetaryItemType > ( new QName ( "http://www.xbrl.org/tw/fr/gaap/tw-gaap-bd-2010-03-31-cr" , "LossesDerivativeFinancialProductsFutures" ) , MonetaryItemType . class , null , value ) ; } 
public PropertyResourceBundle ( Reader reader ) throws IOException { Properties properties = new Properties ( ) ; properties . load ( reader ) ; lookup = new HashMap ( properties ) ; } 
public boolean isAgentUpdateEnabled ( ) { boolean flag = m_preferences . getBoolean ( AgentConfigurationConstants . AGENT_UPDATE_ENABLED , AgentConfigurationConstants . DEFAULT_AGENT_UPDATE_ENABLED ) ; return flag ; } 
HoverDrawable ( @ NonNull final View view , final float downY ) { super ( view . getResources ( ) , BitmapUtils . getBitmapFromView ( view ) ) ; mOriginalY = view . getTop ( ) ; mDownY = downY ; setBounds ( view . getLeft ( ) , view . getTop ( ) , view . getRight ( ) , view . getBottom ( ) ) ; } 
public void dispose ( ) { Container root = getRoot ( ) ; if ( LOGGER . isLoggable ( PlatformLogger . FINER ) ) { LOGGER . finer ( "disposed-BufferInfo-for:-" + root ) ; } if ( root != null ) { root . removeComponentListener ( this ) ; if ( root instanceof Window ) { ( ( Window ) root ) . removeWindowListener ( this ) ; } BufferStrategy bs = getBufferStrategy ( false ) ; if ( bs != null ) { bs . dispose ( ) ; } } this . root = null ; weakBS = null ; } 
public boolean saveModelOthers ( String filename ) { try { BufferedWriter writer = new BufferedWriter ( new FileWriter ( filename ) ) ; writer . write ( "alpha=" + alpha + "-" ) ; writer . write ( "beta=" + beta + "-" ) ; writer . write ( "ntopics=" + K + "-" ) ; writer . write ( "ndocs=" + M + "-" ) ; writer . write ( "nwords=" + V + "-" ) ; writer . write ( "liters=" + liter + "-" ) ; writer . close ( ) ; } catch ( Exception e ) { System . out . println ( "Error-while-saving-model-others:" + e . getMessage ( ) ) ; e . printStackTrace ( ) ; return false ; } return true ; } 
public String getSortSequenceTable ( ) throws AS400SecurityException , ErrorCompletingRequestException , InterruptedException , IOException , ObjectDoesNotExistException { String table = ( ( String ) getValue ( SORT_SEQUENCE_TABLE ) ) . trim ( ) ; if ( table . length ( ) > 0 && ! table . startsWith ( "*" ) ) { String name = table . substring ( 0 , 10 ) . trim ( ) ; String lib = table . substring ( 10 , table . length ( ) ) ; String path = QSYSObjectPathName . toPath ( lib , name , "FILE" ) ; return path ; } return table ; } 
public static final Value setLocalVar ( Value var , Value value ) { value = value . toValue ( ) ; if ( var instanceof Var ) var . set ( value ) ; return value ; } 
@ Deprecated public boolean isFillBelowLine ( ) { return mFillBelowLine . size ( ) > 0 ; } 
static GLAPISpec parseLine ( String line ) { List < String > words = Arrays . asList ( line . split ( "," ) ) ; String retType = words . get ( 0 ) . trim ( ) ; String func = words . get ( 1 ) . trim ( ) ; List < String > argDefinitions = words . subList ( 2 , words . size ( ) ) ; List < GLDataTypeSpec > glArgs = new ArrayList < GLDataTypeSpec > ( argDefinitions . size ( ) / 2 ) ; for ( String argDefn : argDefinitions ) { argDefn = argDefn . trim ( ) ; int lastSeparator = argDefn . lastIndexOf ( '-' ) ; if ( lastSeparator == - 1 ) { glArgs . add ( new GLDataTypeSpec ( argDefn , null ) ) ; } else { String type = argDefn . substring ( 0 , lastSeparator ) ; String name = argDefn . substring ( lastSeparator + 1 ) ; glArgs . add ( new GLDataTypeSpec ( type , name ) ) ; } } return new GLAPISpec ( func , new GLDataTypeSpec ( retType , null ) , glArgs ) ; } 
public final int getAndSet ( int newValue ) { for ( ; ; ) { int current = get ( ) ; if ( compareAndSet ( current , newValue ) ) return current ; } } 
public Request put ( String name , short value ) { removeFromRequestData ( name ) ; mParamList . add ( name ) ; mTypeList . add ( TYPE_SHORT ) ; mBundle . putShort ( name , value ) ; return this ; } 
public static ImageDescriptor getImageDescriptor ( String path ) { return imageDescriptorFromPlugin ( PLUGIN_ID , path ) ; } 
public static void println ( char x ) { out . println ( x ) ; } 
public ChannelEventRoute getEventRoute ( Event event ) throws AppiaEventException { if ( eventsRoutes == null ) throw new AppiaEventException ( AppiaEventException . CLOSEDCHANNEL , "Channel-Not-Started" ) ; ChannelEventRoute channelRoute = ( ChannelEventRoute ) eventsRoutes . get ( event . getClass ( ) ) ; if ( channelRoute == null ) { for ( Class c = event . getClass ( ) . getSuperclass ( ) ; ( c != null ) && ( channelRoute == null ) ; c = c . getSuperclass ( ) ) { channelRoute = ( ChannelEventRoute ) eventsRoutes . get ( c ) ; } if ( channelRoute != null ) { eventsRoutes . put ( event . getClass ( ) , channelRoute ) ; } else { throw new AppiaEventException ( AppiaEventException . UNWANTEDEVENT , "Unwanted-Event-'" + event . getClass ( ) . getName ( ) + "'-on-Channel-'" + this . channelID + "'." ) ; } } return channelRoute ; } 
private static final int headerLength ( ) { return String . valueOf ( Integer . MAX_VALUE ) . length ( ) * 2 + 8 ; } 
public void testGetNextEvent2 ( ) throws Exception { DailyFrequency freq = new DailyFrequency ( 4 , 5 , 23 ) ; Calendar cal = GregorianCalendar . getInstance ( ) ; cal . set ( 2005 , Calendar . JUNE , 12 , 22 , 42 ) ; Date d1 = cal . getTime ( ) ; cal . add ( Calendar . DAY_OF_MONTH , 4 ) ; cal . add ( Calendar . MINUTE , ( ( 60 + 23 ) - 42 ) ) ; cal . add ( Calendar . HOUR , ( ( 24 + 5 ) - ( 22 + 1 ) ) ) ; Date d3 = cal . getTime ( ) ; Date d4 = freq . getNextEvent ( d1 ) ; assertEquals ( "Second-event-should-happen-four-days-later,-on-the-23rd-minute-of-the-5th-hour" , d3 , d4 ) ; } 
public File pathToFile ( Path path ) { checkPath ( path ) ; if ( ! path . isAbsolute ( ) ) { path = new Path ( getWorkingDirectory ( ) , path ) ; } return new File ( path . toUri ( ) . getPath ( ) ) ; } 
public static Name fromAddress ( byte [ ] addr ) { if ( addr . length != 4 && addr . length != 16 ) throw new IllegalArgumentException ( "array-must-contain-" + "4-or-16-elements" ) ; StringBuffer sb = new StringBuffer ( ) ; if ( addr . length == 4 ) { for ( int i = addr . length - 1 ; i >= 0 ; i -- ) { sb . append ( addr [ i ] & 0xFF ) ; if ( i > 0 ) sb . append ( "." ) ; } } else { int [ ] nibbles = new int [ 2 ] ; for ( int i = addr . length - 1 ; i >= 0 ; i -- ) { nibbles [ 0 ] = ( addr [ i ] & 0xFF ) >> 4 ; nibbles [ 1 ] = ( addr [ i ] & 0xFF ) & 0xF ; for ( int j = nibbles . length - 1 ; j >= 0 ; j -- ) { sb . append ( Integer . toHexString ( nibbles [ j ] ) ) ; if ( i > 0 || j > 0 ) sb . append ( "." ) ; } } } try { if ( addr . length == 4 ) return Name . fromString ( sb . toString ( ) , inaddr4 ) ; else return Name . fromString ( sb . toString ( ) , inaddr6 ) ; } catch ( TextParseException e ) { throw new IllegalStateException ( "name-cannot-be-invalid" ) ; } } 
public static void refreshFactoryToDefaults ( ) { threadLocSingleton . set ( new Factory ( ) ) ; } 
public void setInput ( String filterName , Object input ) throws ConnectException , UnsupportedOperationException { if ( input instanceof ReadableByteChannel ) { this . reader = Channels . newReader ( ( ReadableByteChannel ) input , this . decoder , - 1 ) ; } else if ( input instanceof InputStream ) { this . reader = new BufferedReader ( new InputStreamReader ( ( InputStream ) input , this . decoder ) ) ; } else { throw new UnsupportedOperationException ( "CharsetDecoderFilter-does-not-accept-input-of-type-" + input . getClass ( ) . getName ( ) ) ; } } 
public List < Extension > getExtension ( ) { if ( extension == null ) { extension = new ArrayList < Extension > ( ) ; } return this . extension ; } 
private static Permission [ ] flatten ( Permission [ ] pa ) { List l = new ArrayList ( pa . length ) ; for ( int i = 0 ; i < pa . length ; i ++ ) { Permission p = pa [ i ] ; if ( p instanceof GrantPermission ) { l . addAll ( Arrays . asList ( ( ( GrantPermission ) p ) . grants ) ) ; } else { l . add ( p ) ; } } return ( Permission [ ] ) l . toArray ( new Permission [ l . size ( ) ] ) ; } 
public static ArrayList < Vec2 > calculateOffsets ( int numSides , float radius ) { ArrayList < Vec2 > offsets = new ArrayList < Vec2 > ( ) ; for ( int i = 1 ; i <= numSides ; i ++ ) { Double angle = ( ( double ) ( i - 1 ) / numSides ) * 2 * Math . PI ; ; Double worldX = radius * Math . cos ( angle ) ; Double worldY = radius * Math . sin ( angle ) ; Vec2 pos = new Vec2 ( worldX . floatValue ( ) , worldY . floatValue ( ) ) ; offsets . add ( pos ) ; } return offsets ; } 
private String replaceAll ( String src , char ch , String replaceWith ) { StringBuffer b = new StringBuffer ( ) ; for ( int i = 0 ; i < src . length ( ) ; i ++ ) { char c = src . charAt ( i ) ; if ( c == ch ) { b . append ( replaceWith ) ; } else { b . append ( c ) ; } } return b . toString ( ) ; } 
private void initialize ( ) { frame = new JFrame ( ) ; frame . setBounds ( 100 , 100 , 450 , 300 ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; } 
private synchronized void setState ( int state ) { if ( D ) Log . d ( TAG , "setState()-" + mState + "-->-" + state ) ; mState = state ; mHandler . obtainMessage ( BluetoothChat . MESSAGE_STATE_CHANGE , state , - 1 ) . sendToTarget ( ) ; } 
public String toString ( ) { String str = "" ; for ( int loop = 0 ; loop < _vec . size ( ) ; ++ loop ) { str += "-" + _vec . elementAt ( loop ) + "-" ; } return str ; } 
public List < Float > getHalf4 ( ) { if ( half4 == null ) { half4 = new ArrayList < Float > ( ) ; } return this . half4 ; } 
public boolean removePart ( int index ) { if ( parts . containsKey ( index ) ) { parts . remove ( index ) ; return true ; } return false ; } 
public final Type visitFloatingPointLiteral ( final GNode n ) { final String s = n . getString ( 0 ) ; final boolean isFloat = 'f' == Character . toLowerCase ( s . charAt ( s . length ( ) - 1 ) ) ; final Number value = isFloat ? ( Number ) new Float ( s ) : new Double ( s ) ; if ( ! assrt ( n , isFloat ? ! ( ( Float ) value ) . isInfinite ( ) : ! ( ( Double ) value ) . isInfinite ( ) , "literal-out-of-range" ) || ! assrt ( n , ( 0.0 == value . doubleValue ( ) ) == JavaEntities . zeroLiteral ( s ) , "literal-out-of-range" ) ) return setType ( n , ErrorT . TYPE ) ; final Type type = JavaEntities . nameToBaseType ( isFloat ? "float" : "double" ) ; return setType ( n , type . annotate ( ) . constant ( value ) ) ; } 
public Object nextElement ( ) { return nextToken ( ) ; } 
public boolean contentEquals ( CharSequence cs ) { if ( cs == null ) { throw new NullPointerException ( "cs-==-null" ) ; } int len = cs . length ( ) ; if ( len != count ) { return false ; } if ( len == 0 && count == 0 ) { return true ; } return regionMatches ( 0 , cs . toString ( ) , 0 , len ) ; } 
public int getPoolSize ( ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { return runStateAtLeast ( ctl . get ( ) , TIDYING ) ? 0 : workers . size ( ) ; } finally { mainLock . unlock ( ) ; } } 
public void filter ( Filter filter ) { filter . apply ( instances ) ; } 
@ Override public String toString ( ) { return "SIGNATURE-" + algorithm + "-state:-" + stateToString ( state ) ; } 
public Collection getValues ( Object object ) { return ( Collection ) object ; } 
public static Socket createSocket ( ) throws IOException { return new Socket ( ADB_HOST , ADB_PORT ) ; } 
public static List < JNCryptor > getCryptors ( ) { List < JNCryptor > result = new ArrayList < JNCryptor > ( supportedVersions . size ( ) ) ; for ( Integer version : supportedVersions . keySet ( ) ) { result . add ( supportedVersions . get ( version ) ) ; } return result ; } 
private static Object invokeGetter ( Object obj , String methodName , Object defaultValue ) { try { Method method = obj . getClass ( ) . getMethod ( methodName , new Class [ 0 ] ) ; Object result = method . invoke ( obj , new Object [ 0 ] ) ; return result ; } catch ( NoSuchMethodException e ) { return defaultValue ; } catch ( IllegalAccessException e ) { return defaultValue ; } catch ( InvocationTargetException e ) { return defaultValue ; } } 
public E peek ( ) { return peekFirst ( ) ; } 
public void ignorableWhitespace ( XMLString text , Augmentations augs ) throws XNIException { characters ( text , augs ) ; fOut . flush ( ) ; } 
public Builder setStyle ( Style style ) { if ( mStyle != style ) { mStyle = style ; if ( mStyle != null ) { mStyle . setBuilder ( this ) ; } } return this ; } 
public static String [ ] getTokens ( String text , char delimiter ) { ArrayList < String > list = new ArrayList < String > ( ) ; int next = text . indexOf ( delimiter ) ; while ( next > - 1 ) { list . add ( text . substring ( 0 , next ) ) ; text = text . substring ( next + 1 ) ; next = text . indexOf ( delimiter ) ; } list . add ( text ) ; String [ ] result = new String [ list . size ( ) ] ; for ( int C = 0 ; C <= list . size ( ) - 1 ; C ++ ) result [ C ] = list . get ( C ) . toString ( ) ; return result ; } 
private boolean bitmaskIntersect ( Entity e ) { BufferedImage mask1 = new BufferedImage ( width , height , BufferedImage . TYPE_BYTE_BINARY ) ; Graphics2D g = mask1 . createGraphics ( ) ; g . rotate ( radians , width / 2 , height / 2 ) ; g . fillPolygon ( entity ) ; BufferedImage mask2 = new BufferedImage ( e . width , e . height , BufferedImage . TYPE_BYTE_BINARY ) ; g = mask2 . createGraphics ( ) ; g . rotate ( e . radians , e . width / 2 , e . height / 2 ) ; g . fillPolygon ( e . entity ) ; g . dispose ( ) ; for ( int x = 0 ; x < width ; x ++ ) { int x2 = ( int ) ( x + this . x - e . x ) ; if ( x2 >= e . width || x2 < 0 ) continue ; for ( int y = 0 ; y < height ; y ++ ) { int y2 = ( int ) ( y + this . y - e . y ) ; if ( y2 >= e . height || y2 < 0 ) continue ; if ( mask1 . getRGB ( x , y ) == - 1 && mask2 . getRGB ( x2 , y2 ) == - 1 ) { return true ; } } } return false ; } 
public static List < Verrechnet > getVerrechnetByBill ( Rechnung bill ) { ArrayList < Verrechnet > ret = new ArrayList < Verrechnet > ( ) ; Query < VerrechnetCopy > vcQuery = new Query < VerrechnetCopy > ( VerrechnetCopy . class ) ; vcQuery . add ( VerrechnetCopy . RECHNUNGID , Query . EQUALS , bill . getId ( ) ) ; List < VerrechnetCopy > res = vcQuery . execute ( ) ; ret . addAll ( res ) ; return ret ; } 
private String deriveNestedProperty ( ) { Object idObj = pageContext . getAttribute ( id ) ; if ( idObj instanceof Map . Entry ) { return nesting + "(" + ( ( Map . Entry ) idObj ) . getKey ( ) + ")" ; } else { return nesting + "[" + this . getIndex ( ) + "]" ; } } 
void writeComment ( String string ) throws IOException { write ( "<!--" ) ; if ( string != null ) { write ( string ) ; } write ( "-->" ) ; writeLineSeparator ( ) ; indentSmart ( ) ; } 
public PropertyEditor getEditor ( Class type ) { PropertyEditor editor ; editor = defaultEditors . get ( type ) ; if ( editor != null ) return editor ; editor = PropertyEditorManager . findEditor ( type ) ; return editor ; } 
private void percolateUp ( int index ) { Comparable temp = elements [ index ] ; while ( index > 1 ) { if ( temp . compareTo ( elements [ index / 2 ] ) < 0 ) { elements [ index ] = elements [ index / 2 ] ; index = index / 2 ; } else { break ; } } elements [ index ] = temp ; } 
public void hPubStartPerformed ( HPubStartEvent evt ) { if ( tracing == true ) { traceArgs [ 0 ] = this ; traceArgs [ 1 ] = "DocketListingTabDown_Access.hPubStartPerformed()" ; try { traceMethod . invoke ( o , traceArgs ) ; } catch ( Exception x ) { } } Thread newThread = new Thread ( this ) ; newThread . start ( ) ; } 
public synchronized void returnBuf ( byte [ ] buf ) { if ( buf == null || buf . length > mSizeLimit ) { return ; } mBuffersByLastUse . add ( buf ) ; int pos = Collections . binarySearch ( mBuffersBySize , buf , BUF_COMPARATOR ) ; if ( pos < 0 ) { pos = - pos - 1 ; } mBuffersBySize . add ( pos , buf ) ; mCurrentSize += buf . length ; trim ( ) ; } 
private Object readResolve ( ) throws ObjectStreamException { log . info ( "Using-DiskStoreSampleSender-for-this-test-run" ) ; singleExecutor = Executors . newSingleThreadExecutor ( ) ; try { temporaryFile = File . createTempFile ( "SerialisedSampleSender" , ".ser" ) ; temporaryFile . deleteOnExit ( ) ; singleExecutor . submit ( new Runnable ( ) { @ Override public void run ( ) { OutputStream anOutputStream ; try { anOutputStream = new FileOutputStream ( temporaryFile ) ; oos = new ObjectOutputStream ( anOutputStream ) ; } catch ( IOException e ) { log . error ( "Failed-to-create-output-Stream" , e ) ; } } } ) ; } catch ( IOException e ) { log . error ( "Failed-to-create-output-file" , e ) ; } return this ; } 
public void addDependency ( Dependency dependency ) { if ( dependencies == null ) { dependencies = new ArrayList < Dependency > ( ) ; nodeDependencies = new ArrayList < Node > ( ) ; } dependencies . add ( dependency ) ; if ( ! nodeDependencies . contains ( dependency . node ) ) { nodeDependencies . add ( dependency . node ) ; } Node dependencyNode = dependency . node ; if ( dependencyNode . nodeDependents == null ) { dependencyNode . nodeDependents = new ArrayList < Node > ( ) ; } dependencyNode . nodeDependents . add ( this ) ; } 
public Card dealCard ( ) { return cards . remove ( 0 ) ; } 
public void setFormatter ( Formatter newFormatter ) { LogManager . getLogManager ( ) . checkAccess ( ) ; internalSetFormatter ( newFormatter ) ; } 
private String getFullExecutablePath ( ) { StringBuffer pathBuf = new StringBuffer ( ) ; String optionalExecutablePath = getServerProps ( ) . getProperty ( EXECUTABLE_PATH_KEY ) ; if ( optionalExecutablePath == null ) { String basedir = getServerProps ( ) . getProperty ( BASEDIR_KEY ) ; pathBuf . append ( basedir ) ; if ( ! basedir . endsWith ( File . separator ) ) { pathBuf . append ( File . separatorChar ) ; } if ( runningOnWindows ( ) ) { pathBuf . append ( "bin" ) ; } else { pathBuf . append ( "libexec" ) ; } pathBuf . append ( File . separatorChar ) ; } else { pathBuf . append ( optionalExecutablePath ) ; if ( ! optionalExecutablePath . endsWith ( File . separator ) ) { pathBuf . append ( File . separatorChar ) ; } } String executableName = getServerProps ( ) . getProperty ( EXECUTABLE_NAME_KEY , "mysqld" ) ; pathBuf . append ( executableName ) ; return pathBuf . toString ( ) ; } 
public void setPublicId ( String id ) { if ( isReadOnly ( ) ) { throw new DOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR , DOMMessageFormatter . formatMessage ( DOMMessageFormatter . DOM_DOMAIN , "NO_MODIFICATION_ALLOWED_ERR" , null ) ) ; } if ( needsSyncData ( ) ) { synchronizeData ( ) ; } publicId = id ; } 
public boolean await ( long timeout , TimeUnit unit ) throws InterruptedException { return sync . tryAcquireSharedNanos ( 1 , unit . toNanos ( timeout ) ) ; } 
private void initUi ( ) { JLabel instructionLabel = new JLabel ( ) ; instructionLabel . setText ( "Press:-S-key-to-start-a-new-SIN-oscillogram-C-key-to-start-a-new-COS-oscillogram" ) ; this . add ( instructionLabel ) ; } 
public static byte [ ] stringToUtf8Bytes ( String string ) { int len = string . length ( ) ; byte [ ] bytes = new byte [ len * 3 ] ; int outAt = 0 ; for ( int i = 0 ; i < len ; i ++ ) { char c = string . charAt ( i ) ; if ( ( c != 0 ) && ( c < 0x80 ) ) { bytes [ outAt ] = ( byte ) c ; outAt ++ ; } else if ( c < 0x800 ) { bytes [ outAt ] = ( byte ) ( ( ( c >> 6 ) & 0x1f ) | 0xc0 ) ; bytes [ outAt + 1 ] = ( byte ) ( ( c & 0x3f ) | 0x80 ) ; outAt += 2 ; } else { bytes [ outAt ] = ( byte ) ( ( ( c >> 12 ) & 0x0f ) | 0xe0 ) ; bytes [ outAt + 1 ] = ( byte ) ( ( ( c >> 6 ) & 0x3f ) | 0x80 ) ; bytes [ outAt + 2 ] = ( byte ) ( ( c & 0x3f ) | 0x80 ) ; outAt += 3 ; } } byte [ ] result = new byte [ outAt ] ; System . arraycopy ( bytes , 0 , result , 0 , outAt ) ; return result ; } 
public static String timestampDirectoryComponent ( long millisecondTime ) { Calendar timestamp = Calendar . getInstance ( ) ; timestamp . setTimeInMillis ( millisecondTime ) ; String dateString = null ; dateString = String . format ( TIMESTAMP_DIR_FORMAT , timestamp . get ( Calendar . YEAR ) , timestamp . get ( Calendar . MONTH ) + 1 , timestamp . get ( Calendar . DAY_OF_MONTH ) ) ; dateString = dateString . intern ( ) ; return dateString ; } 
public static List < Class < ? >> getUpperBoundClassAndInterfaces ( Type type ) { LinkedHashSet < Class < ? >> result = new LinkedHashSet < Class < ? >> ( ) ; buildUpperBoundClassAndInterfaces ( type , result ) ; return new ArrayList < Class < ? >> ( result ) ; } 
public void rightClick ( ) throws Exception { RemoteServer . instance ( ) . execute ( "rightclick" , refId ) ; } 
public List < BuildType > getBuild ( ) { if ( build == null ) { build = new ArrayList < BuildType > ( ) ; } return this . build ; } 
@ Override public void dump ( DataOutputStream out ) throws IOException { if ( wide ( ) ) { out . writeByte ( Constants . WIDE ) ; } out . writeByte ( opcode ) ; if ( length > 1 ) { if ( wide ( ) ) { out . writeShort ( n ) ; } else { out . writeByte ( n ) ; } } } 
public int getTTLParam ( ) { Integer ttl = ( Integer ) uriParms . getValue ( "ttl" ) ; if ( ttl != null ) return ttl . intValue ( ) ; else return - 1 ; } 
public Shape modelToView ( int pos , Shape a , Position . Bias bias ) throws BadLocationException { boolean backward = bias == Position . Bias . Backward ; int testpos = backward ? Math . max ( 0 , pos - 1 ) : pos ; Shape ret = null ; if ( ! backward || testpos >= getStartOffset ( ) ) { int childIndex = getViewIndexAtPosition ( testpos ) ; if ( childIndex != - 1 && childIndex < getViewCount ( ) ) { View child = getView ( childIndex ) ; if ( child != null && testpos >= child . getStartOffset ( ) && testpos < child . getEndOffset ( ) ) { Shape childAlloc = getChildAllocation ( childIndex , a ) ; if ( childAlloc != null ) { ret = child . modelToView ( pos , childAlloc , bias ) ; if ( ret == null && child . getEndOffset ( ) == pos ) { childIndex ++ ; if ( childIndex < getViewCount ( ) ) { child = getView ( childIndex ) ; childAlloc = getChildAllocation ( childIndex , a ) ; ret = child . modelToView ( pos , childAlloc , bias ) ; } } } } } } if ( ret == null ) throw new BadLocationException ( "Position-" + pos + "-is-not-represented-by-view." , pos ) ; return ret ; } 
public byte getByte ( int columnIndex ) throws SQLException { if ( ! this . isBinaryEncoded ) { String stringVal = getString ( columnIndex ) ; if ( this . wasNullFlag || ( stringVal == null ) ) { return 0 ; } return getByteFromString ( stringVal , columnIndex ) ; } return getNativeByte ( columnIndex ) ; } 
public VolatileImage createVolatileImage ( int width , int height , ImageCapabilities caps ) throws AWTException { return createVolatileImage ( width , height ) ; } 
public void setRelationshipId ( JAXBElement < Long > value ) { this . relationshipId = ( ( JAXBElement < Long > ) value ) ; } 
public static IOFileFilter notFileFilter ( IOFileFilter filter ) { return new NotFileFilter ( filter ) ; } 
public synchronized void reloadFile ( ) { try { System . err . println ( "Reload-" + filename ) ; reader . close ( ) ; File file = new File ( filename ) ; FileInputStream in = new FileInputStream ( file ) ; reader = new BufferedReader ( new InputStreamReader ( in ) ) ; } catch ( IOException e ) { System . err . println ( "Exception:-" + e ) ; } } 
public static boolean hasTime ( String s ) { return s . indexOf ( '-' ) > 0 ; } 
void resetModifiedDiagrams ( ) { modifiedDiagrams = new ArrayList < ArgoDiagram > ( ) ; } 
private void outputFullLines ( ) throws IOException { for ( ; ; ) { int leftLen = leftBuf . indexOf ( "-" ) ; if ( leftLen < 0 ) { return ; } int rightLen = rightBuf . indexOf ( "-" ) ; if ( rightLen < 0 ) { return ; } if ( leftLen != 0 ) { out . write ( leftBuf . substring ( 0 , leftLen ) ) ; } if ( rightLen != 0 ) { writeSpaces ( out , leftWidth - leftLen ) ; out . write ( rightBuf . substring ( 0 , rightLen ) ) ; } out . write ( '|n' ) ; leftBuf . delete ( 0 , leftLen + 1 ) ; rightBuf . delete ( 0 , rightLen + 1 ) ; } } 
private boolean scanRegEx ( ) { assert ch0 == '/' ; if ( ch1 != '/' && ch1 != '*' ) { final int start = position ; skip ( 1 ) ; boolean inBrackets = false ; while ( ! atEOF ( ) && ( ch0 != '/' || inBrackets ) && ! isEOL ( ch0 ) ) { if ( ch0 == '|' ) { skip ( 1 ) ; if ( isEOL ( ch0 ) ) { reset ( start ) ; return false ; } skip ( 1 ) ; } else { if ( ch0 == '[' ) { inBrackets = true ; } else if ( ch0 == ']' ) { inBrackets = false ; } skip ( 1 ) ; } } if ( ch0 == '/' ) { skip ( 1 ) ; while ( ! atEOF ( ) && Character . isJavaIdentifierPart ( ch0 ) || ch0 == '|' && ch1 == 'u' ) { skip ( 1 ) ; } add ( REGEX , start ) ; return true ; } reset ( start ) ; } return false ; } 
public String readTextLine ( int n ) throws IOException { StringBuilder l = new StringBuilder ( ) ; int c ; while ( ( c = read ( ) ) != - 1 && ! ( c == '-' && l . length ( ) >= n ) ) { if ( c != - 2 ) l . append ( ( char ) c ) ; } if ( c == - 1 && l . length ( ) == 0 ) return ( null ) ; return ( l . toString ( ) ) ; } 
public int index ( ) { Object index = map . get ( INDEX_KEY ) ; if ( index != null && index instanceof Integer ) { return ( ( Integer ) index ) . intValue ( ) ; } else { return - 1 ; } } 
public boolean haReale ( ) { return carteSulTavolo . size ( ) == 2 && punteggio == Partita . MAXPUNTI ; } 
public synchronized void setMaxSize ( long maxSize ) { this . maxSize = maxSize ; executorService . submit ( cleanupCallable ) ; } 
public static String bind ( String message ) { return bind ( message , null ) ; } 
public void drawColor ( int color ) { native_drawColor ( mNativeCanvas , color ) ; } 
protected boolean scanPubidLiteral ( XMLString literal ) throws IOException , XNIException { int quote = fEntityScanner . scanChar ( ) ; if ( quote != '|'' && quote != '"' ) { reportFatalError ( "QuoteRequiredInPublicID" , null ) ; return false ; } fStringBuffer . clear ( ) ; boolean skipSpace = true ; boolean dataok = true ; while ( true ) { int c = fEntityScanner . scanChar ( ) ; if ( c == '-' || c == '|n' || c == '|r' || c == 0x85 || c == 0x2028 ) { if ( ! skipSpace ) { fStringBuffer . append ( '-' ) ; skipSpace = true ; } } else if ( c == quote ) { if ( skipSpace ) { fStringBuffer . length -- ; } literal . setValues ( fStringBuffer ) ; break ; } else if ( XMLChar . isPubid ( c ) ) { fStringBuffer . append ( ( char ) c ) ; skipSpace = false ; } else if ( c == - 1 ) { reportFatalError ( "PublicIDUnterminated" , null ) ; return false ; } else { dataok = false ; reportFatalError ( "InvalidCharInPublicID" , new Object [ ] { Integer . toHexString ( c ) } ) ; } } return dataok ; } 
protected void checkPath ( Path path ) { URI uri = path . toUri ( ) ; String thatScheme = uri . getScheme ( ) ; if ( thatScheme == null ) return ; URI thisUri = getCanonicalUri ( ) ; String thisScheme = thisUri . getScheme ( ) ; if ( thisScheme . equalsIgnoreCase ( thatScheme ) ) { String thisAuthority = thisUri . getAuthority ( ) ; String thatAuthority = uri . getAuthority ( ) ; if ( thatAuthority == null && thisAuthority != null ) { URI defaultUri = getDefaultUri ( getConf ( ) ) ; if ( thisScheme . equalsIgnoreCase ( defaultUri . getScheme ( ) ) ) { uri = defaultUri ; } else { uri = null ; } } if ( uri != null ) { uri = NetUtils . getCanonicalUri ( uri , getDefaultPort ( ) ) ; thatAuthority = uri . getAuthority ( ) ; if ( thisAuthority == thatAuthority || ( thisAuthority != null && thisAuthority . equalsIgnoreCase ( thatAuthority ) ) ) return ; } } throw new IllegalArgumentException ( "Wrong-FS:-" + path + ",-expected:-" + this . getUri ( ) ) ; } 
private CartesianProduct ( List < T > addedTo , List < ? extends Set < T >> sets , Predicate < List < T >> filter ) { addedTo_ = addedTo ; filter_ = filter ; int setCount = sets . size ( ) ; Set < T > firstSet = setCount == 0 ? Collections . < T > emptySet ( ) : sets . get ( 0 ) ; firstSetIterator_ = firstSet . iterator ( ) ; otherSets_ = setCount < 2 ? Collections . < Set < T >> emptyList ( ) : sets . subList ( 1 , setCount ) ; } 
@ XmlElementDecl ( namespace = "" , name = "classificationattributevalue" ) public JAXBElement < ClassificationAttributeValueDTO > createClassificationattributevalue ( ClassificationAttributeValueDTO value ) { return new JAXBElement < ClassificationAttributeValueDTO > ( _Classificationattributevalue_QNAME , ClassificationAttributeValueDTO . class , null , value ) ; } 
public int cMD_74_0_0 ( String option , String s0 , String s1 , String s2 , String s3 , String s4 , String s5 ) { return Dispatch . call ( this , "CMD_74_0_0" , option , s0 , s1 , s2 , s3 , s4 , s5 ) . changeType ( Variant . VariantInt ) . getInt ( ) ; } 
public static TerminalOp < Double , Boolean > makeDouble ( DoublePredicate predicate , MatchKind matchKind ) { Objects . requireNonNull ( predicate ) ; Objects . requireNonNull ( matchKind ) ; class MatchSink extends BooleanTerminalSink < Double > implements Sink . OfDouble { MatchSink ( ) { super ( matchKind ) ; } @ Override public void accept ( double t ) { if ( ! stop && predicate . test ( t ) == matchKind . stopOnPredicateMatches ) { stop = true ; value = matchKind . shortCircuitResult ; } } } return new MatchOp < > ( StreamShape . DOUBLE_VALUE , matchKind , MatchSink :: new ) ; } 
private static final String setProperty ( final String name , final String value ) { final PrivilegedAction < String > action ; if ( value != null ) action = new PrivilegedAction < String > ( ) { public String run ( ) { return System . setProperty ( name , value ) ; } } ; else action = new PrivilegedAction < String > ( ) { public String run ( ) { return System . clearProperty ( name ) ; } } ; return AccessController . doPrivileged ( action ) ; } 
private void writeObject ( java . io . ObjectOutputStream out ) throws IOException { out . writeFloat ( x ) ; out . writeFloat ( y ) ; } 
@ LayoutlibDelegate static long currentThreadTimeMicro ( ) { return System . currentTimeMillis ( ) * 1000 ; } 
public void deactivate ( ) { try { if ( mContext != null ) { mContext . unregisterReceiver ( this ) ; mContext = null ; mMimeType = null ; } } catch ( IllegalArgumentException e ) { } } 
public static java . util . Random newRandom ( ) { return new Random ( true ) ; } 
private static final int getShort ( InputStream is ) throws IOException { return ( is . read ( ) << 8 ) + is . read ( ) ; } 
public void showStatus ( String msg ) { getAppletContext ( ) . showStatus ( msg ) ; } 
public double getLogLikelihood ( ) { if ( updateMatrix ) { if ( ! Utils . connectedAndWellConditioned ( probability , this ) ) { return Double . NEGATIVE_INFINITY ; } } return 0 ; } 
protected static boolean isRelativeUri ( URI uri ) { if ( uri . isAbsolute ( ) ) return false ; String path = uri . normalize ( ) . getPath ( ) ; if ( path . length ( ) == 0 ) return false ; if ( ! path . equals ( uri . getPath ( ) ) ) return false ; if ( path . startsWith ( "/" ) || path . startsWith ( "./" ) || path . startsWith ( "../" ) ) return false ; return true ; } 
public static final void writeMapXml ( Map val , XmlSerializer out , WriteMapCallback callback ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { return ; } Set s = val . entrySet ( ) ; Iterator i = s . iterator ( ) ; while ( i . hasNext ( ) ) { Map . Entry e = ( Map . Entry ) i . next ( ) ; writeValueXml ( e . getValue ( ) , ( String ) e . getKey ( ) , out , callback ) ; } } 
public void add ( Listener listener ) { for ( Listener x : listeners ) if ( x == listener ) return ; listeners . add ( listener ) ; } 
static public RemoteObject getRemoteObject ( Connection connection , int objectID , Class ... ifaces ) { if ( connection == null ) throw new IllegalArgumentException ( "connection-cannot-be-null." ) ; if ( ifaces == null ) throw new IllegalArgumentException ( "ifaces-cannot-be-null." ) ; Class [ ] temp = new Class [ ifaces . length + 1 ] ; temp [ 0 ] = RemoteObject . class ; System . arraycopy ( ifaces , 0 , temp , 1 , ifaces . length ) ; return ( RemoteObject ) Proxy . newProxyInstance ( ObjectSpace . class . getClassLoader ( ) , temp , new RemoteInvocationHandler ( connection , objectID ) ) ; } 
LoggerService fastGetLoggerServiceForAccount ( String account_name ) throws PException { synchronized ( ACCOUNT_INFO_LOCK ) { AccountInfo account_info = account_info_cache . get ( account_name ) ; if ( account_info != null ) { return account_info . logger_service ; } } return getLoggerServiceForAccount ( account_name ) ; } 
public NumberFormat getNumberFormat ( int style ) { if ( style < 0 || style >= NF_LIMIT ) { throw new IllegalArgumentException ( "Illegal-number-format-type" ) ; } NumberFormat result = null ; if ( numberFormats != null ) { result = numberFormats [ style ] ; } if ( result != null ) { result = ( NumberFormat ) result . clone ( ) ; } else { result = guessNumberFormat ( style ) ; } return result ; } 
protected XMLDocumentScanner createDocumentScanner ( ) { fNamespaceScanner = new XMLNSDocumentScannerImpl ( ) ; return fNamespaceScanner ; } 
void emitCLDCStackMap ( int pc , int localsSize ) { if ( lastStackMapPC == pc ) { stackMapBuffer [ -- stackMapBufferSize ] = null ; } lastStackMapPC = pc ; if ( stackMapBuffer == null ) { stackMapBuffer = new StackMapFrame [ 20 ] ; } else if ( stackMapBuffer . length == stackMapBufferSize ) { StackMapFrame [ ] newStackMapBuffer = new StackMapFrame [ stackMapBufferSize << 1 ] ; System . arraycopy ( stackMapBuffer , 0 , newStackMapBuffer , 0 , stackMapBufferSize ) ; stackMapBuffer = newStackMapBuffer ; } StackMapFrame frame = stackMapBuffer [ stackMapBufferSize ++ ] = new StackMapFrame ( ) ; frame . pc = pc ; frame . locals = new Type [ localsSize ] ; for ( int i = 0 ; i < localsSize ; i ++ ) { if ( state . defined . isMember ( i ) && lvar [ i ] != null ) { Type vtype = lvar [ i ] . sym . type ; if ( ! ( vtype instanceof UninitializedType ) ) vtype = types . erasure ( vtype ) ; frame . locals [ i ] = vtype ; } } frame . stack = new Type [ state . stacksize ] ; for ( int i = 0 ; i < state . stacksize ; i ++ ) frame . stack [ i ] = state . stack [ i ] ; } 
public void scheduleAtFixedRate ( TimerTask task , Date when , long period ) { if ( period <= 0 || when . getTime ( ) < 0 ) { throw new IllegalArgumentException ( ) ; } long delay = when . getTime ( ) - System . currentTimeMillis ( ) ; scheduleImpl ( task , delay , period , true ) ; } 
protected static PreparedStatement getInstance ( MySQLConnection conn , String sql , String catalog , ParseInfo cachedParseInfo ) throws SQLException { if ( ! Util . isJdbc4 ( ) ) { return new PreparedStatement ( conn , sql , catalog , cachedParseInfo ) ; } return ( PreparedStatement ) Util . handleNewInstance ( JDBC_4_PSTMT_4_ARG_CTOR , new Object [ ] { conn , sql , catalog , cachedParseInfo } , conn . getExceptionInterceptor ( ) ) ; } 
void doSeed ( StringTokenizer tokens ) throws SyntaxError { if ( ! tokens . hasMoreTokens ( ) ) { throw new SyntaxError ( "Semilla-no-especificada" ) ; } String tmp = tokens . nextToken ( ) ; parSeed = Long . parseLong ( tmp ) ; } 
private < G extends StorageGroup , C extends StorageGroup > void chooseStorageGroups ( Collection < G > groups , Collection < C > candidates , Matcher matcher ) { for ( final Iterator < G > i = groups . iterator ( ) ; i . hasNext ( ) ; ) { final G g = i . next ( ) ; for ( ; choose4One ( g , candidates , matcher ) ; ) ; if ( ! g . hasSpaceForScheduling ( ) ) { i . remove ( ) ; } } } 
public void reset ( ) { resources . removeAllElements ( ) ; zipFile = null ; baseDir = null ; groupfilesets . removeAllElements ( ) ; duplicate = "add" ; archiveType = "zip" ; doCompress = true ; emptyBehavior = "skip" ; doUpdate = false ; doFilesonly = false ; encoding = null ; } 
public void addContents ( ListEntry param ) { if ( localContents == null ) { localContents = new ListEntry [ ] { } ; } localContentsTracker = true ; java . util . List list = org . apache . axis2 . databinding . utils . ConverterUtil . toList ( localContents ) ; list . add ( param ) ; this . localContents = ( ListEntry [ ] ) list . toArray ( new ListEntry [ list . size ( ) ] ) ; } 
public void keyPressed ( KeyEvent e ) { synchronized ( keyLock ) { keysDown . add ( e . getKeyCode ( ) ) ; } } 
public Drawable getDrawable ( int id , @ Nullable Theme theme ) throws NotFoundException { TypedValue value ; synchronized ( mAccessLock ) { value = mTmpValue ; if ( value == null ) { value = new TypedValue ( ) ; } else { mTmpValue = null ; } getValue ( id , value , true ) ; } final Drawable res = loadDrawable ( value , id , theme ) ; synchronized ( mAccessLock ) { if ( mTmpValue == null ) { mTmpValue = value ; } } return res ; } 
public Collection getSelectionReference ( ) { return Collections . unmodifiableCollection ( selection . keySet ( ) ) ; } 
@ Override public void write ( final char [ ] chr , final int st , final int len ) throws IOException { try { beforeWrite ( len ) ; out . write ( chr , st , len ) ; afterWrite ( len ) ; } catch ( final IOException e ) { handleIOException ( e ) ; } } 
public Room getExit ( String direction ) { return exits . get ( direction ) ; } 
void readTreeSet ( int size , java . io . ObjectInputStream s , V defaultVal ) throws java . io . IOException , ClassNotFoundException { buildFromSorted ( size , null , s , defaultVal ) ; } 
public Vector3D crossProduct ( Vector3D other ) { float x = this . y * other . z - this . z * other . y ; float y = this . z * other . x - this . x * other . z ; float z = this . x * other . y - this . y * other . x ; return new Vector3D ( x , y , z ) ; } 
public boolean set ( Rect r ) { return nativeSetRect ( mNativeRegion , r . left , r . top , r . right , r . bottom ) ; } 
public static Constructor < ? > [ ] getDeclaredConstructors ( Class < ? > clazz , boolean recursively ) { List < Constructor < ? >> constructors = new LinkedList < Constructor < ? >> ( ) ; Constructor < ? > [ ] declaredConstructors = clazz . getDeclaredConstructors ( ) ; Collections . addAll ( constructors , declaredConstructors ) ; Class < ? > superClass = clazz . getSuperclass ( ) ; if ( superClass != null && recursively ) { Constructor < ? > [ ] declaredConstructorsOfSuper = getDeclaredConstructors ( superClass , true ) ; if ( declaredConstructorsOfSuper . length > 0 ) Collections . addAll ( constructors , declaredConstructorsOfSuper ) ; } return constructors . toArray ( new Constructor < ? > [ constructors . size ( ) ] ) ; } 
public boolean cancel ( Runnable r ) { boolean scheduled = false ; synchronized ( this . taskSet ) { ScheduledTask task = this . taskTable . get ( r ) ; if ( task != null ) { this . taskSet . remove ( task ) ; this . taskTable . remove ( task . getTask ( ) ) ; if ( ! task . isDaemon ) { this . numNonDaemonTask -- ; if ( this . numNonDaemonTask <= 0 ) this . jvmLifeKeeper . keep ( false ) ; } scheduled = true ; } this . taskSet . notify ( ) ; } return scheduled ; } 
public TypeLiteral < ? > getReturnType ( Method method ) { if ( ! method . getDeclaringClass ( ) . isAssignableFrom ( rawType ) ) { throw new IllegalArgumentException ( method + "-is-not-defined-by-a-supertype-of-" + type ) ; } return resolve ( method . getGenericReturnType ( ) ) ; } 
void doOutputData ( StringTokenizer tokens ) throws SyntaxError { if ( ! tokens . hasMoreTokens ( ) ) { throw new SyntaxError ( "OutputData-no-especificado" ) ; } String linea = new String ( ) ; while ( tokens . hasMoreTokens ( ) ) { linea = linea + tokens . nextToken ( ) ; } System . out . println ( "Procesando-argumento[" + linea + "]" ) ; String tmp ; StringTokenizer tk = new StringTokenizer ( linea , """ ) ; while ( tk . hasMoreTokens ( ) ) { tmp = tk . nextToken ( ) ; tmp = tmp . trim ( ) ; if ( tmp . length ( ) > 0 ) { System . out . println ( "Nombre-resultados-train-[" + tmp + "]" ) ; parResultTrainName = tmp ; tmp = new String ( "" ) ; if ( tk . hasMoreTokens ( ) ) { tmp = tk . nextToken ( ) ; tmp = tmp . trim ( ) ; } if ( tmp . length ( ) == 0 ) { tmp = new String ( "result.log" ) ; } System . out . println ( "Nombre-resultados-test-[" + tmp + "]" ) ; parResultName = tmp ; break ; } } createResultFile = true ; while ( tk . hasMoreTokens ( ) ) { tmp = tk . nextToken ( ) ; tmp = tmp . trim ( ) ; if ( tmp . length ( ) > 0 ) { outputData . add ( tmp ) ; } } } 
public int getCapHeight ( ) { return metric . getCapHeight ( fontSize ) / 1000 ; } 
public List < Object > getBrokerServiceOrAny ( ) { if ( brokerServiceOrAny == null ) { brokerServiceOrAny = new ArrayList < Object > ( ) ; } return this . brokerServiceOrAny ; } 
public final int sign ( byte [ ] outbuf , int offset , int len ) throws SignatureException { if ( outbuf == null || offset < 0 || len < 0 || offset + len > outbuf . length ) { throw new IllegalArgumentException ( ) ; } if ( state != SIGN ) { throw new SignatureException ( "Signature-object-is-not-initialized-properly" ) ; } return engineSign ( outbuf , offset , len ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public String getObjectId ( ) { return ServiceContext . getObjectId ( ) ; } 
public static byte [ ] trimToCapacity ( byte [ ] array , int maxCapacity ) { if ( array . length > maxCapacity ) { byte oldArray [ ] = array ; array = new byte [ maxCapacity ] ; System . arraycopy ( oldArray , 0 , array , 0 , maxCapacity ) ; } return array ; } 
public static String getStackTrace ( Throwable e ) { Writer result = new StringWriter ( ) ; PrintWriter printWriter = new PrintWriter ( result ) ; e . printStackTrace ( printWriter ) ; return result . toString ( ) ; } 
AccessibleStateSet getAccessibleStateSet ( ) { AccessibleStateSet states = new AccessibleStateSet ( ) ; return states ; } 
public static boolean closureIsBusy ( DFAState d , NFAConfiguration proposedNFAConfiguration ) { return d . closureBusy . contains ( proposedNFAConfiguration ) ; } 
private void loadPalette ( Resources res ) { colorPalette [ 0 ] = res . getColor ( R . color . chat_dark_yellow ) ; colorPalette [ 1 ] = res . getColor ( R . color . chat_dark_orange ) ; colorPalette [ 2 ] = res . getColor ( R . color . chat_grass_green ) ; colorPalette [ 3 ] = res . getColor ( R . color . chat_pale_yellow ) ; colorPalette [ 4 ] = res . getColor ( R . color . chat_dark_pink ) ; colorPalette [ 5 ] = res . getColor ( R . color . chat_light_orange ) ; colorPalette [ 6 ] = res . getColor ( R . color . chat_dark_green ) ; colorPalette [ 7 ] = res . getColor ( R . color . chat_olive_green ) ; colorPalette [ 8 ] = res . getColor ( R . color . chat_earth_brown ) ; colorPalette [ 9 ] = res . getColor ( R . color . chat_strong_purple ) ; } 
public List < Metric > getMetrics ( ) { return Arrays . asList ( QMTREE , QMTREE_PROJECTKEY , BENCHMARK , BENCHMARK_PROJECTKEY ) ; } 
public static void isInstanceOf ( Class < ? > type , Object obj , String message ) { notNull ( type , "Type-to-check-against-must-not-be-null" ) ; if ( ! type . isInstance ( obj ) ) { throw new IllegalArgumentException ( message + "Object-of-class-[" + ( obj != null ? obj . getClass ( ) . getName ( ) : "null" ) + "]-must-be-an-instance-of-" + type ) ; } } 
public static boolean hasNextChar ( ) { scanner . useDelimiter ( EMPTY_PATTERN ) ; final boolean result = scanner . hasNext ( ) ; scanner . useDelimiter ( WHITESPACE_PATTERN ) ; return result ; } 
public synchronized Set < Map . Entry < Object , Object >> entrySet ( ) { if ( entrySet == null ) { if ( entrySetCallCount ++ == 0 ) entrySet = Collections . unmodifiableMap ( this ) . entrySet ( ) ; else return super . entrySet ( ) ; } if ( entrySetCallCount != 2 ) throw new RuntimeException ( "Internal-error." ) ; return entrySet ; } 
public Status ( int type , String reason ) throws IllegalArgumentException { if ( type < 0 || type >= NUM_STATES ) throw new IllegalArgumentException ( String . valueOf ( type ) ) ; for ( int i = 0 ; i < reason . length ( ) ; i ++ ) { if ( ! isPrintable ( reason . charAt ( i ) ) ) { StringBuffer r = new StringBuffer ( reason . length ( ) ) ; for ( int j = 0 ; j < reason . length ( ) ; j ++ ) { char c = reason . charAt ( j ) ; r . append ( isPrintable ( c ) ? c : '-' ) ; } reason = r . toString ( ) ; break ; } } this . type = type ; this . reason = reason . trim ( ) ; } 
public static void restore ( ThreadContext oldContext ) throws NullPointerException , IllegalArgumentException { if ( oldContext == null ) throw new NullPointerException ( ) ; for ( ThreadContext context = getContext ( ) ; context != oldContext ; context = context . previous ) { if ( context == null ) { throw new IllegalArgumentException ( "Restored-context-is-not-" + "contained-in-current-" + "context" ) ; } } if ( oldContext . key == null ) oldContext = null ; setContext ( oldContext ) ; } 
@ Override public String modifyWhitespace ( String whitespace ) { return whitespace . length ( ) > 0 ? "-" : "" ; } 
public int getWarningCount ( ) { return errorManager . getWarningCount ( ) ; } 
public static String canonicalPropertyName ( String propertyName ) { if ( propertyName == null ) { return "" ; } StringBuilder sb = new StringBuilder ( propertyName ) ; int searchIndex = 0 ; while ( searchIndex != - 1 ) { int keyStart = sb . indexOf ( PropertyAccessor . PROPERTY_KEY_PREFIX , searchIndex ) ; searchIndex = - 1 ; if ( keyStart != - 1 ) { int keyEnd = sb . indexOf ( PropertyAccessor . PROPERTY_KEY_SUFFIX , keyStart + PropertyAccessor . PROPERTY_KEY_PREFIX . length ( ) ) ; if ( keyEnd != - 1 ) { String key = sb . substring ( keyStart + PropertyAccessor . PROPERTY_KEY_PREFIX . length ( ) , keyEnd ) ; if ( ( key . startsWith ( "'" ) && key . endsWith ( "'" ) ) || ( key . startsWith ( """ ) && key . endsWith ( """ ) ) ) { sb . delete ( keyStart + 1 , keyStart + 2 ) ; sb . delete ( keyEnd - 2 , keyEnd - 1 ) ; keyEnd = keyEnd - 2 ; } searchIndex = keyEnd + PropertyAccessor . PROPERTY_KEY_SUFFIX . length ( ) ; } } } return sb . toString ( ) ; } 
private void invokePreDestroy ( Object o ) { Class clazz = o . getClass ( ) ; for ( Method method : clazz . getDeclaredMethods ( ) ) { if ( method . isAnnotationPresent ( PreDestroy . class ) ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; Object [ ] parameters = new Object [ parameterTypes . length ] ; boolean accessible = method . isAccessible ( ) ; if ( ! accessible ) { method . setAccessible ( true ) ; } try { method . invoke ( o , parameters ) ; } catch ( Exception ex ) { logger . log ( Level . SEVERE , null , ex ) ; } finally { if ( ! accessible ) { method . setAccessible ( accessible ) ; } } } } } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public U getCurrentFirst ( ) { return firstList . get ( position ) ; } 
private JComboBox < TechRating > get_UnitTechRatingComboBox ( ) { if ( _UnitTechRatingComboBox == null ) { _UnitTechRatingComboBox = new JComboBox < TechRating > ( TechRating . values ( ) ) ; _UnitTechRatingComboBox . setBounds ( new Rectangle ( 459 , 223 , 141 , 23 ) ) ; } return _UnitTechRatingComboBox ; } 
public static void validateTableName ( String tableName ) { if ( Utility . isNullOrEmptyOrWhitespace ( tableName ) ) { throw new IllegalArgumentException ( String . format ( Utility . LOCALE_US , SR . RESOURCE_NAME_EMPTY , SR . TABLE ) ) ; } if ( tableName . length ( ) < NameValidator . CONTAINER_SHARE_QUEUE_TABLE_MIN_LENGTH || tableName . length ( ) > NameValidator . CONTAINER_SHARE_QUEUE_TABLE_MAX_LENGTH ) { throw new IllegalArgumentException ( String . format ( Utility . LOCALE_US , SR . INVALID_RESOURCE_NAME_LENGTH , SR . TABLE , NameValidator . CONTAINER_SHARE_QUEUE_TABLE_MIN_LENGTH , NameValidator . CONTAINER_SHARE_QUEUE_TABLE_MAX_LENGTH ) ) ; } if ( ! ( NameValidator . TABLE_REGEX . matcher ( tableName ) . matches ( ) || NameValidator . METRICS_TABLE_REGEX . matcher ( tableName ) . matches ( ) || tableName . equalsIgnoreCase ( "$MetricsCapacityBlob" ) ) ) { throw new IllegalArgumentException ( String . format ( Utility . LOCALE_US , SR . INVALID_RESOURCE_NAME , SR . TABLE ) ) ; } } 
public void set ( String command , int [ ] keyCode ) { ArrayList < KeyCodes > keyList = new ArrayList < KeyCodes > ( ) ; KeyCodes key = new KeyCodes ( ) ; key . keys = keyCode ; keyList . add ( key ) ; keyMap . put ( command , keyList ) ; } 
protected void clearHistory ( ) { _historyIndex = 0 ; if ( _history != null ) _history . clear ( ) ; } 
private static PathStrategy getPathStrategy ( Context context , String authority ) { PathStrategy strat ; synchronized ( sCache ) { strat = sCache . get ( authority ) ; if ( strat == null ) { try { strat = parsePathStrategy ( context , authority ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( "Failed-to-parse-" + META_DATA_FILE_PROVIDER_PATHS + "-meta-data" , e ) ; } catch ( XmlPullParserException e ) { throw new IllegalArgumentException ( "Failed-to-parse-" + META_DATA_FILE_PROVIDER_PATHS + "-meta-data" , e ) ; } sCache . put ( authority , strat ) ; } } return strat ; } 
public static void appendEncoded ( final StringBuffer buffer , final String unencodedValue , final char [ ] reserved ) { final int offset = buffer . length ( ) ; buffer . append ( unencodedValue ) ; encode ( buffer , offset , unencodedValue . length ( ) , reserved ) ; } 
protected String formatValue ( final Object value ) { if ( value instanceof Number ) { if ( numberFormat == null ) { numberFormat = NumberFormat . getNumberInstance ( locale ) ; } return numberFormat . format ( value ) ; } if ( value instanceof Date ) { if ( dateFormat == null ) { dateFormat = DateFormat . getDateInstance ( DateFormat . MEDIUM , locale ) ; } return dateFormat . format ( value ) ; } if ( value instanceof Angle ) { if ( angleFormat == null ) { angleFormat = AngleFormat . getInstance ( locale ) ; } return angleFormat . format ( value ) ; } return String . valueOf ( value ) ; } 
public Object [ ] toArray ( ) { return copyElements ( new Object [ size ( ) ] ) ; } 
protected void acceptDrag ( int dragOperation ) { DropTargetContextPeer peer = getDropTargetContextPeer ( ) ; if ( peer != null ) { peer . acceptDrag ( dragOperation ) ; } } 
public void expectEvent ( AccessibilityEvent expectedEvent ) { mExpectedEvents . add ( expectedEvent ) ; } 
public static < K , V > LinkedHashMap < K , V > newLinkedHashMap ( ) { return new LinkedHashMap < K , V > ( ) ; } 
public boolean accepts ( double value ) { if ( Double . isNaN ( value ) ) { return false ; } if ( value < this . lowerBound ) { return false ; } if ( value > this . upperBound ) { return false ; } if ( value == this . lowerBound ) { return this . includeLowerBound ; } if ( value == this . upperBound ) { return this . includeUpperBound ; } return true ; } 
public void maybeShare ( Connection connection ) { executorService . submit ( connectionsCleanupCallable ) ; if ( ! connection . isSpdy ( ) ) { return ; } if ( connection . isAlive ( ) ) { synchronized ( this ) { connections . addFirst ( connection ) ; } } } 
private void mergeCOMNode ( Node node ) throws IIOInvalidTreeException { COMMarkerSegment newGuy = new COMMarkerSegment ( node ) ; insertCOMMarkerSegment ( newGuy ) ; } 
public static float createFloat ( int min , int max ) { if ( min < 0 ) throw new IllegalArgumentException ( ) ; if ( max < 0 ) throw new IllegalArgumentException ( ) ; if ( max < min ) throw new IllegalArgumentException ( ) ; float seed = getRandom ( ) . nextFloat ( ) ; return Math . abs ( min + seed * ( max - min ) ) ; } 
public boolean isLinkable ( ClassDoc classDoc , Configuration configuration ) { return ( ( classDoc . isIncluded ( ) && configuration . isGeneratedDoc ( classDoc ) ) ) || ( configuration . extern . isExternal ( classDoc ) && ( classDoc . isPublic ( ) || classDoc . isProtected ( ) ) ) ; } 
public static int [ ] toCodePointArray ( final CharSequence charSequence , final int startIndex , final int endIndex ) { final int length = charSequence . length ( ) ; if ( length <= 0 ) { return EMPTY_CODEPOINTS ; } final int [ ] codePoints = new int [ Character . codePointCount ( charSequence , startIndex , endIndex ) ] ; copyCodePointsAndReturnCodePointCount ( codePoints , charSequence , startIndex , endIndex , false ) ; return codePoints ; } 
public static Vector < String > findPackages ( ) { Vector < String > result ; Enumeration < String > packages ; initCache ( ) ; result = new Vector < String > ( ) ; packages = m_ClassCache . packages ( ) ; while ( packages . hasMoreElements ( ) ) result . add ( packages . nextElement ( ) ) ; Collections . sort ( result , new StringCompare ( ) ) ; return result ; } 
public final static DateFormat getDateTimeInstance ( int dateStyle , int timeStyle , Locale aLocale ) { return get ( timeStyle , dateStyle , 3 , aLocale ) ; } 
public void adjustMultipliedLeading ( Font font ) { if ( originMultipliedLeading != null && font != null && font . getBaseFont ( ) != null ) { float size = font . getSize ( ) ; float ascender = font . getBaseFont ( ) . getFontDescriptor ( BaseFont . AWT_ASCENT , size ) ; float descender = - font . getBaseFont ( ) . getFontDescriptor ( BaseFont . AWT_DESCENT , size ) ; float margin = font . getBaseFont ( ) . getFontDescriptor ( BaseFont . AWT_LEADING , size ) ; float multiplier = ( ascender + descender + margin ) / size ; super . setMultipliedLeading ( originMultipliedLeading * multiplier ) ; } } 
@ XmlElementDecl ( namespace = "urn:oasis:names:tc:ebxml-regrep:xsd:rim:3.0" , name = "ClassificationNode" , substitutionHeadNamespace = "urn:oasis:names:tc:ebxml-regrep:xsd:rim:3.0" , substitutionHeadName = "Identifiable" ) public JAXBElement < ClassificationNodeType > createClassificationNode ( ClassificationNodeType value ) { return new JAXBElement < ClassificationNodeType > ( _ClassificationNode_QNAME , ClassificationNodeType . class , null , value ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
@ Override public void close ( ) throws IOException { mOpen = false ; mParent . streamClosed ( true ) ; } 
public final void addWindowAddedListener ( Listener listener ) { addHandlers . add ( listener ) ; } 
public List < Lane > getAllLanes ( ) { List < Lane > laneList = new ArrayList < Lane > ( ) ; for ( Lane lane : this . getLanes ( ) ) { laneList . add ( lane ) ; laneList . addAll ( lane . getLaneList ( ) ) ; } return laneList ; } 
public MailcapFile ( InputStream is ) throws IOException { if ( LogSupport . isLoggable ( ) ) LogSupport . log ( "new-MailcapFile:-InputStream" ) ; parse ( new BufferedReader ( new InputStreamReader ( is , "iso-8859-1" ) ) ) ; } 
protected void dropFewItems ( boolean par1 , int par2 ) { if ( par1 ) { int var3 = this . rand . nextInt ( 2 + par2 ) ; for ( int var4 = 0 ; var4 < var3 ; ++ var4 ) { this . dropItem ( Item . blazeRod . itemID , 1 ) ; } } } 
public Dimension getPreferredSize ( ) { Dimension size = new Dimension ( 200 , 200 ) ; return size ; } 
public int hashCode ( ) { if ( hashCode == 0 ) { int result = 17 ; result = 37 * result + getShortName ( ) . hashCode ( ) ; if ( isScalar ( ) ) result ++ ; result = 37 * result + getDataType ( ) . hashCode ( ) ; result = 37 * result + getParentGroup ( ) . hashCode ( ) ; if ( getParentStructure ( ) != null ) result = 37 * result + getParentStructure ( ) . hashCode ( ) ; if ( isVariableLength ) result ++ ; result = 37 * result + dimensions . hashCode ( ) ; hashCode = result ; } return hashCode ; } 
public void register ( Character command , AtCommandHandler handler ) { mBasicHandlers . put ( command , handler ) ; } 
public void openFrame ( String name ) { StringBuffer buff = m_Results . get ( name ) ; JTextComponent currentText = m_FramedOutput . get ( name ) ; if ( ( buff != null ) && ( currentText == null ) ) { JTextArea ta = new JTextArea ( ) ; ta . setBorder ( BorderFactory . createEmptyBorder ( 5 , 5 , 5 , 5 ) ) ; ta . setFont ( new Font ( "Monospaced" , Font . PLAIN , 12 ) ) ; ta . setEditable ( false ) ; ta . setText ( buff . toString ( ) ) ; m_FramedOutput . put ( name , ta ) ; final JFrame jf = new JFrame ( name ) ; jf . addWindowListener ( new WindowAdapter ( ) { @ Override public void windowClosing ( WindowEvent e ) { m_FramedOutput . remove ( jf . getTitle ( ) ) ; jf . dispose ( ) ; } } ) ; jf . getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ; jf . getContentPane ( ) . add ( new JScrollPane ( ta ) , BorderLayout . CENTER ) ; jf . pack ( ) ; jf . setSize ( 450 , 350 ) ; jf . setVisible ( true ) ; } } 
@ Override protected < T > T convertToType ( Class < T > type , Object value ) throws Throwable { if ( Class . class . equals ( type ) ) { ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( classLoader != null ) { try { return type . cast ( classLoader . loadClass ( value . toString ( ) ) ) ; } catch ( ClassNotFoundException ex ) { } } classLoader = ClassConverter . class . getClassLoader ( ) ; return type . cast ( classLoader . loadClass ( value . toString ( ) ) ) ; } throw conversionException ( type , value ) ; } 
protected void appendShortType ( StringBuilder sb , FieldType fieldType , int fieldWidth ) { sb . append ( "SMALLINT" ) ; } 
protected void fireMenuDeselected ( ) { if ( DEBUG ) { System . out . println ( "In-JMenu.fireMenuDeselected" ) ; } Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == MenuListener . class ) { if ( listeners [ i + 1 ] == null ) { throw new Error ( getText ( ) + "-has-a-NULL-Listener!!-" + i ) ; } else { if ( menuEvent == null ) menuEvent = new MenuEvent ( this ) ; ( ( MenuListener ) listeners [ i + 1 ] ) . menuDeselected ( menuEvent ) ; } } } } 
public List < String > get_skipped_methods ( ) { return new ArrayList < String > ( skipped_methods ) ; } 
public static List < String > findSchemeMatch ( String schemeToFind , boolean matchAnywhere ) { return findSchemeMatch ( null , schemeToFind , matchAnywhere , false ) ; } 
final long fullyRelease ( Node node ) { boolean failed = true ; try { long savedState = getState ( ) ; if ( release ( savedState ) ) { failed = false ; return savedState ; } else { throw new IllegalMonitorStateException ( ) ; } } finally { if ( failed ) node . waitStatus = Node . CANCELLED ; } } 
public static ArrayList < TimeZone > getTimeZonesWithUniqueOffsets ( String country ) { synchronized ( sLastUniqueLockObj ) { if ( ( country != null ) && country . equals ( sLastUniqueCountry ) ) { if ( DBG ) { Log . d ( TAG , "getTimeZonesWithUniqueOffsets(" + country + "):-return-cached-version" ) ; } return sLastUniqueZoneOffsets ; } } Collection < TimeZone > zones = getTimeZones ( country ) ; ArrayList < TimeZone > uniqueTimeZones = new ArrayList < TimeZone > ( ) ; for ( TimeZone zone : zones ) { boolean found = false ; for ( int i = 0 ; i < uniqueTimeZones . size ( ) ; i ++ ) { if ( uniqueTimeZones . get ( i ) . getRawOffset ( ) == zone . getRawOffset ( ) ) { found = true ; break ; } } if ( found == false ) { if ( DBG ) { Log . d ( TAG , "getTimeZonesWithUniqueOffsets:-add-unique-offset=" + zone . getRawOffset ( ) + "-zone.getID=" + zone . getID ( ) ) ; } uniqueTimeZones . add ( zone ) ; } } synchronized ( sLastUniqueLockObj ) { sLastUniqueZoneOffsets = uniqueTimeZones ; sLastUniqueCountry = country ; return sLastUniqueZoneOffsets ; } } 
public static String left ( String s , int w ) { int n = s . length ( ) ; if ( w < n ) return s . substring ( 0 , w ) ; StringBuffer b = new StringBuffer ( w ) ; b . append ( s ) ; for ( int i = n ; i < w ; ++ i ) { b . append ( '-' ) ; } return b . toString ( ) ; } 
public String getRackName ( ) { return rackName == null ? null : rackName . toString ( ) ; } 
public void startWordIterator ( ) { words = new StringTokenizer ( transcript , wordSeparator ) ; } 
@ Override public void clear ( ) { removeAllElements ( ) ; } 
public WebAppDescriptor displayName ( String ... values ) { if ( values != null ) { for ( String name : values ) { model . createChild ( "display-name" ) . text ( name ) ; } } return this ; } 
public static List < PropertySuffix > getProperties ( String prefix ) { int prefixLength = prefix . length ( ) ; List < PropertySuffix > values = new ArrayList < PropertySuffix > ( ) ; for ( Map . Entry < String , String > entry : properties . entrySet ( ) ) { String name = entry . getKey ( ) ; if ( name . startsWith ( prefix ) ) { String suffix = name . substring ( prefixLength ) ; String value = entry . getValue ( ) ; values . add ( new PropertySuffix ( name , suffix , value ) ) ; } } return values ; } 
public boolean contains ( final Account account ) { childLock . readLock ( ) . lock ( ) ; try { return cachedSortedChildren . contains ( account ) ; } finally { childLock . readLock ( ) . unlock ( ) ; } } 
public static ArrayList < Callable < Object >> GetResetTasks ( ) { ArrayList < Callable < Object >> tasks = new ArrayList < Callable < Object >> ( ) ; for ( final String directoryPath : ListUtilities . CreateStringList ( Settings . FEATURE_SELECTION_DIR , Settings . PREDICTIONS_DIR , Settings . ENSEMBLE_PREDICTIONS_DIR , Settings . OUTPUT_DIR , Settings . STATUS_DIR , Settings . DATA_DIR , Settings . TEMP_DATA_DIR , Settings . TEMP_RESULTS_DIR , Settings . LOCKS_DIR ) ) { tasks . add ( new Callable < Object > ( ) { public Object call ( ) throws Exception { MiscUtilities . DeleteCoreDirectory ( directoryPath ) ; return null ; } } ) ; } return tasks ; } 
public void skippedEntity ( String name ) throws SAXException { if ( docNext != null ) docNext . skippedEntity ( name ) ; } 
public int charCount ( ) { return value . length ( ) ; } 
void componentInputMapChanged ( ComponentInputMap inputMap ) { InputMap km = getInputMap ( WHEN_IN_FOCUSED_WINDOW , false ) ; while ( km != inputMap && km != null ) { km = ( ComponentInputMap ) km . getParent ( ) ; } if ( km != null ) { registerWithKeyboardManager ( false ) ; } } 
private String getForwardToPageOnLogin ( Long loginId ) throws SMException { ISecurityManager securityManager = SecurityManagerFactory . getSecurityManager ( ) ; String roleName = securityManager . getRoleName ( loginId ) ; if ( roleName != null && ! roleName . equals ( "" ) ) { String modifiedRolename = roleName . substring ( 0 , 1 ) . toUpperCase ( ) + roleName . substring ( 1 , roleName . length ( ) ) . toLowerCase ( ) ; return ( Constants . PAGEOF + modifiedRolename ) ; } return null ; } 
public void set ( Matrix_Delegate matrix ) { System . arraycopy ( matrix . mValues , 0 , mValues , 0 , MATRIX_SIZE ) ; } 
protected int [ ] getPixels ( BufferedImage bi ) { if ( ( bi . getType ( ) != BufferedImage . TYPE_INT_ARGB && bi . getType ( ) != BufferedImage . TYPE_INT_RGB ) || ! ( bi . getRaster ( ) . getDataBuffer ( ) instanceof DataBufferInt ) ) { BufferedImage tmp = bi ; bi = new BufferedImage ( tmp . getWidth ( ) , tmp . getHeight ( ) , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g = bi . createGraphics ( ) ; g . drawImage ( tmp , 0 , 0 , null ) ; g . dispose ( ) ; } DataBufferInt buf = ( DataBufferInt ) bi . getRaster ( ) . getDataBuffer ( ) ; int [ ] p = buf . getData ( ) ; return p ; } 
private void putEntry ( String key , CacheHeader entry ) { if ( ! mEntries . containsKey ( key ) ) { mTotalSize += entry . size ; } else { CacheHeader oldEntry = mEntries . get ( key ) ; mTotalSize += ( entry . size - oldEntry . size ) ; } mEntries . put ( key , entry ) ; } 
public String shortcutTag ( Element element , String newElementName , String childContent , Class < ? extends Content > childType ) throws ProcessorException { String response = "" ; if ( element == null ) { return "" ; } if ( ( ! "" . equals ( childContent ) ) && ( ( childType == Element . class ) || ( childType == Text . class ) ) ) { Element newElement = new Element ( newElementName , element . getNamespaceURI ( ) ) ; if ( childType == Element . class ) { newElement . addContent ( new Element ( childContent , element . getNamespaceURI ( ) ) ) ; } else if ( childType == Text . class ) { newElement . setText ( childContent ) ; } response = response + evaluate ( newElement ) ; } return response ; } 
private void checkKey ( Key < ? > key ) { if ( factories . containsKey ( key ) && ! allowDuplicates ) { throw new DependencyException ( "Dependency-mapping-for-" + key + "-already-exists." ) ; } } 
public void print ( PrintWriter strm ) { if ( _valid ) { strm . println ( "InputBuffer-:-" ) ; strm . println ( "InputBuffer-:-" ) ; for ( int i = 0 ; i < _byteArray . length ; i ++ ) strm . write ( ( char ) _byteArray [ i ] ) ; } else strm . println ( "InputBuffer-:-invalid." ) ; } 
@ RequestMapping ( "/index.htm" ) public String showOurHomePage ( ) { return Context . isAuthenticated ( ) ? ( "forward:/" + KENYAEMR_HOME_URL ) : ( "redirect:/" + OPENMRS_LOGIN_URL ) ; } 
private JButton getBCancelar ( ) { if ( bCancelar == null ) { bCancelar = new JButton ( ) ; bCancelar . setBounds ( new Rectangle ( 150 , 190 , 100 , 30 ) ) ; bCancelar . setText ( "Cerrar" ) ; bCancelar . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent e ) { limpiarCampos ( ) ; dAbmArticulos . setVisible ( false ) ; } } ) ; } return bCancelar ; } 
public Point getLocationForChatWindow ( ) { Point mw_loc = this . getLocation ( ) ; Dimension mw_size = this . getSize ( ) ; Dimension screensize = Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; int windowcount = openFilesTable . getRowCount ( ) + connectedRoomsTable . getRowCount ( ) ; int dist = 40 ; int xpos = ( int ) ( mw_loc . getX ( ) + mw_size . getWidth ( ) + windowcount * dist ) ; int ypos = dist * windowcount ; xpos = ( int ) Math . min ( xpos , screensize . getWidth ( ) - 100 ) ; ypos = ( int ) Math . min ( ypos , screensize . getHeight ( ) - 100 ) ; return new Point ( xpos , ypos ) ; } 
public static void drawOval ( Graphics g , int centerX , int centerY , int hRadius , int vRadius ) { int hDiameter = 2 * hRadius ; int vDiameter = 2 * vRadius ; g . drawOval ( centerX - hRadius , centerY - vRadius , hDiameter , vDiameter ) ; } 
public Object get ( ) { while ( true ) { Thread t = threadVar . get ( ) ; if ( t == null ) { return getValue ( ) ; } try { t . join ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; return null ; } } } 
public List < Entry < K , V >> entries ( ) { List < Entry < K , V >> entries = new LinkedList < Entry < K , V >> ( ) ; for ( int i = 0 ; i < map . length ; i ++ ) { if ( map [ i ] != null ) { Iterator < Entry < K , V >> it = map [ i ] . iterator ( ) ; while ( it . hasNext ( ) ) { entries . add ( it . next ( ) ) ; } } } return entries ; } 
void interruptIdleWorkers ( ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { for ( Worker w : workers ) w . interruptIfIdle ( ) ; } finally { mainLock . unlock ( ) ; } } 
public static char readChar ( ) { scanner . useDelimiter ( EMPTY_PATTERN ) ; String ch = scanner . next ( ) ; assert ( ch . length ( ) == 1 ) : "Internal-(Std)In.readChar()-error!" + "-Please-contact-the-authors." ; scanner . useDelimiter ( WHITESPACE_PATTERN ) ; return ch . charAt ( 0 ) ; } 
private void requestInputMethod ( Dialog dialog ) { Window window = dialog . getWindow ( ) ; window . setSoftInputMode ( WindowManager . LayoutParams . SOFT_INPUT_STATE_ALWAYS_VISIBLE ) ; } 
protected String escapeValue ( Object value ) { return String . valueOf ( value ) ; } 
protected boolean canEditImmediately ( EventObject event ) { if ( ( event instanceof MouseEvent ) && SwingUtilities . isLeftMouseButton ( ( MouseEvent ) event ) ) { MouseEvent me = ( MouseEvent ) event ; return ( ( me . getClickCount ( ) > 2 ) && inHitRegion ( me . getX ( ) , me . getY ( ) ) ) ; } return ( event == null ) ; } 
public final void addElements ( Object value , int numberOfElements ) { if ( ( m_firstFree + numberOfElements ) >= m_mapSize ) { m_mapSize += ( m_blocksize + numberOfElements ) ; Object newMap [ ] = new Object [ m_mapSize ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_firstFree + 1 ) ; m_map = newMap ; } for ( int i = 0 ; i < numberOfElements ; i ++ ) { m_map [ m_firstFree ] = value ; m_firstFree ++ ; } } 
public void run ( ) { try { Runnable job = null ; while ( isRunning ( ) ) { if ( job != null ) { _isIdle = false ; Runnable todo = job ; job = null ; todo . run ( ) ; } else { synchronized ( _jobsLock ) { if ( _queued > 0 ) { _queued -- ; job = _jobs [ _nextJob ++ ] ; if ( _nextJob == _jobs . length ) _nextJob = 0 ; continue ; } } synchronized ( _idleLock ) { _warned = false ; if ( ( _threads . size ( ) > _maxThreads || _idle . size ( ) > _spawnOrShrinkAt && _threads . size ( ) > _minThreads ) ) { _isIdle = _idle . contains ( this ) ; long now = System . currentTimeMillis ( ) ; if ( _isIdle && ( now - _lastShrink ) > getMaxIdleTimeMs ( ) ) { _lastShrink = now ; return ; } } if ( ! _isIdle ) { _idle . add ( this ) ; _isIdle = true ; } } try { synchronized ( this ) { if ( _job == null ) this . wait ( getMaxIdleTimeMs ( ) ) ; job = _job ; _job = null ; } } catch ( InterruptedException e ) { Log . ignore ( e ) ; } } } } finally { synchronized ( _idleLock ) { _idle . remove ( this ) ; } synchronized ( _threadLock ) { _threads . remove ( this ) ; } Runnable job = null ; synchronized ( this ) { job = _job ; } if ( job != null && isRunning ( ) ) QueuedThreadPool . this . dispatch ( job ) ; } } 
protected static MultiMap loadMetaMap ( Element element ) { MultiMap result = new MultiHashMap ( ) ; List metaAttributeList = new ArrayList ( ) ; metaAttributeList . addAll ( element . elements ( "meta" ) ) ; for ( Iterator iter = metaAttributeList . iterator ( ) ; iter . hasNext ( ) ; ) { Element metaAttrib = ( Element ) iter . next ( ) ; String attribute = metaAttrib . attributeValue ( "attribute" ) ; String value = metaAttrib . getText ( ) ; String inheritStr = metaAttrib . attributeValue ( "inherit" ) ; boolean inherit = true ; if ( inheritStr != null ) { inherit = Boolean . valueOf ( inheritStr ) . booleanValue ( ) ; } MetaAttributeBinder . SimpleMetaAttribute ma = new MetaAttributeBinder . SimpleMetaAttribute ( value , inherit ) ; result . put ( attribute , ma ) ; } return result ; } 
public static List < SearchMemberStatus > listOfShortOfFormalized ( ) { return new ArrayList < SearchMemberStatus > ( Arrays . asList ( Provisional ) ) ; } 
public int getYears ( ) { return getField ( DatatypeConstants . YEARS ) . intValue ( ) ; } 
public void setFetchDirection ( int direction ) throws SQLException { if ( ( ( getType ( ) == ResultSet . TYPE_FORWARD_ONLY ) && ( direction != ResultSet . FETCH_FORWARD ) ) || ( ( direction != ResultSet . FETCH_FORWARD ) && ( direction != ResultSet . FETCH_REVERSE ) && ( direction != ResultSet . FETCH_UNKNOWN ) ) ) { throw new SQLException ( "Invalid-Fetch-Direction" ) ; } fetchDir = direction ; } 
public static Object [ ] addObjectToArray ( Object [ ] array , Object obj ) { Class < ? > compType = Object . class ; if ( array != null ) { compType = array . getClass ( ) . getComponentType ( ) ; } else if ( obj != null ) { compType = obj . getClass ( ) ; } int newArrLength = ( array != null ? array . length + 1 : 1 ) ; Object [ ] newArr = ( Object [ ] ) Array . newInstance ( compType , newArrLength ) ; if ( array != null ) { System . arraycopy ( array , 0 , newArr , 0 , array . length ) ; } newArr [ newArr . length - 1 ] = obj ; return newArr ; } 
public String getValueFlag ( final char flag ) { final String result = valueFlags . get ( Character . toLowerCase ( flag ) ) ; if ( result == null ) { return null ; } if ( parsedArgs . remove ( result ) ) { length -- ; } return result ; } 
public static synchronized TimerThread getInstance ( ) { if ( instance == null ) { instance = new TimerThread ( ) ; instance . start ( ) ; } return instance ; } 
@ Override public boolean equals ( Object object ) { return ( object == this ) || ( object instanceof Date ) && ( milliseconds == ( ( Date ) object ) . milliseconds ) ; } 
public T peek ( ) throws EmptyCollectionException { if ( isEmpty ( ) ) throw new EmptyCollectionException ( "stack" ) ; return stack [ top - 1 ] ; } 
@ CheckReturnValue public String removeFrom ( CharSequence sequence ) { String string = sequence . toString ( ) ; int pos = indexIn ( string ) ; if ( pos == - 1 ) { return string ; } char [ ] chars = string . toCharArray ( ) ; int spread = 1 ; OUT : while ( true ) { pos ++ ; while ( true ) { if ( pos == chars . length ) { break OUT ; } if ( matches ( chars [ pos ] ) ) { break ; } chars [ pos - spread ] = chars [ pos ] ; pos ++ ; } spread ++ ; } return new String ( chars , 0 , pos - spread ) ; } 
public BigInteger getSerialNumber ( ) { if ( holder . getBaseCertificateID ( ) != null ) { return holder . getBaseCertificateID ( ) . getSerial ( ) . getValue ( ) ; } return null ; } 
private void addExtracted ( CrawlURI curi , String file ) { try { file = URLEncoder . encode ( file , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( e ) ; } if ( logger . isLoggable ( Level . FINEST ) ) { logger . log ( Level . FINEST , "Found-" + file ) ; } String base = curi . toString ( ) ; if ( base . endsWith ( "/" ) ) { base = base . substring ( 0 , base . length ( ) - 1 ) ; } try { UURI n = UURIFactory . getInstance ( base + "/" + file ) ; CrawlURI link = curi . createCrawlURI ( n , LinkContext . NAVLINK_MISC , Hop . NAVLINK ) ; curi . getOutLinks ( ) . add ( link ) ; } catch ( URIException e ) { logger . log ( Level . WARNING , "URI-error-during-extraction." , e ) ; } } 
@ Override protected void replaceEditor ( JComponent oldEditor , JComponent newEditor ) { spinner . remove ( oldEditor ) ; spinner . add ( newEditor , "Editor" ) ; if ( oldEditor instanceof JSpinner . DefaultEditor ) { JTextField tf = ( ( JSpinner . DefaultEditor ) oldEditor ) . getTextField ( ) ; if ( tf != null ) { tf . removeFocusListener ( editorFocusHandler ) ; } } if ( newEditor instanceof JSpinner . DefaultEditor ) { JTextField tf = ( ( JSpinner . DefaultEditor ) newEditor ) . getTextField ( ) ; if ( tf != null ) { tf . addFocusListener ( editorFocusHandler ) ; } } } 
public static synchronized int inferMailboxTypeFromName ( Context context , String mailboxName ) { if ( sServerMailboxNames . size ( ) == 0 ) { sServerMailboxNames . put ( context . getString ( R . string . mailbox_name_server_inbox ) . toLowerCase ( ) , Mailbox . TYPE_INBOX ) ; sServerMailboxNames . put ( context . getString ( R . string . mailbox_name_server_outbox ) . toLowerCase ( ) , Mailbox . TYPE_OUTBOX ) ; sServerMailboxNames . put ( context . getString ( R . string . mailbox_name_server_drafts ) . toLowerCase ( ) , Mailbox . TYPE_DRAFTS ) ; sServerMailboxNames . put ( context . getString ( R . string . mailbox_name_server_trash ) . toLowerCase ( ) , Mailbox . TYPE_TRASH ) ; sServerMailboxNames . put ( context . getString ( R . string . mailbox_name_server_sent ) . toLowerCase ( ) , Mailbox . TYPE_SENT ) ; sServerMailboxNames . put ( context . getString ( R . string . mailbox_name_server_junk ) . toLowerCase ( ) , Mailbox . TYPE_JUNK ) ; } if ( mailboxName == null || mailboxName . length ( ) == 0 ) { return Mailbox . TYPE_MAIL ; } String lowerCaseName = mailboxName . toLowerCase ( ) ; Integer type = sServerMailboxNames . get ( lowerCaseName ) ; if ( type != null ) { return type ; } return Mailbox . TYPE_MAIL ; } 
@ XmlElementDecl ( namespace = "http://www.opengis.net/kml/2.2" , name = "AbstractTimePrimitiveObjectExtensionGroup" , substitutionHeadNamespace = "http://www.opengis.net/kml/2.2" , substitutionHeadName = "AbstractObjectGroup" ) public JAXBElement < AbstractObjectType > createAbstractTimePrimitiveObjectExtensionGroup ( AbstractObjectType value ) { return new JAXBElement < AbstractObjectType > ( _AbstractTimePrimitiveObjectExtensionGroup_QNAME , AbstractObjectType . class , null , value ) ; } 
@ Deprecated public void send ( DatagramPacket pack , byte ttl ) throws IOException { checkClosedAndBind ( false ) ; InetAddress packAddr = pack . getAddress ( ) ; SecurityManager security = System . getSecurityManager ( ) ; if ( security != null ) { if ( packAddr . isMulticastAddress ( ) ) { security . checkMulticast ( packAddr , ttl ) ; } else { security . checkConnect ( packAddr . getHostName ( ) , pack . getPort ( ) ) ; } } int currTTL = getTimeToLive ( ) ; if ( packAddr . isMulticastAddress ( ) && ( byte ) currTTL != ttl ) { try { setTimeToLive ( ttl & 0xff ) ; impl . send ( pack ) ; } finally { setTimeToLive ( currTTL ) ; } } else { impl . send ( pack ) ; } } 
public FaceletTaglibType < T > removeTaglibExtension ( ) { childNode . removeChild ( "taglib-extension" ) ; return this ; } 
private void checkPropertyKeys ( Properties properties ) throws IllegalArgumentException { Set keys = properties . keySet ( ) ; Iterator i = keys . iterator ( ) ; while ( i . hasNext ( ) ) { String k = ( String ) i . next ( ) ; if ( ! keyValid ( k ) ) { throw new IllegalArgumentException ( k + "-is-not-a-valid-IBM-SSL-property-key." ) ; } } } 
private void splitLineAndAddWords ( String line ) { StringTokenizer tokenizer = new StringTokenizer ( line ) ; String word ; String lower ; Pattern pattern = Pattern . compile ( "|w+" ) ; Matcher matcher ; while ( tokenizer . hasMoreTokens ( ) ) { word = tokenizer . nextToken ( ) ; lower = word . toLowerCase ( ) ; matcher = pattern . matcher ( lower ) ; while ( matcher . find ( ) ) { wordList . add ( matcher . group ( ) ) ; } } } 
public static boolean isInternalClassType ( String internalType ) { int length = internalType . length ( ) ; return length > 1 && internalType . charAt ( length - 1 ) == ClassConstants . INTERNAL_TYPE_CLASS_END ; } 
SnmpRequest findRequest ( SnmpPduPacket pdu ) { synchronized ( m_requests ) { if ( m_requests . size ( ) > 0 ) { ListIterator < SnmpRequest > iter = m_requests . listIterator ( 0 ) ; while ( iter . hasNext ( ) ) { SnmpRequest req = iter . next ( ) ; if ( ! req . m_expired && req . m_pdu instanceof SnmpPduPacket && ( ( SnmpPduPacket ) req . m_pdu ) . getRequestId ( ) == pdu . getRequestId ( ) ) { return req ; } } } } return null ; } 
private static int getBrightness ( final int color ) { int min = Math . min ( Math . min ( Color . red ( color ) , Color . green ( color ) ) , Color . blue ( color ) ) ; int sum = Color . red ( color ) + Color . green ( color ) + Color . blue ( color ) ; return sum - min ; } 
public E remove ( int index ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { Object [ ] elements = getArray ( ) ; int len = elements . length ; E oldValue = get ( elements , index ) ; int numMoved = len - index - 1 ; if ( numMoved == 0 ) setArray ( Arrays . copyOf ( elements , len - 1 ) ) ; else { Object [ ] newElements = new Object [ len - 1 ] ; System . arraycopy ( elements , 0 , newElements , 0 , index ) ; System . arraycopy ( elements , index + 1 , newElements , index , numMoved ) ; setArray ( newElements ) ; } return oldValue ; } finally { lock . unlock ( ) ; } } 
public static String toOctalString ( int i ) { return toUnsignedString ( i , 3 ) ; } 
public synchronized String getAssignedTracker ( TaskAttemptID taskId ) { return taskidToTrackerMap . get ( taskId ) ; } 
public static double [ ] copyOf ( double [ ] original , int newLength ) { if ( newLength < 0 ) { throw new NegativeArraySizeException ( ) ; } return copyOfRange ( original , 0 , newLength ) ; } 
@ Override public void changeCursor ( Cursor c ) { if ( DBG ) Log . d ( LOG_TAG , "changeCursor(" + c + ")" ) ; if ( mClosed ) { Log . w ( LOG_TAG , "Tried-to-change-cursor-after-adapter-was-closed." ) ; if ( c != null ) c . close ( ) ; return ; } try { super . changeCursor ( c ) ; if ( c != null ) { mText1Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_TEXT_1 ) ; mText2Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_TEXT_2 ) ; mText2UrlCol = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_TEXT_2_URL ) ; mIconName1Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_ICON_1 ) ; mIconName2Col = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_ICON_2 ) ; mFlagsCol = c . getColumnIndex ( SearchManager . SUGGEST_COLUMN_FLAGS ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , "error-changing-cursor-and-caching-columns" , e ) ; } } 
public synchronized BlockInputStreams getTmpInputStreams ( Block b , long blkOffset , long ckoff ) throws IOException { DatanodeBlockInfo info = volumeMap . get ( b ) ; if ( info == null ) { throw new IOException ( "Block-" + b + "-does-not-exist-in-volumeMap." ) ; } FSVolume v = info . getVolume ( ) ; File blockFile = info . getFile ( ) ; if ( blockFile == null ) { blockFile = v . getTmpFile ( b ) ; } RandomAccessFile blockInFile = new RandomAccessFile ( blockFile , "r" ) ; if ( blkOffset > 0 ) { blockInFile . seek ( blkOffset ) ; } File metaFile = getMetaFile ( blockFile , b ) ; RandomAccessFile metaInFile = new RandomAccessFile ( metaFile , "r" ) ; if ( ckoff > 0 ) { metaInFile . seek ( ckoff ) ; } return new BlockInputStreams ( new FileInputStream ( blockInFile . getFD ( ) ) , new FileInputStream ( metaInFile . getFD ( ) ) ) ; } 
SearchResult searchTree ( CharSequence key ) { Node parentNodesParent = null ; Node parentNode = null ; Node currentNode = root ; int charsMatched = 0 , charsMatchedInNodeFound = 0 ; final int keyLength = key . length ( ) ; outer_loop : while ( charsMatched < keyLength ) { Node nextNode = currentNode . getOutgoingEdge ( key . charAt ( charsMatched ) ) ; if ( nextNode == null ) { break outer_loop ; } parentNodesParent = parentNode ; parentNode = currentNode ; currentNode = nextNode ; charsMatchedInNodeFound = 0 ; CharSequence currentNodeEdgeCharacters = currentNode . getIncomingEdge ( ) ; for ( int i = 0 , numEdgeChars = currentNodeEdgeCharacters . length ( ) ; i < numEdgeChars && charsMatched < keyLength ; i ++ ) { if ( currentNodeEdgeCharacters . charAt ( i ) != key . charAt ( charsMatched ) ) { break outer_loop ; } charsMatched ++ ; charsMatchedInNodeFound ++ ; } } return new SearchResult ( key , currentNode , charsMatched , charsMatchedInNodeFound , parentNode , parentNodesParent ) ; } 
public Builder setAccelZ ( int value ) { bitField0_ |= 0x00002000 ; accelZ_ = value ; onChanged ( ) ; return this ; } 
public void lcd ( String path ) throws SftpException { path = localAbsolutePath ( path ) ; if ( ! new File ( path ) . isDirectory ( ) ) { throw new SftpException ( SSH_FX_NO_SUCH_FILE , "Failed-to-lcd,-directory-does-not-exist:-" + path ) ; } try { path = new File ( path ) . getCanonicalPath ( ) ; } catch ( Exception e ) { } _lcwd = path ; } 
@ Override public void removeMapping ( String mapping ) { mappingsLock . writeLock ( ) . lock ( ) ; try { mappings . remove ( mapping ) ; } finally { mappingsLock . writeLock ( ) . unlock ( ) ; } if ( parent . getState ( ) . equals ( LifecycleState . STARTED ) ) fireContainerEvent ( REMOVE_MAPPING_EVENT , mapping ) ; } 
public static String capitalize ( String name ) { if ( name == null || name . length ( ) == 0 ) { return name ; } char chars [ ] = name . toCharArray ( ) ; chars [ 0 ] = Character . toUpperCase ( chars [ 0 ] ) ; return new String ( chars ) ; } 
public ColorModel getColorModel ( ) { if ( theModel == null ) { BufferedImage bufImg = new BufferedImage ( 1 , 1 , BufferedImage . TYPE_3BYTE_BGR ) ; theModel = bufImg . getColorModel ( ) ; } return theModel ; } 
public void setRenderingHint ( RenderingHints . Key hintKey , Object hintValue ) { _hints . put ( hintKey , hintValue ) ; } 
List < String > getMyContactsIds ( Connection connection , int myId ) throws SQLException { ResultSet rs = null ; PreparedStatement pstmt = null ; List < String > myContactsIds = new ArrayList < String > ( ) ; try { String query = "SELECT-user2Id-" + "FROM-sb_sn_RelationShip,-st_user-" + "WHERE-user1Id-=-?-" + "and-user2Id-=-st_user.id-" + "and-st_user.state-<>-'DELETED'" ; pstmt = connection . prepareStatement ( query ) ; pstmt . setInt ( 1 , myId ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { myContactsIds . add ( Integer . toString ( rs . getInt ( 1 ) ) ) ; } } finally { DBUtil . close ( rs , pstmt ) ; } return myContactsIds ; } 
ByteBuffer getBufferWithHeader ( ) { ByteBuffer dupBuf = buf . duplicate ( ) ; dupBuf . rewind ( ) ; return dupBuf ; } 
public static boolean testFileExists ( String name ) { boolean status ; if ( ( testSaveLocationExists ( ) ) && ( ! name . equals ( "" ) ) ) { File path = Environment . getExternalStorageDirectory ( ) ; File newPath = constructFilePaths ( path . toString ( ) , name ) ; status = newPath . exists ( ) ; } else { status = false ; } return status ; } 
public boolean hasNext ( ) { if ( _lookahead == null ) do { _lookahead = _iterator . hasNext ( ) ? _iterator . next ( ) : null ; } while ( _lookahead != null && ! shouldInclude ( _lookahead ) ) ; return _lookahead != null ; } 
public List < GarcomModel > getAllGarcom ( ) { List < GarcomModel > todos = new ArrayList < GarcomModel > ( ) ; String selectQuery = "SELECT-*-FROM-" + TABLE_GARCOM ; Log . e ( LOG , selectQuery ) ; SQLiteDatabase db = this . getReadableDatabase ( ) ; Cursor c = db . rawQuery ( selectQuery , null ) ; if ( c . moveToFirst ( ) ) { do { GarcomModel td = new GarcomModel ( ) ; td . id = ( c . getLong ( ( c . getColumnIndex ( KEY_ID ) ) ) ) ; td . codigo = ( ( c . getString ( c . getColumnIndex ( KEY_GARCOM_CODIGO ) ) ) ) ; td . nome = ( ( c . getString ( c . getColumnIndex ( KEY_GARCOM_NOME ) ) ) ) ; todos . add ( td ) ; } while ( c . moveToNext ( ) ) ; } return todos ; } 
public ZipFile ( final File f , final String encoding , final boolean useUnicodeExtraFields ) throws IOException { this . archiveName = f . getAbsolutePath ( ) ; this . encoding = encoding ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . useUnicodeExtraFields = useUnicodeExtraFields ; archive = new RandomAccessFile ( f , "r" ) ; boolean success = false ; try { final Map < ZipEntry , NameAndComment > entriesWithoutUTF8Flag = populateFromCentralDirectory ( ) ; resolveLocalFileHeaderData ( entriesWithoutUTF8Flag ) ; success = true ; } finally { closed = ! success ; if ( ! success ) { try { archive . close ( ) ; } catch ( final IOException e2 ) { } } } } 
private synchronized void retireMap ( TaskInProgress tip ) { if ( runningMapCache == null ) { LOG . warn ( "Running-cache-for-maps-missing!!-" + "Job-details-are-missing." ) ; return ; } String [ ] splitLocations = tip . getSplitLocations ( ) ; if ( splitLocations == null || splitLocations . length == 0 ) { nonLocalRunningMaps . remove ( tip ) ; return ; } for ( String host : splitLocations ) { Node node = jobtracker . getNode ( host ) ; for ( int j = 0 ; j < maxLevel ; ++ j ) { Set < TaskInProgress > hostMaps = runningMapCache . get ( node ) ; if ( hostMaps != null ) { hostMaps . remove ( tip ) ; if ( hostMaps . size ( ) == 0 ) { runningMapCache . remove ( node ) ; } } node = node . getParent ( ) ; } } } 
@ XmlElementDecl ( namespace = "https://bingads.microsoft.com/CampaignManagement/v10" , name = "ArrayOfSitePlacement" ) public JAXBElement < ArrayOfSitePlacement > createArrayOfSitePlacement ( ArrayOfSitePlacement value ) { return new JAXBElement < ArrayOfSitePlacement > ( _ArrayOfSitePlacement_QNAME , ArrayOfSitePlacement . class , null , value ) ; } 
private ArrayList < ContentProviderOperation > processAllSessionsCalendar ( ContentResolver resolver , final long calendarId ) { ArrayList < ContentProviderOperation > batch = new ArrayList < ContentProviderOperation > ( ) ; if ( calendarId == INVALID_CALENDAR_ID ) { return batch ; } Cursor cursor = resolver . query ( ScheduleContract . Sessions . CONTENT_URI , SessionsQuery . PROJECTION , null , null , null ) ; if ( cursor != null ) { while ( cursor . moveToNext ( ) ) { Uri uri = ScheduleContract . Sessions . buildSessionUri ( Long . valueOf ( cursor . getLong ( 0 ) ) . toString ( ) ) ; boolean isAddEvent = ( cursor . getInt ( SessionsQuery . SESSION_STARRED ) == 1 ) ; if ( isAddEvent ) { batch . addAll ( processSessionCalendar ( resolver , calendarId , isAddEvent , uri , cursor . getLong ( SessionsQuery . BLOCK_START ) , cursor . getLong ( SessionsQuery . BLOCK_END ) , cursor . getString ( SessionsQuery . SESSION_TITLE ) , cursor . getString ( SessionsQuery . ROOM_NAME ) ) ) ; } } cursor . close ( ) ; } return batch ; } 
public CharSequence getDisplayNumber ( CharSequence number , CharSequence formattedNumber ) { if ( TextUtils . isEmpty ( number ) ) { return "" ; } if ( number . equals ( CallerInfo . UNKNOWN_NUMBER ) ) { return mResources . getString ( R . string . unknown ) ; } if ( number . equals ( CallerInfo . PRIVATE_NUMBER ) ) { return mResources . getString ( R . string . private_num ) ; } if ( number . equals ( CallerInfo . PAYPHONE_NUMBER ) ) { return mResources . getString ( R . string . payphone ) ; } if ( isVoicemailNumber ( number ) ) { return mResources . getString ( R . string . voicemail ) ; } if ( TextUtils . isEmpty ( formattedNumber ) ) { return number ; } else { return formattedNumber ; } } 
public float getHeading ( ) { this . lastAccessTime = System . currentTimeMillis ( ) ; return this . heading ; } 
private void setLogLevel ( final String level ) { if ( null != level ) { switch ( Integer . parseInt ( level ) ) { case 1 : LOGGER . setLevel ( Level . FINEST ) ; break ; case 2 : LOGGER . setLevel ( Level . FINER ) ; break ; case 3 : LOGGER . setLevel ( Level . FINE ) ; break ; case 4 : LOGGER . setLevel ( Level . CONFIG ) ; break ; case 6 : LOGGER . setLevel ( Level . WARNING ) ; break ; case 7 : LOGGER . setLevel ( Level . SEVERE ) ; break ; default : LOGGER . setLevel ( Level . INFO ) ; break ; } } } 
public void addCallbackListener ( CallbackListener listener ) { synchronized ( mListeners ) { mListeners . add ( listener ) ; } } 
public static boolean isJarURL ( URL url ) { String protocol = url . getProtocol ( ) ; return ( URL_PROTOCOL_JAR . equals ( protocol ) || URL_PROTOCOL_ZIP . equals ( protocol ) || URL_PROTOCOL_WSJAR . equals ( protocol ) || ( URL_PROTOCOL_CODE_SOURCE . equals ( protocol ) && url . getPath ( ) . contains ( JAR_URL_SEPARATOR ) ) ) ; } 
public double ptSegDistSq ( double px , double py ) { return ptSegDistSq ( getX1 ( ) , getY1 ( ) , getX2 ( ) , getY2 ( ) , px , py ) ; } 
private JTable getHttpSessionsTable ( ) { if ( sessionsTable == null ) { sessionsTable = new JTable ( sessionsModel ) ; sessionsTable . setColumnSelectionAllowed ( false ) ; sessionsTable . setCellSelectionEnabled ( false ) ; sessionsTable . setRowSelectionAllowed ( true ) ; sessionsTable . setAutoCreateRowSorter ( true ) ; this . setSessionsTableColumnSizes ( ) ; sessionsTable . setName ( PANEL_NAME ) ; sessionsTable . setFont ( new java . awt . Font ( "Dialog" , java . awt . Font . PLAIN , 11 ) ) ; sessionsTable . setDoubleBuffered ( true ) ; sessionsTable . setSelectionMode ( javax . swing . ListSelectionModel . SINGLE_SELECTION ) ; sessionsTable . addMouseListener ( new java . awt . event . MouseAdapter ( ) { @ Override public void mousePressed ( java . awt . event . MouseEvent e ) { if ( SwingUtilities . isRightMouseButton ( e ) ) { int row = sessionsTable . rowAtPoint ( e . getPoint ( ) ) ; if ( row < 0 || ! sessionsTable . getSelectionModel ( ) . isSelectedIndex ( row ) ) { sessionsTable . getSelectionModel ( ) . clearSelection ( ) ; if ( row >= 0 ) { sessionsTable . getSelectionModel ( ) . setSelectionInterval ( row , row ) ; } } View . getSingleton ( ) . getPopupMenu ( ) . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } } } ) ; } return sessionsTable ; } 
public static int indexOf ( String name ) { if ( name != null && ! name . isEmpty ( ) ) for ( int i = 0 ; i < GUILD_LIST . size ( ) ; i ++ ) if ( GUILD_LIST . get ( i ) . getName ( ) . equals ( name ) ) return i ; return - 1 ; } 
public final int actualNumClasses ( int bagIndex ) { int returnValue = 0 ; int i ; for ( i = 0 ; i < m_perClass . length ; i ++ ) if ( Utils . gr ( m_perClassPerBag [ bagIndex ] [ i ] , 0 ) ) returnValue ++ ; return returnValue ; } 
@ Override public InputStream toInputStream ( ) { try { return _url . openStream ( ) ; } catch ( IOException e ) { throw new QuercusRuntimeException ( e ) ; } } 
public static int findEmptyLine ( String s ) { int ret = 0 ; while ( ( ret = s . indexOf ( "-" , ret ) ) != - 1 ) { while ( s . charAt ( ret ) == '|r' ) { ret ++ ; } if ( s . charAt ( ret ) == '|n' ) { ret ++ ; break ; } } return ret ; } 
public boolean addLink ( final URI link ) { return links . add ( link ) ; } 
public synchronized final V get ( K key ) { if ( key == null ) { throw new NullPointerException ( "key-==-null" ) ; } V result = map . get ( key ) ; if ( result != null ) { return result ; } result = create ( key ) ; if ( result != null ) { map . put ( key , result ) ; trimToSize ( maxSize ) ; } return result ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public FileAttribute ( String fileName , int fileSize ) throws ParameterException { if ( fileName == null || fileName . length ( ) == 0 ) { throw new ParameterException ( "FileAttribute():-Error---invalid-file-name." ) ; } if ( fileSize <= 0 ) { throw new ParameterException ( "FileAttribute():-Error---size-<=-0." ) ; } size = fileSize ; name = fileName ; Date date = CloudSim . getSimulationCalendar ( ) . getTime ( ) ; if ( date == null ) { creationTime = 0 ; } else { creationTime = date . getTime ( ) ; } ownerName = null ; id = File . NOT_REGISTERED ; checksum = 0 ; type = File . TYPE_UNKOWN ; lastUpdateTime = 0 ; cost = 0 ; resourceId = - 1 ; masterCopy = true ; readOnly = false ; } 
private void writeStartElement ( java . lang . String prefix , java . lang . String namespace , java . lang . String localPart , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String writerPrefix = xmlWriter . getPrefix ( namespace ) ; if ( writerPrefix != null ) { xmlWriter . writeStartElement ( namespace , localPart ) ; } else { if ( namespace . length ( ) == 0 ) { prefix = "" ; } else if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; } xmlWriter . writeStartElement ( prefix , localPart , namespace ) ; xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } } 
Set < Field > getFields ( JCTree tree ) { Set < Field > fields = map . get ( tree . getTag ( ) ) ; if ( fields == null ) { fields = new HashSet < Field > ( ) ; for ( Field f : tree . getClass ( ) . getFields ( ) ) { Class < ? > fc = f . getType ( ) ; if ( JCTree . class . isAssignableFrom ( fc ) || List . class . isAssignableFrom ( fc ) ) fields . add ( f ) ; } map . put ( tree . getTag ( ) , fields ) ; } return fields ; } 
public synchronized static final void destroyInstance ( SyslogIF syslog ) throws SyslogRuntimeException { if ( syslog == null ) { return ; } String protocol = syslog . getProtocol ( ) . toLowerCase ( ) ; if ( instances . containsKey ( protocol ) ) { try { syslog . shutdown ( ) ; } finally { instances . remove ( protocol ) ; } } else { throwRuntimeException ( "Cannot-destroy-protocol-"" + protocol + ""-instance;-call-shutdown-instead" ) ; return ; } } 
public void stopPlayback ( ) { fastSpeedSlider . removeChangeListener ( this ) ; fastReverseButton . removeActionListener ( this ) ; reverseButton . removeActionListener ( this ) ; pauseButton . removeActionListener ( this ) ; forwardButton . removeActionListener ( this ) ; fastForwardButton . removeActionListener ( this ) ; fastReverseButton . setEnabled ( false ) ; reverseButton . setEnabled ( false ) ; pauseButton . setEnabled ( false ) ; forwardButton . setEnabled ( false ) ; fastForwardButton . setEnabled ( false ) ; fastSpeedSlider . setEnabled ( false ) ; playbackSlider . setEnabled ( false ) ; playbackSlider . setValue ( 0 ) ; player = null ; } 
public String makeConditionIn ( String fieldName , int numParameters ) { StringBuffer strRes = new StringBuffer ( "-" ) . append ( fieldName ) . append ( "-in-(" ) ; for ( int i = 0 ; i < numParameters ; i ++ ) { if ( i != 0 ) { strRes . append ( "," ) ; } strRes . append ( "?" ) ; } strRes . append ( ")" ) ; return strRes . toString ( ) ; } 
private String readChecksum ( File f ) { BufferedReader diskChecksumReader = null ; try { diskChecksumReader = new BufferedReader ( new FileReader ( f ) ) ; Object [ ] result = format . parse ( diskChecksumReader . readLine ( ) ) ; if ( result == null || result . length == 0 || result [ 0 ] == null ) { throw new BuildException ( "failed-to-find-a-checksum" ) ; } return ( String ) result [ 0 ] ; } catch ( IOException e ) { throw new BuildException ( "Couldn't-read-checksum-file-" + f , e ) ; } catch ( ParseException e ) { throw new BuildException ( "Couldn't-read-checksum-file-" + f , e ) ; } finally { FileUtils . close ( diskChecksumReader ) ; } } 
public static Map < PIFMetrics , PIFMetrics . Record > getAllRecords ( Connection c ) throws BadServerResponse , XenAPIException , XmlRpcException { String method_call = "PIF_metrics.get_all_records" ; String session = c . getSessionReference ( ) ; Object [ ] method_params = { Marshalling . toXMLRPC ( session ) } ; Map response = c . dispatch ( method_call , method_params ) ; Object result = response . get ( "Value" ) ; return Types . toMapOfPIFMetricsPIFMetricsRecord ( result ) ; } 
@ Override public void postDeregister ( ) { if ( oname != null ) unregisterJmx ( ) ; } 
public Set < String > names ( ) { TreeSet < String > result = new TreeSet < String > ( String . CASE_INSENSITIVE_ORDER ) ; for ( int i = 0 ; i < length ( ) ; i ++ ) { result . add ( getFieldName ( i ) ) ; } return Collections . unmodifiableSet ( result ) ; } 
public boolean colorMatch ( int color1 , int color2 ) { int tolerance = 25 ; if ( ( int ) Math . abs ( Color . red ( color1 ) - Color . red ( color2 ) ) > tolerance ) return false ; if ( ( int ) Math . abs ( Color . green ( color1 ) - Color . green ( color2 ) ) > tolerance ) return false ; if ( ( int ) Math . abs ( Color . blue ( color1 ) - Color . blue ( color2 ) ) > tolerance ) return false ; Log . v ( TAG , "Colors-match" ) ; return true ; } 
public void addCallback ( Callback callback ) { if ( ! callbacks . contains ( callback ) ) { callbacks . add ( callback ) ; } } 
private List < IndexedWord > getPathToRoot ( IndexedWord vertex , List < IndexedWord > used ) { used . add ( vertex ) ; List < IndexedWord > parents = getParentList ( vertex ) ; parents . removeAll ( used ) ; if ( roots . contains ( vertex ) || ( parents . isEmpty ( ) ) ) { used . remove ( used . size ( ) - 1 ) ; if ( roots . contains ( vertex ) ) return Generics . newArrayList ( ) ; else return null ; } for ( IndexedWord parent : parents ) { List < IndexedWord > path = getPathToRoot ( parent , used ) ; if ( path != null ) { path . add ( parent ) ; used . remove ( used . size ( ) - 1 ) ; return path ; } } used . remove ( used . size ( ) - 1 ) ; return null ; } 
public void restore ( ) { Thread . currentThread ( ) . setContextClassLoader ( loader ) ; } 
public String next ( int n ) throws JSONException { if ( n == 0 ) { return "" ; } char [ ] buffer = new char [ n ] ; int pos = 0 ; if ( this . useLastChar ) { this . useLastChar = false ; buffer [ 0 ] = this . lastChar ; pos = 1 ; } try { int len ; while ( ( pos < n ) && ( ( len = reader . read ( buffer , pos , n - pos ) ) != - 1 ) ) { pos += len ; } } catch ( IOException exc ) { throw new JSONException ( exc ) ; } this . index += pos ; if ( pos < n ) { throw syntaxError ( "Substring-bounds-error" ) ; } this . lastChar = buffer [ n - 1 ] ; return new String ( buffer ) ; } 
public synchronized int size ( ) { return rrs . size ( ) - nsigs ; } 
public static Element getFirstChildElement ( Element root ) { Node child = root . getFirstChild ( ) ; while ( child != null ) { if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { return ( Element ) child ; } child = child . getNextSibling ( ) ; } return null ; } 
public void shutdownServiceConnector ( ) { scheduleTaskExecutor . shutdown ( ) ; } 
@ XmlElementDecl ( namespace = "urn:oasis:names:tc:ebxml-regrep:xsd:rim:3.0" , name = "SpecificationLink" , substitutionHeadNamespace = "urn:oasis:names:tc:ebxml-regrep:xsd:rim:3.0" , substitutionHeadName = "Identifiable" ) public JAXBElement < SpecificationLinkType > createSpecificationLink ( SpecificationLinkType value ) { return new JAXBElement < SpecificationLinkType > ( _SpecificationLink_QNAME , SpecificationLinkType . class , null , value ) ; } 
public List < DateDrop > getAllDrops ( ) { List < DateDrop > list = new FastList < DateDrop > ( ) ; for ( DateDrop drop : _allNpcDateDrops ) { Date currentDate = new Date ( ) ; if ( drop . dateRange . isWithinRange ( currentDate ) ) { list . add ( drop ) ; } } return list ; } 
private synchronized void removeMessageListener ( MessageTypeEventHandler < ? > messageListener ) { synchronized ( messageListeners ) { messageListeners . remove ( messageListener ) ; } } 
public void results ( Bundle results ) throws RemoteException { Message . obtain ( mHandler , MSG_RESET ) . sendToTarget ( ) ; mListener . onResults ( results ) ; } 
public Policy normalize ( PolicyRegistry reg , boolean deep ) { return normalize ( this , reg , deep ) ; } 
public double getWidth ( ) { if ( ! initialized ) { initialize ( ) ; } return width ; } 
public AccessibleStateSet getAccessibleStateSet ( ) { AccessibleStateSet states = super . getAccessibleStateSet ( ) ; states . add ( AccessibleState . ACTIVE ) ; return states ; } 
public void setXIncludeAware ( final boolean state ) { if ( state ) { throw new UnsupportedOperationException ( "-setXIncludeAware-" + "is-not-supported-on-this-JAXP" + "-implementation-or-earlier:-" + this . getClass ( ) ) ; } } 
public Element getElement ( ) { if ( view != null ) { return view . getElement ( ) ; } return editor . getDocument ( ) . getDefaultRootElement ( ) ; } 
void createStyleGroup ( ) { super . createStyleGroup ( ) ; if ( orientationButtons ) { horizontalButton = new Button ( styleGroup , SWT . RADIO ) ; horizontalButton . setText ( "SWT.HORIZONTAL" ) ; verticalButton = new Button ( styleGroup , SWT . RADIO ) ; verticalButton . setText ( "SWT.VERTICAL" ) ; } borderButton = new Button ( styleGroup , SWT . CHECK ) ; borderButton . setText ( "SWT.BORDER" ) ; } 
public void paintValue ( java . awt . Graphics gfx , java . awt . Rectangle box ) { FontMetrics fm = gfx . getFontMetrics ( ) ; int vpad = ( box . height - fm . getHeight ( ) ) / 2 ; File f = ( File ) getValue ( ) ; String val = "No-file" ; if ( f != null ) { val = f . getName ( ) ; } gfx . drawString ( val , 2 , fm . getHeight ( ) + vpad ) ; } 
protected boolean isWhitespace ( char ch ) { return ( ( ch == '|t' ) || Character . isSpaceChar ( ch ) ) ; } 
public double getDouble ( int index ) throws JSONException { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . doubleValue ( ) : Double . parseDouble ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONArray[" + index + "]-is-not-a-number." ) ; } } 
private void resetColumnValues ( ) { if ( Debug . isLevelEnabled ( Debug . MSG_STATUS ) ) { Debug . log ( Debug . MSG_STATUS , "Resetting-column-values-..." ) ; } Iterator iter = columns . iterator ( ) ; ColumnData cd = null ; while ( iter . hasNext ( ) ) { cd = ( ColumnData ) iter . next ( ) ; cd . value = null ; } } 
private void closeSocketChannelAndCancelConnection ( final SocketChannel channel , final SelectionKey connection ) throws CloudCommunicationException { try { channel . close ( ) ; connection . cancel ( ) ; } catch ( IOException ex ) { throw wrapNIOSocketIOException ( ex ) ; } } 
public void close ( ) throws IOException { fInputStream . close ( ) ; } 
protected long getTimeInMillis ( ) { if ( ! isTimeSet ) { computeTime ( ) ; isTimeSet = true ; } return this . time ; } 
public void determineComplexity ( final EvaluableExpression expression ) { this . visitor = new Visitor ( ) ; this . visitor . visitRecursively ( expression ) ; if ( this . visitor . maxDepth > DEPTH_PENALTY_THRESHOLD ) { this . visitor . humanComprehensibilityComplexitySum += PENALTY_MAX_DEPTH_FACTOR * Math . pow ( this . visitor . maxDepth , PENALTY_MAX_DEPTH_EXPONTENT ) ; } } 
public boolean setValue ( String value ) { if ( mDataType != TYPE_ASCII && mDataType != TYPE_UNDEFINED ) { return false ; } byte [ ] buf = value . getBytes ( US_ASCII ) ; byte [ ] finalBuf = buf ; if ( buf . length > 0 ) { finalBuf = ( buf [ buf . length - 1 ] == 0 || mDataType == TYPE_UNDEFINED ) ? buf : Arrays . copyOf ( buf , buf . length + 1 ) ; } else if ( mDataType == TYPE_ASCII && mComponentCountActual == 1 ) { finalBuf = new byte [ ] { 0 } ; } int count = finalBuf . length ; if ( checkBadComponentCount ( count ) ) { return false ; } mComponentCountActual = count ; mValue = finalBuf ; return true ; } 
public static DocumentBuilderFactory newInstance ( ) { return new DocumentBuilderFactoryImpl ( ) ; } 
private static String format ( int number , int format ) { String retVal = "" + number ; while ( retVal . length ( ) < format ) { retVal = "0" + retVal ; } return retVal ; } 
private void createSearchControl ( ) { Composite searchComp = new Composite ( shell , SWT . NONE ) ; GridLayout gl = new GridLayout ( 2 , false ) ; searchComp . setLayout ( gl ) ; GridData gd = new GridData ( SWT . RIGHT , SWT . DEFAULT , true , false ) ; searchComp . setLayoutData ( gd ) ; Label searchLbl = new Label ( searchComp , SWT . NONE ) ; searchLbl . setText ( "Search:-" ) ; gd = new GridData ( 100 , SWT . DEFAULT ) ; searchTF = new Text ( searchComp , SWT . BORDER ) ; searchTF . setLayoutData ( gd ) ; searchTF . addKeyListener ( new KeyListener ( ) { public void keyPressed ( KeyEvent e ) { } public void keyReleased ( KeyEvent e ) { String tmp = searchTF . getText ( ) . toUpperCase ( ) ; int i = 0 ; String [ ] listItems = dataList . getItems ( ) ; for ( String item : listItems ) { if ( item . startsWith ( tmp ) == true ) { dataList . select ( i ) ; selectSite ( ) ; break ; } i ++ ; } } } ) ; } 
private void initMaps ( ) { int items , i ; propMap = new HashMap < > ( ) ; items = properties . length ; for ( i = 0 ; i < items ; i ++ ) { propMap . put ( properties [ i ] , Integer . valueOf ( i ) ) ; } colDefMap = new HashMap < > ( ) ; items = colDef . length ; for ( i = 0 ; i < items ; i ++ ) { colDefMap . put ( colDef [ i ] , Integer . valueOf ( i ) ) ; } dataMap = new HashMap < > ( ) ; items = data . length ; for ( i = 0 ; i < items ; i ++ ) { dataMap . put ( data [ i ] , Integer . valueOf ( i ) ) ; } typeMap = new HashMap < > ( ) ; } 
public static Class goodClassOrNull ( Configuration conf , String className , String defaultPackage ) { Class clazz = null ; try { clazz = conf . getClassByName ( className ) ; } catch ( ClassNotFoundException cnf ) { } if ( clazz == null ) { if ( className . indexOf ( '.' ) == - 1 && defaultPackage != null ) { className = defaultPackage + "." + className ; try { clazz = conf . getClassByName ( className ) ; } catch ( ClassNotFoundException cnf ) { } } } return clazz ; } 
public static int compareNotNullSigned ( byte [ ] data1 , byte [ ] data2 ) { if ( data1 == data2 ) { return 0 ; } int len = Math . min ( data1 . length , data2 . length ) ; for ( int i = 0 ; i < len ; i ++ ) { byte b = data1 [ i ] ; byte b2 = data2 [ i ] ; if ( b != b2 ) { return b > b2 ? 1 : - 1 ; } } return Integer . signum ( data1 . length - data2 . length ) ; } 
String sendRequestInternal ( final String requestUrl ) throws Exception { HttpURLConnection connection = null ; int responseCode ; try { connection = ( HttpURLConnection ) new URL ( requestUrl ) . openConnection ( ) ; connection . setConnectTimeout ( this . connectionTimeout ) ; connection . setReadTimeout ( this . connectionTimeout ) ; connection . setUseCaches ( false ) ; connection . setDoOutput ( false ) ; connection . setDoInput ( true ) ; if ( this . isGzipEnable ) { connection . setRequestProperty ( "Accept-Encoding" , "gzip" ) ; } responseCode = connection . getResponseCode ( ) ; log ( Log . DEBUG , "Server-responce-code:-" + responseCode ) ; if ( responseCode == - 1 ) { throw new Exception ( "Got-response-code--1,-may-be-http-keep-alive-problem" ) ; } InputStream is = new BufferedInputStream ( connection . getInputStream ( ) , 8192 ) ; final String contentEncoding = connection . getContentEncoding ( ) ; if ( contentEncoding != null && contentEncoding . equalsIgnoreCase ( "gzip" ) ) { is = new GZIPInputStream ( is ) ; } return VKUtils . convertStreamToString ( is ) ; } finally { if ( connection != null ) { connection . disconnect ( ) ; } } } 
public static String getLocationString ( IResource resource ) { URI uri = resource . getLocationURI ( ) ; if ( uri == null ) return null ; return EFS . SCHEME_FILE . equalsIgnoreCase ( uri . getScheme ( ) ) ? new File ( uri ) . getAbsolutePath ( ) : uri . toString ( ) ; } 
public synchronized void addActionListener ( ActionListener listener ) { action_listeners = AWTEventMulticaster . add ( action_listeners , listener ) ; } 
static public ConstantGrid getEnumerationForValue ( int aVal ) throws EnumNotFoundException { ConstantGrid val ; val = enumerations . get ( new Integer ( aVal ) ) ; if ( val == null ) throw new EnumNotFoundException ( "no-enumeration-found-for-value-" + aVal + "-of-enumeration-ConstantGrid" ) ; return val ; } 
@ SuppressWarnings ( "rawtypes" ) public void initialize ( Node rootContext ) { Property [ ] properties = rootContext . getPropertySets ( ) [ 0 ] . getProperties ( ) ; if ( properties != null ) { for ( Property col : properties ) { super . addPropertyColumn ( col . getName ( ) , col . getDisplayName ( ) , col . getShortDescription ( ) ) ; } } } 
private static int parseNumberAtStart ( String numberString ) { if ( numberString == null || numberString . length ( ) == 0 ) { return - 1 ; } int endOfNumbers = 0 ; while ( Character . isDigit ( numberString . charAt ( endOfNumbers ) ) ) { endOfNumbers ++ ; } try { return Integer . parseInt ( numberString . substring ( 0 , endOfNumbers ) ) ; } catch ( NumberFormatException ex ) { return - 1 ; } } 
public static void main ( String [ ] args ) throws Exception { int n , line ; LineNumberReader reader = new LineNumberReader ( new StringReader ( "0-1-2-3-5-7-9" ) ) ; for ( n = 0 ; n < 7 ; n ++ ) { skipWhiteSpace ( reader ) ; int c = reader . read ( ) ; if ( c < 0 ) { break ; } line = reader . getLineNumber ( ) ; if ( line != ( c - 48 ) ) { throw new Exception ( "Failed-test-:-Line-number-expected-" + ( c - 48 ) + "-got-" + line ) ; } } } 
public static boolean isAbstractClass ( Class clazz ) { int modifier = clazz . getModifiers ( ) ; return Modifier . isAbstract ( modifier ) || Modifier . isInterface ( modifier ) ; } 
public static void loadUrlPatterns ( ) { FileInputStream fis = null ; try { Properties p = new Properties ( ) ; fis = new FileInputStream ( SystemGlobals . getValue ( ConfigKeys . CONFIG_DIR ) + "/urlPattern.properties" ) ; p . load ( fis ) ; for ( Iterator iter = p . entrySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; UrlPatternCollection . addPattern ( ( String ) entry . getKey ( ) , ( String ) entry . getValue ( ) ) ; } } catch ( IOException e ) { throw new ForumException ( e ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( Exception e ) { } } } } 
public void addTransformation ( TransformationNode trans ) { transformations . add ( trans ) ; } 
private int findInsertionIndex ( final int key ) { return findInsertionIndex ( keys , states , key , mask ) ; } 
public static boolean isValidSetter ( Method method ) throws RemoteException { startManagers ( ) ; if ( method . getName ( ) . startsWith ( "set" ) && method . getName ( ) . length ( ) > 3 && method . getParameterTypes ( ) . length == 1 && method . getReturnType ( ) . getName ( ) . equals ( "void" ) ) { return true ; } return false ; } 
private List < AVLNode < T >> getChildren ( AVLNode < T > node ) { ArrayList < AVLNode < T >> list = new ArrayList < AVLNode < T >> ( ) ; list . add ( node ) ; return getChildren ( list ) ; } 
public Double length ( ) { return Math . sqrt ( x * x + y * y ) ; } 
protected static void remove ( SSListener listener ) { listeners . remove ( listener ) ; } 
public int getPosition ( ) { return buffer . getPosition ( ) ; } 
public boolean pointInView ( View target , float localX , float localY , float slop ) { return localX >= - slop && localY >= - slop && localX < ( ( target . getRight ( ) - target . getLeft ( ) ) + slop ) && localY < ( ( target . getBottom ( ) - target . getTop ( ) ) + slop ) ; } 
public static long readLong ( ) { return scanner . nextLong ( ) ; } 
void checkDefaultSerialize ( ) throws InvalidClassException { if ( defaultSerializeEx != null ) { InvalidClassException ice = new InvalidClassException ( defaultSerializeEx . classname , defaultSerializeEx . getMessage ( ) ) ; throw ice ; } } 
public boolean isMultipleMode ( ) { return allowsMultipleSelections ( ) ; } 
public void save ( String text ) throws IOException { LOGGER . debug ( "Starting-to-save-to-file-{}:-{}" , FILE_NAME , text ) ; PrintWriter writer = new PrintWriter ( getWriter ( ) , false ) ; writer . println ( text ) ; writer . close ( ) ; LOGGER . debug ( "Saved-to-file-{}:-{}" , FILE_NAME , text ) ; } 
public void playSequentially ( List < Animator > items ) { if ( items != null && items . size ( ) > 0 ) { mNeedsSort = true ; if ( items . size ( ) == 1 ) { play ( items . get ( 0 ) ) ; } else { for ( int i = 0 ; i < items . size ( ) - 1 ; ++ i ) { play ( items . get ( i ) ) . before ( items . get ( i + 1 ) ) ; } } } } 
public void setTo ( Rectangle3D rect ) { origin . setTo ( rect . origin ) ; directionU . setTo ( rect . directionU ) ; directionV . setTo ( rect . directionV ) ; width = rect . width ; height = rect . height ; } 
static Suite parse ( Reader reader , String source ) { StreamTokenizer st = new StreamTokenizer ( reader ) ; st . resetSyntax ( ) ; st . whitespaceChars ( 0 , '-' ) ; st . wordChars ( '!' , '}' ) ; st . eolIsSignificant ( false ) ; SortedMap classes = new TreeMap ( ) ; String className = null ; SortedMap fields = null ; SortedMap methods = null ; String label = parseWord ( st , source , MakeAPI . SUITE_FILE_EXTENSION ) ; String suiteName = parseWord ( st , source , null ) ; do { label = parseWordOrEOF ( st , source , ".class-.method-.field" ) ; if ( label == null || label . equals ( ".class" ) ) { if ( className != null ) { Class klass = new Class ( className , fields , methods ) ; classes . put ( className , klass ) ; } if ( label == null ) { break ; } } if ( label . equals ( ".class" ) ) { className = parseWord ( st , source , null ) ; fields = new TreeMap ( ) ; methods = new TreeMap ( ) ; } else { String name = parseWord ( st , source , null ) ; String desc = parseWord ( st , source , null ) ; if ( label . equals ( ".field" ) ) { fields . put ( name + desc , new Field ( name , desc ) ) ; } else { methods . put ( name + desc , new Method ( name , desc ) ) ; } } } while ( true ) ; return new Suite ( suiteName , classes ) ; } 
public Properties readSettings ( ) { try { String pacScriptUrl = detectScriptUrlPerDHCP ( ) ; if ( pacScriptUrl == null ) { pacScriptUrl = detectScriptUrlPerDNS ( ) ; } if ( pacScriptUrl == null ) { return null ; } Properties result = new Properties ( ) ; result . setProperty ( "url" , pacScriptUrl ) ; return result ; } catch ( IOException e ) { return new Properties ( ) ; } } 
private void removeLongPressCallback ( ) { if ( mPendingCheckForLongPress != null ) { removeCallbacks ( mPendingCheckForLongPress ) ; } } 
private QName toQName ( String uri , String localName , String qname ) { String prefix = null ; int idx = qname . indexOf ( ':' ) ; if ( idx > 0 ) prefix = symbolize ( qname . substring ( 0 , idx ) ) ; localName = symbolize ( localName ) ; qname = symbolize ( qname ) ; uri = symbolize ( uri ) ; fQName . setValues ( prefix , localName , qname , uri ) ; return fQName ; } 
public void setOnCancelListener ( final OnCancelListener listener ) { if ( mCancelAndDismissTaken != null ) { throw new IllegalStateException ( "OnCancelListener-is-already-taken-by-" + mCancelAndDismissTaken + "-and-can-not-be-replaced." ) ; } if ( listener != null ) { mCancelMessage = mListenersHandler . obtainMessage ( CANCEL , listener ) ; } else { mCancelMessage = null ; } } 
@ Override public final void flatMap ( IN value , Collector < OUT > out ) throws Exception { for ( Iterator < OUT > iter = flatMap ( value ) ; iter . hasNext ( ) ; ) { out . collect ( iter . next ( ) ) ; } } 
public Writer append ( CharSequence csq ) throws IOException { if ( csq == null ) write ( "null" ) ; else write ( csq . toString ( ) ) ; return this ; } 
@ CallerSensitive public void setDouble ( Object obj , double d ) throws IllegalArgumentException , IllegalAccessException { if ( ! override ) { if ( ! Reflection . quickCheckMemberAccess ( clazz , modifiers ) ) { Class < ? > caller = Reflection . getCallerClass ( ) ; checkAccess ( caller , clazz , obj , modifiers ) ; } } getFieldAccessor ( obj ) . setDouble ( obj , d ) ; } 
public Builder collection ( ResourceCollection collection ) { this . collections . add ( collection ) ; return this ; } 
public static void print ( int x ) { out . print ( x ) ; out . flush ( ) ; } 
public static void closeQuietly ( InputStream input ) { try { if ( input != null ) { input . close ( ) ; } } catch ( IOException ignored ) { } } 
private void scrollToColumn ( int col ) { Container container ; JTable table ; if ( ( header . getParent ( ) == null ) || ( ( container = header . getParent ( ) . getParent ( ) ) == null ) || ! ( container instanceof JScrollPane ) || ( ( table = header . getTable ( ) ) == null ) ) { return ; } Rectangle vis = table . getVisibleRect ( ) ; Rectangle cellBounds = table . getCellRect ( 0 , col , true ) ; vis . x = cellBounds . x ; vis . width = cellBounds . width ; table . scrollRectToVisible ( vis ) ; } 
public void addAccessibleTableListener ( AccessibleTableListener listener ) { checkWidget ( ) ; if ( listener == null ) SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; if ( accessibleTableListeners == null ) accessibleTableListeners = new Vector ( ) ; accessibleTableListeners . addElement ( listener ) ; } 
private ExpiringMap < InetAddress , TreePair > rendezvousPairs ( CFPair cf ) { ExpiringMap < InetAddress , TreePair > ctrees = trees . get ( cf ) ; if ( ctrees == null ) { ctrees = new ExpiringMap < InetAddress , TreePair > ( TREE_STORE_TIMEOUT ) ; trees . put ( cf , ctrees ) ; } return ctrees ; } 
private void loadActivitiesLocked ( ) { mActivites . clear ( ) ; if ( mIntent != null ) { List < ResolveInfo > resolveInfos = mContext . getPackageManager ( ) . queryIntentActivities ( mIntent , 0 ) ; final int resolveInfoCount = resolveInfos . size ( ) ; for ( int i = 0 ; i < resolveInfoCount ; i ++ ) { ResolveInfo resolveInfo = resolveInfos . get ( i ) ; mActivites . add ( new ActivityResolveInfo ( resolveInfo ) ) ; } sortActivities ( ) ; } else { notifyChanged ( ) ; } } 
final void setup ( Location location , StAXResult result , boolean stringsInternalized ) { fDepth = 0 ; fComponentManager . reset ( ) ; setupStAXResultHandler ( result ) ; fValidationManager . setEntityState ( this ) ; if ( fEntities != null && ! fEntities . isEmpty ( ) ) { fEntities . clear ( ) ; } fStAXLocationWrapper . setLocation ( location ) ; fErrorReporter . setDocumentLocator ( fStAXLocationWrapper ) ; fStringsInternalized = stringsInternalized ; } 
public URI toURI ( ) { try { File f = getAbsoluteFile ( ) ; String sp = slashify ( f . getPath ( ) , f . isDirectory ( ) ) ; if ( sp . startsWith ( "//" ) ) sp = "//" + sp ; return new URI ( "file" , null , sp , null ) ; } catch ( URISyntaxException x ) { throw new Error ( x ) ; } } 
public static byte [ ] cloneByteArray ( byte [ ] b ) { if ( b == null ) { return null ; } int len = b . length ; if ( len == 0 ) { return EMPTY_BYTES ; } byte [ ] copy = new byte [ len ] ; System . arraycopy ( b , 0 , copy , 0 , len ) ; return copy ; } 
private void copyAction ( File srcFile , File destFile ) throws FileNotFoundException , IOException { FileInputStream istream = new FileInputStream ( srcFile ) ; FileOutputStream ostream = new FileOutputStream ( destFile ) ; FileChannel input = istream . getChannel ( ) ; FileChannel output = ostream . getChannel ( ) ; try { input . transferTo ( 0 , input . size ( ) , output ) ; } finally { istream . close ( ) ; ostream . close ( ) ; input . close ( ) ; output . close ( ) ; } } 
public BasicDocument < L > init ( List < ? extends Word > words ) { return init ( words , null ) ; } 
@ Deprecated public static String getTaskAttemptIDsPattern ( String jtIdentifier , Integer jobId , TaskType type , Integer taskId , Integer attemptId ) { StringBuilder builder = new StringBuilder ( ATTEMPT ) . append ( SEPARATOR ) ; builder . append ( getTaskAttemptIDsPatternWOPrefix ( jtIdentifier , jobId , type , taskId , attemptId ) ) ; return builder . toString ( ) ; } 
public int getAttributeInt ( final String attributeId ) { try { final String str = getAttributeValue ( attributeId ) ; return Integer . parseInt ( str ) ; } catch ( final NumberFormatException e ) { throw new ParseError ( e ) ; } } 
@ Deprecated public long getDefaultBlockSize ( ) { return getConf ( ) . getLong ( "fs.local.block.size" , 32 * 1024 * 1024 ) ; } 
private DatabaseConnection ( String path ) { try { Class . forName ( "com.mysql.jdbc.Driver" ) . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new NullPointerException ( "driver-failure" ) ; } catch ( InstantiationException e ) { throw new NullPointerException ( "driver-failure" ) ; } catch ( IllegalAccessException e ) { throw new NullPointerException ( "driver-failure" ) ; } try { this . connect = DriverManager . getConnection ( path + ServiceConstants . DB_NAME , ServiceConstants . DB_ROOT , ServiceConstants . DB_ROOT_PWD ) ; } catch ( SQLException e ) { System . out . println ( e . toString ( ) ) ; } this . resultSet = null ; if ( this . connect == null ) { throw new NullPointerException ( "cannot-establish-connection" ) ; } } 
public java . sql . ResultSet getTableTypes ( ) throws SQLException { ArrayList tuples = new ArrayList ( ) ; Field [ ] fields = new Field [ 1 ] ; fields [ 0 ] = new Field ( "" , "TABLE_TYPE" , Types . VARCHAR , 5 ) ; byte [ ] [ ] tableTypeRow = new byte [ 1 ] [ ] ; tableTypeRow [ 0 ] = TABLE_AS_BYTES ; tuples . add ( tableTypeRow ) ; if ( this . conn . versionMeetsMinimum ( 5 , 0 , 1 ) ) { byte [ ] [ ] viewTypeRow = new byte [ 1 ] [ ] ; viewTypeRow [ 0 ] = VIEW_AS_BYTES ; tuples . add ( viewTypeRow ) ; } byte [ ] [ ] tempTypeRow = new byte [ 1 ] [ ] ; tempTypeRow [ 0 ] = s2b ( "LOCAL-TEMPORARY" ) ; tuples . add ( tempTypeRow ) ; return buildResultSet ( fields , tuples ) ; } 
public List < FxAnnotateCommon > getAnnotates ( ) { if ( annotates == null ) { annotates = new ArrayList < FxAnnotateCommon > ( ) ; } return this . annotates ; } 
public String getAccessibleDescription ( ) { AccessibleContext ac = getCurrentAccessibleContext ( ) ; if ( ac != null ) { return ac . getAccessibleDescription ( ) ; } else { return super . getAccessibleDescription ( ) ; } } 
private void removeSendViewScrolledAccessibilityEventCallback ( ) { if ( mSendViewScrolledAccessibilityEvent != null ) { removeCallbacks ( mSendViewScrolledAccessibilityEvent ) ; } } 
private int getMaxDigits ( ) { long etime = - 1 ; long max_time = 0 ; for ( Event e : events ) { if ( etime != - 1 ) { long time = e . eventTime ( ) - etime ; max_time = Math . max ( max_time , time ) ; } if ( ! e . isStart ) { long time = e . tracer . stopTimeMs - e . tracer . startTimeMs ; max_time = Math . max ( max_time , time ) ; } etime = e . eventTime ( ) ; } return Math . max ( 3 , numDigits ( max_time ) ) ; } 
int readDiskBlockInformation ( String diskName , int defSector ) { assert perDiskSectorSize != null && diskName != null ; String procfsDiskSectorFile = "/sys/block/" + diskName + "/queue/hw_sector_size" ; BufferedReader in ; try { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( procfsDiskSectorFile ) , Charset . forName ( "UTF-8" ) ) ) ; } catch ( FileNotFoundException f ) { return defSector ; } Matcher mat ; try { String str = in . readLine ( ) ; while ( str != null ) { mat = PROCFS_DISKSECTORFILE_FORMAT . matcher ( str ) ; if ( mat . find ( ) ) { String secSize = mat . group ( 1 ) ; if ( secSize != null ) { return Integer . parseInt ( secSize ) ; } } str = in . readLine ( ) ; } return defSector ; } catch ( IOException | NumberFormatException e ) { LOG . warn ( "Error-reading-the-stream-" + procfsDiskSectorFile , e ) ; return defSector ; } finally { try { in . close ( ) ; } catch ( IOException e ) { LOG . warn ( "Error-closing-the-stream-" + procfsDiskSectorFile , e ) ; } } } 
public int hashCode ( ) { return p . hashCode ( ) ; } 
public static File createUniqueFile ( File f ) { while ( f . exists ( ) ) { String ext = getExtension ( f ) ; String name = getName ( f ) ; int dashPos = name . lastIndexOf ( '-' ) ; if ( dashPos == - 1 ) { name = name + "-1" ; } else { String num = name . substring ( dashPos + 1 , name . length ( ) ) ; String temp = name . substring ( 0 , dashPos ) ; try { int cur = Integer . parseInt ( num ) + 1 ; name = temp + "-" + cur ; } catch ( NumberFormatException nfe ) { name = name + "-1" ; } } String uniqueName = name ; if ( ! ext . equals ( "" ) ) uniqueName = uniqueName + "." + ext ; String parent = "" ; if ( f . getParent ( ) != null ) parent = f . getParent ( ) ; f = new File ( parent , uniqueName ) ; } return f ; } 
public short getFilStBlk ( ) { return Util . readShortBE ( filStBlk ) ; } 
public void draw ( Graphics2D g2 , Rectangle2D area ) { double t = this . insets . calculateTopInset ( area . getHeight ( ) ) ; double b = this . insets . calculateBottomInset ( area . getHeight ( ) ) ; double l = this . insets . calculateLeftInset ( area . getWidth ( ) ) ; double r = this . insets . calculateRightInset ( area . getWidth ( ) ) ; double x = area . getX ( ) ; double y = area . getY ( ) ; double w = area . getWidth ( ) ; double h = area . getHeight ( ) ; g2 . setPaint ( this . paint ) ; Rectangle2D rect = new Rectangle2D . Double ( ) ; if ( t > 0.0 ) { rect . setRect ( x , y , w , t ) ; g2 . fill ( rect ) ; } if ( b > 0.0 ) { rect . setRect ( x , y + h - b , w , b ) ; g2 . fill ( rect ) ; } if ( l > 0.0 ) { rect . setRect ( x , y , l , h ) ; g2 . fill ( rect ) ; } if ( r > 0.0 ) { rect . setRect ( x + w - r , y , r , h ) ; g2 . fill ( rect ) ; } } 
public void setIgnoreRange ( String rangeList ) { m_SelectCols . setRanges ( rangeList ) ; } 
protected int computeHorizontalScrollExtent ( ) { return getWidth ( ) ; } 
private void buildGraphMapping ( Map mapping , Subgraph subGraph ) { Enumeration e = subGraph . nodeElements ( ) ; while ( e . hasMoreElements ( ) ) { Node n = ( Node ) e . nextElement ( ) ; mapping . put ( n . object , n ) ; } e = subGraph . edgeElements ( ) ; while ( e . hasMoreElements ( ) ) { Edge n = ( Edge ) e . nextElement ( ) ; mapping . put ( n . object , n ) ; } e = subGraph . subgraphElements ( ) ; while ( e . hasMoreElements ( ) ) { Subgraph n = ( Subgraph ) e . nextElement ( ) ; buildGraphMapping ( mapping , n ) ; } } 
public static String getDomainName ( URL url ) { DomainSuffixes tlds = DomainSuffixes . getInstance ( ) ; String host = url . getHost ( ) ; if ( host . endsWith ( "." ) ) host = host . substring ( 0 , host . length ( ) - 1 ) ; if ( IP_PATTERN . matcher ( host ) . matches ( ) ) return host ; int index = 0 ; String candidate = host ; for ( ; index >= 0 ; ) { index = candidate . indexOf ( '.' ) ; String subCandidate = candidate . substring ( index + 1 ) ; if ( tlds . isDomainSuffix ( subCandidate ) ) { return candidate ; } candidate = subCandidate ; } return candidate ; } 
public void disable ( RichFormatterFeature feature ) { features . remove ( feature ) ; } 
public void deliverError ( VolleyError error ) { if ( mErrorListener != null ) { mErrorListener . onErrorResponse ( error ) ; } } 
public static String formatSessionSubtitle ( long blockStart , long blockEnd , String roomName , Context context ) { TimeZone . setDefault ( CONFERENCE_TIME_ZONE ) ; final CharSequence timeString = DateUtils . formatDateRange ( context , blockStart , blockEnd , TIME_FLAGS ) ; return context . getString ( R . string . session_subtitle , timeString , roomName ) ; } 
public final void dispatchEvent ( AWTEvent e ) { dispatchEventImpl ( e ) ; } 
private long getLong ( int cursorIndex ) { return mCursor . getLong ( cursorIndex ) ; } 
public final boolean isSwitch ( @ Nonnull final String name ) { return _switches . contains ( name ) ; } 
public boolean hasAliasSpecificLockModes ( ) { return aliasSpecificLockModes != null && ! aliasSpecificLockModes . isEmpty ( ) ; } 
public String toString ( ) { return super . toString ( ) + ":" + getAttributes ( ) ; } 
public void paintScrollBarTrackBackground ( SynthContext context , Graphics g , int x , int y , int w , int h , int orientation ) { paintScrollBarTrackBackground ( context , g , x , y , w , h ) ; } 
public void setPolicy ( String policyType , String policyValue ) { if ( policyType . equals ( "Tree.Horizontal_ScrollBar" ) ) { if ( policyValue . equals ( "ScrollBar_ALWAYS" ) ) { hbarPolicy = 0 ; if ( ! hbar . isVisible ( ) ) resetScrollBars ( ) ; } else if ( policyValue . equals ( "ScrollBar_AS_NEEDED" ) ) { hbarPolicy = 1 ; resetScrollBars ( ) ; } else if ( policyValue . equals ( "ScrollBar_NEVER" ) ) { hbarPolicy = 2 ; hbar . setVisible ( false ) ; } } } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public BigDecimal abs ( MathContext mc ) { BigDecimal result = abs ( ) ; result . inplaceRound ( mc ) ; return result ; } 
public void setApproveButtonMnemonic ( int mnemonic ) { if ( approveButtonMnemonic == mnemonic ) { return ; } int oldValue = approveButtonMnemonic ; approveButtonMnemonic = mnemonic ; firePropertyChange ( APPROVE_BUTTON_MNEMONIC_CHANGED_PROPERTY , oldValue , approveButtonMnemonic ) ; } 
public Date getTimeOfDayForDate ( Date dateTime ) { if ( dateTime == null ) return null ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( dateTime ) ; cal . set ( Calendar . HOUR_OF_DAY , hour ) ; cal . set ( Calendar . MINUTE , minute ) ; cal . set ( Calendar . SECOND , second ) ; cal . clear ( Calendar . MILLISECOND ) ; return cal . getTime ( ) ; } 
private static char [ ] zzUnpackCMap ( String packed ) { char [ ] map = new char [ 0x10000 ] ; int i = 0 ; int j = 0 ; while ( i < 1154 ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > 0 ) ; } return map ; } 
public int getUnfiledEntryCount ( ) { return unfiledEntries . size ( ) ; } 
public void resume ( ) { if ( this . runningState != State . SUSPENDED ) { throw new IllegalStateException ( "Stopwatch-must-be-suspended-to-resume.-" ) ; } this . startTime += System . nanoTime ( ) - this . stopTime ; this . runningState = State . RUNNING ; } 
public synchronized int getConnectionCount ( ) { return connections . size ( ) ; } 
public double distanceTo ( GeoLocation location , double radius ) { return Math . acos ( Math . sin ( radLat ) * Math . sin ( location . radLat ) + Math . cos ( radLat ) * Math . cos ( location . radLat ) * Math . cos ( radLon - location . radLon ) ) * radius ; } 
final void runWorker ( Worker w ) { Thread wt = Thread . currentThread ( ) ; Runnable task = w . firstTask ; w . firstTask = null ; w . unlock ( ) ; boolean completedAbruptly = true ; try { while ( task != null || ( task = getTask ( ) ) != null ) { w . lock ( ) ; if ( ( runStateAtLeast ( ctl . get ( ) , STOP ) || ( Thread . interrupted ( ) && runStateAtLeast ( ctl . get ( ) , STOP ) ) ) && ! wt . isInterrupted ( ) ) wt . interrupt ( ) ; try { beforeExecute ( wt , task ) ; Throwable thrown = null ; try { task . run ( ) ; } catch ( RuntimeException x ) { thrown = x ; throw x ; } catch ( Error x ) { thrown = x ; throw x ; } catch ( Throwable x ) { thrown = x ; throw new Error ( x ) ; } finally { afterExecute ( task , thrown ) ; } } finally { task = null ; w . completedTasks ++ ; w . unlock ( ) ; } } completedAbruptly = false ; } finally { processWorkerExit ( w , completedAbruptly ) ; } } 
public int check ( ) { int status = NOT_RUNNING ; lockFile = new File ( LOCK_PATH ) ; if ( lockFile . exists ( ) ) { if ( ! lockFile . isFile ( ) ) { LOGGER . error ( "The-lock-path-'{}'-must-be-a-file,-not-a-directory" , LOCK_PATH ) ; status = INVALID_LOCK ; } } else { try { lockFile . createNewFile ( ) ; } catch ( IOException e ) { LOGGER . error ( e . getMessage ( ) ) ; status = INVALID_LOCK ; } } if ( status != INVALID_LOCK ) { try { RandomAccessFile raf = new RandomAccessFile ( lockFile , "rw" ) ; fileChannel = raf . getChannel ( ) ; try { fileLock = fileChannel . tryLock ( ) ; if ( fileLock == null ) { fileChannel . close ( ) ; status = ALREADY_RUNNING ; } } catch ( IOException e ) { LOGGER . error ( e . getMessage ( ) ) ; status = INVALID_LOCK ; } } catch ( FileNotFoundException e ) { LOGGER . error ( "The-impossible-scenario-has-happened!" ) ; status = INVALID_LOCK ; } } return status ; } 
static String getNearResourceCapacityLimit ( ) { return instance . resources . getString ( "resource.nearcapacity" ) ; } 
public void setAcceptCharset ( List < Charset > acceptableCharsets ) { StringBuilder builder = new StringBuilder ( ) ; for ( Iterator < Charset > iterator = acceptableCharsets . iterator ( ) ; iterator . hasNext ( ) ; ) { Charset charset = iterator . next ( ) ; builder . append ( charset . name ( ) . toLowerCase ( Locale . ENGLISH ) ) ; if ( iterator . hasNext ( ) ) { builder . append ( ",-" ) ; } } set ( ACCEPT_CHARSET , builder . toString ( ) ) ; } 
public List < Integer > shortCycle ( int startNode , int limit ) { List < Integer > path = new ArrayList < > ( ) ; path = shortCycle ( startNode , - 1 , startNode , path , limit ) ; if ( path != null ) { path . add ( 0 , startNode ) ; } return path ; } 
public static boolean isWorkProfileSupported ( ) { final PackageManager pm = Factory . get ( ) . getApplicationContext ( ) . getPackageManager ( ) ; return pm . hasSystemFeature ( PackageManager . FEATURE_MANAGED_USERS ) ; } 
protected synchronized PropertyProxy < ? , ? > _getPropertyProxyFromCache ( String uniqueName ) { PropertyProxyHolder h = propertyCache . get ( uniqueName ) ; if ( h == null ) { return null ; } return h . proxy ; } 
protected void addLoadedDefinition ( String definitionName , URI definitionURI ) { loadedDefinitions . put ( definitionName , definitionURI ) ; } 
private boolean isFastPath ( String regex ) { char ch ; return ( ( ( regex . length ( ) == 1 && ".$|()[{^?*+|" . indexOf ( ch = regex . charAt ( 0 ) ) == - 1 ) || ( regex . length ( ) == 2 && regex . charAt ( 0 ) == '|' && ( ( ( ch = regex . charAt ( 1 ) ) - '0' ) | ( '9' - ch ) ) < 0 && ( ( ch - 'a' ) | ( 'z' - ch ) ) < 0 && ( ( ch - 'A' ) | ( 'Z' - ch ) ) < 0 ) ) && ( ch < Character . MIN_HIGH_SURROGATE || ch > Character . MAX_LOW_SURROGATE ) ) ; } 
public float getAlignment ( int axis ) { updateRequirements ( axis ) ; return requirements [ axis ] . alignment ; } 
@ Override public Object lookup ( Name name ) throws NamingException { CacheEntry entry = cacheLookup ( name . toString ( ) ) ; if ( entry != null ) { if ( ! entry . exists ) { throw NOT_FOUND_EXCEPTION ; } if ( entry . resource != null ) { return entry . resource ; } else { return entry . context ; } } Object object = dirContext . lookup ( parseName ( name ) ) ; if ( object instanceof InputStream ) return new Resource ( ( InputStream ) object ) ; else return object ; } 
public boolean contains ( Object o ) { return indexOf ( o , 0 ) >= 0 ; } 
public void marshall ( ) { try { File markup = new File ( this . directory + this . studentID + ".annotations" ) ; JAXBElement < MFAXPDFMarkup > pdfMarkup = this . mfaxObjectFactory . createPdfMarkup ( this . mfaxPDFMarkup ) ; JAXBContext jc = JAXBContext . newInstance ( ObjectFactory . class . getPackage ( ) . getName ( ) ) ; Marshaller m = jc . createMarshaller ( ) ; m . marshal ( pdfMarkup , markup ) ; } catch ( JAXBException ex ) { Logger . getLogger ( PDFMarkupTool . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } 
public static Quarter parseQuarter ( String s ) { int i = s . indexOf ( "Q" ) ; if ( i == - 1 ) { throw new TimePeriodFormatException ( "Missing-Q." ) ; } if ( i == s . length ( ) - 1 ) { throw new TimePeriodFormatException ( "Q-found-at-end-of-string." ) ; } String qstr = s . substring ( i + 1 , i + 2 ) ; int quarter = Integer . parseInt ( qstr ) ; String remaining = s . substring ( 0 , i ) + s . substring ( i + 2 , s . length ( ) ) ; remaining = remaining . replace ( '/' , '-' ) ; remaining = remaining . replace ( ',' , '-' ) ; remaining = remaining . replace ( '-' , '-' ) ; Year year = Year . parseYear ( remaining . trim ( ) ) ; Quarter result = new Quarter ( quarter , year ) ; return result ; } 
public boolean tryLock ( ) { return sync . tryReadLock ( ) ; } 
public static List < String > parse ( String url ) { List < String > iplist = new ArrayList < String > ( ) ; try { URL fileURL = new URL ( url ) ; InputStream file = fileURL . openStream ( ) ; if ( file != null ) { BufferedReader buffer = new BufferedReader ( new InputStreamReader ( file , "UTF-8" ) ) ; String ipLine = null ; String specIP = null ; while ( ( ipLine = buffer . readLine ( ) ) != null ) { ipLine = ipLine . trim ( ) ; if ( ipLine . length ( ) == 0 || ipLine . charAt ( 0 ) == COMMENT_CHAR ) { continue ; } int comIndex = ipLine . indexOf ( COMMENT_STR ) ; if ( comIndex == - 1 ) { specIP = ipLine ; } else { specIP = ipLine . substring ( 0 , comIndex ) ; ipLine = ipLine . trim ( ) ; } iplist . add ( specIP ) ; } buffer . close ( ) ; } else { log ( ) . warn ( "URL-does-not-exist:-" + url ) ; } } catch ( MalformedURLException e ) { log ( ) . error ( "Error-reading-URL:-" + url + ":-" + e . getLocalizedMessage ( ) ) ; } catch ( FileNotFoundException e ) { log ( ) . error ( "Error-reading-URL:-" + url + ":-" + e . getLocalizedMessage ( ) ) ; } catch ( IOException e ) { log ( ) . error ( "Error-reading-URL:-" + url + ":-" + e . getLocalizedMessage ( ) ) ; } return iplist ; } 
public Color getForeground ( ) { AccessibleContext ac = getCurrentAccessibleContext ( ) ; if ( ac instanceof AccessibleComponent ) { return ( ( AccessibleComponent ) ac ) . getForeground ( ) ; } else { Component c = getCurrentComponent ( ) ; if ( c != null ) { return c . getForeground ( ) ; } else { return null ; } } } 
public boolean containsKey ( Object key ) { Iterator < Map . Entry < K , V >> entries = entrySet ( ) . iterator ( ) ; int pos = size ( ) ; while ( -- pos >= 0 ) if ( equals ( key , entries . next ( ) . getKey ( ) ) ) return true ; return false ; } 
public static Iterator < Recipe > recipeIterator ( ) { return server . recipeIterator ( ) ; } 
public void printAllDataFromTable ( ) { Statement stmt = null ; ResultSet resultSet ; try { stmt = conn . createStatement ( ) ; resultSet = stmt . executeQuery ( "SELECT-*-FROM-" + DBParams . TABLE6 ) ; while ( resultSet . next ( ) ) { System . out . println ( resultSet . getString ( "PARAM" ) + "-" + resultSet . getString ( "VALUE" ) + "-" + resultSet . getString ( "DATE" ) ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } } 
private void closeWriter ( Writer pobjWriter ) { if ( pobjWriter == null ) { return ; } try { pobjWriter . close ( ) ; } catch ( IOException IOExIgnore ) { } } 
private LinkedEntry < V > [ ] makeTable ( int newCapacity ) { @ SuppressWarnings ( "unchecked" ) LinkedEntry < V > [ ] newTable = ( LinkedEntry < V > [ ] ) new LinkedEntry [ newCapacity ] ; table = newTable ; threshold = ( newCapacity >> 1 ) + ( newCapacity >> 2 ) ; return newTable ; } 
public int getTransactionIsolation ( ) throws SQLException { if ( this . hasIsolationLevels && ! getUseLocalSessionState ( ) ) { java . sql . Statement stmt = null ; java . sql . ResultSet rs = null ; try { stmt = getMetadataSafeStatement ( ) ; String query = null ; int offset = 0 ; if ( versionMeetsMinimum ( 4 , 0 , 3 ) ) { query = "SELECT-@@session.tx_isolation" ; offset = 1 ; } else { query = "SHOW-VARIABLES-LIKE-'transaction_isolation'" ; offset = 2 ; } rs = stmt . executeQuery ( query ) ; if ( rs . next ( ) ) { String s = rs . getString ( offset ) ; if ( s != null ) { Integer intTI = ( Integer ) mapTransIsolationNameToValue . get ( s ) ; if ( intTI != null ) { return intTI . intValue ( ) ; } } throw SQLError . createSQLException ( "Could-not-map-transaction-isolation-'" + s + "-to-a-valid-JDBC-level." , SQLError . SQL_STATE_GENERAL_ERROR ) ; } throw SQLError . createSQLException ( "Could-not-retrieve-transaction-isolation-level-from-server" , SQLError . SQL_STATE_GENERAL_ERROR ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( Exception ex ) { ; } rs = null ; } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( Exception ex ) { ; } stmt = null ; } } } return this . isolationLevel ; } 
private static String sanitizeArg ( String arg ) { arg = arg . replace ( '|0' , '?' ) ; arg = arg . replace ( '|n' , '?' ) ; return arg ; } 
public void learnVector ( final Calendar when , final List < Double > vals ) { final double vals2 [ ] = new double [ vals . size ( ) ] ; for ( int i = 0 ; i < vals2 . length ; i ++ ) { vals2 [ i ] = vals . get ( i ) ; } this . learnVector ( when , vals2 ) ; } 
public static DayOfYear now ( Clock clock ) { final LocalDate now = LocalDate . now ( clock ) ; return DayOfYear . of ( now . getDayOfYear ( ) ) ; } 
protected void log ( String message , Throwable throwable ) { Logger logger = null ; if ( container != null ) logger = container . getLogger ( ) ; if ( logger != null ) logger . log ( "StandardPipeline[" + container . getName ( ) + "]:-" + message , throwable ) ; else { System . out . println ( "StandardPipeline[" + container . getName ( ) + "]:-" + message ) ; throwable . printStackTrace ( System . out ) ; } } 
public void windowActivated ( WindowEvent e ) { ( ( WindowListener ) a ) . windowActivated ( e ) ; ( ( WindowListener ) b ) . windowActivated ( e ) ; } 
public String getQuery ( ) { if ( ( decodedQuery == null ) && ( query != null ) ) decodedQuery = decode ( query ) ; return decodedQuery ; } 
public void idleAbort ( ) throws ProtocolException { OutputStream os = getOutputStream ( ) ; try { os . write ( DONE ) ; os . flush ( ) ; } catch ( IOException ex ) { } } 
public final boolean compareAndSet ( int i , int expect , int update ) { return compareAndSetRaw ( checkedByteOffset ( i ) , expect , update ) ; } 
public boolean setValue ( String value ) { if ( mDataType != TYPE_ASCII && mDataType != TYPE_UNDEFINED ) { return false ; } byte [ ] buf = value . getBytes ( US_ASCII ) ; byte [ ] finalBuf = buf ; if ( buf . length > 0 ) { finalBuf = ( buf [ buf . length - 1 ] == 0 || mDataType == TYPE_UNDEFINED ) ? buf : Arrays . copyOf ( buf , buf . length + 1 ) ; } else if ( mDataType == TYPE_ASCII && mComponentCountActual == 1 ) { finalBuf = new byte [ ] { 0 } ; } int count = finalBuf . length ; if ( checkBadComponentCount ( count ) ) { return false ; } mComponentCountActual = count ; mValue = finalBuf ; return true ; } 
public final Certificate generateCertificate ( InputStream inStream ) throws CertificateException { return spiImpl . engineGenerateCertificate ( inStream ) ; } 
public void setTypeFromString ( String typeName ) { try { type = Type . valueOf ( typeName ) ; } catch ( Exception e ) { if ( parent != null ) { type = Type . defaulType ; } else { type = Type . number ; } } } 
public static boolean pushDebug ( EscapeAnalysis . SigKind kw , EscapeAnalysis . SigKind pw , Method kid , Signature vk , Method parent , Signature pk ) { String s = "OW-" + kw + "-" + pw + "|" + kid + "-(sig:-" + vk . parseableFormat ( ) + ")-" + "-to-" + parent + "-sig-" + pk ; messages . add ( s ) ; methods . push ( parent ) ; compare . push ( pk . toString ( ) ) ; pk . clearFlags ( true ) ; assert ! pk . hasChanged ( ) ; check ( kid , vk ) ; check ( parent , pk ) ; return true ; } 
protected synchronized boolean canGetStatus ( ) { if ( ! triggered ) { return false ; } int ti = Thread . currentThread ( ) . hashCode ( ) ; Integer t = Integer . valueOf ( ti ) ; int idx = lastRequest . indexOf ( t ) ; if ( idx == - 1 ) { lastRequest . add ( t ) ; return true ; } return false ; } 
public void enterQuarters ( int amount ) { payment = payment . add ( QUARTER_VALUE . multiply ( new BigDecimal ( amount ) ) ) ; } 
public void setOnCreateContextMenuListener ( OnCreateContextMenuListener l ) { if ( ! isLongClickable ( ) ) { setLongClickable ( true ) ; } getListenerInfo ( ) . mOnCreateContextMenuListener = l ; } 
public String evaluate ( String expression , InputSource source ) throws XPathExpressionException { return ( String ) this . evaluate ( expression , source , XPathConstants . STRING ) ; } 
public BaseCard drawTopCard ( ) throws IndexOutOfBoundsException { return cards . remove ( 0 ) ; } 
public HourStatistics get ( String hour ) { HourStatistics h = stats . get ( hour ) ; if ( h != null ) { return h ; } else { HourStatistics ns = new HourStatistics ( ) ; stats . put ( hour , ns ) ; return ns ; } } 
public Object create ( Object parent ) { try { return _instanceClass . newInstance ( ) ; } catch ( Exception e ) { throw ConfigException . create ( e ) ; } } 
public static void removeDefaultDuplicates ( Map < String , Set < String >> attributeValues , Map < String , Set < String >> finalAttributes ) { for ( String attributeKey : attributeValues . keySet ( ) ) { if ( attributeKey != null && attributeKey . length ( ) > 0 && attributeKey . endsWith ( "]" ) ) { int endIndex = attributeKey . lastIndexOf ( "[" ) ; if ( endIndex != - 1 ) { attributeKey = attributeKey . substring ( 0 , endIndex ) ; if ( finalAttributes . containsKey ( attributeKey ) ) { finalAttributes . remove ( attributeKey ) ; } } } } } 
public static String getInsertSql ( String tableName , LinkedHashMap < String , Object > insertValue ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "insert-into-`" ) ; sb . append ( tableName ) ; sb . append ( "`(" ) ; int m = 0 ; for ( String s : insertValue . keySet ( ) ) { if ( m > 0 ) { sb . append ( "," ) ; } sb . append ( "`" ) ; sb . append ( s ) ; sb . append ( "`" ) ; m ++ ; } sb . append ( ")-values(" ) ; m = 0 ; for ( String s : insertValue . keySet ( ) ) { if ( m > 0 ) { sb . append ( "," ) ; } if ( "now()" . equals ( insertValue . get ( s ) . toString ( ) ) ) { sb . append ( "now()" ) ; } else { sb . append ( "'" ) ; sb . append ( insertValue . get ( s ) . toString ( ) ) ; sb . append ( "'" ) ; } m ++ ; } sb . append ( ")" ) ; return sb . toString ( ) ; } 
String readUntil ( char end ) throws IOException { mBufferReadUntil . setLength ( 0 ) ; for ( ; ; ) { final int ch = readByte ( ) ; if ( ch != end ) { mBufferReadUntil . append ( ( char ) ch ) ; } else { return mBufferReadUntil . toString ( ) ; } } } 
public Property < V > getFirstResult ( ) { List < Property < V >> results = getResultList ( ) ; return results . isEmpty ( ) ? null : results . get ( 0 ) ; } 
public static Range shift ( Range base , double delta ) { return shift ( base , delta , false ) ; } 
private static void matchIP ( String expectedIP , X509Certificate cert ) throws CertificateException { Collection < List < ? >> subjAltNames = cert . getSubjectAlternativeNames ( ) ; if ( subjAltNames == null ) { throw new CertificateException ( "No-subject-alternative-names-present" ) ; } for ( List < ? > next : subjAltNames ) { if ( ( ( Integer ) next . get ( 0 ) ) . intValue ( ) == ALTNAME_IP ) { String ipAddress = ( String ) next . get ( 1 ) ; if ( expectedIP . equalsIgnoreCase ( ipAddress ) ) { return ; } } } throw new CertificateException ( "No-subject-alternative-" + "names-matching-" + "IP-address-" + expectedIP + "-found" ) ; } 
public Set < String > getExtraFields ( ) { return new HashSet < String > ( extraFields ) ; } 
public static String encodeBytes ( byte [ ] source , int off , int len , int options ) throws java . io . IOException { byte [ ] encoded = encodeBytesToBytes ( source , off , len , options ) ; try { return new String ( encoded , PREFERRED_ENCODING ) ; } catch ( java . io . UnsupportedEncodingException uue ) { return new String ( encoded ) ; } } 
public String toASCIIString ( ) { StringBuilder result = new StringBuilder ( ) ; ASCII_ONLY . appendEncoded ( result , toString ( ) ) ; return result . toString ( ) ; } 
public void windowClosing ( WindowEvent e ) { action . actionPerformed ( new ActionEvent ( window , ActionEvent . ACTION_PERFORMED , action . getValue ( Action . ACTION_COMMAND_KEY ) . toString ( ) ) ) ; } 
private void rMoveTo ( float dx , float dy ) { dx += mLastX ; dy += mLastY ; mPath . moveTo ( mLastX = dx , mLastY = dy ) ; } 
public MethodHash getMethodHash ( XMethod method ) { return methodHashMap . get ( method ) ; } 
private String getCommandLine ( ) { StringBuffer commandLine = new StringBuffer ( getFullExecutablePath ( ) ) ; commandLine . append ( buildOptionalCommandLine ( ) ) ; return commandLine . toString ( ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
boolean isSupportedFileSuffix ( String fileSuffix ) { return mFileSuffixList . contains ( fileSuffix ) ; } 
public void prettyPrint ( PrintStream out ) { out . print ( value ) ; } 
public long getLong ( int index ) throws JSONException { Object object = this . get ( index ) ; try { return object instanceof Number ? ( ( Number ) object ) . longValue ( ) : Long . parseLong ( ( String ) object ) ; } catch ( Exception e ) { throw new JSONException ( "JSONArray[" + index + "]-is-not-a-number." ) ; } } 
@ SuppressWarnings ( "unchecked" ) public Painter getBackgroundPainter ( SynthContext ctx ) { if ( ! ( style instanceof NimbusStyle ) ) { return null ; } return new PainterWrapper ( ( ( NimbusStyle ) style ) . getBackgroundPainter ( ctx ) ) ; } 
public Dimension getSize ( ) { if ( parent != null ) { Rectangle r = parent . getHeaderRect ( column ) ; if ( r != null ) { return r . getSize ( ) ; } } return null ; } 
public synchronized List < String > getFoundChannels ( ) { Log . i ( TAG , "getFoundChannels()" ) ; List < String > clone = new ArrayList < String > ( mChannels . size ( ) ) ; for ( String string : mChannels ) { Log . i ( TAG , "getFoundChannels():-added-" + string ) ; clone . add ( new String ( string ) ) ; } return clone ; } 
Worker ( String name ) { Thread t = new Thread ( null , this , name ) ; t . setPriority ( Thread . MIN_PRIORITY ) ; t . start ( ) ; synchronized ( mLock ) { while ( mLooper == null ) { try { mLock . wait ( ) ; } catch ( InterruptedException ex ) { } } } } 
protected StandardMBean ( Class < ? > mbeanInterface ) throws NotCompliantMBeanException { construct ( null , mbeanInterface , true , false ) ; } 
public static @ DottedClassName String extractPackageName ( @ DottedClassName String className ) { int i = className . lastIndexOf ( '.' ) ; if ( i < 0 ) return "" ; return className . substring ( 0 , i ) ; } 
private static String [ ] [ ] getPassThruAttributes ( String exclusion ) { if ( exclusion == null ) return PASSTHRU_ATTRIBUTES ; String [ ] [ ] passthruAttributes = passthruAttributesWithExclusion . get ( exclusion ) ; if ( passthruAttributes == null ) { String [ ] excludes = exclusion . split ( "," ) ; passthruAttributes = new String [ PASSTHRU_ATTRIBUTES . length - excludes . length ] [ ] ; int next = 0 ; for ( int i = 0 ; i < PASSTHRU_ATTRIBUTES . length ; i ++ ) { String name = PASSTHRU_ATTRIBUTES [ i ] [ 0 ] ; boolean skip = false ; for ( int j = 0 ; j < excludes . length ; j ++ ) { if ( name . equals ( excludes [ j ] ) ) { skip = true ; break ; } } if ( ! skip ) { passthruAttributes [ next ++ ] = PASSTHRU_ATTRIBUTES [ i ] ; } } assert next == passthruAttributes . length ; passthruAttributesWithExclusion . putIfAbsent ( exclusion , passthruAttributes ) ; } return passthruAttributes ; } 
public void setContinuousLayout ( boolean newContinuousLayout ) { boolean oldCD = continuousLayout ; continuousLayout = newContinuousLayout ; firePropertyChange ( CONTINUOUS_LAYOUT_PROPERTY , oldCD , newContinuousLayout ) ; } 
private void removeServer ( LdapServer server , boolean notifyListeners ) { if ( serversList . contains ( server ) ) { serversList . remove ( server ) ; serversIdMap . remove ( server . getId ( ) ) ; if ( notifyListeners ) { for ( LdapServersManagerListener listener : listeners . toArray ( new LdapServersManagerListener [ 0 ] ) ) { listener . serverRemoved ( server ) ; } } } } 
public Date getTimeModifiedDate ( ) { if ( timeModified == 0 ) return null ; return new Date ( timeModified ) ; } 
public void windowClosing ( WindowEvent e ) { setSelected ( false ) ; } 
private static String formatDate ( Date date ) { if ( date == null ) { return "" ; } return new SimpleDateFormat ( ISO_8601_DATE_FORMAT ) . format ( date ) ; } 
public static List < Window > windows ( List < String > words , int windowSize ) { List < Window > ret = new ArrayList < > ( ) ; for ( int i = 0 ; i < words . size ( ) ; i ++ ) ret . add ( windowForWordInPosition ( windowSize , i , words ) ) ; return ret ; } 
public static DynSequence narrow ( org . omg . CORBA . Object obj ) { try { return ( DynSequence ) obj ; } catch ( ClassCastException cex ) { throw new BAD_PARAM ( obj . getClass ( ) . getName ( ) + "-is-not-a-DynSequence" ) ; } } 
public Node previousNode ( ) throws DOMException { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESET_CANNOT_ITERATE , null ) ) ; if ( ( m_next - 1 ) > 0 ) { m_next -- ; return this . elementAt ( m_next ) ; } else return null ; } 
public void setRecman ( String recman ) { this . recman = recman == null ? null : recman . trim ( ) ; } 
private void enablePluginToolBarActions ( Plugin selectedPlugin ) { for ( Iterator stream1 = this . pluginToolBarActions . entrySet ( ) . iterator ( ) ; stream1 . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) stream1 . next ( ) ; boolean enabled = entry . getKey ( ) == selectedPlugin ; for ( Iterator stream2 = ( ( Collection ) entry . getValue ( ) ) . iterator ( ) ; stream2 . hasNext ( ) ; ) { ( ( Action ) stream2 . next ( ) ) . setEnabled ( enabled ) ; } } } 
public static IdVector selectIdOnly ( Connection pCon , String pIdName , DBCriteria pCriteria ) throws SQLException { StringBuffer sqlBuf = new StringBuffer ( "SELECT-DISTINCT-" + pIdName + "-FROM-CLW_WORKFLOW_ASSOC" ) ; String where = pCriteria . getSqlClause ( ) ; if ( where != null && ! where . equals ( "" ) ) { sqlBuf . append ( "-WHERE-" ) ; sqlBuf . append ( where ) ; } String sql = sqlBuf . toString ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "SQL:-" + sql ) ; } Statement stmt = pCon . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( sql ) ; IdVector v = new IdVector ( ) ; while ( rs . next ( ) ) { Integer x = new Integer ( rs . getInt ( 1 ) ) ; v . add ( x ) ; } rs . close ( ) ; stmt . close ( ) ; return v ; } 
public static Dialog buildGlobalChangeWarningDialog ( final Context context , int titleResId , final Runnable positiveAction ) { final AlertDialog . Builder builder = new AlertDialog . Builder ( context ) ; builder . setTitle ( titleResId ) ; builder . setMessage ( R . string . global_change_warning ) ; builder . setPositiveButton ( android . R . string . ok , new DialogInterface . OnClickListener ( ) { @ Override public void onClick ( DialogInterface dialog , int which ) { positiveAction . run ( ) ; } } ) ; builder . setNegativeButton ( android . R . string . cancel , null ) ; return builder . create ( ) ; } 
public Sequence < Span > addSelectedRange ( Span range ) { if ( range == null ) { throw new IllegalArgumentException ( "range-is-null." ) ; } return addSelectedRange ( range . start , range . end ) ; } 
public void cleanUp ( ) { if ( mOutputJar != null ) { try { mOutputJar . close ( ) ; } catch ( IOException e ) { } } } 
public final String getCallingPackage ( ) { final String pkg = mCallingPackage . get ( ) ; if ( pkg != null ) { mTransport . mAppOpsManager . checkPackage ( Binder . getCallingUid ( ) , pkg ) ; } return pkg ; } 
@ Override public boolean isError ( ) { Object oo = get_Value ( COLUMNNAME_IsError ) ; if ( oo != null ) { if ( oo instanceof Boolean ) return ( ( Boolean ) oo ) . booleanValue ( ) ; return "Y" . equals ( oo ) ; } return false ; } 
public void updateArray ( String columnLabel , java . sql . Array x ) throws SQLException { throw Util . notSupported ( ) ; } 
public boolean verifyTimeoutCode ( String timeoutCode , long currentInterval , int pastIntervals , int futureIntervals ) throws GeneralSecurityException { pastIntervals = Math . max ( pastIntervals , 0 ) ; futureIntervals = Math . max ( futureIntervals , 0 ) ; for ( int i = - pastIntervals ; i <= futureIntervals ; ++ i ) { String candidate = generateResponseCode ( currentInterval - i , null ) ; if ( candidate . equals ( timeoutCode ) ) { return true ; } } return false ; } 
public final Element getDocumentElement ( ) { int dochandle = dtm . getDocument ( ) ; int elementhandle = DTM . NULL ; for ( int kidhandle = dtm . getFirstChild ( dochandle ) ; kidhandle != DTM . NULL ; kidhandle = dtm . getNextSibling ( kidhandle ) ) { switch ( dtm . getNodeType ( kidhandle ) ) { case Node . ELEMENT_NODE : if ( elementhandle != DTM . NULL ) { elementhandle = DTM . NULL ; kidhandle = dtm . getLastChild ( dochandle ) ; } else elementhandle = kidhandle ; break ; case Node . COMMENT_NODE : case Node . PROCESSING_INSTRUCTION_NODE : case Node . DOCUMENT_TYPE_NODE : break ; default : elementhandle = DTM . NULL ; kidhandle = dtm . getLastChild ( dochandle ) ; break ; } } if ( elementhandle == DTM . NULL ) throw new DTMDOMException ( DOMException . NOT_SUPPORTED_ERR ) ; else return ( Element ) ( dtm . getNode ( elementhandle ) ) ; } 
final static int getPositionRelativeToDocumentElement ( Node currentNode ) { if ( ( currentNode == null ) || ( currentNode . getParentNode ( ) . getNodeType ( ) != Node . DOCUMENT_NODE ) ) { return CanonicalizerBase . NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT ; } Element documentElement = currentNode . getOwnerDocument ( ) . getDocumentElement ( ) ; if ( ( documentElement == null ) || ( documentElement == currentNode ) ) { return CanonicalizerBase . NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT ; } for ( Node x = currentNode ; x != null ; x = x . getNextSibling ( ) ) { if ( x == documentElement ) { return CanonicalizerBase . NODE_BEFORE_DOCUMENT_ELEMENT ; } } return CanonicalizerBase . NODE_AFTER_DOCUMENT_ELEMENT ; } 
public void removeProtein ( IntermediateProtein protein ) { if ( proteins != null ) { proteins . remove ( protein ) ; } } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public int hashCode ( ) { int hashCode = 1 ; Iterator < E > itr = iterator ( ) ; int pos = size ( ) ; while ( -- pos >= 0 ) hashCode = 31 * hashCode + hashCode ( itr . next ( ) ) ; return hashCode ; } 
private void ensureCapacity ( int size ) { if ( size > data . length ) { Object [ ] oldData = this . data ; int newSize = data . length * 2 ; if ( newSize < size ) { newSize = size ; } this . data = new Object [ newSize ] ; System . arraycopy ( oldData , 0 , this . data , 0 , oldData . length ) ; } } 
public boolean putMappingResource ( Class forLoader , String name ) throws IOException { InputStream stream = forLoader . getResourceAsStream ( name ) ; byte [ ] bytebuf = new byte [ 4096 ] ; int cnt ; StringBuilder buf = new StringBuilder ( ) ; while ( ( cnt = stream . read ( bytebuf ) ) != - 1 ) { buf . append ( new String ( bytebuf , 0 , cnt , Charset . forName ( "UTF-8" ) ) ) ; } return putMapping ( buf . toString ( ) . split ( "[-]+" ) ) ; } 
public List < Extra > getExtras ( ) { if ( extras == null ) { extras = new ArrayList < Extra > ( ) ; } return this . extras ; } 
public static boolean isMailTo ( String url ) { if ( url != null && url . startsWith ( MAILTO_SCHEME ) ) { return true ; } return false ; } 
public String getClade ( int index ) { BitSet bits = ( BitSet ) get ( index ) ; StringBuffer buffer = new StringBuffer ( "{" ) ; boolean first = true ; for ( int i = 0 ; i < bits . length ( ) ; i ++ ) { if ( bits . get ( i ) ) { if ( ! first ) { buffer . append ( ",-" ) ; } else { first = false ; } buffer . append ( taxonList . getTaxonId ( i ) ) ; } } buffer . append ( "}" ) ; return buffer . toString ( ) ; } 
public void setStatusLine ( String statusLine ) { this . statusLine = statusLine ; props . add ( 0 , null ) ; props . add ( 1 , statusLine ) ; } 
public static ClassLoader getLoader ( ) { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( loader == null ) { loader = ClassLoader . class . getClassLoader ( ) ; } return loader ; } 
public static String asString ( InputStream pStream ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; copy ( pStream , baos , true ) ; return baos . toString ( ) ; } 
void unregisterOnActivityStopListener ( OnActivityStopListener listener ) { synchronized ( this ) { if ( mActivityStopListeners != null ) { mActivityStopListeners . remove ( listener ) ; } } } 
private void openMenuItemActionPerformed ( java . awt . event . ActionEvent evt ) { JFileChooser chooser = drawFileChooser ( ) ; if ( chooser . showOpenDialog ( this ) == JFileChooser . APPROVE_OPTION ) { try { directory = chooser . getCurrentDirectory ( ) ; BufferedReader br = new BufferedReader ( new FileReader ( chooser . getSelectedFile ( ) ) ) ; String sr = "" ; while ( br . ready ( ) ) sr += ( char ) br . read ( ) ; br . close ( ) ; addInternalFrame ( chooser . getSelectedFile ( ) . getPath ( ) , sr . replace ( "-" , "-" ) ) . setPreviouslySaved ( true ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( null , "An-error-occurred-while-trying-to-open-the-specified-file" , "Error" , JOptionPane . ERROR_MESSAGE ) ; } } } 
private void initGameAreaPanel ( ) { gameAreaPanel = new JPanel ( ) ; gameAreaPanel . setLayout ( null ) ; gameAreaPanel . add ( this . levelTypeInfoView ) ; } 
private static String getIdBasename ( String id ) { if ( id . startsWith ( NEW_ID_PREFIX ) ) { return id . substring ( NEW_ID_PREFIX . length ( ) ) ; } else if ( id . startsWith ( ID_PREFIX ) ) { return id . substring ( ID_PREFIX . length ( ) ) ; } return null ; } 
private String buildTask1GoldElem ( StringBuilder textBuilder , List < String > goldElems ) { String strGold ; textBuilder . setLength ( 0 ) ; textBuilder . append ( "[" ) ; textBuilder . append ( concatWithSeparator ( goldElems , "," ) ) ; textBuilder . append ( "]" ) ; strGold = new String ( textBuilder ) ; return strGold ; } 
public boolean isShorterThan ( final Duration duration ) { return compare ( duration ) == DatatypeConstants . LESSER ; } 
public void testEmpty ( ) { PriorityBlockingQueue q = new PriorityBlockingQueue ( 2 ) ; assertTrue ( q . isEmpty ( ) ) ; assertEquals ( NOCAP , q . remainingCapacity ( ) ) ; q . add ( one ) ; assertFalse ( q . isEmpty ( ) ) ; q . add ( two ) ; q . remove ( ) ; q . remove ( ) ; assertTrue ( q . isEmpty ( ) ) ; } 
public List < Property > getProperties ( String name ) { return mPropsMap . get ( name ) ; } 
@ Deprecated public void sync ( ) { CookieManager . getInstance ( ) . flush ( ) ; } 
protected void appendSummary ( final StringBuffer buffer , final String fieldName , final float [ ] array ) { appendSummarySize ( buffer , fieldName , array . length ) ; } 
public String getMove ( int weight ) { String move = "" ; if ( weight >= 0 ) { if ( hand . hasSevenOfDiamonds ( ) ) { move = "7D" ; } else { Card [ ] cards = this . hand . getCardsWithWeight ( weight ) ; int i = 0 ; ArrayList < Card > playableCards = new ArrayList < Card > ( ) ; while ( i < cards . length ) { if ( state . isCardPlayable ( cards [ i ] ) ) { playableCards . add ( cards [ i ] ) ; } i = i + 1 ; } if ( playableCards . size ( ) == 0 ) { move = getMove ( weight - 1 ) ; } else if ( playableCards . size ( ) == 1 ) { move = new StringBuilder ( ) . append ( playableCards . get ( 0 ) . getValue ( ) ) . append ( playableCards . get ( 0 ) . getSuit ( ) ) . toString ( ) ; } else { Card playedCard = playableCards . get ( 0 ) ; int j = 1 ; while ( j < playableCards . size ( ) ) { if ( hand . getSuitCount ( playedCard . getSuit ( ) ) < hand . getSuitCount ( playableCards . get ( j ) . getSuit ( ) ) ) { playedCard = playableCards . get ( j ) ; } j = j + 1 ; } move = new StringBuilder ( ) . append ( playedCard . getValue ( ) ) . append ( playedCard . getSuit ( ) ) . toString ( ) ; } } } return move ; } 
public void execute ( ) { for ( LatestRepoCallable task : tasks ) { futures . add ( executor . submit ( task ) ) ; } executor . shutdown ( ) ; } 
public void msgThisIsAHoldup ( BankCustomer bc , double amount ) { log . add ( new LoggedEvent ( "Received-msgThisIsAHoldUp-from-BankCustomer" ) ) ; this . bc = bc ; synchronized ( tasks ) { tasks . add ( new Task ( "robBank" , amount , - 1 ) ) ; } stateChanged ( ) ; } 
public BigDecimal nextBigDecimal ( ) { if ( ( typeCache != null ) && ( typeCache instanceof BigDecimal ) ) { BigDecimal val = ( BigDecimal ) typeCache ; useTypeCache ( ) ; return val ; } setRadix ( 10 ) ; clearCaches ( ) ; try { String s = processFloatToken ( next ( decimalPattern ( ) ) ) ; return new BigDecimal ( s ) ; } catch ( NumberFormatException nfe ) { position = matcher . start ( ) ; throw new InputMismatchException ( nfe . getMessage ( ) ) ; } } 
@ Override public String [ ] getEnabledProtocols ( ) { ArrayList < String > array = new ArrayList < String > ( ) ; if ( ( ssl_op_no & SSL_OP_NO_SSLv3 ) == 0x00000000L ) { array . add ( supportedProtocols [ 0 ] ) ; } if ( ( ssl_op_no & SSL_OP_NO_TLSv1 ) == 0x00000000L ) { array . add ( supportedProtocols [ 1 ] ) ; } return array . toArray ( new String [ array . size ( ) ] ) ; } 
public String readLine ( ) throws IOException { synchronized ( in ) { if ( buf == null ) { throw new IOException ( "LineReader-is-closed" ) ; } if ( pos >= end ) { fillBuf ( ) ; } for ( int i = pos ; i != end ; ++ i ) { if ( buf [ i ] == LF ) { int lineEnd = ( i != pos && buf [ i - 1 ] == CR ) ? i - 1 : i ; String res = new String ( buf , pos , lineEnd - pos , charset . name ( ) ) ; pos = i + 1 ; return res ; } } ByteArrayOutputStream out = new ByteArrayOutputStream ( end - pos + 80 ) { @ Override public String toString ( ) { int length = ( count > 0 && buf [ count - 1 ] == CR ) ? count - 1 : count ; try { return new String ( buf , 0 , length , charset . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( e ) ; } } } ; while ( true ) { out . write ( buf , pos , end - pos ) ; end = - 1 ; fillBuf ( ) ; for ( int i = pos ; i != end ; ++ i ) { if ( buf [ i ] == LF ) { if ( i != pos ) { out . write ( buf , pos , i - pos ) ; } pos = i + 1 ; return out . toString ( ) ; } } } } } 
public void addPropertyChangeListener ( String propertyName , PropertyChangeListener listener ) { if ( listener != null ) { synchronized ( this ) { if ( changeSupport == null ) { changeSupport = new PropertyChangeSupport ( this ) ; } changeSupport . addPropertyChangeListener ( propertyName , listener ) ; } } } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public Caret getCaret ( ) { checkWidget ( ) ; return caret ; } 
public void updateNonceParameters ( ) { if ( nextnonce . equals ( nonce ) ) { nc ++ ; } else { nc = 1 ; nonce = nextnonce ; } } 
public void addVariable ( VariableWrapper variable ) { fWorkingSet . add ( variable ) ; } 
public boolean matches ( ) { return match ( from , ENDANCHOR ) ; } 
public static void main ( String [ ] args ) { SimpleGraph graph = new SimpleGraph ( ) ; Hashtable table = GraphInput . LoadSimpleGraph ( graph ) ; BinaryHeap heap = new BinaryHeap ( ) ; Scanner reader = new Scanner ( System . in ) ; String origin , destination , repeat ; boolean again = true ; while ( again ) { System . out . println ( "Please-enter-the-name-of-the-starting-location:" ) ; origin = reader . nextLine ( ) ; System . out . println ( "Please-enter-the-name-of-the-destination:" ) ; destination = reader . nextLine ( ) ; initializeNodes ( graph , heap ) ; DijkstraNode start = ( DijkstraNode ) ( ( Vertex ) table . get ( origin ) ) . getData ( ) ; DijkstraNode finish = ( DijkstraNode ) ( ( Vertex ) table . get ( destination ) ) . getData ( ) ; dijkstra ( start , graph , heap ) ; printResults ( finish ) ; System . out . println ( "Would-you-like-to-go-again?-yes/no" ) ; repeat = reader . nextLine ( ) ; while ( ! repeat . equals ( "yes" ) && ! repeat . equals ( "no" ) ) { System . out . println ( "Invalid-input,-please-try-again." ) ; repeat = reader . nextLine ( ) ; } again = repeat . equals ( "yes" ) ; } } 
private void startView ( String view ) { String path = "../view/fxml/" + view + ".fxml" ; pop = new Popup ( ) ; final ProgressIndicator indicator = new ProgressIndicator ( ) ; pop . getContent ( ) . add ( indicator ) ; pop . show ( PrimaryStage . getInstance ( ) . getStage ( ) ) ; pop . centerOnScreen ( ) ; final Task < Parent > loadTask = new FXMLLoadTask ( path ) ; loadTask . stateProperty ( ) . addListener ( new ChangeListener < Worker . State > ( ) { @ Override public void changed ( ObservableValue < ? extends Worker . State > stateProp , Worker . State oldState , Worker . State newState ) { switch ( newState ) { case SCHEDULED : indicator . setProgress ( - 1 ) ; break ; case SUCCEEDED : setView ( loadTask . getValue ( ) ) ; break ; default : break ; } } } ) ; new Thread ( loadTask ) . start ( ) ; } 
public static final String getDefaultType ( ) { String dt = Security . getProperty ( PROPERTY_NAME ) ; return ( dt == null ? DEFAULT_KEYSTORE_TYPE : dt ) ; } 
public static URI makeFileLoggerURL ( File dataDir , File dataLogDir ) { return URI . create ( makeURIString ( dataDir . getPath ( ) , dataLogDir . getPath ( ) , null ) ) ; } 
public void setBump ( String bumpFlag ) { _bump = Boolean . parseBoolean ( bumpFlag ) ; } 
void logSyncAll ( ) { synchronized ( this ) { TransactionId id = myTransactionId . get ( ) ; id . txid = txid ; } logSync ( ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
static int doTest ( String testArguments , String expectedPattern ) { ProcessBuilder pb = new ProcessBuilder ( TestHelper . javaCmd , VersionStr , testArguments ) ; Map < String , String > env = pb . environment ( ) ; env . put ( "_JAVA_LAUNCHER_DEBUG" , "true" ) ; return doTest0 ( pb , testArguments ) ? 0 : 1 ; } 
public void sendAccessibilityEvent ( View host , int eventType ) { host . sendAccessibilityEventInternal ( eventType ) ; } 
public void runTo ( int index ) { if ( ! m_cacheNodes ) throw new RuntimeException ( XSLMessages . createXPATHMessage ( XPATHErrorResources . ER_NODESETDTM_CANNOT_INDEX , null ) ) ; if ( ( index >= 0 ) && ( m_next < m_firstFree ) ) m_next = index ; else m_next = m_firstFree - 1 ; } 
public String nextTo ( char delimiter ) throws JSONException { StringBuffer sb = new StringBuffer ( ) ; for ( ; ; ) { char c = next ( ) ; if ( c == delimiter || c == 0 || c == '|n' || c == '|r' ) { if ( c != 0 ) { back ( ) ; } return sb . toString ( ) . trim ( ) ; } sb . append ( c ) ; } } 
public String toString ( ) { return ( "" + proxyIP . getHostName ( ) + ":" + proxyPort + "-Version-" + version ) ; } 
public static void dumpCurrentRow ( Cursor cursor , PrintStream stream ) { String [ ] cols = cursor . getColumnNames ( ) ; stream . println ( "" + cursor . getPosition ( ) + "-{" ) ; int length = cols . length ; for ( int i = 0 ; i < length ; i ++ ) { String value ; try { value = cursor . getString ( i ) ; } catch ( SQLiteException e ) { value = "<unprintable>" ; } stream . println ( "-" + cols [ i ] + '=' + value ) ; } stream . println ( "}" ) ; } 
public synchronized void removeTextListener ( TextListener cl ) { m_textListeners . remove ( cl ) ; } 
static public double j1 ( double x ) throws ArithmeticException { double ax ; double y ; double ans1 , ans2 ; if ( ( ax = Math . abs ( x ) ) < 8.0 ) { y = x * x ; ans1 = x * ( 72362614232.0 + y * ( - 7895059235.0 + y * ( 242396853.1 + y * ( - 2972611.439 + y * ( 15704.48260 + y * ( - 30.16036606 ) ) ) ) ) ) ; ans2 = 144725228442.0 + y * ( 2300535178.0 + y * ( 18583304.74 + y * ( 99447.43394 + y * ( 376.9991397 + y * 1.0 ) ) ) ) ; return ans1 / ans2 ; } else { double z = 8.0 / ax ; double xx = ax - 2.356194491 ; y = z * z ; ans1 = 1.0 + y * ( 0.183105e-2 + y * ( - 0.3516396496e-4 + y * ( 0.2457520174e-5 + y * ( - 0.240337019e-6 ) ) ) ) ; ans2 = 0.04687499995 + y * ( - 0.2002690873e-3 + y * ( 0.8449199096e-5 + y * ( - 0.88228987e-6 + y * 0.105787412e-6 ) ) ) ; double ans = Math . sqrt ( 0.636619772 / ax ) * ( Math . cos ( xx ) * ans1 - z * Math . sin ( xx ) * ans2 ) ; if ( x < 0.0 ) ans = - ans ; return ans ; } } 
private static String sanitize ( String inputString ) { String result = "" ; for ( int i = 0 ; i < inputString . length ( ) ; i ++ ) { if ( Character . toUpperCase ( inputString . charAt ( i ) ) >= 'A' && Character . toUpperCase ( inputString . charAt ( i ) ) <= 'Z' ) { result += inputString . charAt ( i ) ; } } return result ; } 
@ Override public String toScript ( ) { return super . toScript ( ) + ",-" + croots . toString ( ) ; } 
public static String format ( Date value ) { return STANDARD_DATE_FORMAT . get ( ) . format ( value ) ; } 
public void clear ( ) { Arrays . fill ( ritems , 0 , rsize , null ) ; Arrays . fill ( pitems , 0 , psize , null ) ; rsize = 0 ; psize = 0 ; } 
private ScannerConfigProfileManager ( ) { projectToProfileInstanceMap = new HashMap < IProject , Map < InfoContext , Object >> ( ) ; } 
public void remove ( String key ) { urlParams . remove ( key ) ; urlParamsWithArray . remove ( key ) ; } 
protected String signedValue ( int value ) { return String . valueOf ( value ) ; } 
private static String convertFBXString ( String string ) { return string . replaceAll ( " " , "::" ) ; } 
public Range getDataRange ( ValueAxis axis ) { Range result = null ; int axisIdx = getAxisIndex ( axis ) ; List mappedDatasets = new ArrayList ( ) ; if ( axisIdx >= 0 ) { mappedDatasets = getDatasetsMappedToAxis ( new Integer ( axisIdx ) ) ; } Iterator iterator = mappedDatasets . iterator ( ) ; int datasetIdx = - 1 ; while ( iterator . hasNext ( ) ) { datasetIdx ++ ; XYDataset d = ( XYDataset ) iterator . next ( ) ; if ( d != null ) { result = Range . combine ( result , DatasetUtilities . findRangeBounds ( d ) ) ; } } return result ; } 
public static Object decodeToObject ( String encodedObject ) { byte [ ] objBytes = decode ( encodedObject ) ; java . io . ByteArrayInputStream bais = null ; java . io . ObjectInputStream ois = null ; Object obj = null ; try { bais = new java . io . ByteArrayInputStream ( objBytes ) ; ois = new java . io . ObjectInputStream ( bais ) ; obj = ois . readObject ( ) ; } catch ( java . io . IOException e ) { logger . error ( Logger . SECURITY_FAILURE , "Problem-reading-object" , e ) ; obj = null ; } catch ( java . lang . ClassNotFoundException e ) { logger . error ( Logger . SECURITY_FAILURE , "Problem-reading-object" , e ) ; obj = null ; } finally { try { bais . close ( ) ; } catch ( Exception e ) { } try { ois . close ( ) ; } catch ( Exception e ) { } } return obj ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public static boolean bernoulli ( ) { return bernoulli ( 0.5 ) ; } 
public Repository editRepository ( IRepositoryIdProvider provider , Map < String , Object > fields ) throws IOException { String id = getId ( provider ) ; if ( fields == null ) throw new IllegalArgumentException ( "Fields-cannot-be-null" ) ; StringBuilder uri = new StringBuilder ( SEGMENT_REPOS ) ; uri . append ( '/' ) . append ( id ) ; return client . post ( uri . toString ( ) , fields , Repository . class ) ; } 
public ItemStack [ ] getItems ( int tier ) { List < ItemStack > items = new ArrayList < ItemStack > ( ) ; for ( Entry < Integer , ItemStack [ ] > e : this . items . entrySet ( ) ) { if ( ( tier & e . getKey ( ) ) == e . getKey ( ) ) items . addAll ( Arrays . asList ( e . getValue ( ) ) ) ; } return items . toArray ( new ItemStack [ items . size ( ) ] ) ; } 
public final CertPathBuilderResult build ( CertPathParameters params ) throws CertPathBuilderException , InvalidAlgorithmParameterException { return builderSpi . engineBuild ( params ) ; } 
@ Override public synchronized void reset ( ) throws IOException { in . reset ( ) ; } 
public static String decode ( byte [ ] utf8 ) throws CharacterCodingException { return decode ( ByteBuffer . wrap ( utf8 ) , true ) ; } 
protected Point getTreeMousePoint ( int column , MouseEvent me ) { return new Point ( me . getX ( ) - getCellRect ( 0 , column , false ) . x , me . getY ( ) ) ; } 
private void safeDamageRange ( final Position p0 , final Position p1 ) { safeDamager . damageRange ( p0 , p1 ) ; } 
public ArrayList < Habitacion > retHabitacionesConServiciosEnHotel ( ArrayList < DeHotel > s , ArrayList < Habitacion > hab ) { ArrayList < Habitacion > ret = new ArrayList < Habitacion > ( ) ; for ( Habitacion h : hab ) { if ( h . getHotel ( ) . getServiciosDeHotel ( ) . contains ( s ) ) { ret . add ( h ) ; } } return ret ; } 
protected void insertTextContent ( StringBuffer buf ) throws DOMException { String content = getNodeValue ( ) ; if ( content != null ) { buf . insert ( 0 , content ) ; } } 
private boolean defaultResolve ( ) { switch ( typeString . charAt ( 0 ) ) { case 'I' : type = Integer . TYPE ; return true ; case 'B' : type = Byte . TYPE ; return true ; case 'C' : type = Character . TYPE ; return true ; case 'S' : type = Short . TYPE ; return true ; case 'Z' : type = Boolean . TYPE ; return true ; case 'J' : type = Long . TYPE ; return true ; case 'F' : type = Float . TYPE ; return true ; case 'D' : type = Double . TYPE ; return true ; default : type = Object . class ; return false ; } } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public String toString ( ) { return name . toString ( ) ; } 
public static void write ( String data , Writer output ) throws IOException { if ( data != null ) { output . write ( data ) ; } } 
public static void main ( String [ ] args ) throws Exception { File folder = new File ( "D:/pdt_data/decompressed/" ) ; File [ ] files = folder . listFiles ( ) ; File outF = new File ( "D:/pdt_data/output/output.sql" ) ; if ( ! outF . exists ( ) ) { outF . createNewFile ( ) ; } int count = 0 ; BufferedReader in = null ; BufferedWriter out = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( outF ) , "windows-1250" ) ) ; for ( File f : files ) { in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( f ) , "windows-1250" ) ) ; String buffer = getContent ( in ) ; List < Entry > entries = generateSQL ( buffer ) ; for ( Entry e : entries ) { out . append ( e . toString ( ) ) ; } in . close ( ) ; ++ count ; if ( count % 50 == 0 ) { outF = new File ( "D:/pdt_data/output/output" + count / 50 + ".sql" ) ; if ( ! outF . exists ( ) ) { outF . createNewFile ( ) ; } out . flush ( ) ; out . close ( ) ; out = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( outF ) , "windows-1250" ) ) ; } } out . flush ( ) ; out . close ( ) ; } 
public void setPrimaryAddressCity ( JAXBElement < String > value ) { this . primaryAddressCity = ( ( JAXBElement < String > ) value ) ; } 
public JTextArea createTextArea ( String uiKey , JLabel label ) { JTextArea t = new JTextArea ( ) { public Dimension getPreferredScrollableViewportSize ( ) { return new Dimension ( 100 , 100 ) ; } } ; t . setName ( uiKey ) ; if ( label != null ) label . setLabelFor ( t ) ; else setAccessibleName ( t , uiKey ) ; setToolTip ( t , uiKey ) ; return t ; } 
@ SuppressWarnings ( "unchecked" ) public static List < Camera . Size > getSupportedPreviewSizes ( Camera . Parameters params ) { List < Camera . Size > retList = null ; try { Object retObj = mParameters_getSupportedPreviewSizes . invoke ( params ) ; if ( retObj != null ) { retList = ( List < Camera . Size > ) retObj ; } } catch ( InvocationTargetException ite ) { Throwable cause = ite . getCause ( ) ; if ( cause instanceof RuntimeException ) { throw ( RuntimeException ) cause ; } else if ( cause instanceof Error ) { throw ( Error ) cause ; } else { throw new RuntimeException ( ite ) ; } } catch ( IllegalAccessException ie ) { } return retList ; } 
@ Override public void setup ( Context context ) throws IOException , InterruptedException { conf = context . getConfiguration ( ) ; syncFolders = conf . getBoolean ( DistCpOptionSwitch . SYNC_FOLDERS . getConfigLabel ( ) , false ) ; ignoreFailures = conf . getBoolean ( DistCpOptionSwitch . IGNORE_FAILURES . getConfigLabel ( ) , false ) ; skipCrc = conf . getBoolean ( DistCpOptionSwitch . SKIP_CRC . getConfigLabel ( ) , false ) ; overWrite = conf . getBoolean ( DistCpOptionSwitch . OVERWRITE . getConfigLabel ( ) , false ) ; preserve = DistCpUtils . unpackAttributes ( conf . get ( DistCpOptionSwitch . PRESERVE_STATUS . getConfigLabel ( ) ) ) ; targetWorkPath = new Path ( conf . get ( DistCpConstants . CONF_LABEL_TARGET_WORK_PATH ) ) ; Path targetFinalPath = new Path ( conf . get ( DistCpConstants . CONF_LABEL_TARGET_FINAL_PATH ) ) ; targetFS = targetFinalPath . getFileSystem ( conf ) ; if ( targetFS . exists ( targetFinalPath ) && targetFS . isFile ( targetFinalPath ) ) { overWrite = true ; } if ( conf . get ( DistCpConstants . CONF_LABEL_SSL_CONF ) != null ) { initializeSSLConf ( context ) ; } } 
protected void split ( Stack < DistanceNode > point_set , Stack < DistanceNode > far_set , int max_scale ) { int new_index = 0 ; double fmax = dist_of_scale ( max_scale ) ; for ( int i = 0 ; i < point_set . length ; i ++ ) { DistanceNode n = point_set . element ( i ) ; if ( n . dist . element ( n . dist . length - 1 ) . doubleValue ( ) <= fmax ) { point_set . set ( new_index ++ , point_set . element ( i ) ) ; } else far_set . push ( point_set . element ( i ) ) ; } List < DistanceNode > l = new java . util . LinkedList < DistanceNode > ( ) ; for ( int i = 0 ; i < new_index ; i ++ ) l . add ( point_set . element ( i ) ) ; point_set . clear ( ) ; point_set . addAll ( l ) ; } 
int size ( ) { return Integer . bitCount ( set ) ; } 
XSLTAttributeDef ( String namespace , String name , boolean required , boolean supportsAVT , boolean prefixedQNameValAllowed , int errorType , String k1 , int v1 , String k2 , int v2 ) { this . m_namespace = namespace ; this . m_name = name ; this . m_type = prefixedQNameValAllowed ? this . T_ENUM_OR_PQNAME : this . T_ENUM ; this . m_required = required ; this . m_supportsAVT = supportsAVT ; this . m_errorType = errorType ; m_enums = new StringToIntTable ( 2 ) ; m_enums . put ( k1 , v1 ) ; m_enums . put ( k2 , v2 ) ; } 
public final synchronized String [ ] getCatalogList ( ) { return ( fCatalogsList != null ) ? ( String [ ] ) fCatalogsList . clone ( ) : null ; } 
public static void executeInsertDeleteQuery ( String user , String message , String graphName , String revision , String triplesInsert , String triplesDelete ) throws InternalErrorException { String query = String . format ( "USER-"%s"-%n" + "MESSAGE-"%s"-%n" + "INSERT-DATA-{-GRAPH-<%s>-REVISION-"%s"-%n" + "-{-%n" + "-%s-%n" + "-}-%n" + "}-;-%n" + "DELETE-DATA-{-GRAPH-<%s>-REVISION-"%s"-%n" + "-{-%n" + "-%s-%n" + "-}-%n" + "}" , user , message , graphName , revision , triplesInsert , graphName , revision , triplesDelete ) ; ep . sparql ( MediaType . TEXT_HTML , query ) ; } 
protected void addOption ( Option opt ) { options . add ( opt ) ; } 
public static Long getCurrentTimeInMillis ( ) { Calendar cal = Calendar . getInstance ( TimeZone . getTimeZone ( "GMT" ) ) ; return cal . getTimeInMillis ( ) ; } 
public void writeLine ( String s , String sensitiveReplacement ) throws IOException { if ( Config . LOGD && Email . DEBUG ) { if ( sensitiveReplacement != null && ! Email . DEBUG_SENSITIVE ) { Log . d ( Email . LOG_TAG , ">>>-" + sensitiveReplacement ) ; } else { Log . d ( Email . LOG_TAG , ">>>-" + s ) ; } } OutputStream out = getOutputStream ( ) ; out . write ( s . getBytes ( ) ) ; out . write ( '|r' ) ; out . write ( '|n' ) ; out . flush ( ) ; } 
@ Override public void seekTo ( long msec ) throws IllegalStateException { Log . d ( TAG , "seekTo()" ) ; if ( mPreparedQuery != null && ! TomahawkApp . PLUGINNAME_BEATSMUSIC . equals ( mPreparedQuery . getPreferredTrackResult ( ) . getResolvedBy ( ) . getId ( ) ) ) { getMediaPlayerInstance ( ) . setTime ( msec ) ; } } 
public void addIssuerSerial ( String X509IssuerName , BigInteger X509SerialNumber ) { this . add ( new XMLX509IssuerSerial ( this . doc , X509IssuerName , X509SerialNumber ) ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public Collection < ? > getOverrides ( ) { List < Object > r = new ArrayList < Object > ( ) ; for ( JobProperty < ? super JobT > p : properties ) r . addAll ( p . getJobOverrides ( ) ) ; return r ; } 
private JTextField getFqCodeTextField ( ) { if ( fqCodeTextField == null ) { fqCodeTextField = new JTextField ( ) ; fqCodeTextField . setBounds ( new Rectangle ( 160 , 79 , 250 , 20 ) ) ; fqCodeTextField . setText ( fqCode ) ; } return fqCodeTextField ; } 
private String getString ( int cursorIndex , int position ) { if ( position < mExtraOffset || position > mCount ) { return "" ; } mCursor . moveToPosition ( position - mExtraOffset ) ; return mCursor . getString ( cursorIndex ) ; } 
private HashtableEntry < K , V > [ ] makeTable ( int newCapacity ) { @ SuppressWarnings ( "unchecked" ) HashtableEntry < K , V > [ ] newTable = ( HashtableEntry < K , V > [ ] ) new HashtableEntry [ newCapacity ] ; table = newTable ; threshold = ( newCapacity >> 1 ) + ( newCapacity >> 2 ) ; return newTable ; } 
public Future < UpdateDefaultSearchFieldResult > updateDefaultSearchFieldAsync ( final UpdateDefaultSearchFieldRequest updateDefaultSearchFieldRequest , final AsyncHandler < UpdateDefaultSearchFieldRequest , UpdateDefaultSearchFieldResult > asyncHandler ) throws AmazonServiceException , AmazonClientException { return executorService . submit ( new Callable < UpdateDefaultSearchFieldResult > ( ) { public UpdateDefaultSearchFieldResult call ( ) throws Exception { UpdateDefaultSearchFieldResult result ; try { result = updateDefaultSearchField ( updateDefaultSearchFieldRequest ) ; } catch ( Exception ex ) { asyncHandler . onError ( ex ) ; throw ex ; } asyncHandler . onSuccess ( updateDefaultSearchFieldRequest , result ) ; return result ; } } ) ; } 
protected void appendDetail ( StringBuffer buffer , String fieldName , Object [ ] array ) { buffer . append ( arrayStart ) ; for ( int i = 0 ; i < array . length ; i ++ ) { Object item = array [ i ] ; if ( i > 0 ) { buffer . append ( arraySeparator ) ; } if ( item == null ) { appendNullText ( buffer , fieldName ) ; } else { appendInternal ( buffer , fieldName , item , arrayContentDetail ) ; } } buffer . append ( arrayEnd ) ; } 
public int getGridLineWidth ( ) { checkWidget ( ) ; return 0 ; } 
private void readLanguagesFile ( ) { File file = new File ( Utils . getClassPath ( ) + File . separator + "files" + File . separator + LANGUAGES_FILE_NAME ) ; System . out . println ( Utils . getClassPath ( ) + File . separator + "files" + File . separator + LANGUAGES_FILE_NAME ) ; try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; Document doc = db . parse ( file ) ; NodeList nList = doc . getElementsByTagName ( "language" ) ; number_of_languages = nList . getLength ( ) ; for ( int temp = 0 ; temp < nList . getLength ( ) ; temp ++ ) { Node nNode = nList . item ( temp ) ; if ( nNode . getNodeType ( ) == Node . ELEMENT_NODE ) { Element eElement = ( Element ) nNode ; int index = Integer . parseInt ( eElement . getAttribute ( "id" ) ) ; languages_names . add ( index , eElement . getTextContent ( ) ) ; } } } catch ( Exception e ) { JOptionPane . showMessageDialog ( new JFrame ( ) , "Unable-to-load-" + LANGUAGES_FILE_NAME + "." , "Error" , JOptionPane . ERROR_MESSAGE ) ; System . exit ( 0 ) ; } } 
public Complex sub ( Complex b ) { return new Complex ( re - b . re , im - b . im ) ; } 
@ XmlElementDecl ( namespace = "http://ws.chapter7.bpmnwithactiviti.org/" , name = "findCustomerById" ) public JAXBElement < FindCustomerById > createFindCustomerById ( FindCustomerById value ) { return new JAXBElement < FindCustomerById > ( _FindCustomerById_QNAME , FindCustomerById . class , null , value ) ; } 
public static void remove ( long [ ] array , int size , int index ) { System . arraycopy ( array , index + 1 , array , index , array . length - index - 1 ) ; array [ size - 1 ] = 0 ; } 
Item newConstItem ( final Object cst ) { if ( cst instanceof Integer ) { int val = ( ( Integer ) cst ) . intValue ( ) ; return newInteger ( val ) ; } else if ( cst instanceof String ) { return newString ( ( String ) cst ) ; } else if ( cst instanceof Type ) { Type t = ( Type ) cst ; return newClassItem ( t . getSort ( ) == Type . OBJECT ? t . getInternalName ( ) : t . getDescriptor ( ) ) ; } else { throw new IllegalArgumentException ( "value-" + cst ) ; } } 
public URI getURI ( ) { String s = func_50088_a ( ) ; if ( s == null ) { return null ; } Matcher matcher = pattern . matcher ( s ) ; if ( matcher . matches ( ) ) { try { String s1 = matcher . group ( 0 ) ; if ( matcher . group ( 1 ) == null ) { s1 = ( new StringBuilder ( ) ) . append ( "http://" ) . append ( s1 ) . toString ( ) ; } return new URI ( s1 ) ; } catch ( URISyntaxException urisyntaxexception ) { Logger . getLogger ( "Minecraft" ) . log ( Level . SEVERE , "Couldn't-create-URI-from-chat" , urisyntaxexception ) ; } } return null ; } 
public void addUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { mUpdateListeners = new ArrayList < AnimatorUpdateListener > ( ) ; } mUpdateListeners . add ( listener ) ; } 
public void addParticipantListener ( PacketListener listener ) { connection . addPacketListener ( listener , presenceFilter ) ; connectionListeners . add ( listener ) ; } 
public Builder setItems ( String [ ] items , DialogInterface . OnClickListener listener ) { this . mListStyle = EasyDialog . LIST_STYLE_LISTVIEW ; this . mOnItemClickListener = listener ; this . mListItems = new ArrayList < ListItem > ( ) ; for ( String label : items ) { this . mListItems . add ( new ListItem ( label ) ) ; } return this ; } 
public boolean offerFirst ( E e ) { addFirst ( e ) ; return true ; } 
private void calcXValAverageLength ( ) { if ( mXVals . size ( ) <= 0 ) { mXValAverageLength = 1 ; return ; } float sum = 1f ; for ( int i = 0 ; i < mXVals . size ( ) ; i ++ ) { sum += mXVals . get ( i ) . length ( ) ; } mXValAverageLength = sum / ( float ) mXVals . size ( ) ; } 
public XMLSignatureInput getReferencedContentAfterTransformsItem ( int i ) throws XMLSecurityException { return this . item ( i ) . getContentsAfterTransformation ( ) ; } 
public void error ( int error ) throws RemoteException { Message . obtain ( mHandler , MSG_RESET ) . sendToTarget ( ) ; mListener . onError ( error ) ; } 
private void ensureCapacity ( int n ) { if ( n > 0 && ( data == null || data . length == 0 ) ) { data = new String [ 25 ] ; } int max = data . length ; if ( max >= n * 5 ) { return ; } while ( max < n * 5 ) { max *= 2 ; } String newData [ ] = new String [ max ] ; System . arraycopy ( data , 0 , newData , 0 , length * 5 ) ; data = newData ; } 
protected void addComponent ( XMLComponent component ) { if ( fComponents . contains ( component ) ) { return ; } fComponents . add ( component ) ; addRecognizedParamsAndSetDefaults ( component ) ; } 
public static Element create ( ) { com . google . gwt . user . client . Element span = DOM . createSpan ( ) ; span . setAttribute ( "type" , "refItemsComplexType" ) ; span . setAttribute ( "ns" , "http://docs.oasis-open.org/legaldocml/ns/akn/3.0/CSD02" ) ; span . setClassName ( "widget-refItemsComplexType" ) ; return span ; } 
public List < NewHireEmployeeType > getNewHireEmployee ( ) { if ( newHireEmployee == null ) { newHireEmployee = new ArrayList < NewHireEmployeeType > ( ) ; } return this . newHireEmployee ; } 
public int isNullable ( int column ) throws SQLException { if ( ! getField ( column ) . isNotNull ( ) ) { return java . sql . ResultSetMetaData . columnNullable ; } return java . sql . ResultSetMetaData . columnNoNulls ; } 
public final String getMatchesNodeName ( ) { return pattern . getMatchesNodeName ( ) ; } 
private void insertElementAt ( int value , int at ) { if ( at == m_firstFree ) addElement ( value ) ; else if ( at > m_firstFree ) { int index = at >>> m_SHIFT ; if ( index >= m_map . length ) { int newsize = index + m_numblocks ; int [ ] [ ] newMap = new int [ newsize ] [ ] ; System . arraycopy ( m_map , 0 , newMap , 0 , m_map . length ) ; m_map = newMap ; } int [ ] block = m_map [ index ] ; if ( null == block ) block = m_map [ index ] = new int [ m_blocksize ] ; int offset = at & m_MASK ; block [ offset ] = value ; m_firstFree = offset + 1 ; } else { int index = at >>> m_SHIFT ; int maxindex = m_firstFree >>> m_SHIFT ; ++ m_firstFree ; int offset = at & m_MASK ; int push ; while ( index <= maxindex ) { int copylen = m_blocksize - offset - 1 ; int [ ] block = m_map [ index ] ; if ( null == block ) { push = 0 ; block = m_map [ index ] = new int [ m_blocksize ] ; } else { push = block [ m_blocksize - 1 ] ; System . arraycopy ( block , offset , block , offset + 1 , copylen ) ; } block [ offset ] = value ; value = push ; offset = 0 ; ++ index ; } } } 
public JSONObject put ( String name , Object value ) throws JSONException { if ( value == null ) { nameValuePairs . remove ( name ) ; return this ; } if ( value instanceof Number ) { JSON . checkDouble ( ( ( Number ) value ) . doubleValue ( ) ) ; } nameValuePairs . put ( checkName ( name ) , value ) ; return this ; } 
protected Attribute read ( final ClassReader cr , final int off , final int len , final char [ ] buf , final int codeOff , final Label [ ] labels ) { Attribute attr = new Attribute ( type ) ; attr . value = new byte [ len ] ; System . arraycopy ( cr . b , off , attr . value , 0 , len ) ; return attr ; } 
private Path getPath ( ) { Path path = new Path ( ) ; boolean firstIter = true ; if ( ! points . isEmpty ( ) ) { for ( Point iter : points ) { if ( firstIter ) { path . moveTo ( iter . getX ( ) , iter . getY ( ) ) ; firstIter = false ; } else { path . lineTo ( iter . getX ( ) , iter . getY ( ) ) ; } } path . lineTo ( points . get ( 0 ) . getX ( ) , points . get ( 0 ) . getY ( ) ) ; } return path ; } 
public void setEmail ( String email ) { this . email = email == null ? null : email . trim ( ) ; } 
static long getSessionIdForBlobId ( final LocalyticsProvider provider , final long blobId ) { long eventId ; { Cursor cursor = null ; try { cursor = provider . query ( UploadBlobEventsDbColumns . TABLE_NAME , new String [ ] { UploadBlobEventsDbColumns . EVENTS_KEY_REF } , String . format ( "%s-=-?" , UploadBlobEventsDbColumns . UPLOAD_BLOBS_KEY_REF ) , new String [ ] { Long . toString ( blobId ) } , null ) ; if ( cursor . moveToFirst ( ) ) { eventId = cursor . getLong ( cursor . getColumnIndexOrThrow ( UploadBlobEventsDbColumns . EVENTS_KEY_REF ) ) ; } else { throw new RuntimeException ( "No-events-associated-with-blob" ) ; } } finally { if ( null != cursor ) { cursor . close ( ) ; cursor = null ; } } } long sessionId ; { Cursor cursor = null ; try { cursor = provider . query ( EventsDbColumns . TABLE_NAME , new String [ ] { EventsDbColumns . SESSION_KEY_REF } , String . format ( "%s-=-?" , EventsDbColumns . _ID ) , new String [ ] { Long . toString ( eventId ) } , null ) ; if ( cursor . moveToFirst ( ) ) { sessionId = cursor . getLong ( cursor . getColumnIndexOrThrow ( EventsDbColumns . SESSION_KEY_REF ) ) ; } else { throw new RuntimeException ( "No-session-associated-with-event" ) ; } } finally { if ( null != cursor ) { cursor . close ( ) ; cursor = null ; } } } return sessionId ; } 
private void info ( String msg ) { if ( logLevel . intValue ( ) <= Level . INFO . intValue ( ) ) { println ( Level . INFO , msg ) ; } } 
public static Date parseDate ( String dateValue ) throws DateParseException { return parseDate ( dateValue , null ) ; } 
public void copyGraph ( Graph graph ) { assert ( ( nodes . isEmpty ( ) ) && ( edges . isEmpty ( ) ) ) ; for ( graph . startNodeIterator ( ) ; graph . hasMoreNodes ( ) ; ) { addNode ( graph . nextNode ( ) ) ; } for ( graph . startEdgeIterator ( ) ; graph . hasMoreEdges ( ) ; ) { addEdge ( graph . nextEdge ( ) ) ; } setInitialNode ( graph . getInitialNode ( ) ) ; setFinalNode ( graph . getFinalNode ( ) ) ; } 
public int hashCode ( ) { return _name . hashCode ( ) ; } 
protected void addSanitizedEntry ( String parameter , String value ) { mEntriesList . add ( new ParameterValuePair ( parameter , value ) ) ; if ( mPreferFirstRepeatedParameter ) { if ( mEntries . containsKey ( parameter ) ) { return ; } } mEntries . put ( parameter , value ) ; } 
protected void drain ( ) throws IOException { bout . drain ( ) ; } 
public void recycle ( Connection connection ) { if ( connection . isSpdy ( ) ) { return ; } if ( ! connection . isAlive ( ) ) { Util . closeQuietly ( connection ) ; return ; } try { Platform . get ( ) . untagSocket ( connection . getSocket ( ) ) ; } catch ( SocketException e ) { Platform . get ( ) . logW ( "Unable-to-untagSocket():-" + e ) ; Util . closeQuietly ( connection ) ; return ; } synchronized ( this ) { connections . addFirst ( connection ) ; connection . resetIdleStartTime ( ) ; } executorService . submit ( connectionsCleanupCallable ) ; } 
public static void closeQuietly ( Reader stream ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( Throwable ex ) { } } } 
@ Override public void updateUI ( ) { super . updateUI ( ) ; TreeCellRenderer tcr = getCellRenderer ( ) ; if ( tcr instanceof DefaultTreeCellRenderer ) { DefaultTreeCellRenderer dtcr = ( ( DefaultTreeCellRenderer ) tcr ) ; dtcr . setTextSelectionColor ( UIManager . getColor ( "Table.focusCellForeground" ) ) ; dtcr . setBackgroundSelectionColor ( UIManager . getColor ( "Table.focusCellBackground" ) ) ; dtcr . setBackground ( UIManager . getColor ( "Table.background" ) ) ; dtcr . setForeground ( UIManager . getColor ( "Table.foreground" ) ) ; } } 
public Block [ ] getBlocksBeingWrittenReport ( ) { TreeSet < Block > blockSet = new TreeSet < Block > ( ) ; volumes . getBlocksBeingWrittenInfo ( blockSet ) ; Block blockTable [ ] = new Block [ blockSet . size ( ) ] ; int i = 0 ; for ( Iterator < Block > it = blockSet . iterator ( ) ; it . hasNext ( ) ; i ++ ) { blockTable [ i ] = it . next ( ) ; } return blockTable ; } 
public static Annotation makeThrows ( TypeList types ) { CstArray array = makeCstArray ( types ) ; Annotation result = new Annotation ( THROWS_TYPE , SYSTEM ) ; result . put ( new NameValuePair ( VALUE_UTF , array ) ) ; result . setImmutable ( ) ; return result ; } 
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj instanceof ECFieldF2m ) { ECFieldF2m o = ( ECFieldF2m ) obj ; if ( this . m == o . m ) { if ( this . rp == null ) { if ( o . rp == null ) { return true ; } } else { return Arrays . equals ( this . ks , o . ks ) ; } } } return false ; } 
public boolean buildDatabase ( Connection con ) { try { boolean engine = useEngine ( con ) ; if ( engine ) { logger . debug ( "mysql-version-is-4-or-greater-switching-INNODB-from-TYPE-to-ENGINE" ) ; } String [ ] sarr = getStatements ( mysqldb ) ; Statement st = con . createStatement ( ) ; int i = 0 ; System . out . print ( "Building-Tables..." ) ; for ( String s : sarr ) { if ( s . trim ( ) . length ( ) > 0 ) { if ( engine ) s = s . replaceAll ( "TYPE=INNODB" , "ENGINE=INNODB" ) ; i += st . executeUpdate ( s ) ; System . out . print ( "." ) ; } } st . close ( ) ; System . out . println ( ) ; logger . debug ( sarr . length + "-queries-run,-" + i + "-issues-" ) ; return true ; } catch ( SQLException sexe ) { logger . error ( "Failed-to-build-bioSQL-Table" , sexe ) ; return false ; } catch ( Exception e ) { logger . error ( "Failed-to-build-bioSQL-Table" , e ) ; return false ; } } 
public void notifyAddOnFailedUninstallation ( final AddOn addOn ) { if ( EventQueue . isDispatchThread ( ) ) { installedAddOnsModel . notifyAddOnFailedUninstallation ( addOn ) ; } else { EventQueue . invokeLater ( new Runnable ( ) { @ Override public void run ( ) { notifyAddOnFailedUninstallation ( addOn ) ; } } ) ; } } 
private void waitForTime ( ) { for ( long start = System . currentTimeMillis ( ) ; System . currentTimeMillis ( ) - start < CLOCK_MAX_WAIT_MILLIS ; ) { if ( currentClockMessage != null ) { return ; } long remainingMs = CLOCK_MAX_WAIT_MILLIS - ( System . currentTimeMillis ( ) - start ) ; Log . i ( ROSTimer . class . getSimpleName ( ) + "-waiting-for-clock-to-be-published-" + remainingMs + "ms-remaining" ) ; try { Thread . sleep ( 250 ) ; } catch ( Exception e ) { } } throw new RuntimeException ( "Time-limit-exceeded-waiting-for-clock-to-be-published-by-ROS" ) ; } 
public long getAndAdd ( T obj , long delta ) { for ( ; ; ) { long current = get ( obj ) ; long next = current + delta ; if ( compareAndSet ( obj , current , next ) ) return current ; } } 
public static boolean isShorthandOnSFXInstBlacklist ( String shorthand , int source ) { for ( String s : sources . get ( source ) . sfxBlackListShorthands ) { if ( s . equals ( shorthand ) ) { return true ; } } return false ; } 
public static < K , V > HashMap < K , V > newHashMap ( ) { return new HashMap < K , V > ( ) ; } 
public URL ( String protocol , String host , int port , String file , URLStreamHandler handler ) throws MalformedURLException { protocol = protocol . toLowerCase ( ) ; this . protocol = protocol ; if ( host != null ) { if ( host . indexOf ( ':' ) >= 0 && ! host . startsWith ( "[" ) ) { host = "[" + host + "]" ; } this . host = host ; if ( port < - 1 ) { throw new MalformedURLException ( "Invalid-port-number-:" + port ) ; } this . port = port ; authority = ( port == - 1 ) ? host : host + ":" + port ; } Parts parts = new Parts ( file ) ; path = parts . getPath ( ) ; query = parts . getQuery ( ) ; if ( query != null ) { this . file = path + "?" + query ; } else { this . file = path ; } ref = parts . getRef ( ) ; if ( handler == null && ( handler = getURLStreamHandler ( protocol ) ) == null ) { throw new MalformedURLException ( "unknown-protocol:-" + protocol ) ; } this . handler = handler ; } 
private void writeObject ( ObjectOutputStream s ) throws IOException { s . defaultWriteObject ( ) ; if ( getUIClassID ( ) . equals ( uiClassID ) ) { byte count = JComponent . getWriteObjCounter ( this ) ; JComponent . setWriteObjCounter ( this , -- count ) ; if ( count == 0 && ui != null ) { ui . installUI ( this ) ; } } } 
public static void toMagnitude ( double [ ] re ) { for ( int i = 0 ; i < re . length ; i ++ ) { re [ i ] = Math . sqrt ( re [ i ] ) ; } } 
public static void sortNexusList ( @ NonNull List < Device > list ) { Collections . sort ( list , new Comparator < Device > ( ) { @ Override public int compare ( Device device1 , Device device2 ) { return nexusRank ( device2 ) - nexusRank ( device1 ) ; } } ) ; } 
public WiiUseApiListener [ ] getWiiUseApiListeners ( ) { return listeners . getListeners ( WiiUseApiListener . class ) ; } 
public void remove ( IEditorIconFactory editorIconFactory ) { pageIcons . remove ( editorIconFactory ) ; } 
private static void createFile ( final String path ) throws Exception { File file = new File ( path ) ; try { if ( ! file . createNewFile ( ) ) { throw new Exception ( "Failed-to-create-file:-" + file . getAbsolutePath ( ) ) ; } } catch ( IOException ioe ) { throw new IOException ( "Failed-to-create-file:-" + file . getAbsolutePath ( ) , ioe ) ; } } 
public void propertyChange ( PropertyChangeEvent evt ) { if ( evt . getPropertyName ( ) . equals ( "day" ) ) { if ( popup . isVisible ( ) ) { dateSelected = true ; popup . setVisible ( false ) ; setDate ( jcalendar . getCalendar ( ) . getTime ( ) ) ; } } else if ( evt . getPropertyName ( ) . equals ( "date" ) ) { if ( evt . getSource ( ) == dateEditor ) { firePropertyChange ( "date" , evt . getOldValue ( ) , evt . getNewValue ( ) ) ; } else { setDate ( ( Date ) evt . getNewValue ( ) ) ; } } } 
public boolean isSynthetic ( ) { int modifiers = getMethodModifiers ( declaringClass , slot ) ; return ( modifiers & Modifier . SYNTHETIC ) != 0 ; } 
public static void lowLevelReboot ( String reason ) { if ( reason == null ) { reason = "" ; } SystemProperties . set ( "sys.powerctl" , "reboot," + reason ) ; try { Thread . sleep ( 20000 ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } 
public void setup ( Looper looper , Callback callback , int style ) { mHandler = new Handler ( looper , this ) ; mCallback = callback ; mCoverStyle = style ; } 
public void addPropertyChangeListener ( PropertyChangeListener listener ) { if ( changeSupport == null ) { changeSupport = new PropertyChangeSupport ( this ) ; } changeSupport . addPropertyChangeListener ( listener ) ; } 
public DateTimeFormatterBuilder appendShortText ( DateTimeFieldType fieldType ) { if ( fieldType == null ) { throw new IllegalArgumentException ( "Field-type-must-not-be-null" ) ; } return append0 ( new TextField ( fieldType , true ) ) ; } 
private static String getMinutes ( Calendar c ) { if ( c . get ( Calendar . MINUTE ) < 10 ) return "0" + c . get ( Calendar . MINUTE ) ; else return "" + c . get ( Calendar . MINUTE ) ; } 
public void set ( boolean value ) { if ( ! getTypeName ( ) . equals ( BasicOntology . BOOLEAN ) ) throw new IllegalArgumentException ( "Wrong-type" ) ; this . value = new Boolean ( value ) ; } 
public Class < ? > [ ] getPCSubclasses ( ) { if ( _owner != null ) return MetaDataRepository . EMPTY_CLASSES ; _repos . processRegisteredClasses ( _loader ) ; if ( _subs == null ) { Collection < Class < ? >> subs = _repos . getPCSubclasses ( _type ) ; _subs = ( Class [ ] ) subs . toArray ( new Class [ subs . size ( ) ] ) ; } return _subs ; } 
static Point inCentre ( final Point a , final Point b , final Point c ) { final double len0 = b . distance ( c ) ; final double len1 = a . distance ( c ) ; final double len2 = a . distance ( b ) ; final double circum = len0 + len1 + len2 ; final double inCentreX = ( len0 * a . getX ( ) + len1 * b . getX ( ) + len2 * c . getX ( ) ) / circum ; final double inCentreY = ( len0 * a . getY ( ) + len1 * b . getY ( ) + len2 * c . getY ( ) ) / circum ; return new PointDouble ( inCentreX , inCentreY , Geometry . NULL_ORDINATE ) ; } 
public static String getName ( ASN1ObjectIdentifier oid ) { return ( String ) names . get ( oid ) ; } 
@ Override public boolean findSecurityRole ( String role ) { synchronized ( securityRolesLock ) { for ( int i = 0 ; i < securityRoles . length ; i ++ ) { if ( role . equals ( securityRoles [ i ] ) ) return ( true ) ; } } return ( false ) ; } 
protected synchronized void callListener ( int eventType , SQLException sqlException ) { if ( this . eventListeners == null ) { return ; } Enumeration enumeration = this . eventListeners . keys ( ) ; ConnectionEvent connectionevent = new ConnectionEvent ( this , sqlException ) ; while ( enumeration . hasMoreElements ( ) ) { ConnectionEventListener connectioneventlistener = ( ConnectionEventListener ) enumeration . nextElement ( ) ; ConnectionEventListener connectioneventlistener1 = ( ConnectionEventListener ) this . eventListeners . get ( connectioneventlistener ) ; if ( eventType == CONNECTION_CLOSED_EVENT ) { connectioneventlistener1 . connectionClosed ( connectionevent ) ; } else if ( eventType == CONNECTION_ERROR_EVENT ) { connectioneventlistener1 . connectionErrorOccurred ( connectionevent ) ; } } } 
private String appendUntilEmptyLine ( String line , ByLineSource source ) throws ParseException { StringBuffer text = new StringBuffer ( ) ; do { if ( line . trim ( ) . length ( ) == 0 ) { break ; } boolean accepted = false ; for ( int i = 0 ; i < parsers . length ; i ++ ) { BlockParser parser = parsers [ i ] ; if ( parser . accept ( line , source ) ) { accepted = true ; break ; } } if ( accepted ) { source . ungetLine ( ) ; break ; } if ( text . length ( ) == 0 ) { text . append ( line . trim ( ) ) ; } else { text . append ( "-" + line . trim ( ) ) ; } } while ( ( line = source . getNextLine ( ) ) != null ) ; return text . toString ( ) ; } 
private void flushEntries ( ) { if ( ! _doLog ) _unwrittenEntries . clear ( ) ; else if ( ( ! _unwrittenEntries . isEmpty ( ) ) && ! _doPause ) writeEntries ( ) ; } 
public final int getTrackIndex ( AudioTrack at ) { return tracks . indexOf ( at ) ; } 
private static String capitalize ( String word ) { return Character . toString ( word . charAt ( 0 ) ) . toUpperCase ( ) + word . substring ( 1 ) ; } 
@ XmlElementDecl ( namespace = "http://www.mulesoft.org/schema/mule/tooling.attributes" , name = "transientBoolean" , scope = Group . class ) public JAXBElement < Booleantype > createGroupTransientBoolean ( Booleantype value ) { return new JAXBElement < Booleantype > ( _GroupTransientBoolean_QNAME , Booleantype . class , Group . class , value ) ; } 
public void commitResource ( String container , Edit edit ) { if ( container == null ) container = "" ; Container c = ( ( Container ) m_store . get ( container ) ) ; if ( c != null ) { Entity updatedEntry = m_user . newResource ( c . container , edit ) ; c . contained . put ( caseId ( updatedEntry . getId ( ) ) , updatedEntry ) ; } m_locks . remove ( edit . getReference ( ) ) ; } 
public void socksAccept ( ) throws IOException { Socks4Message reply = socksReadReply ( ) ; if ( reply . getCommandOrResult ( ) != Socks4Message . RETURN_SUCCESS ) { throw new IOException ( reply . getErrorString ( reply . getCommandOrResult ( ) ) ) ; } } 
private static byte [ ] hexStr2Bin ( String hex ) { int sz = hex . length ( ) / 2 ; byte [ ] b = new byte [ hex . length ( ) / 2 ] ; for ( int i = 0 ; i < sz ; i ++ ) { try { b [ i ] = ( byte ) Integer . parseInt ( hex . substring ( i * 2 , i * 2 + 2 ) , 16 ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } } return b ; } 
public List < String > getFlightIndicator ( ) { if ( flightIndicator == null ) { flightIndicator = new ArrayList < String > ( ) ; } return this . flightIndicator ; } 
private void computeDependence ( final Definition def , Node rValue ) { NodeTraversal . traverse ( compiler , rValue , new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; if ( dep == null ) { def . unknownDependencies = true ; } else { def . depends . add ( dep ) ; } } } } ) ; } 
public boolean isPsuedoVarRef ( ) { java . lang . String ns = m_qname . getNamespaceURI ( ) ; if ( ( null != ns ) && ns . equals ( PSUEDOVARNAMESPACE ) ) { if ( m_qname . getLocalName ( ) . startsWith ( "#" ) ) return true ; } return false ; } 
public boolean canTraverseOutsideSubtree ( ) { return m_xpath . getExpression ( ) . canTraverseOutsideSubtree ( ) ; } 
public int numberOfProperties ( ) { return pList . size ( ) ; } 
void fail ( String s ) { failures ++ ; say ( "" + NEW_LINE + "" ) ; say ( "*******************************************************" ) ; say ( "*********************-FAILURE!-**********************" ) ; say ( "*******************************************************" ) ; say ( "" + NEW_LINE + "" ) ; say ( s ) ; say ( "" ) ; if ( compiler != null ) { PrintWriter writer = new PrintWriter ( System . out ) ; compiler . dumpProgram ( writer ) ; writer . flush ( ) ; say ( "" + NEW_LINE + "" ) ; } } 
protected PolicySourceModel create ( final Policy policy ) { return PolicySourceModel . createPolicySourceModel ( policy . getNamespaceVersion ( ) , policy . getId ( ) , policy . getName ( ) ) ; } 
public static String depunctify ( final String name ) { String s = name . replaceAll ( "[|[|]|.-_]+" , "_" ) ; s = s . replaceAll ( "^_" , "" ) ; s = s . replaceAll ( "_$" , "" ) ; return s ; } 
@ Override public Valve [ ] getValves ( ) { ArrayList < Valve > valveList = new ArrayList < Valve > ( ) ; Valve current = first ; if ( current == null ) { current = basic ; } while ( current != null ) { valveList . add ( current ) ; current = current . getNext ( ) ; } return valveList . toArray ( new Valve [ 0 ] ) ; } 
public String nextToken ( ) { currentPosition = ( newPosition >= 0 && ! delimsChanged ) ? newPosition : skipDelimiters ( currentPosition ) ; delimsChanged = false ; newPosition = - 1 ; if ( currentPosition >= maxPosition ) throw new NoSuchElementException ( ) ; int start = currentPosition ; currentPosition = scanToken ( currentPosition ) ; return str . substring ( start , currentPosition ) ; } 
public static final DateFormatSymbols getInstance ( ) { return getInstance ( Locale . getDefault ( Locale . Category . FORMAT ) ) ; } 
public static long daysBetween ( Long start , Long end , TimeZone zone ) { if ( zone == null ) { zone = TimeZone . getTimeZone ( "UTC" ) ; } Calendar d1 = Calendar . getInstance ( ) ; d1 . setTimeZone ( zone ) ; d1 . setTimeInMillis ( start ) ; Calendar d2 = Calendar . getInstance ( ) ; d2 . setTimeZone ( zone ) ; d2 . setTimeInMillis ( end ) ; Long adjustedStart = d1 . getTimeInMillis ( ) + d1 . get ( Calendar . DST_OFFSET ) ; Long adjustedEnd = d2 . getTimeInMillis ( ) + d2 . get ( Calendar . DST_OFFSET ) ; return ( adjustedEnd - adjustedStart ) / TimeUtil . MILLISECONDS_PER_DAY ; } 
public void registerUnregisteredNamespaces ( ) { for ( int i = 0 ; i < m_unregisteredExtensions . size ( ) ; i ++ ) { String ns = ( String ) m_unregisteredExtensions . get ( i ) ; ExtensionNamespaceSupport extNsSpt = defineJavaNamespace ( ns ) ; if ( extNsSpt != null ) m_extensions . add ( extNsSpt ) ; } } 
private void doValidateClass ( Class proxySuperClass ) { Method [ ] methods = proxySuperClass . getMethods ( ) ; for ( Method method : methods ) { if ( ! Object . class . equals ( method . getDeclaringClass ( ) ) && Modifier . isFinal ( method . getModifiers ( ) ) ) { logger . warn ( "Unable-to-proxy-method-[" + method + "]-because-it-is-final:-" + "All-calls-to-this-method-via-a-proxy-will-be-routed-directly-to-the-proxy." ) ; } } } 
public void addRefinancePlanBalanceLineItemInputRequest ( RefinancePlanSubRequestParent inputRequest ) { if ( irList == null ) { irList = new ArrayList ( ) ; } HashMap inReq = new HashMap ( ) ; inReq . put ( "RequestId" , inputRequest . getRequestId ( ) ) ; inReq . put ( "RelationshipId" , "RefinancePlan_BalanceLineItem_Ref" ) ; irList . add ( inReq ) ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public boolean canEncode ( CharSequence cs ) { CharBuffer cb ; if ( cs instanceof CharBuffer ) cb = ( ( CharBuffer ) cs ) . duplicate ( ) ; else cb = CharBuffer . wrap ( cs . toString ( ) ) ; return canEncode ( cb ) ; } 
public void dispose ( ) { data . clear ( ) ; } 
private JLabel getstcLblDash ( ) { if ( ivjstcLblDash == null ) { try { ivjstcLblDash = new JLabel ( ) ; ivjstcLblDash . setName ( "ivjstcLblDash" ) ; ivjstcLblDash . setText ( DASH ) ; ivjstcLblDash . setMaximumSize ( new java . awt . Dimension ( 4 , 14 ) ) ; ivjstcLblDash . setMinimumSize ( new java . awt . Dimension ( 4 , 14 ) ) ; } catch ( Throwable aeIvjEx ) { handleException ( aeIvjEx ) ; } } return ivjstcLblDash ; } 
public static int getClusterX1 ( ArrayList < Element > cluster ) { int clusterBoundaryX1 = Integer . MAX_VALUE ; String pos ; String [ ] positions ; Element firstWordInCell = cluster . get ( 0 ) ; pos = firstWordInCell . attr ( "title" ) ; positions = pos . split ( "|s+" ) ; int x1 = Integer . parseInt ( positions [ 1 ] ) ; if ( x1 < clusterBoundaryX1 ) { clusterBoundaryX1 = x1 ; } return clusterBoundaryX1 ; } 
public void insert ( RBComponent c ) { if ( c == null ) throw new NullPointerException ( "Not-allowed-to-insert-null" ) ; contents . add ( c ) ; } 
public String getHashableName ( ) { StringBuilder result = new StringBuilder ( ) ; result . append ( name ( ) ) ; if ( mParameters == null ) { return result . toString ( ) ; } int i = 0 ; for ( ParameterInfo param : mParameters ) { result . append ( ":" ) ; if ( i == ( mParameters . size ( ) - 1 ) && isVarArgs ( ) ) { result . append ( param . type ( ) . fullNameNoDimension ( typeVariables ( ) ) ) . append ( "..." ) ; } else { result . append ( param . type ( ) . fullName ( typeVariables ( ) ) ) ; } i ++ ; } return result . toString ( ) ; } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; if ( localItemTracker ) { if ( localItem != null ) { for ( int i = 0 ; i < localItem . length ; i ++ ) { if ( localItem [ i ] != null ) { elementList . add ( new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2012-08-15/" , "item" ) ) ; elementList . add ( localItem [ i ] ) ; } else { } } } else { throw new org . apache . axis2 . databinding . ADBException ( "item-cannot-be-null!!" ) ; } } return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
public boolean isTerminating ( ) { int c = ctl . get ( ) ; return ! isRunning ( c ) && runStateLessThan ( c , TERMINATED ) ; } 
public void add ( CrawlUrlData curl ) { String url = curl . getUrl ( ) ; if ( map . containsKey ( url ) ) { throw new IllegalArgumentException ( "Illegal-to-replace-entry" ) ; } map . put ( url , curl ) ; int size = sorted . size ( ) ; sorted . add ( curl ) ; if ( sorted . size ( ) != size + 1 ) { log . error ( "Adding-" + curl + "-didn't-increase-size-of-crawl-queue;-" + "CrawlUrlComparator-must-have-returned-zero" ) ; } } 
protected int checkMaximumDaysInFebruary ( ) { int maxDays ; Calendar februaryMonthlyDateCalendar = Calendar . getInstance ( ) ; februaryMonthlyDateCalendar . set ( Calendar . MONTH , Calendar . FEBRUARY ) ; maxDays = februaryMonthlyDateCalendar . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; return maxDays ; } 
public void switchToPreviousView ( ) { if ( ! previousViews . isEmpty ( ) ) { switchToView ( previousViews . pop ( ) , false ) ; } } 
public void setEmployeesAtPrimaryAddressEstimation ( JAXBElement < String > value ) { this . employeesAtPrimaryAddressEstimation = ( ( JAXBElement < String > ) value ) ; } 
public static String getDisplayName ( String [ ] [ ] zoneStrings , String id , boolean daylight , int style ) { String [ ] needle = new String [ ] { id } ; int index = Arrays . binarySearch ( zoneStrings , needle , ZONE_STRINGS_COMPARATOR ) ; if ( index >= 0 ) { String [ ] row = zoneStrings [ index ] ; if ( daylight ) { return ( style == TimeZone . LONG ) ? row [ LONG_NAME_DST ] : row [ SHORT_NAME_DST ] ; } else { return ( style == TimeZone . LONG ) ? row [ LONG_NAME ] : row [ SHORT_NAME ] ; } } return null ; } 
public synchronized void close ( ) throws SQLException { realClose ( true , true ) ; } 
public WingMergeableElement mergeChild ( String namespace , String localName , String qName , Attributes attributes ) throws SAXException , WingException { Division found = null ; for ( Division candidate : divisions ) { if ( candidate . mergeEqual ( namespace , localName , qName , attributes ) ) { found = candidate ; } } divisions . remove ( found ) ; return found ; } 
public void testClearBitException ( ) { byte aBytes [ ] = { - 1 , - 128 , 56 , 100 , - 2 , - 76 , 89 , 45 , 91 , 3 , - 15 , 35 , 26 } ; int aSign = 1 ; int number = - 7 ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; try { aNumber . clearBit ( number ) ; fail ( "ArithmeticException-has-not-been-caught" ) ; } catch ( ArithmeticException e ) { } } 
private Element findFrame ( String frameName ) { ElementIterator it = new ElementIterator ( this ) ; Element next ; while ( ( next = it . next ( ) ) != null ) { AttributeSet attr = next . getAttributes ( ) ; if ( matchNameAttribute ( attr , HTML . Tag . FRAME ) ) { String frameTarget = ( String ) attr . getAttribute ( HTML . Attribute . NAME ) ; if ( frameTarget != null && frameTarget . equals ( frameName ) ) { break ; } } } return next ; } 
public boolean getBoolean ( String key ) throws JSONException { Object object = this . get ( key ) ; if ( object . equals ( Boolean . FALSE ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( object . equals ( Boolean . TRUE ) || ( object instanceof String && ( ( String ) object ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONObject[" + quote ( key ) + "]-is-not-a-Boolean." ) ; } 
public boolean checkStartsWith ( String str , String start ) { return str . regionMatches ( ! sensitive , 0 , start , 0 , start . length ( ) ) ; } 
public int getAttributeCount ( ) { return attrs == null ? 0 : attrs . size ( ) ; } 
public static double [ ] toDoubleArray ( List < Double > doubleList ) { double [ ] doubleArray = new double [ doubleList . size ( ) ] ; for ( int i = 0 ; i < doubleArray . length ; i ++ ) { doubleArray [ i ] = doubleList . get ( i ) ; } return doubleArray ; } 
public String consumeIdentifier ( ) throws ParseException { for ( int i = 0 ; i < currentToken . length ( ) ; i ++ ) { final char c = currentToken . charAt ( i ) ; if ( ( 'a' <= c && c <= 'z' ) || ( 'A' <= c && c <= 'Z' ) || ( '0' <= c && c <= '9' ) || ( c == '_' ) || ( c == '.' ) ) { } else { throw parseException ( "Expected-identifier." ) ; } } final String result = currentToken ; nextToken ( ) ; return result ; } 
protected JMenuBar getMonitorMenuBar ( ) { JMenuBar mb = new JMenuBar ( ) ; mb . add ( new JMenu ( "Log" ) ) ; mb . add ( new JMenu ( "Einstellungen" ) ) ; mb . add ( new JMenu ( "Hilfe" ) ) ; mb . add ( Box . createHorizontalGlue ( ) ) ; mb . add ( new JLabel ( "LOGMONITOR" ) ) ; return mb ; } 
public double cond ( ) { return new SingularValueDecomposition ( this ) . cond ( ) ; } 
public synchronized void write ( String s ) { try { if ( writer != null ) { writer . write ( s ) ; writer . flush ( ) ; } } catch ( IOException e ) { System . err . println ( "Cannot-write-to-file-"" + filename + """ ) ; } } 
public Set < URI > getAuthenticatingAuthority ( ) { return Collections . unmodifiableSet ( authenticatingAuthority ) ; } 
public Event createEvent ( ) { return new Event ( ) ; } 
private void appendVal ( Object val ) { if ( val instanceof String ) mypage . setString ( currentpos , ( String ) val ) ; else mypage . setInt ( currentpos , ( Integer ) val ) ; currentpos += size ( val ) ; } 
private void emitAllClusters ( Vector point , Collection < SoftCluster > clusters , Vector pi , Mapper < ? , ? , IntWritable , WeightedVectorWritable > . Context context ) throws IOException , InterruptedException { for ( int i = 0 ; i < clusters . size ( ) ; i ++ ) { double pdf = pi . get ( i ) ; if ( pdf > threshold ) { context . write ( new IntWritable ( i ) , new WeightedVectorWritable ( pdf , point ) ) ; } } } 
public static void setTempCurrentImage ( Thread thread , ImagePlus img ) { if ( thread == null ) throw new RuntimeException ( "thread==null" ) ; if ( img == null ) tempImageTable . remove ( thread ) ; else tempImageTable . put ( thread , img ) ; } 
private void start ( JComponent c , MouseEvent e ) { Point screenLocation = c . getLocationOnScreen ( ) ; if ( component != c ) { _stop ( component ) ; } component = c ; event = new MouseEvent ( component , e . getID ( ) , e . getWhen ( ) , e . getModifiers ( ) , e . getX ( ) + screenLocation . x , e . getY ( ) + screenLocation . y , e . getXOnScreen ( ) , e . getYOnScreen ( ) , e . getClickCount ( ) , e . isPopupTrigger ( ) , MouseEvent . NOBUTTON ) ; if ( timer == null ) { timer = new Timer ( 100 , this ) ; } if ( ! timer . isRunning ( ) ) { timer . start ( ) ; } } 
public void putPreferences ( ) { Preferences prefs = Preferences . userRoot ( ) . node ( "vacuum" ) ; prefs . putInt ( PREF_W , m_w ) ; prefs . putInt ( PREF_H , m_h ) ; prefs . putInt ( PREF_DIRTY , m_dirtyCount ) ; prefs . putInt ( PREF_DELAY , m_delay ) ; prefs . put ( PREF_BOARDFILE , m_boardFileName ) ; prefs . putBoolean ( PREF_SPEAKALOUD , m_bSpeakAloud ) ; } 
public String read ( String name ) { return cookies . get ( name ) ; } 
public ArrayList < String > getSnapshotIndices ( ) { return new ArrayList < String > ( _mySnapshots . keySet ( ) ) ; } 
public void setRequestLine ( String requestLine ) { requestLine = requestLine . trim ( ) ; this . requestLine = requestLine ; } 
public void diffuserProgramme ( Programme p ) { logger . debug ( "Démarrage:-diffuserProgramme" ) ; logger . info ( "Le-programme-" + p . getTitre ( ) + "-est-en-cours-de-diffusion" ) ; Vector medias = new Vector ( ) ; TreeMap documents = p . getDocuments ( ) ; Iterator calages = documents . keySet ( ) . iterator ( ) ; while ( calages . hasNext ( ) ) { medias . addElement ( documents . get ( calages . next ( ) ) ) ; } if ( RTP != null ) { RTP . programmer ( medias ) ; } logger . debug ( "Arrêt:-diffuserProgramme" ) ; } 
protected GrantEntry readGrantEntry ( StreamTokenizer st ) throws IOException , InvalidFormatException { GrantEntry ge = new GrantEntry ( ) ; parsing : while ( true ) { switch ( st . nextToken ( ) ) { case StreamTokenizer . TT_WORD : if ( Util . equalsIgnoreCase ( "signedby" , st . sval ) ) { if ( st . nextToken ( ) == '"' ) { ge . signers = st . sval ; } else { handleUnexpectedToken ( st , Messages . getString ( "security.8B" ) ) ; } } else if ( Util . equalsIgnoreCase ( "codebase" , st . sval ) ) { if ( st . nextToken ( ) == '"' ) { ge . codebase = st . sval ; } else { handleUnexpectedToken ( st , Messages . getString ( "security.8C" ) ) ; } } else if ( Util . equalsIgnoreCase ( "principal" , st . sval ) ) { ge . addPrincipal ( readPrincipalEntry ( st ) ) ; } else { handleUnexpectedToken ( st ) ; } break ; case ',' : break ; case '{' : ge . permissions = readPermissionEntries ( st ) ; break parsing ; default : st . pushBack ( ) ; break parsing ; } } return ge ; } 
protected Set < String > createSetForOriginalKeys ( ) { return Collections . newSetFromMap ( new ConcurrentHashMap < String , Boolean > ( ) ) ; } 
private void writeString ( String string ) throws IOException { string = replaceToken ( string , "|par" , "-|par" ) ; string = replaceToken ( string , "|line" , "-|line" ) ; output . write ( string . getBytes ( "UTF-8" ) ) ; } 
public FlxBasic add ( FlxBasic Object ) { if ( Object == null ) { FlxG . log ( "WARNING:-Cannot-add-'null'-object-to-a-FlxGroup." ) ; return null ; } if ( members . indexOf ( Object , true ) >= 0 ) return Object ; int i = 0 ; int l = members . size ; while ( i < l ) { if ( members . get ( i ) == null ) { members . set ( i , Object ) ; if ( i >= length ) length = i + 1 ; return Object ; } i ++ ; } if ( _maxSize > 0 ) { if ( members . size >= _maxSize ) return Object ; } members . add ( Object ) ; length = i + 1 ; return Object ; } 
private void checkExcludedIP ( Set excluded , byte [ ] ip ) throws PKIXNameConstraintValidatorException { if ( excluded . isEmpty ( ) ) { return ; } Iterator it = excluded . iterator ( ) ; while ( it . hasNext ( ) ) { byte [ ] ipWithSubnet = ( byte [ ] ) it . next ( ) ; if ( isIPConstrained ( ip , ipWithSubnet ) ) { throw new PKIXNameConstraintValidatorException ( "IP-is-from-an-excluded-subtree." ) ; } } } 
public InputStream getInputStream ( ) throws IOException { checkOpenAndCreate ( false ) ; if ( isInputShutdown ( ) ) { throw new SocketException ( "Socket-input-is-shutdown" ) ; } return impl . getInputStream ( ) ; } 
public static Credential basic ( String userName , String password ) { try { String usernameAndPassword = userName + ":" + password ; byte [ ] bytes = usernameAndPassword . getBytes ( "ISO-8859-1" ) ; String encoded = Base64 . encode ( bytes ) ; return new Credential ( "Basic-" + encoded ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( ) ; } } 
private void addPrintMeanToRawTab ( ) { printMean . setPreferredSize ( new Dimension ( 90 , 30 ) ) ; printMean . setBorder ( null ) ; stepSizeBox . setPreferredSize ( new Dimension ( 80 , 30 ) ) ; } 
public static < T extends Resource > List < List < T >> partition ( List < T > l , Property p ) { List < T > source = new ArrayList < T > ( ) ; source . addAll ( l ) ; List < List < T >> parts = new ArrayList < List < T >> ( ) ; while ( ! source . isEmpty ( ) ) { T seed = source . remove ( 0 ) ; List < T > part = removeEquiv ( source , p , seed ) ; part . add ( seed ) ; parts . add ( part ) ; } return parts ; } 
private void addJTextFields ( ) { jtfUser = new JTextField ( ) ; jtfUser . setDocument ( new JTextFieldLimit ( ) ) ; jtfUser = setJTextFieldConfiguration ( jtfUser , 30 ) ; jtfUser . addKeyListener ( new KeyAdapter ( ) { public void keyPressed ( KeyEvent e ) { if ( e . getKeyCode ( ) == KeyEvent . VK_ENTER ) { jbtAccept . doClick ( ) ; } } } ) ; this . add ( jtfUser ) ; jpfPassword = new JPasswordField ( ) ; jpfPassword . setDocument ( new JTextFieldLimit ( ) ) ; jpfPassword = setJPasswordFieldConfiguration ( jpfPassword , 90 ) ; jpfPassword . addKeyListener ( new KeyAdapter ( ) { public void keyPressed ( KeyEvent e ) { if ( e . getKeyCode ( ) == KeyEvent . VK_ENTER ) { jbtAccept . doClick ( ) ; } } } ) ; this . add ( jpfPassword ) ; } 
public void setVenueName ( String venueName ) { reqMap . put ( "venueName" , venueName ) ; } 
private String proxyToString ( Object proxy ) { Class < ? > [ ] interfaces = proxy . getClass ( ) . getInterfaces ( ) ; if ( interfaces . length == 0 ) { return "Proxy[" + this + "]" ; } String iface = interfaces [ 0 ] . getName ( ) ; if ( iface . equals ( "java.rmi.Remote" ) && interfaces . length > 1 ) { iface = interfaces [ 1 ] . getName ( ) ; } int dot = iface . lastIndexOf ( '.' ) ; if ( dot >= 0 ) { iface = iface . substring ( dot + 1 ) ; } return "Proxy[" + iface + "," + this + "]" ; } 
protected static int readFully ( Reader reader , char [ ] buf , int length ) throws IOException { int numCharsRead = 0 ; while ( numCharsRead < length ) { int count = reader . read ( buf , numCharsRead , length - numCharsRead ) ; if ( count < 0 ) { break ; } numCharsRead += count ; } return numCharsRead ; } 
static FormattingTuple format ( final String messagePattern , Object argA , Object argB ) { return arrayFormat ( messagePattern , new Object [ ] { argA , argB } ) ; } 
public InetAddress getInterface ( ) throws SocketException { checkOpen ( ) ; if ( setAddress != null ) { return setAddress ; } InetAddress ipvXaddress = ( InetAddress ) impl . getOption ( SocketOptions . IP_MULTICAST_IF ) ; if ( ipvXaddress . isAnyLocalAddress ( ) ) { NetworkInterface theInterface = getNetworkInterface ( ) ; if ( theInterface != null ) { Enumeration < InetAddress > addresses = theInterface . getInetAddresses ( ) ; if ( addresses != null ) { while ( addresses . hasMoreElements ( ) ) { InetAddress nextAddress = addresses . nextElement ( ) ; if ( nextAddress instanceof Inet6Address ) { return nextAddress ; } } } } } return ipvXaddress ; } 
@ Override public final String toString ( ) { if ( ! initialized ) { return null ; } return spiImpl . engineToString ( ) ; } 
static public long toLong ( Object object ) throws com . sun . star . lang . IllegalArgumentException { Long ret = ( Long ) convertSimple ( TypeClass . HYPER , null , object ) ; return ret . longValue ( ) ; } 
private void getProperties ( ) throws PeopleServiceException { LOGGER . debug ( "Reading-proprties-file-for-connection-info" ) ; try { netFlixConnProp = new Properties ( ) ; netFlixConnProp . load ( Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( Constants . NF_CONN_PROP_FILE ) ) ; consumerKey = netFlixConnProp . getProperty ( Constants . CONSUMER_KEY_NAME ) ; sharedSecret = netFlixConnProp . getProperty ( Constants . SHARED_SEC_NAME ) ; if ( consumerKey . isEmpty ( ) || sharedSecret . isEmpty ( ) ) { throw new PeopleServiceException ( "Either-'consumerKey'-or-'sharedSecret'-not-set-properly" ) ; } } catch ( IOException exception ) { throw new PeopleServiceException ( "IOExcpetion-while-reading-prioperty-file-for-consumer-key-and-shared-secret." ) ; } catch ( Exception exception ) { throw new PeopleServiceException ( "Error-occured-while-reading-properties-from-property-file." ) ; } } 
public static String handleAftermath ( ) { String log = null ; try { log = FileUtils . readTextFile ( LOG_FILE , - LOG_FILE_MAX_LENGTH , "...-" ) ; } catch ( FileNotFoundException e ) { Log . i ( TAG , "No-recovery-log-file" ) ; } catch ( IOException e ) { Log . e ( TAG , "Error-reading-recovery-log" , e ) ; } String [ ] names = RECOVERY_DIR . list ( ) ; for ( int i = 0 ; names != null && i < names . length ; i ++ ) { File f = new File ( RECOVERY_DIR , names [ i ] ) ; if ( ! f . delete ( ) ) { Log . e ( TAG , "Can't-delete:-" + f ) ; } else { Log . i ( TAG , "Deleted:-" + f ) ; } } return log ; } 
public void setVisible ( boolean b ) { if ( source instanceof Component ) { ( ( Component ) source ) . setVisible ( b ) ; } } 
public void startScroll ( ) { _timer . start ( ) ; } 
private int fromFunctionText2Value ( String text ) { if ( text . equals ( FUNCTION_TEXT_LENGTH ) ) return ModelConstants . FUNCTION_LENGTH ; return ModelConstants . FUNCTION_VALUE ; } 
public boolean getState ( String theRadioButtonName ) { int n = _myRadioToggles . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Toggle t = _myRadioToggles . get ( i ) ; if ( theRadioButtonName . equals ( t . name ( ) ) ) { return t . getState ( ) ; } } return false ; } 
public void setRequestLine ( String requestLine ) { requestLine = requestLine . trim ( ) ; this . requestLine = requestLine ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public String toString ( ) { java . text . MessageFormat form = new java . text . MessageFormat ( sun . security . util . ResourcesMgr . getString ( "NTSid.name" , "sun.security.util.AuthResources" ) ) ; Object [ ] source = { sid } ; return form . format ( source ) ; } 
public List < Long > getValidValues ( ) { if ( validValues == null ) { validValues = new ArrayList < Long > ( ) ; } return this . validValues ; } 
public void setWorkdays ( int [ ] workdays ) throws IllegalStateException { setAttribute ( "workdays" , workdays , false ) ; } 
public static File findFile ( String file , String rootPath ) { if ( rootPath == null || "" . equals ( rootPath ) ) { return null ; } File result = null ; Collection < File > fileCollection = listFiles ( new File ( rootPath ) , new String [ ] { file . substring ( file . lastIndexOf ( '.' ) + 1 ) } , true ) ; if ( fileCollection . isEmpty ( ) ) { return result ; } Iterator < File > fileCollectionIterator = fileCollection . iterator ( ) ; while ( fileCollectionIterator . hasNext ( ) ) { File testFile = fileCollectionIterator . next ( ) ; if ( file . equals ( testFile . getName ( ) ) ) { result = testFile ; } } return result ; } 
public static < T > Builder < T > $for ( String prefix , Class < T > api , T app , String wsPrefix ) { return new Builder < T > ( prefix , api , app , wsPrefix ) ; } 
private void writeStartElement ( java . lang . String prefix , java . lang . String namespace , java . lang . String localPart , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String writerPrefix = xmlWriter . getPrefix ( namespace ) ; if ( writerPrefix != null ) { xmlWriter . writeStartElement ( namespace , localPart ) ; } else { if ( namespace . length ( ) == 0 ) { prefix = "" ; } else if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; } xmlWriter . writeStartElement ( prefix , localPart , namespace ) ; xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } } 
protected AttributeList defAttributeList ( String name , int type , int modifier , String value , String values , AttributeList atts ) { Vector < String > vals = null ; if ( values != null ) { vals = new Vector < String > ( ) ; for ( StringTokenizer s = new StringTokenizer ( values , "|" ) ; s . hasMoreTokens ( ) ; ) { String str = s . nextToken ( ) ; if ( str . length ( ) > 0 ) { vals . addElement ( str ) ; } } } return new AttributeList ( name , type , modifier , value , vals , atts ) ; } 
public static final boolean areEqual ( Object o1 , Object o2 ) { if ( o1 == o2 ) { return true ; } else if ( o1 == null || o2 == null ) { return false ; } else { return o1 . equals ( o2 ) ; } } 
public Set < String > getEntriesContainingSynonym ( String word , SolutionPattern pattern , boolean includeSiblings ) { if ( cache . containsKey ( word ) ) { return cache . get ( word ) ; } Set < String > synonyms = new HashSet < > ( ) ; for ( Entry < String , Set < String >> entry : thesaurus . entrySet ( ) ) { if ( entry . getKey ( ) . equals ( word ) || entry . getValue ( ) . contains ( word ) ) { if ( includeSiblings ) { synonyms . addAll ( entry . getValue ( ) ) ; } synonyms . add ( entry . getKey ( ) ) ; } } synonyms . remove ( word ) ; Iterator < String > it = synonyms . iterator ( ) ; while ( it . hasNext ( ) ) { String synonym = it . next ( ) ; if ( ! pattern . match ( synonym ) ) { it . remove ( ) ; } } cache . put ( word , synonyms ) ; return synonyms ; } 
private void closeReader ( Reader pobjRdr ) { if ( pobjRdr == null ) return ; try { pobjRdr . close ( ) ; } catch ( IOException IOExIgnore ) { } } 
public File ( String fileName , int fileSize ) throws ParameterException { if ( fileName == null || fileName . length ( ) == 0 ) { throw new ParameterException ( "File():-Error---invalid-file-name." ) ; } if ( fileSize <= 0 ) { throw new ParameterException ( "File():-Error---size-<=-0." ) ; } name = fileName ; attribute = new FileAttribute ( fileName , fileSize ) ; transactionTime = 0 ; } 
public void show ( ) { if ( localLOGV ) Log . v ( TAG , "SHOW:-" + this ) ; mHandler . post ( mShow ) ; } 
public BufferedReader getReader ( ) throws IOException { return ( bodyContent == null ) ? null : new BufferedReader ( new StringReader ( bodyContent ) ) ; } 
public synchronized int indexOf ( Object object , int location ) { if ( object != null ) { for ( int i = location ; i < elementCount ; i ++ ) { if ( object . equals ( elementData [ i ] ) ) { return i ; } } } else { for ( int i = location ; i < elementCount ; i ++ ) { if ( elementData [ i ] == null ) { return i ; } } } return - 1 ; } 
public void setFixedTree ( boolean fixed ) { setFixed ( fixed ) ; for ( Node argument : arguments ) { if ( argument != null ) { argument . setFixedTree ( fixed ) ; } } } 
private static void appendNewlineIfNecessary ( StringBuffer buf , Writer out ) throws IOException { int len = buf . length ( ) ; if ( ( len != 0 ) && ( buf . charAt ( len - 1 ) != '|n' ) ) { out . write ( '|n' ) ; } } 
public boolean isWrapperFor ( Class < ? > iface ) throws SQLException { boolean isInstance = iface . isInstance ( this ) ; if ( isInstance ) { return true ; } String interfaceClassName = iface . getName ( ) ; return ( interfaceClassName . equals ( "com.mysql.jdbc.Statement" ) || interfaceClassName . equals ( "java.sql.Statement" ) || interfaceClassName . equals ( "java.sql.PreparedStatement" ) || interfaceClassName . equals ( "java.sql.Wrapper" ) ) ; } 
private SortedSet < String > toImplement ( String typeName ) { String name = typeName . replace ( '/' , '_' ) ; String prefix = name + "_" ; String suffix = name + "`" ; SortedSet < String > toReturn = new TreeSet < String > ( ) ; for ( String mangledName : jsoData . getMangledNames ( ) . subSet ( prefix , suffix ) ) { if ( ! implementedMethods . contains ( mangledName ) ) { toReturn . add ( mangledName ) ; } } return toReturn ; } 
@ Override public void generateMethodPrologue ( JavaWriter out , HashMap < String , Object > map ) throws IOException { super . generateMethodPrologue ( out , map ) ; if ( map . get ( "__caucho_manager" ) == null ) { map . put ( "__caucho_manager" , true ) ; out . println ( ) ; out . print ( "private-static-" ) ; out . printClass ( InjectManager . class ) ; out . println ( "-__caucho_manager" ) ; out . print ( "-=-" ) ; out . printClass ( InjectManager . class ) ; out . println ( ".create();" ) ; } if ( hasInterceptor ( ) ) generateInterceptorMethodPrologue ( out , map ) ; if ( hasDecorator ( ) ) generateDecoratorMethodPrologue ( out , map ) ; } 
public List < Node > getChildNodes ( ) { LinkedList < Node > childNodes = new LinkedList < Node > ( ) ; for ( Edge edge : leavingEdges ) { childNodes . add ( edge . getToNode ( ) ) ; } return childNodes ; } 
public static String externalClassName ( String internalClassName ) { return internalClassName . replace ( ClassConstants . INTERNAL_PACKAGE_SEPARATOR , ClassConstants . EXTERNAL_PACKAGE_SEPARATOR ) ; } 
public List < Simplex > getAssociatedSimplices ( int witness ) { List < Simplex > temp = this . witnessSimplexMap . get ( witness ) ; if ( temp == null ) { return null ; } List < Simplex > result = new ArrayList < Simplex > ( ) ; result . addAll ( temp ) ; return result ; } 
public void unregisterRenderer ( RajawaliRenderer renderer ) { mRenderers . remove ( renderer ) ; } 
protected static OutputStream writeFile ( String filename ) throws IOException { filename = transform ( filename ) ; final FileSystem fs = getFileSystem ( filename ) ; if ( fs == null ) throw new FileNotFoundException ( "No-file-system-for-" + filename ) ; if ( ( fs . capabilities ( ) & FSCapability . WRITE ) == 0 ) throw new IOException ( "File-system-not-supporting-writes-for-" + filename ) ; return fs . writeFileStream ( filename ) ; } 
protected void appendDetail ( StringBuffer buffer , String fieldName , short value ) { buffer . append ( value ) ; } 
@ Override public BasicThreadFactory build ( ) { final BasicThreadFactory factory = new BasicThreadFactory ( this ) ; reset ( ) ; return factory ; } 
public static synchronized String getDate ( final long millis ) { date . setTime ( millis ) ; return formatter . format ( date ) ; } 
public void setBackgroundRes ( @ DrawableRes int headerBackgroundRes ) { mAccountHeaderBuilder . mAccountHeaderBackground . setImageResource ( headerBackgroundRes ) ; } 
public void set ( T object , V value ) { throw new UnsupportedOperationException ( "Property-" + getName ( ) + "-is-read-only" ) ; } 
public List < JAXBElement < ? >> getVariantOrI1OrI2 ( ) { if ( variantOrI1OrI2 == null ) { variantOrI1OrI2 = new ArrayList < JAXBElement < ? >> ( ) ; } return this . variantOrI1OrI2 ; } 
private static void copystream ( InputStream in , OutputStream out ) throws IOException { byte [ ] buffer = new byte [ 1024 ] ; int len ; while ( ( len = in . read ( buffer ) ) >= 0 ) out . write ( buffer , 0 , len ) ; } 
public static URI stripSingleURIQueryAndFragment ( final URI inUri ) throws StorageException { if ( inUri == null ) { return null ; } try { return new URI ( inUri . getScheme ( ) , inUri . getAuthority ( ) , inUri . getPath ( ) , null , null ) ; } catch ( final URISyntaxException e ) { throw Utility . generateNewUnexpectedStorageException ( e ) ; } } 
public String [ ] getRowValuesAsString ( int row ) { row = row - 1 ; int startPosition = 0 ; String [ ] rowValues = new String [ nCols + startPosition ] ; for ( int c = 0 ; c < nCols ; c ++ ) { switch ( columnType [ c ] ) { case STRING : String [ ] s = ( String [ ] ) columnData . get ( c ) ; rowValues [ c + startPosition ] = s [ row ] ; break ; case NUMBER : float [ ] f = ( float [ ] ) columnData . get ( c ) ; rowValues [ c + startPosition ] = valueFormat . format ( f [ row ] ) ; break ; } } return rowValues ; } 
public static LocationPojo calculateDerivedPosition ( LocationPojo point , double range , double bearing ) { double EarthRadius = 6371000 ; double latA = Math . toRadians ( point . latitude ) ; double lonA = Math . toRadians ( point . longtitude ) ; double angularDistance = range / EarthRadius ; double trueCourse = Math . toRadians ( bearing ) ; double lat = Math . asin ( Math . sin ( latA ) * Math . cos ( angularDistance ) + Math . cos ( latA ) * Math . sin ( angularDistance ) * Math . cos ( trueCourse ) ) ; double dlon = Math . atan2 ( Math . sin ( trueCourse ) * Math . sin ( angularDistance ) * Math . cos ( latA ) , Math . cos ( angularDistance ) - Math . sin ( latA ) * Math . sin ( lat ) ) ; double lon = ( ( lonA + dlon + Math . PI ) % ( Math . PI * 2 ) ) - Math . PI ; lat = Math . toDegrees ( lat ) ; lon = Math . toDegrees ( lon ) ; LocationPojo newPoint = new LocationPojo ( ) ; newPoint . latitude = lat ; newPoint . longtitude = lon ; return newPoint ; } 
public String toString ( ) { return new Formatter ( ) . toString ( this ) ; } 
void checkRequiredChildren ( Locator locator ) throws SAXParseException { ArrayList < Element > requiredChildren = this . requiredChilden ; if ( requiredChildren != null ) { for ( int i = requiredChildren . size ( ) - 1 ; i >= 0 ; i -- ) { Element child = requiredChildren . get ( i ) ; if ( ! child . visited ) { throw new BadXmlException ( "Element-named-" + this + "-is-missing-required" + "-child-element-named-" + child + "." , locator ) ; } } } } 
public static void copy ( InputStream input , OutputStream output , int bufferSize ) throws IOException { byte [ ] buf = new byte [ bufferSize ] ; int bytesRead = input . read ( buf ) ; while ( bytesRead != - 1 ) { output . write ( buf , 0 , bytesRead ) ; bytesRead = input . read ( buf ) ; } output . flush ( ) ; } 
@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; switch ( mod_op ) { case DirContext . ADD_ATTRIBUTE : sb . append ( "Operation-is-add-attribute:-" ) ; break ; case DirContext . REMOVE_ATTRIBUTE : sb . append ( "Operation-is-remove-attribute:-" ) ; break ; case DirContext . REPLACE_ATTRIBUTE : sb . append ( "Operation-is-replace-attribute:-" ) ; break ; } return sb . append ( attr . toString ( ) ) . toString ( ) ; } 
public int getDefaultPort ( ) { return strmHandler . getDefaultPort ( ) ; } 
public double evaluateModelOnce ( Classifier classifier , Instance instance ) throws Exception { return m_delegate . evaluateModelOnce ( classifier , instance ) ; } 
private static boolean equalsHandlesNulls ( Object a , Object b ) { return ( a == null ) ? ( b == null ) : a . equals ( b ) ; } 
public void setRequestLine ( String requestLine ) { requestLine = requestLine . trim ( ) ; this . requestLine = requestLine ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
private static int removeWhiteSpace ( char [ ] data ) { if ( data == null ) { return 0 ; } int newSize = 0 ; int len = data . length ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! isWhiteSpace ( data [ i ] ) ) { data [ newSize ++ ] = data [ i ] ; } } return newSize ; } 
private void onReorderLayers ( ListDataEvent ev ) { ( ( JComponent ) mapPane ) . setIgnoreRepaint ( true ) ; for ( int pos = ev . getIndex0 ( ) ; pos <= ev . getIndex1 ( ) ; pos ++ ) { Layer layer = listModel . getElementAt ( pos ) ; int newContextPos = listModel . getSize ( ) - pos - 1 ; int curContextPos = mapPane . getMapContent ( ) . layers ( ) . indexOf ( layer ) ; if ( curContextPos != newContextPos ) { mapPane . getMapContent ( ) . moveLayer ( curContextPos , newContextPos ) ; } } ( ( JComponent ) mapPane ) . setIgnoreRepaint ( false ) ; ( ( JComponent ) mapPane ) . repaint ( ) ; } 
public byte [ ] getIssuerAsBytes ( ) throws IOException { if ( issuer == null ) { return null ; } if ( issuerBytes == null ) { issuerBytes = issuer . getEncoded ( ) ; } byte [ ] result = new byte [ issuerBytes . length ] ; System . arraycopy ( issuerBytes , 0 , result , 0 , issuerBytes . length ) ; return result ; } 
public void removeListener ( ServerListener listener ) { this . listeners . remove ( listener ) ; } 
private static boolean unwanted ( Symbol s ) { return s == null || ( s . flags ( ) & SYNTHETIC ) != 0 ; } 
public static URI create ( String str ) { try { return new URI ( str ) ; } catch ( URISyntaxException e ) { throw ( IllegalArgumentException ) new IllegalArgumentException ( ) . initCause ( e ) ; } } 
public synchronized void addConsumer ( ImageConsumer ic ) { if ( proxies == null ) { proxies = new Hashtable ( ) ; } if ( ! proxies . containsKey ( ic ) ) { ImageFilter imgf = filter . getFilterInstance ( ic ) ; proxies . put ( ic , imgf ) ; src . addConsumer ( imgf ) ; } } 
public Path getBoundaryPath ( ) { Path path = new Path ( ) ; nativeGetBoundaryPath ( mNativeRegion , path . ni ( ) ) ; return path ; } 
private String parseComment ( final List commentList , final int commentIndex ) { final StringBuilder comment = new StringBuilder ( ) ; comment . append ( commentList . get ( commentIndex ) ) . append ( "-" ) ; for ( int i = commentIndex + 1 ; i < commentList . size ( ) ; i ++ ) { comment . append ( commentList . get ( i ) ) . append ( "-" ) ; } return comment . toString ( ) . trim ( ) ; } 
private javax . swing . JPanel getJPanel2 ( ) { if ( jPanel2 == null ) { jLabel8 = new JLabel ( ) ; jLabel8 . setText ( PluginServices . getText ( this , "unidades_area" ) ) ; GridLayout gridLayout = new GridLayout ( ) ; gridLayout . setRows ( 3 ) ; jPanel2 = new javax . swing . JPanel ( ) ; jPanel2 . setLayout ( gridLayout ) ; jPanel2 . setPreferredSize ( new java . awt . Dimension ( 140 , 80 ) ) ; jPanel2 . add ( getJLabel4 ( ) , null ) ; jPanel2 . add ( getJLabel5 ( ) , null ) ; jPanel2 . add ( jLabel8 , null ) ; } return jPanel2 ; } 
public String [ ] getDependencies ( ) { return dependencies == null ? null : ( String [ ] ) dependencies . clone ( ) ; } 
public static void pr ( String s ) { if ( showStructure ) System . out . print ( indentStr . substring ( 0 , level * 2 ) ) ; System . out . println ( s ) ; } 
public static String encodeToString ( byte [ ] input , int flags ) { try { return new String ( encode ( input , flags ) , "US-ASCII" ) ; } catch ( UnsupportedEncodingException e ) { throw new AssertionError ( e ) ; } } 
public int yToLine ( int y ) { FontMetrics fm = painter . getFontMetrics ( ) ; int height = fm . getHeight ( ) ; return Math . max ( 0 , Math . min ( getLineCount ( ) - 1 , y / height + firstLine ) ) ; } 
public java . lang . Double getChargedTips ( ) { return chargedTips == null ? Double . valueOf ( 0 ) : chargedTips ; } 
public Point getMousePosition ( ) throws HeadlessException { if ( GraphicsEnvironment . isHeadless ( ) ) { throw new HeadlessException ( ) ; } PointerInfo pi = java . security . AccessController . doPrivileged ( new java . security . PrivilegedAction < PointerInfo > ( ) { public PointerInfo run ( ) { return MouseInfo . getPointerInfo ( ) ; } } ) ; synchronized ( getTreeLock ( ) ) { Component inTheSameWindow = findUnderMouseInWindow ( pi ) ; if ( ! isSameOrAncestorOf ( inTheSameWindow , true ) ) { return null ; } return pointRelativeToComponent ( pi . getLocation ( ) ) ; } } 
private List < Select > initSelectList ( List < String > keyList , ResourceBundle bundle ) { List < Select > list = new ArrayList < Select > ( ) ; for ( String key : keyList ) { String valueOfSelect = "" ; try { valueOfSelect = bundle . getString ( key ) ; } catch ( MissingResourceException e ) { valueOfSelect = key ; } Select option = new Select ( key , valueOfSelect ) ; list . add ( option ) ; } return list ; } 
public static void cursorIntToContentValues ( Cursor cursor , String field , ContentValues values , String key ) { int colIndex = cursor . getColumnIndex ( field ) ; if ( ! cursor . isNull ( colIndex ) ) { values . put ( key , cursor . getInt ( colIndex ) ) ; } else { values . put ( key , ( Integer ) null ) ; } } 
public List < Long > getCnt ( ) { if ( cnt == null ) { cnt = new ArrayList < Long > ( ) ; } return this . cnt ; } 
public Set < Long > getDownloadIds ( ) { synchronized ( this ) { Set < Long > returnIds = new HashSet < Long > ( downloadIds ) ; return returnIds ; } } 
Scanner ( Collection < File > inputPathsToScan , final Set < String > fileExtns ) { this . inputPathsToScan = Util . checkNotNull ( inputPathsToScan ) ; this . fileExtns = Util . checkNotNull ( fileExtns ) ; this . fileFilter = new FileFilter ( ) { public boolean accept ( File file ) { return file . isDirectory ( ) || fileExtns . contains ( fileExtn ( file . getName ( ) ) ) ; } } ; } 
private int deleteAcct ( ) { StringBuffer sql = new StringBuffer ( "DELETE-Fact_Acct-WHERE-AD_Table_ID=" ) . append ( get_Table_ID ( ) ) . append ( "-AND-Record_ID=" ) . append ( p_po . getID ( ) ) ; int no = DB . executeUpdate ( sql . toString ( ) , getTrxName ( ) ) ; if ( no != 0 ) log . info ( "deleted=" + no ) ; return no ; } 
public void getBulk ( SnmpMibRequest inRequest , int nonRepeat , int maxRepeat ) throws SnmpStatusException { SNMP_ADAPTOR_LOGGER . logp ( Level . FINEST , SnmpErrorHandlerAgent . class . getName ( ) , "getBulk" , "GetBulk-in-Exception" ) ; if ( inRequest . getVersion ( ) == SnmpDefinitions . snmpVersionOne ) throw new SnmpStatusException ( SnmpDefinitions . snmpRspGenErr , 0 ) ; Enumeration l = inRequest . getElements ( ) ; while ( l . hasMoreElements ( ) ) { SnmpVarBind varbind = ( SnmpVarBind ) l . nextElement ( ) ; varbind . setEndOfMibView ( ) ; } } 
public Object validateAndConvert ( String value , Object originalValue , StringBuffer messageBuffer ) { if ( value . equals ( "<null>" ) || value . equals ( "" ) ) return null ; try { Object obj = new Byte ( value ) ; return obj ; } catch ( Exception e ) { messageBuffer . append ( e . toString ( ) + "-" ) ; return null ; } } 
public void setLastUpdateLogin ( JAXBElement < String > value ) { this . lastUpdateLogin = ( ( JAXBElement < String > ) value ) ; } 
public static void trim ( List < String > strs ) { for ( int i = 0 , n = strs . size ( ) ; i < n ; i ++ ) strs . set ( i , strs . get ( i ) . trim ( ) ) ; } 
void addFieldValue ( Map < TemporalField , Long > fieldValues , ChronoField field , long value ) { Long old = fieldValues . get ( field ) ; if ( old != null && old . longValue ( ) != value ) { throw new DateTimeException ( "Conflict-found:-" + field + "-" + old + "-differs-from-" + field + "-" + value ) ; } fieldValues . put ( field , value ) ; } 
public Lookup ( String name , int type ) throws TextParseException { this ( Name . fromString ( name ) , type , DClass . IN ) ; } 
public void setLimit ( int limit ) { checkThread ( ) ; if ( limitPosition == - 1 ) { throw new IllegalStateException ( "Limit-must-be-set-with-QueryBuilder-before-it-can-be-used-here" ) ; } parameters [ limitPosition ] = Integer . toString ( limit ) ; } 
private void setViewDrawable ( ImageView v , Drawable drawable , int nullVisibility ) { v . setImageDrawable ( drawable ) ; if ( drawable == null ) { v . setVisibility ( nullVisibility ) ; } else { v . setVisibility ( View . VISIBLE ) ; drawable . setVisible ( false , false ) ; drawable . setVisible ( true , false ) ; } } 
public static void setAutoIncrMapperProcCount ( Configuration conf , boolean autoIncr ) { conf . setBoolean ( AUTO_INCR_MAP_PROC_COUNT , autoIncr ) ; } 
protected void doSocketConnect ( InetAddress host , int port ) throws IOException { RDPLogger . d ( "Socket-connection-initialization" + host . getHostAddress ( ) + "Port-:" + port ) ; this . rdpsock = new Socket ( host , port ) ; } 
public void removeOnAccountsUpdatedListener ( OnAccountsUpdateListener listener ) { if ( listener == null ) throw new IllegalArgumentException ( "listener-is-null" ) ; synchronized ( mAccountsUpdatedListeners ) { if ( ! mAccountsUpdatedListeners . containsKey ( listener ) ) { Log . e ( TAG , "Listener-was-not-previously-added" ) ; return ; } mAccountsUpdatedListeners . remove ( listener ) ; if ( mAccountsUpdatedListeners . isEmpty ( ) ) { mContext . unregisterReceiver ( mAccountsChangedBroadcastReceiver ) ; } } } 
public OneToOne < T > removeJoinTable ( ) { childNode . removeChildren ( "join-table" ) ; return this ; } 
public String getURL ( ) { StringBuffer result = new StringBuffer ( ) ; if ( null != protocol ) { result . append ( protocol + ":" ) ; if ( null != driver ) { result . append ( driver + ":" ) ; if ( driver . equals ( "as400" ) | driver . equals ( "postgresql" ) ) { result . append ( "//" ) ; } if ( null != server ) { result . append ( server ) ; if ( null != arguments ) { for ( java . util . Enumeration e = arguments . elements ( ) ; e . hasMoreElements ( ) ; ) { result . append ( e . nextElement ( ) . toString ( ) ) ; } } } } } return result . toString ( ) ; } 
public void drawOutline ( Graphics2D g2 , CategoryPlot plot , Rectangle2D dataArea ) { float x0 = ( float ) dataArea . getX ( ) ; float x1 = x0 + ( float ) Math . abs ( this . xOffset ) ; float x3 = ( float ) dataArea . getMaxX ( ) ; float x2 = x3 - ( float ) Math . abs ( this . xOffset ) ; float y0 = ( float ) dataArea . getMaxY ( ) ; float y1 = y0 - ( float ) Math . abs ( this . yOffset ) ; float y3 = ( float ) dataArea . getMinY ( ) ; float y2 = y3 + ( float ) Math . abs ( this . yOffset ) ; GeneralPath clip = new GeneralPath ( ) ; clip . moveTo ( x0 , y0 ) ; clip . lineTo ( x0 , y2 ) ; clip . lineTo ( x1 , y3 ) ; clip . lineTo ( x3 , y3 ) ; clip . lineTo ( x3 , y1 ) ; clip . lineTo ( x2 , y0 ) ; clip . closePath ( ) ; Stroke outlineStroke = plot . getOutlineStroke ( ) ; Paint outlinePaint = plot . getOutlinePaint ( ) ; if ( ( outlineStroke != null ) && ( outlinePaint != null ) ) { g2 . setStroke ( outlineStroke ) ; g2 . setPaint ( outlinePaint ) ; g2 . draw ( clip ) ; } } 
public String toString ( ) { if ( disposition == null ) return "" ; if ( list == null ) return disposition ; StringBuffer sb = new StringBuffer ( disposition ) ; sb . append ( list . toString ( sb . length ( ) + 21 ) ) ; return sb . toString ( ) ; } 
public boolean hasJobs ( ) { if ( jobstack . size ( ) > 0 ) { return true ; } for ( int i = 0 ; i < workers . length ; i ++ ) { if ( workers [ i ] == null ) { continue ; } if ( workers [ i ] . isWorking ) { return true ; } } return false ; } 
protected static AuthenticatorDescription findAuthenticator ( AuthenticatorDescription [ ] auths , String accountType ) { for ( AuthenticatorDescription auth : auths ) { if ( accountType . equals ( auth . type ) ) { return auth ; } } throw new IllegalStateException ( "Couldn't-find-authenticator-for-specific-account-type" ) ; } 
public void addStatement ( Statement newStatement ) { statements . add ( newStatement ) ; } 
private void parseOrdering ( SourceFile file , List < SourceFile > ordering ) { for ( SourceFile dependency : file . requires ( ) . dependencies ( ) ) if ( ! ordering . contains ( dependency ) ) { parseOrdering ( dependency , ordering ) ; } ordering . add ( file ) ; } 
private Rectangle2D [ ] splitVerticalBar ( RectangularShape bar , double a , double b , double c ) { Rectangle2D [ ] result = new Rectangle2D [ 4 ] ; double x0 = bar . getMinX ( ) ; double x1 = Math . rint ( x0 + ( bar . getWidth ( ) * a ) ) ; double x2 = Math . rint ( x0 + ( bar . getWidth ( ) * b ) ) ; double x3 = Math . rint ( x0 + ( bar . getWidth ( ) * c ) ) ; result [ 0 ] = new Rectangle2D . Double ( bar . getMinX ( ) , bar . getMinY ( ) , x1 - x0 , bar . getHeight ( ) ) ; result [ 1 ] = new Rectangle2D . Double ( x1 , bar . getMinY ( ) , x2 - x1 , bar . getHeight ( ) ) ; result [ 2 ] = new Rectangle2D . Double ( x2 , bar . getMinY ( ) , x3 - x2 , bar . getHeight ( ) ) ; result [ 3 ] = new Rectangle2D . Double ( x3 , bar . getMinY ( ) , bar . getMaxX ( ) - x3 , bar . getHeight ( ) ) ; return result ; } 
public static void assertEmpty ( String message , Iterable < ? > iterable ) { if ( iterable . iterator ( ) . hasNext ( ) ) { failNotEmpty ( message , iterable . toString ( ) ) ; } } 
@ Override public void mark ( int readAheadLimit ) throws IOException { fInputStream . mark ( readAheadLimit ) ; } 
public String getMessage ( ) { return ( args == null ) ? message : Format . substitute ( message , args ) ; } 
public static void readFully ( InputStream in , byte [ ] dst , int offset , int byteCount ) throws IOException { if ( byteCount == 0 ) { return ; } if ( in == null ) { throw new NullPointerException ( "in-==-null" ) ; } if ( dst == null ) { throw new NullPointerException ( "dst-==-null" ) ; } checkOffsetAndCount ( dst . length , offset , byteCount ) ; while ( byteCount > 0 ) { int bytesRead = in . read ( dst , offset , byteCount ) ; if ( bytesRead < 0 ) { throw new EOFException ( ) ; } offset += bytesRead ; byteCount -= bytesRead ; } } 
public void deliver ( String addr , Envelope env , byte [ ] payload ) throws MTPException { HTTPAddress url ; byte [ ] request ; try { HTTPAddress host = new HTTPAddress ( addr ) ; if ( useProxy ) { url = new HTTPAddress ( proxyHost , proxyPort , false ) ; } else { url = host ; } String connPol = ( keepAlive ) ? HTTPIO . KA : HTTPIO . CLOSE ; StringBuffer boundary = new StringBuffer ( ) ; for ( int i = 0 ; i < 31 ; i ++ ) { boundary . append ( Integer . toString ( ( int ) Math . round ( Math . random ( ) * 15 ) , 16 ) ) ; } byte [ ] boundaryBytes = boundary . toString ( ) . getBytes ( "ISO-8859-1" ) ; byte [ ] body = HTTPIO . createHTTPBody ( env , boundaryBytes , payload ) ; byte [ ] header = HTTPIO . createHTTPHeader ( host , body . length , connPol , boundaryBytes , useProxy ) ; ByteArrayOutputStream requestStream = new ByteArrayOutputStream ( header . length + body . length ) ; requestStream . write ( header ) ; requestStream . write ( body ) ; requestStream . flush ( ) ; requestStream . close ( ) ; request = requestStream . toByteArray ( ) ; } catch ( Exception e ) { throw new MTPException ( e . getMessage ( ) ) ; } ka . send ( url , request ) ; } 
public static Token getToken ( int v ) { Token t = ( Token ) tokens . get ( new Integer ( v ) ) ; return t != null ? t : UNKNOWN ; } 
@ Override public V get ( Object key ) { if ( key == null ) { key = NULL_OBJECT ; } int index = findIndex ( key , elementData ) ; if ( elementData [ index ] == key ) { Object result = elementData [ index + 1 ] ; return massageValue ( result ) ; } return null ; } 
synchronized private boolean isUserLocked ( ) { sql = "SELECT-tiLocked-FROM-m_Maildrop-WHERE-iMaildropID-=-" + usersiMaildropID ; try { statement . executeQuery ( sql ) ; ResultSet rs = statement . executeQuery ( sql ) ; while ( rs . next ( ) ) { if ( rs . getInt ( "tiLocked" ) == 1 ) { return true ; } } } catch ( SQLException e ) { System . out . println ( "Error-in-SQL-Statement" ) ; e . printStackTrace ( ) ; } return false ; } 
@ Override public void update ( Graphics g , JComponent c ) { SynthContext context = getContext ( c ) ; SynthLookAndFeel . update ( context , g ) ; paintBackground ( context , g , c ) ; paint ( context , g ) ; context . dispose ( ) ; } 
public String toString ( ) { return elements . toString ( ) ; } 
public static boolean isString ( final Class < ? > cls ) { return cls . equals ( String . class ) ; } 
protected static TreeModel createTreeModel ( Object value ) { DefaultMutableTreeNode root ; if ( ( value instanceof Object [ ] ) || ( value instanceof Hashtable ) || ( value instanceof Vector ) ) { root = new DefaultMutableTreeNode ( "root" ) ; DynamicUtilTreeNode . createChildren ( root , value ) ; } else { root = new DynamicUtilTreeNode ( "root" , value ) ; } return new DefaultTreeModel ( root , false ) ; } 
public CCNode getChildByTag ( int tag ) { assert tag != kCCNodeTagInvalid : "Invalid-tag_" ; if ( children_ != null ) for ( int i = 0 ; i < children_ . size ( ) ; ++ i ) { CCNode node = children_ . get ( i ) ; if ( node . tag_ == tag ) { return node ; } } return null ; } 
private final void setSecurityProperty ( String properties , String packageList ) { if ( System . getSecurityManager ( ) != null ) { String definition = Security . getProperty ( properties ) ; if ( definition != null && definition . length ( ) > 0 ) { if ( packageList . length ( ) > 0 ) { definition = definition + ',' + packageList ; } } else { definition = packageList ; } Security . setProperty ( properties , definition ) ; } } 
private static XMLSignatureInput resolveInput ( RetrievalMethod rm , String baseURI , boolean secureValidation ) throws XMLSecurityException { Attr uri = rm . getURIAttr ( ) ; Transforms transforms = rm . getTransforms ( ) ; ResourceResolver resRes = ResourceResolver . getInstance ( uri , baseURI , secureValidation ) ; XMLSignatureInput resource = resRes . resolve ( uri , baseURI , secureValidation ) ; if ( transforms != null ) { if ( log . isLoggable ( java . util . logging . Level . FINE ) ) { log . log ( java . util . logging . Level . FINE , "We-have-Transforms" ) ; } resource = transforms . performTransforms ( resource ) ; } return resource ; } 
private void rotateRight ( Node < K , V > root ) { Node < K , V > pivot = root . left ; Node < K , V > right = root . right ; Node < K , V > pivotLeft = pivot . left ; Node < K , V > pivotRight = pivot . right ; root . left = pivotRight ; if ( pivotRight != null ) { pivotRight . parent = root ; } replaceInParent ( root , pivot ) ; pivot . right = root ; root . parent = pivot ; root . height = Math . max ( right != null ? right . height : 0 , pivotRight != null ? pivotRight . height : 0 ) + 1 ; pivot . height = Math . max ( root . height , pivotLeft != null ? pivotLeft . height : 0 ) + 1 ; } 
public static void inputToEntry ( TupleInput input , DatabaseEntry entry ) { entry . setData ( input . getBufferBytes ( ) , input . getBufferOffset ( ) , input . getBufferLength ( ) ) ; } 
public int getIntegerProperty ( String name , int defaultValue ) { Bundle bundle = this . getIntent ( ) . getExtras ( ) ; if ( bundle == null ) { return defaultValue ; } name = name . toLowerCase ( Locale . getDefault ( ) ) ; Integer p ; try { p = ( Integer ) bundle . get ( name ) ; } catch ( ClassCastException e ) { p = Integer . parseInt ( bundle . get ( name ) . toString ( ) ) ; } if ( p == null ) { return defaultValue ; } return p . intValue ( ) ; } 
public void testHashcode ( ) { Month m1 = new Month ( 2 , 2003 ) ; Month m2 = new Month ( 2 , 2003 ) ; assertTrue ( m1 . equals ( m2 ) ) ; int h1 = m1 . hashCode ( ) ; int h2 = m2 . hashCode ( ) ; assertEquals ( h1 , h2 ) ; } 
public void removeUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { return ; } mUpdateListeners . remove ( listener ) ; if ( mUpdateListeners . size ( ) == 0 ) { mUpdateListeners = null ; } } 
private Insets getParentInsets ( ) { if ( rootParent instanceof JApplet ) { return ( ( JApplet ) rootParent ) . getInsets ( ) ; } return ( ( Window ) rootParent ) . getInsets ( ) ; } 
public boolean hasAdditional ( ) { return ( m_Additional . size ( ) > 0 ) ; } 
static public void assertEquals ( String message , double expected , double actual , double delta ) { if ( Double . isInfinite ( expected ) ) { if ( ! ( expected == actual ) ) failNotEquals ( message , new Double ( expected ) , new Double ( actual ) ) ; } else if ( ! ( Math . abs ( expected - actual ) <= delta ) ) failNotEquals ( message , new Double ( expected ) , new Double ( actual ) ) ; } 
public void dragMouseMoved ( DragSourceDragEvent dsde ) { ( ( DragSourceMotionListener ) a ) . dragMouseMoved ( dsde ) ; ( ( DragSourceMotionListener ) b ) . dragMouseMoved ( dsde ) ; } 
public void setBlob ( int parameterIndex , Blob x ) throws SQLException { checkParamIndex ( parameterIndex ) ; if ( params == null ) { throw new SQLException ( "Set-initParams()-before-setBlob" ) ; } params . put ( new Integer ( parameterIndex - 1 ) , new SerialBlob ( x ) ) ; } 
public BigDecimal [ ] divideAndRemainder ( BigDecimal divisor , MathContext mc ) { if ( mc . precision == 0 ) return divideAndRemainder ( divisor ) ; BigDecimal [ ] result = new BigDecimal [ 2 ] ; BigDecimal lhs = this ; result [ 0 ] = lhs . divideToIntegralValue ( divisor , mc ) ; result [ 1 ] = lhs . subtract ( result [ 0 ] . multiply ( divisor ) ) ; return result ; } 
public IMOps orderedDither ( String threshold_map ) { String oper ; StringBuffer buf = new StringBuffer ( ) ; iCmdArgs . add ( "-ordered-dither" ) ; if ( threshold_map != null ) { buf . append ( threshold_map . toString ( ) ) ; } if ( buf . length ( ) > 0 ) { iCmdArgs . add ( buf . toString ( ) ) ; } return this ; } 
public static String getImageWorkingDirectory ( ) { return props . getProperty ( PROPERTY_CONFIG_FILE_IMAGE_DIR ) ; } 
public static synchronized void mapHostNametoIP ( String hostname , String IP ) throws UnknownHostException { if ( hostname == null || IP == null || hostname . trim ( ) . length ( ) == 0 || IP . trim ( ) . length ( ) == 0 ) { throw new IllegalArgumentException ( ) ; } InetAddress . getByName ( IP . trim ( ) ) ; mapOfHostnamesVsIPs . put ( hostname . trim ( ) . toUpperCase ( ) , IP . trim ( ) ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public Set < String > getScopeNames ( ) { log . debug ( "Children:-{}" , children ) ; Set < String > names = new HashSet < String > ( ) ; for ( IBasicScope child : children ) { names . add ( child . getName ( ) ) ; } return names ; } 
public static SizeUnit valueOf ( String type ) { return types . get ( type ) ; } 
public static BufferedImage getBufferedImage ( String imageFile , Component c ) { if ( imageFile == null || c == null ) { return null ; } BufferedImage bufferedImage = ( BufferedImage ) imageCache . get ( imageFile ) ; if ( bufferedImage != null ) { return bufferedImage ; } Image image = c . getToolkit ( ) . getImage ( imageFile ) ; MediaTracker tracker = new MediaTracker ( c ) ; tracker . addImage ( image , 0 ) ; try { tracker . waitForAll ( ) ; } catch ( InterruptedException e ) { } bufferedImage = new BufferedImage ( image . getWidth ( c ) , image . getHeight ( c ) , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g2d = bufferedImage . createGraphics ( ) ; g2d . drawImage ( image , 0 , 0 , c ) ; imageCache . put ( imageFile , bufferedImage ) ; return bufferedImage ; } 
public Object readCollection ( Element node ) throws Exception { Collection < Object > coll ; Vector < Object > v ; Vector < Element > children ; Element child ; int i ; int index ; int currIndex ; if ( DEBUG ) trace ( new Throwable ( ) , node . getAttribute ( ATT_NAME ) ) ; m_CurrentNode = node ; children = XMLDocument . getChildTags ( node ) ; v = new Vector < Object > ( ) ; index = children . size ( ) - 1 ; for ( i = 0 ; i < children . size ( ) ; i ++ ) { child = ( Element ) children . get ( i ) ; currIndex = Integer . parseInt ( child . getAttribute ( ATT_NAME ) ) ; if ( currIndex > index ) index = currIndex ; } v . setSize ( index + 1 ) ; for ( i = 0 ; i < children . size ( ) ; i ++ ) { child = ( Element ) children . get ( i ) ; v . set ( Integer . parseInt ( child . getAttribute ( ATT_NAME ) ) , invokeReadFromXML ( child ) ) ; } coll = Utils . cast ( Class . forName ( node . getAttribute ( ATT_CLASS ) ) . newInstance ( ) ) ; coll . addAll ( v ) ; return coll ; } 
public static Reader newReader ( URL url , String encoding ) throws IOException { return new InputStreamReader ( url . openStream ( ) , encoding ) ; } 
public void setBrushColor ( Color brushColor ) { Color oldBrushColor = this . brushColor ; this . brushColor = brushColor ; propertyChangeSupport . firePropertyChange ( "brushColor" , oldBrushColor , brushColor ) ; } 
@ XmlElementDecl ( namespace = "urn:hl7-org:v3" , name = "paragraph" , scope = StrucDocTd . class ) public JAXBElement < StrucDocParagraph > createStrucDocTdParagraph ( StrucDocParagraph value ) { return new JAXBElement < StrucDocParagraph > ( _StrucDocItemParagraph_QNAME , StrucDocParagraph . class , StrucDocTd . class , value ) ; } 
public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( getArg0AsString ( xctxt ) . length ( ) ) ; } 
public List < String > getNilReason ( ) { if ( nilReason == null ) { nilReason = new ArrayList < String > ( ) ; } return this . nilReason ; } 
public void startPlotThread ( ) { if ( m_plotThread == null ) { m_plotThread = new PlotThread ( ) ; m_plotThread . setPriority ( Thread . MIN_PRIORITY ) ; m_plotThread . start ( ) ; } } 
public int getResultCount ( ) { return results . size ( ) ; } 
public FileOutputStream ( String filename , boolean append ) throws FileNotFoundException { this ( new File ( filename ) , append ) ; } 
private static Socket createSocket ( InetAddress localaddr , int localport , String host , int port , int cto , SocketFactory sf , boolean useSSL ) throws IOException { Socket socket ; if ( sf != null ) socket = sf . createSocket ( ) ; else if ( useSSL ) socket = SSLSocketFactory . getDefault ( ) . createSocket ( ) ; else socket = new Socket ( ) ; if ( localaddr != null ) socket . bind ( new InetSocketAddress ( localaddr , localport ) ) ; if ( cto >= 0 ) socket . connect ( new InetSocketAddress ( host , port ) , cto ) ; else socket . connect ( new InetSocketAddress ( host , port ) ) ; return socket ; } 
public void login ( ) throws LoginException { PrivilegedExceptionAction < Void > action = new PrivilegedExceptionAction < Void > ( ) { public Void run ( ) throws LoginException { loginImpl ( ) ; return null ; } } ; try { if ( userProvidedConfig ) { AccessController . doPrivileged ( action , userContext ) ; } else { AccessController . doPrivileged ( action ) ; } } catch ( PrivilegedActionException ex ) { throw ( LoginException ) ex . getException ( ) ; } } 
public Map < T , HandlerMethod > getHandlerMethods ( ) { return Collections . unmodifiableMap ( this . handlerMethods ) ; } 
public static < T > LinkedHashMap < T , Double > getNBest ( Map < T , Double > initTable , int nbest ) { if ( nbest < 1 ) { log . warning ( "nbest-should-be->=-1,-but-is-" + nbest ) ; nbest = 1 ; } List < Map . Entry < T , Double >> entries = new ArrayList < Map . Entry < T , Double >> ( initTable . entrySet ( ) ) ; Collections . sort ( entries , ( a , b ) -> { double result = a . getValue ( ) - b . getValue ( ) ; return ( Math . abs ( result ) < 0.0001 ) ? 0 : ( int ) ( result * 10000000 ) ; } ) ; Collections . reverse ( entries ) ; LinkedHashMap < T , Double > newTable = new LinkedHashMap < T , Double > ( ) ; int nb = 0 ; for ( Map . Entry < T , Double > entry : entries ) { if ( nb < nbest ) { newTable . put ( entry . getKey ( ) , entry . getValue ( ) ) ; nb ++ ; } } return newTable ; } 
public final void removeCallback ( StatusCallback callback ) { synchronized ( callbacks ) { callbacks . remove ( callback ) ; } } 
public Dimension getMinimumSize ( JComponent c ) { Dimension result = null ; Iterator iterator = uis . iterator ( ) ; if ( iterator . hasNext ( ) ) { ComponentUI ui = ( ComponentUI ) iterator . next ( ) ; result = ui . getMinimumSize ( c ) ; } while ( iterator . hasNext ( ) ) { ComponentUI ui = ( ComponentUI ) iterator . next ( ) ; ui . getMinimumSize ( c ) ; } return result ; } 
public void fireAddTargetsEvent ( List < Village > pVillages ) { DefaultTableModel victimModel = ( DefaultTableModel ) jVictimTable . getModel ( ) ; for ( Village v : pVillages ) { if ( v != null ) { boolean contains = false ; for ( int row = 0 ; row < victimModel . getRowCount ( ) ; row ++ ) { if ( victimModel . getValueAt ( row , 1 ) . equals ( v ) ) { contains = true ; break ; } } if ( ! contains ) { int maxAttacks = 1 ; try { maxAttacks = ( Integer ) jMaxAttacksPerVillage . getValue ( ) ; } catch ( Exception e ) { maxAttacks = 1 ; } if ( v != null ) { victimModel . addRow ( new Object [ ] { v . getTribe ( ) , v , jMarkTargetAsFake . isSelected ( ) , maxAttacks , 0 } ) ; } } } } updateInfo ( ) ; ( ( DefaultTableModel ) jVictimTable . getModel ( ) ) . fireTableDataChanged ( ) ; } 
public double perplexity ( Vector document , Vector docTopics ) { double perplexity = 0 ; double norm = docTopics . norm ( 1 ) + ( docTopics . size ( ) * alpha ) ; Iterator < Vector . Element > it = document . iterateNonZero ( ) ; while ( it . hasNext ( ) ) { Vector . Element e = it . next ( ) ; int term = e . index ( ) ; double prob = 0 ; for ( int x = 0 ; x < numTopics ; x ++ ) { double d = ( docTopics . get ( x ) + alpha ) / norm ; double p = d * ( topicTermCounts . viewRow ( x ) . get ( term ) + eta ) / ( topicSums . get ( x ) + eta * numTerms ) ; prob += p ; } perplexity += e . get ( ) * Math . log ( prob ) ; } return - perplexity ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public int awaitAdvanceInterruptibly ( int phase ) throws InterruptedException { final Phaser root = this . root ; long s = ( root == this ) ? state : reconcileState ( ) ; int p = ( int ) ( s >>> PHASE_SHIFT ) ; if ( phase < 0 ) return phase ; if ( p == phase ) { QNode node = new QNode ( this , phase , true , false , 0L ) ; p = root . internalAwaitAdvance ( phase , node ) ; if ( node . wasInterrupted ) throw new InterruptedException ( ) ; } return p ; } 
public boolean equals ( Expression other ) { if ( other == this ) { return true ; } if ( other == null ) { return false ; } if ( opType != ( ( Expression ) other ) . opType ) { return false ; } return column == ( ( Expression ) other ) . getColumn ( ) ; } 
@ Deprecated public static String getAMPMString ( int ampm ) { return LocaleData . get ( Locale . getDefault ( ) ) . amPm [ ampm - Calendar . AM ] ; } 
public List < Object > getAny ( ) { if ( any == null ) { any = new ArrayList < Object > ( ) ; } return this . any ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public static int codePointAt ( char [ ] a , int index , int limit ) { if ( index >= limit || limit < 0 || limit > a . length ) { throw new IndexOutOfBoundsException ( ) ; } return codePointAtImpl ( a , index , limit ) ; } 
private String newUniqueMemberName ( String name , String descriptor ) { return name . equals ( ClassConstants . INTERNAL_METHOD_NAME_INIT ) ? ClassConstants . INTERNAL_METHOD_NAME_INIT : name + ClassConstants . SPECIAL_MEMBER_SEPARATOR + Long . toHexString ( Math . abs ( ( descriptor ) . hashCode ( ) ) ) ; } 
public Version getVersion ( ) { Version version = new Version ( ) ; version . major = Version . VIDEOEDITOR_MAJOR_VERSION ; version . minor = Version . VIDEOEDITOR_MINOR_VERSION ; version . revision = Version . VIDEOEDITOR_REVISION_VERSION ; return version ; } 
public IRCEventListener getEventHandler ( Type type ) { return stratMap . get ( type ) ; } 
public void jsxSet_height ( final String width ) { setWidthOrHeight ( "height" , width , ! getBrowserVersion ( ) . hasFeature ( BrowserVersionFeatures . GENERATED_101 ) ) ; } 
public static void savePPM ( OutputStream out , int [ ] pels , int w , int h ) throws IOException { BufferedOutputStream bout = new BufferedOutputStream ( out ) ; DataOutputStream fout = new DataOutputStream ( bout ) ; fout . writeByte ( 'P' ) ; fout . writeByte ( '6' ) ; fout . writeByte ( '|n' ) ; fout . writeBytes ( String . valueOf ( w ) ) ; fout . writeByte ( '-' ) ; fout . writeBytes ( String . valueOf ( h ) ) ; fout . writeByte ( '|n' ) ; fout . writeBytes ( String . valueOf ( 255 ) ) ; fout . writeByte ( '|n' ) ; int size = w * h ; byte [ ] tmp = new byte [ 3 * size ] ; for ( int i = 0 , j = 0 ; i < size ; i ++ , j += 3 ) { tmp [ j ] = ( byte ) ( ( pels [ i ] & 0xff0000 ) >> 16 ) ; tmp [ j + 1 ] = ( byte ) ( ( pels [ i ] & 0xff00 ) >> 8 ) ; tmp [ j + 2 ] = ( byte ) ( ( pels [ i ] & 0xff ) ) ; } fout . write ( tmp , 0 , 3 * size ) ; } 
public synchronized void close ( ) throws IOException { isClosed = true ; localAddress = Inet4Address . ANY ; impl . close ( ) ; } 
public List < TaxesType > getTaxes ( ) { if ( taxes == null ) { taxes = new ArrayList < TaxesType > ( ) ; } return this . taxes ; } 
public synchronized int getConnectionCount ( ) { return connections . size ( ) ; } 
public void testActiveCount_NewThreads ( ) { ThreadGroup group = new ThreadGroup ( "new" ) ; new Thread ( group , "t1" ) ; new Thread ( group , "t2" ) ; new Thread ( group , "t3" ) ; assertEquals ( 0 , group . activeCount ( ) ) ; } 
protected void appendLabel ( final Label l ) { if ( labelNames == null ) { labelNames = new HashMap < Label , String > ( ) ; } String name = labelNames . get ( l ) ; if ( name == null ) { name = "L" + labelNames . size ( ) ; labelNames . put ( l , name ) ; } buf . append ( name ) ; } 
@ XmlElementDecl ( namespace = "http://schemas.xmlsoap.org/soap/envelope/" , name = "Header" ) public JAXBElement < Header > createHeader ( Header value ) { return new JAXBElement < Header > ( _Header_QNAME , Header . class , null , value ) ; } 
public static SourceFile [ ] toSourceFiles ( File [ ] javaFiles ) { return toSourceFiles ( asList ( javaFiles ) ) ; } 
public Object getDataElements ( int x , int y , int w , int h , Object outData ) { return sampleModel . getDataElements ( x - sampleModelTranslateX , y - sampleModelTranslateY , w , h , outData , dataBuffer ) ; } 
public String getTokenTypeAsTargetLabel ( int ttype ) { if ( grammar . type == Grammar . LEXER ) { String name = grammar . getTokenDisplayName ( ttype ) ; return target . getTargetCharLiteralFromANTLRCharLiteral ( this , name ) ; } return target . getTokenTypeAsTargetLabel ( this , ttype ) ; } 
private static void postProcess ( List < Group > groups ) { for ( Iterator < Group > iter = groups . iterator ( ) ; iter . hasNext ( ) ; ) { Group group = iter . next ( ) ; if ( group . isEmpty ( ) ) iter . remove ( ) ; logger . info ( "{}" , group ) ; } } 
public BigInteger remainder ( BigInteger divisor ) { BigInt remainder = new BigInt ( ) ; BigInt . division ( getBigInt ( ) , divisor . getBigInt ( ) , null , remainder ) ; return new BigInteger ( remainder ) ; } 
public ClassLoader getClassLoader ( ) { if ( this . isPrimitive ( ) ) { return null ; } ClassLoader loader = getClassLoaderImpl ( ) ; if ( loader == null ) { loader = BootClassLoader . getInstance ( ) ; } return loader ; } 
public static String readAsciiLine ( InputStream in ) throws IOException { StringBuilder result = new StringBuilder ( 80 ) ; while ( true ) { int c = in . read ( ) ; if ( c == - 1 ) { throw new EOFException ( ) ; } else if ( c == '|n' ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > 0 && result . charAt ( length - 1 ) == '|r' ) { result . setLength ( length - 1 ) ; } return result . toString ( ) ; } 
public static void matToBitmap ( Mat mat , Bitmap bmp ) { matToBitmap ( mat , bmp , false ) ; } 
@ SuppressWarnings ( "unchecked" ) @ Override public Object clone ( ) { HashMap < K , V > result ; try { result = ( HashMap < K , V > ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new InternalError ( e ) ; } result . reinitialize ( ) ; result . putMapEntries ( this , false ) ; return result ; } 
public void addItemOrderedNrcInputRequest ( ItemSubRequestParent inputRequest ) { if ( irList == null ) { irList = new ArrayList ( ) ; } HashMap inReq = new HashMap ( ) ; inReq . put ( "RequestId" , inputRequest . getRequestId ( ) ) ; inReq . put ( "RelationshipId" , "Item_OrderedNrc_Ref" ) ; irList . add ( inReq ) ; } 
public boolean addIfAbsent ( E e ) { lock . lock ( ) ; try { E [ ] data ; E [ ] old = getData ( ) ; int size = old . length ; if ( size != 0 ) { if ( indexOf ( e ) >= 0 ) { return false ; } } data = newElementArray ( size + 1 ) ; System . arraycopy ( old , 0 , data , 0 , size ) ; data [ size ] = e ; setData ( data ) ; return true ; } finally { lock . unlock ( ) ; } } 
void addVerifyListener ( VerifyListener listener ) { checkWidget ( ) ; if ( listener == null ) error ( SWT . ERROR_NULL_ARGUMENT ) ; TypedListener typedListener = new TypedListener ( listener ) ; addListener ( SWT . Verify , typedListener ) ; } 
public Calendar getCalendar ( ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( new Date ( getDate ( ) ) ) ; return calendar ; } 
private static void addListeners ( ) { inputTextField . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent e ) { push ( inputTextField . getText ( ) ) ; CommandHandler . parse ( inputTextField . getText ( ) ) ; inputTextField . setText ( "" ) ; } } ) ; } 
public BigDecimal divide ( BigDecimal divisor , int scale , RoundingMode roundingMode ) { return divide ( divisor , scale , roundingMode . oldMode ) ; } 
public void add ( String fieldName , String value ) { if ( fieldName == null ) throw new IllegalArgumentException ( "fieldname-==-null" ) ; if ( value == null ) throw new IllegalArgumentException ( "value-==-null" ) ; if ( fieldName . length ( ) == 0 || fieldName . indexOf ( '|0' ) != - 1 || value . indexOf ( '|0' ) != - 1 ) { throw new IllegalArgumentException ( "Unexpected-header:-" + fieldName + ":-" + value ) ; } addLenient ( fieldName , value ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public double getLogLikelihood ( ) { if ( updateMatrix ) { if ( ! Utils . connectedAndWellConditioned ( probability , this ) ) { return Double . NEGATIVE_INFINITY ; } } return 0 ; } 
@ UsedForTesting @ Nullable public static byte [ ] hexStringToByteArray ( @ Nullable final String hexString ) { if ( isEmpty ( hexString ) ) { return null ; } final int N = hexString . length ( ) ; if ( N % 2 != 0 ) { throw new NumberFormatException ( "Input-hex-string-length-must-be-an-even-number." + "-Length-=-" + N ) ; } final byte [ ] bytes = new byte [ N / 2 ] ; for ( int i = 0 ; i < N ; i += 2 ) { bytes [ i / 2 ] = ( byte ) ( ( Character . digit ( hexString . charAt ( i ) , 16 ) << 4 ) + Character . digit ( hexString . charAt ( i + 1 ) , 16 ) ) ; } return bytes ; } 
public boolean isBefore ( OffsetTime other ) { return toEpochNano ( ) < other . toEpochNano ( ) ; } 
public static String getURLBasePath ( String url ) { int start = url . indexOf ( '/' , url . indexOf ( "://" ) + 3 ) ; int end = url . lastIndexOf ( '/' ) ; if ( start != - 1 && end > start ) { return url . substring ( start , end + 1 ) ; } return "/" ; } 
public static Object extractDatabaseMetaData ( DataSource dataSource , final String metaDataMethodName ) throws MetaDataAccessException { return extractDatabaseMetaData ( dataSource , new DatabaseMetaDataCallback ( ) { @ Override public Object processMetaData ( DatabaseMetaData dbmd ) throws SQLException , MetaDataAccessException { try { Method method = DatabaseMetaData . class . getMethod ( metaDataMethodName , ( Class [ ] ) null ) ; return method . invoke ( dbmd , ( Object [ ] ) null ) ; } catch ( NoSuchMethodException ex ) { throw new MetaDataAccessException ( "No-method-named-'" + metaDataMethodName + "'-found-on-DatabaseMetaData-instance-[" + dbmd + "]" , ex ) ; } catch ( IllegalAccessException ex ) { throw new MetaDataAccessException ( "Could-not-access-DatabaseMetaData-method-'" + metaDataMethodName + "'" , ex ) ; } catch ( InvocationTargetException ex ) { if ( ex . getTargetException ( ) instanceof SQLException ) { throw ( SQLException ) ex . getTargetException ( ) ; } throw new MetaDataAccessException ( "Invocation-of-DatabaseMetaData-method-'" + metaDataMethodName + "'-failed" , ex ) ; } } } ) ; } 
public Map < String , Object > buildCriteriaMap ( String fieldName , Object fieldValue ) { Map < String , Object > fieldsToMatch = new HashMap < String , Object > ( ) ; fieldsToMatch . put ( fieldName , fieldValue ) ; return fieldsToMatch ; } 
public static void setOutputDir ( String path ) { outputDir = new File ( path ) ; } 
@ XmlElementDecl ( namespace = "urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2" , name = "ConsumerUnitQuantity" ) public JAXBElement < ConsumerUnitQuantityType > createConsumerUnitQuantity ( ConsumerUnitQuantityType value ) { return new JAXBElement < ConsumerUnitQuantityType > ( _ConsumerUnitQuantity_QNAME , ConsumerUnitQuantityType . class , null , value ) ; } 
private boolean isParentIcon ( ) { if ( rootParent instanceof JFrame ) { return ( ( ( JFrame ) rootParent ) . getExtendedState ( ) & Frame . ICONIFIED ) != 0 ; } else { return false ; } } 
public void test6_7_5_3s18 ( ) throws Exception { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( "int-(*apfi[3])(int-*x,-int-*y);-" ) ; parseCandCPP ( buffer . toString ( ) , true , 0 ) ; } 
public BaseField getField ( String fieldName ) { return fieldMap . get ( fieldName ) ; } 
public void print ( char ch ) { print ( String . valueOf ( ch ) ) ; } 
public String toVString ( String ind , boolean usenhi ) { Vector infolist = null ; String rtrnh = null ; String str = ind + "RL-----------Router-Links-" ; for ( Enumeration enum1 = RouterLink . keys ( ) ; enum1 . hasMoreElements ( ) ; ) { rtrnh = ( String ) enum1 . nextElement ( ) ; infolist = ( Vector ) RouterLink . get ( rtrnh ) ; if ( ! infolist . isEmpty ( ) ) { str += ind + "RL-" + rtrnh + "-router-" + rtrnh + "---->-" ; str += linksToString ( infolist , ind + "RL-" + rtrnh + "-.-" , usenhi ) ; } } str += ind + "AE-----------AS-External-Links-" ; for ( Enumeration enum1 = ASExt . keys ( ) ; enum1 . hasMoreElements ( ) ; ) { rtrnh = ( String ) enum1 . nextElement ( ) ; infolist = ( Vector ) ASExt . get ( rtrnh ) ; if ( ! infolist . isEmpty ( ) ) { str += ind + "AE-" + rtrnh + "-router-" + rtrnh + "---->-" ; str += linksToString ( infolist , ind + "AE-" + rtrnh + "-.-" , usenhi ) ; } } return str ; } 
public void beginClearText ( int hashAlgorithm ) throws IOException { String hash ; switch ( hashAlgorithm ) { case HashAlgorithmTags . SHA1 : hash = "SHA1" ; break ; case HashAlgorithmTags . SHA256 : hash = "SHA256" ; break ; case HashAlgorithmTags . SHA384 : hash = "SHA384" ; break ; case HashAlgorithmTags . SHA512 : hash = "SHA512" ; break ; case HashAlgorithmTags . MD2 : hash = "MD2" ; break ; case HashAlgorithmTags . MD5 : hash = "MD5" ; break ; case HashAlgorithmTags . RIPEMD160 : hash = "RIPEMD160" ; break ; default : throw new IOException ( "unknown-hash-algorithm-tag-in-beginClearText:-" + hashAlgorithm ) ; } String armorHdr = "-----BEGIN-PGP-SIGNED-MESSAGE-----" + nl ; String hdrs = "Hash:-" + hash + nl + nl ; for ( int i = 0 ; i != armorHdr . length ( ) ; i ++ ) { out . write ( armorHdr . charAt ( i ) ) ; } for ( int i = 0 ; i != hdrs . length ( ) ; i ++ ) { out . write ( hdrs . charAt ( i ) ) ; } clearText = true ; newLine = true ; lastb = 0 ; } 
private void establishConnection ( Socket socket ) throws XMPPException , IOException { DataOutputStream out = new DataOutputStream ( socket . getOutputStream ( ) ) ; DataInputStream in = new DataInputStream ( socket . getInputStream ( ) ) ; int b = in . read ( ) ; if ( b != 5 ) { throw new XMPPException ( "Only-SOCKS5-supported" ) ; } b = in . read ( ) ; byte [ ] auth = new byte [ b ] ; in . readFully ( auth ) ; byte [ ] authMethodSelectionResponse = new byte [ 2 ] ; authMethodSelectionResponse [ 0 ] = ( byte ) 0x05 ; boolean noAuthMethodFound = false ; for ( int i = 0 ; i < auth . length ; i ++ ) { if ( auth [ i ] == ( byte ) 0x00 ) { noAuthMethodFound = true ; break ; } } if ( ! noAuthMethodFound ) { authMethodSelectionResponse [ 1 ] = ( byte ) 0xFF ; out . write ( authMethodSelectionResponse ) ; out . flush ( ) ; throw new XMPPException ( "Authentication-method-not-supported" ) ; } authMethodSelectionResponse [ 1 ] = ( byte ) 0x00 ; out . write ( authMethodSelectionResponse ) ; out . flush ( ) ; byte [ ] connectionRequest = Socks5Utils . receiveSocks5Message ( in ) ; String responseDigest = new String ( connectionRequest , 5 , connectionRequest [ 4 ] ) ; connectionRequest [ 1 ] = ( byte ) 0x00 ; out . write ( connectionRequest ) ; out . flush ( ) ; Socks5TestProxy . this . connectionMap . put ( responseDigest , socket ) ; } 
public synchronized void add ( Date x , double y ) { super . add ( x . getTime ( ) , y ) ; } 
public T first ( ) throws EmptyCollectionException { if ( isEmpty ( ) ) throw new EmptyCollectionException ( "list" ) ; return list [ 0 ] ; } 
public void removeLookupProviderListener ( String number , LookupProviderListener listener ) { log ( "removeLookupProviderListener(" + number + ",-" + listener + ")" ) ; if ( TextUtils . isEmpty ( number ) ) { return ; } if ( mLookupListeners . containsKey ( number ) ) { mLookupListeners . get ( number ) . remove ( listener ) ; } } 
private long getTotalDuration ( ) { if ( mMarkers . size ( ) == 0 ) { return 0 ; } long first = mMarkers . get ( 0 ) . time ; long last = mMarkers . get ( mMarkers . size ( ) - 1 ) . time ; return last - first ; } 
private final String getPathStr ( String t ) { if ( t == null || t . equals ( "/" ) ) { return "" ; } return t ; } 
public int hashCode ( ) { return uri . hashCode ( ) ; } 
private JButton getMyInfoButton ( ) { if ( myInfoButton == null ) { myInfoButton = new JButton ( ) { private static final long serialVersionUID = 1L ; { setContentAreaFilled ( false ) ; setOpaque ( false ) ; } public void paintComponent ( Graphics g ) { g . setColor ( Color . blue ) ; ImageIcon img = null ; img = new ImageIcon ( "images/buttonbg.png" ) ; g . drawImage ( img . getImage ( ) , 0 , 0 , null ) ; super . paintComponent ( g ) ; } } ; myInfoButton . setBounds ( new Rectangle ( 200 , 32 , 82 , 32 ) ) ; myInfoButton . setVisible ( false ) ; myInfoButton . setCursor ( Cursor . getPredefinedCursor ( Cursor . HAND_CURSOR ) ) ; myInfoButton . addActionListener ( new java . awt . event . ActionListener ( ) { public void actionPerformed ( java . awt . event . ActionEvent e ) { if ( reviseInformationFrame == null ) { reviseInformationFrame = new ReviseInformationFrame ( ) ; } reviseInformationFrame . setVisible ( true ) ; reviseInformationFrame . setInformation ( Login . person . getMyInformation ( ) ) ; } } ) ; } return myInfoButton ; } 
public Group getGroup ( String groupName ) { if ( ! hasGroup ( groupName ) ) return null ; return groups . get ( groupName . toLowerCase ( ) ) ; } 
public static Set < Role > getByPermissionNameLabel ( Connection c , String label ) throws BadServerResponse , XenAPIException , XmlRpcException { String method_call = "role.get_by_permission_name_label" ; String session = c . getSessionReference ( ) ; Object [ ] method_params = { Marshalling . toXMLRPC ( session ) , Marshalling . toXMLRPC ( label ) } ; Map response = c . dispatch ( method_call , method_params ) ; Object result = response . get ( "Value" ) ; return Types . toSetOfRole ( result ) ; } 
public void addItem ( BasicBlock item ) { workList . add ( item ) ; } 
public String generateHostBasedRealm ( ) { String rlm = null ; if ( this . url != null ) { try { URL tmp = new URL ( this . url ) ; rlm = tmp . getHost ( ) ; if ( tmp . getPort ( ) >= 0 ) rlm += ":" + tmp . getPort ( ) ; } catch ( MalformedURLException e ) { } } return rlm ; } 
public boolean getUseStaticCatalog ( ) { if ( useStaticCatalog == null ) { useStaticCatalog = new Boolean ( queryUseStaticCatalog ( ) ) ; } return useStaticCatalog . booleanValue ( ) ; } 
public Enumeration listOptions ( ) { Vector newVector = new Vector ( 6 ) ; newVector . addElement ( new Option ( "-Specifies-if-inverse-of-selection-is-to-be-output.-" , "V" , 0 , "-V" ) ) ; newVector . addElement ( new Option ( "-Specifies-number-of-folds-dataset-is-split-into.-" + "-(default-10)-" , "N" , 1 , "-N-<number-of-folds>" ) ) ; newVector . addElement ( new Option ( "-Specifies-which-fold-is-selected.-(default-1)-" , "F" , 1 , "-F-<fold>" ) ) ; newVector . addElement ( new Option ( "-Specifies-random-number-seed.-(default-0,-no-randomizing)-" , "S" , 1 , "-S-<seed>" ) ) ; return newVector . elements ( ) ; } 
@ Override public boolean equals ( Object x ) { return ( ( x instanceof MathContext ) && ( ( ( MathContext ) x ) . getPrecision ( ) == precision ) && ( ( ( MathContext ) x ) . getRoundingMode ( ) == roundingMode ) ) ; } 
public void init ( ServletConfig config ) throws ServletException { super . init ( config ) ; initTime = new java . util . Date ( ) . toString ( ) ; hitCount = 0 ; } 
public boolean hasBOM ( ByteOrderMark bom ) throws IOException { if ( ! boms . contains ( bom ) ) { throw new IllegalArgumentException ( "Stream-not-configure-to-detect-" + bom ) ; } return byteOrderMark != null && getBOM ( ) . equals ( bom ) ; } 
public void stateChanged ( ChangeEvent e ) { if ( changeListeners != null ) { Vector listeners = changeListeners ; int count = listeners . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { ( ( ChangeListener ) listeners . elementAt ( i ) ) . stateChanged ( e ) ; } } } 
private static < T extends Comparable < T >> void sort ( List < T > list ) { int size = list . size ( ) ; for ( int i = 1 ; i < size ; i ++ ) { for ( int j = i ; j > 0 ; j -- ) { T a = list . get ( j ) ; T b = list . get ( j - 1 ) ; if ( a . compareTo ( b ) < 0 ) { list . set ( j - 1 , a ) ; list . set ( j , b ) ; } else { break ; } } } } 
boolean sameInputMethod ( InputMethodLocator other ) { if ( other == this ) { return true ; } if ( other == null ) { return false ; } if ( ! descriptor . getClass ( ) . equals ( other . descriptor . getClass ( ) ) ) { return false ; } if ( loader == null && other . loader != null || loader != null && ! loader . equals ( other . loader ) ) { return false ; } return true ; } 
private void saveProgress ( ) { if ( modified && fileName != null ) { if ( JOptionPane . YES_OPTION == JOptionPane . showConfirmDialog ( frame , new JLabel ( "Save-progress-with-" + fileName + "-?" ) , "Unsaved-Progress" , JOptionPane . YES_NO_OPTION ) ) { saveToFile ( fileName ) ; } } } 
public void setGetAutoPaymentsForAccountResult ( JAXBElement < ArrayOfAutoPayment > value ) { this . getAutoPaymentsForAccountResult = ( ( JAXBElement < ArrayOfAutoPayment > ) value ) ; } 
private void init ( ) { runnerThread = Thread . currentThread ( ) ; keepAlive = true ; try { socket . setTcpNoDelay ( true ) ; dataInput = new DataInputStream ( new BufferedInputStream ( socket . getInputStream ( ) ) ) ; dataOutput = new DataOutputStream ( socket . getOutputStream ( ) ) ; int firstInt = handshake ( ) ; switch ( streamProtocol ) { case HSQL_STREAM_PROTOCOL : if ( firstInt != ClientConnection . NETWORK_COMPATIBILITY_VERSION_INT ) { if ( firstInt == - 1900000 ) { firstInt = - 2000000 ; } String verString = ClientConnection . toNetCompVersionString ( firstInt ) ; throw Error . error ( null , ErrorCode . SERVER_VERSIONS_INCOMPATIBLE , 0 , new String [ ] { verString , HsqlDatabaseProperties . hsqldb_version } ) ; } Result resultIn = Result . newResult ( dataInput , rowIn ) ; resultIn . readAdditionalResults ( session , dataInput , rowIn ) ; Result resultOut ; resultOut = setDatabase ( resultIn ) ; resultOut . write ( session , dataOutput , rowOut ) ; break ; case ODBC_STREAM_PROTOCOL : odbcConnect ( firstInt ) ; break ; default : keepAlive = false ; } } catch ( Exception e ) { StringBuffer sb = new StringBuffer ( mThread + ":Failed-to-connect-client." ) ; if ( user != null ) { sb . append ( "-User-'" + user + "'." ) ; } server . printWithThread ( sb . toString ( ) + "-Stack-trace-follows." ) ; server . printStackTrace ( e ) ; } } 
public static boolean isAlphabets ( String obj ) { return obj . matches ( "[-A-Za-z]+" ) ; } 
@ Override public void setAttribute ( String name , Object value ) { if ( name == null ) { throw new IllegalArgumentException ( sm . getString ( "coyoteRequest.setAttribute.namenull" ) ) ; } if ( value == null ) { removeAttribute ( name ) ; return ; } SpecialAttributeAdapter adapter = specialAttributes . get ( name ) ; if ( adapter != null ) { adapter . set ( this , name , value ) ; return ; } if ( Globals . IS_SECURITY_ENABLED && name . equals ( Globals . SENDFILE_FILENAME_ATTR ) ) { String canonicalPath ; try { canonicalPath = new File ( value . toString ( ) ) . getCanonicalPath ( ) ; } catch ( IOException e ) { throw new SecurityException ( sm . getString ( "coyoteRequest.sendfileNotCanonical" , value ) , e ) ; } System . getSecurityManager ( ) . checkRead ( canonicalPath ) ; value = canonicalPath ; } Object oldValue = attributes . put ( name , value ) ; if ( name . startsWith ( "org.apache.tomcat." ) ) { coyoteRequest . setAttribute ( name , value ) ; } notifyAttributeAssigned ( name , value , oldValue ) ; } 
private final HistoryRecord moveActivityToFrontLocked ( int where ) { HistoryRecord newTop = ( HistoryRecord ) mHistory . remove ( where ) ; int top = mHistory . size ( ) ; HistoryRecord oldTop = ( HistoryRecord ) mHistory . get ( top - 1 ) ; mHistory . add ( top , newTop ) ; oldTop . frontOfTask = false ; newTop . frontOfTask = true ; return newTop ; } 
public void applyFacets ( XSFacets facets , short presentFacet , short fixedFacet , ValidationContext context ) throws InvalidDatatypeFacetException { if ( context == null ) { context = fEmptyContext ; } applyFacets ( facets , presentFacet , fixedFacet , SPECIAL_PATTERN_NONE , context ) ; } 
protected void fireValueChanged ( TreeSelectionEvent e ) { Object [ ] listeners = listenerList . getListenerList ( ) ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == TreeSelectionListener . class ) { ( ( TreeSelectionListener ) listeners [ i + 1 ] ) . valueChanged ( e ) ; } } } 
public static Token newToken ( int ofKind , String image ) { switch ( ofKind ) { default : return new Token ( ofKind , image ) ; } } 
public static String getExtension ( String name ) { int i = name . lastIndexOf ( '.' ) ; if ( i == - 1 ) { return "" ; } return name . substring ( i + 1 , name . length ( ) ) ; } 
@ Deprecated protected String getPostParamsEncoding ( ) { return getParamsEncoding ( ) ; } 
private boolean linkLast ( Node < E > node ) { if ( count >= capacity ) return false ; Node < E > l = last ; node . prev = l ; last = node ; if ( first == null ) first = node ; else l . next = node ; ++ count ; notEmpty . signal ( ) ; return true ; } 
public Object [ ] getMarkerTypes ( ) { org . simonme . tracer . logger . Tracer . traceMethodInvoke ( ) ; return types . toArray ( ) ; } 
public long getLoginId ( String login ) throws AgentNotKnownException { Long result = htLogin2UserIds . get ( login ) ; if ( result != null ) return result ; throw new AgentNotKnownException ( "No-agent-registered-for-login:-" + login ) ; } 
public List < Object > getAny ( ) { if ( any == null ) { any = new ArrayList < Object > ( ) ; } return this . any ; } 
public void translateTo ( ClassGenerator classGen , MethodGenerator methodGen , StringType type ) { final ConstantPoolGen cpg = classGen . getConstantPool ( ) ; final InstructionList il = methodGen . getInstructionList ( ) ; il . append ( DUP ) ; final BranchHandle ifNull = il . append ( new IFNULL ( null ) ) ; il . append ( new INVOKEVIRTUAL ( cpg . addMethodref ( _javaClassName , "toString" , "()" + STRING_SIG ) ) ) ; final BranchHandle gotobh = il . append ( new GOTO ( null ) ) ; ifNull . setTarget ( il . append ( POP ) ) ; il . append ( new PUSH ( cpg , "" ) ) ; gotobh . setTarget ( il . append ( NOP ) ) ; } 
public static String newClusterID ( ) { return "CID-" + UUID . randomUUID ( ) . toString ( ) ; } 
public boolean check ( boolean request ) { reqPermissions = new ArrayList < String > ( ) ; reqExplainIds = new ArrayList < Integer > ( ) ; checkPermission ( ) ; if ( reqPermissions . size ( ) > 0 ) { if ( request ) requestPermissions ( ) ; return false ; } return true ; } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; elementList . add ( new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2012-08-15/" , "groupId" ) ) ; if ( localGroupId != null ) { elementList . add ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( localGroupId ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "groupId-cannot-be-null!!" ) ; } elementList . add ( new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2012-08-15/" , "ipPermissions" ) ) ; if ( localIpPermissions == null ) { throw new org . apache . axis2 . databinding . ADBException ( "ipPermissions-cannot-be-null!!" ) ; } elementList . add ( localIpPermissions ) ; return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
public void addReflectedScene ( final Spatial renderNode ) { if ( renderNode == null ) { return ; } if ( ! renderList . contains ( renderNode ) ) { renderList . add ( renderNode ) ; } } 
public double getDensity ( double x ) { int k = ( int ) Math . rint ( x ) ; return comb ( type1Size , k ) * comb ( populationSize - type1Size , sampleSize - k ) / c ; } 
public int breakText ( String text , boolean measureForwards , float maxWidth , float [ ] measuredWidth ) { if ( text == null ) { throw new IllegalArgumentException ( "text-cannot-be-null" ) ; } if ( text . length ( ) == 0 ) { return 0 ; } if ( ! mHasCompatScaling ) { return native_breakText ( text , measureForwards , maxWidth , mBidiFlags , measuredWidth ) ; } final float oldSize = getTextSize ( ) ; setTextSize ( oldSize * mCompatScaling ) ; int res = native_breakText ( text , measureForwards , maxWidth * mCompatScaling , mBidiFlags , measuredWidth ) ; setTextSize ( oldSize ) ; if ( measuredWidth != null ) measuredWidth [ 0 ] *= mInvCompatScaling ; return res ; } 
public static int randColor ( ) { return randColor ( new Random ( ) ) ; } 
public void delete ( ) throws IOException { if ( ResponseCache . getDefault ( ) == this ) { ResponseCache . setDefault ( null ) ; } delegate . getCache ( ) . delete ( ) ; } 
public void checkSystemSetting ( ) { if ( ! mEnabled ) { return ; } try { int val = mSystemSettings . getInt ( mContentResolver , System . HAPTIC_FEEDBACK_ENABLED , 0 ) ; mSettingEnabled = val != 0 ; } catch ( Resources . NotFoundException nfe ) { Log . e ( TAG , "Could-not-retrieve-system-setting." , nfe ) ; mSettingEnabled = false ; } } 
public List < IconType > getIcon ( ) { if ( icon == null ) { icon = new ArrayList < IconType > ( ) ; } return this . icon ; } 
private void closeAllOpenStatements ( ) throws SQLException { SQLException postponedException = null ; if ( this . openStatements != null ) { List < Statement > currentlyOpenStatements = new ArrayList < Statement > ( ) ; for ( Iterator < Statement > iter = this . openStatements . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { currentlyOpenStatements . add ( iter . next ( ) ) ; } int numStmts = currentlyOpenStatements . size ( ) ; for ( int i = 0 ; i < numStmts ; i ++ ) { StatementImpl stmt = ( StatementImpl ) currentlyOpenStatements . get ( i ) ; try { stmt . realClose ( false , true ) ; } catch ( SQLException sqlEx ) { postponedException = sqlEx ; } } if ( postponedException != null ) { throw postponedException ; } } } 
public static double toDouble ( Object obj ) throws JMSException { if ( obj == null || obj instanceof Float || obj instanceof Double ) return ( ( Number ) obj ) . doubleValue ( ) ; else if ( obj == null || obj instanceof String ) return Double . parseDouble ( ( String ) obj ) ; else throw new MessageFormatException ( L . l ( "can't-convert-'{0}'-to-double" , obj . getClass ( ) . getName ( ) ) ) ; } 
public static void v ( String tag , String s , Object ... args ) { if ( LOG . VERBOSE >= LOGLEVEL ) Log . v ( tag , String . format ( s , args ) ) ; } 
public static String getName ( int codePoint ) { checkValidCodePoint ( codePoint ) ; if ( getType ( codePoint ) == Character . UNASSIGNED ) { return null ; } String result = getNameImpl ( codePoint ) ; if ( result == null ) { String blockName = Character . UnicodeBlock . of ( codePoint ) . toString ( ) . replace ( '_' , '-' ) ; result = blockName + "-" + IntegralToString . intToHexString ( codePoint , true , 0 ) ; } return result ; } 
public int getTargetIndex ( Location location ) { for ( int x = 0 ; x < targets . size ( ) ; x ++ ) if ( targets . get ( x ) . getLocation ( ) != null && targets . get ( x ) . getLocation ( ) . getYCoord ( ) == location . getYCoord ( ) && targets . get ( x ) . getLocation ( ) . getXCoord ( ) == location . getXCoord ( ) ) return x ; return - 1 ; } 
public static int solveQuadratic ( double [ ] eqn ) { return solveQuadratic ( eqn , eqn ) ; } 
public List < String > getClazzs ( ) { if ( clazzs == null ) { clazzs = new ArrayList < String > ( ) ; } return this . clazzs ; } 
public void setLoadNativeLibraries ( Configuration conf , boolean loadNativeLibraries ) { conf . setBoolean ( CommonConfigurationKeys . IO_NATIVE_LIB_AVAILABLE_KEY , loadNativeLibraries ) ; } 
public static List < Response > executeBatchAndWait ( RequestBatch requests ) { Validate . notEmptyAndContainsNoNulls ( requests , "requests" ) ; HttpURLConnection connection = null ; try { connection = toHttpConnection ( requests ) ; } catch ( Exception ex ) { List < Response > responses = Response . constructErrorResponses ( requests . getRequests ( ) , null , new FacebookException ( ex ) ) ; runCallbacks ( requests , responses ) ; return responses ; } List < Response > responses = executeConnectionAndWait ( connection , requests ) ; return responses ; } 
public void addBundle ( Integer bundleId , String bundleName , String bundleDescription ) { if ( BreadcrumbsAdapter . DEBUG ) { Log . d ( TAG , "addBundle(Integer-" + bundleId + ",-String-" + bundleName + ",-String-" + bundleDescription + ")" ) ; } if ( ! sBundleMappings . containsKey ( bundleId ) ) { sBundleMappings . put ( bundleId , new HashMap < String , String > ( ) ) ; } if ( ! sBundlesWithTracks . containsKey ( bundleId ) ) { sBundlesWithTracks . put ( bundleId , new ArrayList < Integer > ( ) ) ; } sBundleMappings . get ( bundleId ) . put ( NAME , bundleName ) ; sBundleMappings . get ( bundleId ) . put ( DESCRIPTION , bundleDescription ) ; setChanged ( ) ; notifyObservers ( ) ; } 
public StringBuilder encodeBody ( StringBuilder buffer ) { return buffer . append ( rSeqNumber ) . append ( SP ) . append ( cSeqNumber ) . append ( SP ) . append ( method ) ; } 
public int getMinimum ( ) { checkWidget ( ) ; SCROLLINFO info = new SCROLLINFO ( ) ; info . cbSize = SCROLLINFO . sizeof ; info . fMask = OS . SIF_RANGE ; int hwnd = hwndScrollBar ( ) ; int type = scrollBarType ( ) ; OS . GetScrollInfo ( hwnd , type , info ) ; return info . nMin ; } 
public final boolean trySuccess ( final T value ) { return _state . get ( ) . trySuccess ( value ) ; } 
@ XmlElementDecl ( namespace = "http://echa.europa.eu/schemas/iuclid5/20130101" , name = "otherValue" , scope = Substance . IdentifiedUses . ProfessionalWorkers . Use . ExposureDescriptions . ExposureDescription . class ) public JAXBElement < String > createSubstanceIdentifiedUsesProfessionalWorkersUseExposureDescriptionsExposureDescriptionOtherValue ( String value ) { return new JAXBElement < String > ( _SubstanceUsesAdvisedAgainstConsumersUseSectorUsesSectorUseOtherValue_QNAME , String . class , Substance . IdentifiedUses . ProfessionalWorkers . Use . ExposureDescriptions . ExposureDescription . class , value ) ; } 
public com . google . protobuf . ByteString getInputFormatBytes ( ) { java . lang . Object ref = inputFormat_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; inputFormat_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; elementList . add ( new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2010-11-15/" , "vpnGatewayId" ) ) ; if ( localVpnGatewayId != null ) { elementList . add ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( localVpnGatewayId ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "vpnGatewayId-cannot-be-null!!" ) ; } elementList . add ( new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2010-11-15/" , "vpcId" ) ) ; if ( localVpcId != null ) { elementList . add ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( localVpcId ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "vpcId-cannot-be-null!!" ) ; } return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
public static boolean templateExists ( String templateName ) { int index = templateName . lastIndexOf ( '.' ) ; if ( index > 0 ) { String ext = templateName . substring ( index + 1 ) ; if ( ! ext . equals ( "tex" ) ) { templateName += ".tex" ; } } else { templateName += ".tex" ; } URL templ = TexlipsePlugin . getDefault ( ) . getBundle ( ) . getEntry ( SYSTEM_TEMPLATES_DIR + "/" + templateName ) ; if ( templ != null ) { return true ; } File userTemplateFolder = getUserTemplateFolder ( ) ; return new File ( userTemplateFolder , templateName ) . exists ( ) ; } 
private Collection < ClassDoc > subclasses ( ClassDoc cd ) { Collection < ClassDoc > ret = classToSubclass . get ( cd . qualifiedName ( ) ) ; if ( ret == null ) { ret = new TreeSet < ClassDoc > ( ) ; List < ClassDoc > subs = classtree . subclasses ( cd ) ; if ( subs != null ) { ret . addAll ( subs ) ; for ( Iterator < ClassDoc > it = subs . iterator ( ) ; it . hasNext ( ) ; ) { ret . addAll ( subclasses ( it . next ( ) ) ) ; } } addAll ( classToSubclass , cd , ret ) ; } return ret ; } 
public int getplaylistID ( ) { return Dispatch . get ( this , "playlistID" ) . toInt ( ) ; } 
public short acceptNode ( int n , XPathContext xctxt ) { try { xctxt . pushCurrentNode ( n ) ; xctxt . pushIteratorRoot ( m_context ) ; if ( DEBUG ) { System . out . println ( "traverser:-" + m_traverser ) ; System . out . print ( "node:-" + n ) ; System . out . println ( ",-" + m_cdtm . getNodeName ( n ) ) ; System . out . println ( "pattern:-" + m_pattern . toString ( ) ) ; m_pattern . debugWhatToShow ( m_pattern . getWhatToShow ( ) ) ; } XObject score = m_pattern . execute ( xctxt ) ; if ( DEBUG ) { System . out . println ( "score:-" + score ) ; System . out . println ( "skip:-" + ( score == NodeTest . SCORE_NONE ) ) ; } return ( score == NodeTest . SCORE_NONE ) ? DTMIterator . FILTER_SKIP : DTMIterator . FILTER_ACCEPT ; } catch ( javax . xml . transform . TransformerException se ) { throw new RuntimeException ( se . getMessage ( ) ) ; } finally { xctxt . popCurrentNode ( ) ; xctxt . popIteratorRoot ( ) ; } } 
public SharedPreferences getSharedPreferences ( ) { if ( mSharedPreferences == null ) { mSharedPreferences = mContext . getSharedPreferences ( mSharedPreferencesName , mSharedPreferencesMode ) ; } return mSharedPreferences ; } 
public CallableStatement ( MySQLConnection conn , String sql , String catalog , boolean isFunctionCall ) throws SQLException { super ( conn , sql , catalog ) ; this . callingStoredFunction = isFunctionCall ; if ( ! this . callingStoredFunction ) { if ( ! StringUtils . startsWithIgnoreCaseAndWs ( sql , "CALL" ) ) { fakeParameterTypes ( false ) ; } else { determineParameterTypes ( ) ; } generateParameterMap ( ) ; } else { determineParameterTypes ( ) ; generateParameterMap ( ) ; this . parameterCount += 1 ; } this . retrieveGeneratedKeys = true ; } 
public Enumeration getDeclaredPrefixes ( ) { return currentContext . getDeclaredPrefixes ( ) ; } 
private static String toJava ( Class classRep ) { return classRep . isArray ( ) ? toJava ( classRep . getComponentType ( ) ) + "[]" : classRep . getName ( ) ; } 
public int getStartOffset ( ) { Element elem = pos . current ( ) ; if ( elem != null ) { return elem . getStartOffset ( ) ; } return - 1 ; } 
public boolean contains ( lalr_item itm ) { return _all . containsKey ( itm ) ; } 
public ConfigurationsBuilder put ( String key , double value ) { configurations . put ( key , value ) ; return this ; } 
private void signalNotEmpty ( ) { final ReentrantLock takeLock = this . takeLock ; takeLock . lock ( ) ; try { notEmpty . signal ( ) ; } finally { takeLock . unlock ( ) ; } } 
public static int hashCode ( Object ... objects ) { return Arrays . hashCode ( objects ) ; } 
public void removeAttribute ( String attributeName ) { attributeMap . remove ( attributeName ) ; } 
private Session ( String applicationId , SessionState state , AccessToken tokenInfo , Date lastAttemptedTokenExtendDate , boolean shouldAutoPublish , AuthorizationRequest pendingAuthorizationRequest ) { this . applicationId = applicationId ; this . state = state ; this . tokenInfo = tokenInfo ; this . lastAttemptedTokenExtendDate = lastAttemptedTokenExtendDate ; this . pendingAuthorizationRequest = pendingAuthorizationRequest ; handler = new Handler ( Looper . getMainLooper ( ) ) ; currentTokenRefreshRequest = null ; tokenCachingStrategy = null ; callbacks = new ArrayList < StatusCallback > ( ) ; } 
public static < V > Map < String , V > lowercaseKeys ( Map < String , V > map ) { Map < String , V > result = new HashMap < String , V > ( map . size ( ) ) ; for ( Map . Entry < String , V > entry : map . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( result . containsKey ( key . toLowerCase ( ) ) ) { throw new IllegalArgumentException ( "Duplicate-string-key-in-map-when-lower-casing" ) ; } result . put ( key . toLowerCase ( ) , entry . getValue ( ) ) ; } return result ; } 
private synchronized void sendHandshake ( ) throws IOException { ByteBuffer tempBuffer = ByteBuffer . allocate ( JdwpPacket . HANDSHAKE_LEN ) ; JdwpPacket . putHandshake ( tempBuffer ) ; int expectedLength = tempBuffer . position ( ) ; tempBuffer . flip ( ) ; if ( mChannel . write ( tempBuffer ) != expectedLength ) { throw new IOException ( "partial-handshake-write" ) ; } expectedLength = mPreDataBuffer . position ( ) ; if ( expectedLength > 0 ) { Log . d ( "ddms" , "Sending-" + mPreDataBuffer . position ( ) + "-bytes-of-saved-data" ) ; mPreDataBuffer . flip ( ) ; if ( mChannel . write ( mPreDataBuffer ) != expectedLength ) { throw new IOException ( "partial-pre-data-write" ) ; } mPreDataBuffer . clear ( ) ; } } 
public Set < Object > getMBeansFromURL ( URL url ) throws ServiceNotFoundException { if ( url == null ) { throw new ServiceNotFoundException ( "The-specified-URL-is-null" ) ; } return getMBeansFromURL ( url . toString ( ) ) ; } 
public static boolean canParse ( InputStream input ) throws IOException { try { LineReader reader = new LineReader ( input ) ; Text buffer = new Text ( ) ; return reader . readLine ( buffer ) != 0 && buffer . toString ( ) . equals ( "Meta-VERSION="1"-." ) ; } catch ( EOFException e ) { return false ; } } 
protected static PreparedStatement getInstance ( MySQLConnection conn , String sql , String catalog , ParseInfo cachedParseInfo ) throws SQLException { if ( ! Util . isJdbc4 ( ) ) { return new PreparedStatement ( conn , sql , catalog , cachedParseInfo ) ; } return ( PreparedStatement ) Util . handleNewInstance ( JDBC_4_PSTMT_4_ARG_CTOR , new Object [ ] { conn , sql , catalog , cachedParseInfo } , conn . getExceptionInterceptor ( ) ) ; } 
public static QRCode encode ( String content , ErrorCorrectionLevel ecLevel ) throws WriterException { return encode ( content , ecLevel , null ) ; } 
public static double hypot ( double x , double y ) { return StrictMath . hypot ( x , y ) ; } 
public static byte [ ] read ( InputStream input ) { return OctetSeqHelper . read ( input ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public byte [ ] getPostBody ( ) throws AuthFailureError { Map < String , String > postParams = getPostParams ( ) ; if ( postParams != null && postParams . size ( ) > 0 ) { return encodeParameters ( postParams , getPostParamsEncoding ( ) ) ; } return null ; } 
public void writeVNCChallengeResponseMsg ( byte [ ] response ) throws IOException { os . write ( response ) ; } 
private JButton getBrowseButton ( ) { if ( browseButton == null ) { browseButton = new JButton ( ) ; browseButton . setMargin ( new Insets ( 0 , 0 , 0 , 0 ) ) ; browseButton . setText ( "" ) ; browseButton . setToolTipText ( i18n . str ( "browse_" ) ) ; browseButton . setMnemonic ( KeyEvent . VK_UNDEFINED ) ; browseButton . setIcon ( UIUtils . getIcon ( UIUtils . X16 , "import.png" ) ) ; browseButton . setPreferredSize ( new Dimension ( 21 , 21 ) ) ; browseButton . addActionListener ( new BrowseHandler ( ) ) ; } return browseButton ; } 
private MRAImpl ( Code c ) { this . code = c ; this . isSafeMethod = isSafeMethod ( code . getMethod ( ) ) ; this . bbf = new BasicBlock . Factory ( code , cfger ) ; this . bb2pre = new HashMap ( ) ; this . bb2post = new HashMap ( ) ; analyze ( ) ; this . bb2post = null ; } 
protected boolean loadedByThisOrChild ( Class clazz ) { boolean result = false ; for ( ClassLoader classLoader = clazz . getClassLoader ( ) ; null != classLoader ; classLoader = classLoader . getParent ( ) ) { if ( classLoader . equals ( this ) ) { result = true ; break ; } } return result ; } 
void slide_numGuests_stateChanged ( ChangeEvent e ) { lbl_guestCount . setText ( Integer . toString ( slide_numGuests . getValue ( ) ) ) ; } 
public String getModifiedString ( ) { String tmp = "" ; try { return DateFormat . getDateInstance ( DateFormat . SHORT ) . format ( modified ) ; } catch ( NullPointerException e ) { } return tmp ; } 
final long fn ( long v , long x ) { return Double . doubleToRawLongBits ( Double . longBitsToDouble ( v ) + Double . longBitsToDouble ( x ) ) ; } 
public static RepaintManager currentManager ( JComponent c ) { return currentManager ( ( Component ) c ) ; } 
@ Override public String getPlotType ( ) { return localizationResources . getString ( "Fast_Scatter_Plot" ) ; } 
@ Override public void run ( ) { int cycle = 1 ; for ( int i = 0 ; i < 10 ; i ++ ) { System . out . printf ( "Producer:-Cycle-%d-" , cycle ) ; for ( int j = 0 ; j < 10 ; j ++ ) { String message = "Event-" + ( ( i * 10 ) + j ) ; System . out . printf ( "Producer:-%s-" , message ) ; buffer . add ( message ) ; } try { buffer = exchanger . exchange ( buffer ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } System . out . printf ( "Producer:-%d-" , buffer . size ( ) ) ; cycle ++ ; } } 
public void testGetPropertyInfo ( ) throws Exception { new Driver ( ) . getPropertyInfo ( "" , null ) ; } 
public int size ( ) { return map . size ( ) ; } 
public java . lang . String removeOutageCalendarAt ( final int index ) { java . lang . Object obj = this . _outageCalendarList . remove ( index ) ; return ( java . lang . String ) obj ; } 
public Text append ( char c ) { return text ( text + c ) ; } 
public int getCurrentIndex ( ) throws DisplayIsFullException { int currentIndex = elements . indexOf ( null ) ; if ( currentIndex < 0 || currentIndex > capacity ) throw new DisplayIsFullException ( "case-not-handled" ) ; return currentIndex ; } 
public int lookupString ( String str ) { Index index = ( Index ) string_table . get ( str ) ; return ( index != null ) ? index . index : - 1 ; } 
private void grow ( ) { m_allocatedSize *= 2 ; boolean newVector [ ] = new boolean [ m_allocatedSize ] ; System . arraycopy ( m_values , 0 , newVector , 0 , m_index + 1 ) ; m_values = newVector ; } 
public List < SecurityCheckedParameter > getParametarsByName ( String paramName ) { List < SecurityCheckedParameter > paramsList = new ArrayList < SecurityCheckedParameter > ( ) ; for ( SecurityCheckedParameter param : params ) { if ( param . getName ( ) . equals ( paramName ) ) { paramsList . add ( param ) ; } } return paramsList ; } 
public void addNotify ( ) { synchronized ( getTreeLock ( ) ) { super . addNotify ( ) ; addNotifyContainerChildren ( ) ; } } 
@ Override public void clear ( ) { count = 0 ; Arrays . fill ( keys , null ) ; Arrays . fill ( values , null ) ; } 
public List < FieldType > getField ( ) { if ( field == null ) { field = new ArrayList < FieldType > ( ) ; } return this . field ; } 
public int getHeight ( ) { return image . getHeight ( null ) ; } 
public static BoxedValueHelper getHelper ( Class clazz , String codebase , String repId ) { String className = null ; if ( clazz != null ) { className = clazz . getName ( ) ; if ( codebase == null ) codebase = Util . getCodebase ( clazz ) ; } else { if ( repId != null ) className = RepositoryId . cache . getId ( repId ) . getClassName ( ) ; if ( className == null ) throw wrapper . unableLocateValueHelper ( CompletionStatus . COMPLETED_MAYBE ) ; } try { ClassLoader clazzLoader = ( clazz == null ? null : clazz . getClassLoader ( ) ) ; Class helperClass = loadClassForClass ( className + "Helper" , codebase , clazzLoader , clazz , clazzLoader ) ; return ( BoxedValueHelper ) helperClass . newInstance ( ) ; } catch ( ClassNotFoundException cnfe ) { throw wrapper . unableLocateValueHelper ( CompletionStatus . COMPLETED_MAYBE , cnfe ) ; } catch ( IllegalAccessException iae ) { throw wrapper . unableLocateValueHelper ( CompletionStatus . COMPLETED_MAYBE , iae ) ; } catch ( InstantiationException ie ) { throw wrapper . unableLocateValueHelper ( CompletionStatus . COMPLETED_MAYBE , ie ) ; } catch ( ClassCastException cce ) { throw wrapper . unableLocateValueHelper ( CompletionStatus . COMPLETED_MAYBE , cce ) ; } } 
public void reap ( ) { Reference < ? > zombie ; while ( ( zombie = queue . poll ( ) ) != null ) { backingStore . remove ( zombie ) ; } } 
public String toString ( int n ) { StringBuilder buff = new StringBuilder ( "[" ) ; int sz = objects . size ( ) ; if ( n > sz ) { n = sz ; } int i ; for ( i = 0 ; i < n ; i ++ ) { E e = objects . get ( i ) ; buff . append ( i ) . append ( "=" ) . append ( e ) ; if ( i < ( sz - 1 ) ) buff . append ( "," ) ; } if ( i < sz ) buff . append ( "..." ) ; buff . append ( "]" ) ; return buff . toString ( ) ; } 
public String realPath ( ) { return getFullPath ( ) ; } 
protected JMenuBar createMenuBar ( ) { menuBar = new SystemMenuBar ( ) ; menuBar . setFocusable ( false ) ; menuBar . setBorderPainted ( true ) ; menuBar . add ( createMenu ( ) ) ; return menuBar ; } 
public void intersectPermittedSubtree ( ASN1Sequence permitted ) { Map subtreesMap = new HashMap ( ) ; for ( Enumeration e = permitted . getObjects ( ) ; e . hasMoreElements ( ) ; ) { GeneralSubtree subtree = GeneralSubtree . getInstance ( e . nextElement ( ) ) ; Integer tagNo = Integer . valueOf ( subtree . getBase ( ) . getTagNo ( ) ) ; if ( subtreesMap . get ( tagNo ) == null ) { subtreesMap . put ( tagNo , new HashSet ( ) ) ; } ( ( Set ) subtreesMap . get ( tagNo ) ) . add ( subtree ) ; } for ( Iterator it = subtreesMap . entrySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; switch ( ( ( Integer ) entry . getKey ( ) ) . intValue ( ) ) { case 1 : permittedSubtreesEmail = intersectEmail ( permittedSubtreesEmail , ( Set ) entry . getValue ( ) ) ; break ; case 2 : permittedSubtreesDNS = intersectDNS ( permittedSubtreesDNS , ( Set ) entry . getValue ( ) ) ; break ; case 4 : permittedSubtreesDN = intersectDN ( permittedSubtreesDN , ( Set ) entry . getValue ( ) ) ; break ; case 6 : permittedSubtreesURI = intersectURI ( permittedSubtreesURI , ( Set ) entry . getValue ( ) ) ; break ; case 7 : permittedSubtreesIP = intersectIP ( permittedSubtreesIP , ( Set ) entry . getValue ( ) ) ; } } } 
public void disableLogging ( ) { simulationsToLog . clear ( ) ; final Control [ ] allControls = composite . getChildren ( ) ; for ( final Control element : allControls ) { if ( element instanceof LoggerControl ) { final LoggerControl loggerControl = ( LoggerControl ) element ; loggerControl . remove ( ) ; } else element . dispose ( ) ; } statusLabel . setText ( MONITOR_OFF_TEXT ) ; statusLabel . setBackground ( offColor ) ; loggingOn = false ; loggerOnButton . setSelection ( false ) ; loggerOffButton . setSelection ( true ) ; } 
public void marshal ( final Exchange exchange , final Object graph , final OutputStream stream ) throws Exception { final Message message = exchange . getIn ( ) ; final File file = message . getBody ( File . class ) ; final String fileName = file . getName ( ) ; final InputStream is = exchange . getContext ( ) . getTypeConverter ( ) . convertTo ( InputStream . class , graph ) ; final ZipOutputStream zipOutput = new ZipOutputStream ( stream ) ; zipOutput . setLevel ( compressionLevel ) ; try { zipOutput . putNextEntry ( new ZipEntry ( fileName ) ) ; } catch ( IOException e ) { throw new IllegalStateException ( "Error-while-adding-a-new-Zip-File-Entry-(File-name:-'" + fileName + "')." , e ) ; } IOHelper . copy ( is , zipOutput ) ; zipOutput . close ( ) ; } 
public String nextToken ( ) { if ( currentPosition >= maxPosition ) { throw new NoSuchElementException ( ) ; } int start = currentPosition ; while ( ( currentPosition < maxPosition ) && Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) { currentPosition ++ ; } if ( ( start == currentPosition ) && ( ! Character . isLetterOrDigit ( str . charAt ( currentPosition ) ) ) ) { currentPosition ++ ; } return str . substring ( start , currentPosition ) ; } 
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; } 
@ Override public void removeMapping ( String mapping ) { try { mappingsLock . writeLock ( ) . lock ( ) ; mappings . remove ( mapping ) ; } finally { mappingsLock . writeLock ( ) . unlock ( ) ; } if ( parent . getState ( ) . equals ( LifecycleState . STARTED ) ) fireContainerEvent ( REMOVE_MAPPING_EVENT , mapping ) ; } 
public void dispatchDisplayHint ( int hint ) { onDisplayHint ( hint ) ; } 
public Token emit ( ) { Token t = new CommonToken ( input , state . type , state . channel , state . tokenStartCharIndex , getCharIndex ( ) - 1 ) ; t . setLine ( state . tokenStartLine ) ; t . setText ( state . text ) ; t . setCharPositionInLine ( state . tokenStartCharPositionInLine ) ; emit ( t ) ; return t ; } 
@ Override public boolean accept ( File file ) { String name = file . getName ( ) ; for ( int i = 0 ; i < this . prefixes . length ; i ++ ) { if ( caseSensitivity . checkStartsWith ( name , prefixes [ i ] ) ) { return true ; } } return false ; } 
public void setOmitXMLDeclaration ( boolean b ) { m_handler . setOmitXMLDeclaration ( b ) ; } 
public List < FxAnnotateCommon > getAnnotates ( ) { if ( annotates == null ) { annotates = new ArrayList < FxAnnotateCommon > ( ) ; } return this . annotates ; } 
public boolean isPrimitive ( ) { Class < ? > t = getTypeInternal ( ) ; return t != null && t . isPrimitive ( ) ; } 
public static void execute ( Runnable runnable ) { sDefaultExecutor . execute ( runnable ) ; } 
public List < BroadcastEventType > getBroadcastEvent ( ) { if ( broadcastEvent == null ) { broadcastEvent = new ArrayList < BroadcastEventType > ( ) ; } return this . broadcastEvent ; } 
public List < Long > getNewPortWwns ( ) { if ( newPortWwns == null ) { newPortWwns = new ArrayList < Long > ( ) ; } return this . newPortWwns ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public byte [ ] getProgram ( ) { try { if ( program != null ) return Arrays . copyOf ( program , program . length ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; for ( ScriptChunk chunk : chunks ) { chunk . write ( bos ) ; } program = bos . toByteArray ( ) ; return program ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } 
public ConnectionResult connect ( Map < Sha256Hash , Transaction > transactions , ConnectMode mode ) { Transaction tx = transactions . get ( outpoint . getHash ( ) ) ; if ( tx == null ) { return TransactionInput . ConnectionResult . NO_SUCH_TX ; } return connect ( tx , mode ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
private String getTimeTilNextTest ( int word_level , long milliseconds ) { String o = ( String ) elt_vector . get ( word_level ) ; int i = Integer . parseInt ( o ) ; int screen_lvl = i ; long exclude_time = ( screen_lvl * day ) ; Date now = new Date ( ) ; long this_instant = now . getTime ( ) ; long exclude_period = ( milliseconds + exclude_time ) ; return ( new Long ( exclude_period ) . toString ( ) ) ; } 
public boolean getActive ( ) { return ( BooleanUtility . getBoolean ( ( Boolean ) getCachedValue ( TaskField . ACTIVE ) ) ) ; } 
public List < AGREEMENT > getAGREEMENT ( ) { if ( agreement == null ) { agreement = new ArrayList < AGREEMENT > ( ) ; } return this . agreement ; } 
public static String getAsReference ( String value ) { if ( value . length ( ) < 2 ) { return "" ; } value = value . substring ( 1 , value . length ( ) ) ; return value ; } 
public String [ ] getAttributeNames ( ) { Vector names = new Vector ( ) ; Enumeration keys = attributes . keys ( ) ; while ( keys . hasMoreElements ( ) ) { names . addElement ( ( String ) keys . nextElement ( ) ) ; } String results [ ] = new String [ names . size ( ) ] ; for ( int i = 0 ; i < results . length ; i ++ ) { results [ i ] = ( String ) names . elementAt ( i ) ; } return ( results ) ; } 
public double maxAbs ( int i0 , int i1 , int j ) { double m = Math . abs ( A [ i0 ] [ j ] ) ; for ( int i = i0 + 1 ; i <= i1 ; i ++ ) { m = Math . max ( m , Math . abs ( A [ i ] [ j ] ) ) ; } return m ; } 
public Object createSourcefolder ( ) { Path path = new Path ( getProject ( ) ) ; mSourceList . add ( path ) ; return path ; } 
public int getAccessibleChildrenCount ( ) { return List . this . getItemCount ( ) ; } 
public boolean tryTransfer ( E e ) { return xfer ( e , true , NOW , 0 ) == null ; } 
public int increaseSwipeInvalidMotionCounter ( ) { return increaseCounter ( SWIPE_INVALID_MOTION_COUNTER_ID ) ; } 
Synthetic ( int name_index , int length , DataInputStream file , ConstantPool constant_pool ) throws IOException { this ( name_index , length , ( byte [ ] ) null , constant_pool ) ; if ( length > 0 ) { bytes = new byte [ length ] ; file . readFully ( bytes ) ; System . err . println ( "Synthetic-attribute-with-length->-0" ) ; } } 
public static TemplateParameterMatch newMutableMatch ( final Classifier pElem ) { return new Mutable ( pElem ) ; } 
private static BufferedImage overlayEcho ( BufferedImage image , float echoAlpha , int offsetX , int offsetY ) { int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; offsetX = offsetY = 0 ; BufferedImage negated = getNegated ( image ) ; BufferedImage result = SubstanceCoreUtilities . getBlankImage ( width , height ) ; Graphics2D graphics = ( Graphics2D ) result . getGraphics ( ) . create ( ) ; graphics . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , 0.2f * echoAlpha * echoAlpha * echoAlpha ) ) ; graphics . drawImage ( negated , offsetX - 1 , offsetY - 1 , null ) ; graphics . drawImage ( negated , offsetX + 1 , offsetY - 1 , null ) ; graphics . drawImage ( negated , offsetX - 1 , offsetY + 1 , null ) ; graphics . drawImage ( negated , offsetX + 1 , offsetY + 1 , null ) ; graphics . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , 0.7f * echoAlpha * echoAlpha * echoAlpha ) ) ; graphics . drawImage ( negated , offsetX , offsetY - 1 , null ) ; graphics . drawImage ( negated , offsetX , offsetY + 1 , null ) ; graphics . drawImage ( negated , offsetX - 1 , offsetY , null ) ; graphics . drawImage ( negated , offsetX + 1 , offsetY , null ) ; graphics . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , 1.0f ) ) ; graphics . drawImage ( image , 0 , 0 , null ) ; graphics . dispose ( ) ; return result ; } 
public List < PhysicsMaterial > getPhysicsMaterials ( ) { if ( physicsMaterials == null ) { physicsMaterials = new ArrayList < PhysicsMaterial > ( ) ; } return this . physicsMaterials ; } 
public String property ( String name , Properties props ) { return props . getProperty ( name ) ; } 
public Dimension getMinimumSize ( JComponent a ) { Dimension returnValue = uis . elementAt ( 0 ) . getMinimumSize ( a ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { uis . elementAt ( i ) . getMinimumSize ( a ) ; } return returnValue ; } 
private void clear ( ) { for ( int key : mapTextField . keySet ( ) ) { mapTextField . get ( key ) . setText ( "" ) ; } imageCanvas . mapFocus . clear ( ) ; } 
private Data addData ( final Data data ) { datas . add ( data ) ; return data ; } 
@ Override public Collection < FailedPageInfo > findFailedWebResourceSortedByOccurrence ( WebResource webResource , Audit audit , int nbOfResults ) { StringBuilder queryString = new StringBuilder ( ) ; queryString . append ( SELECT_STR ) ; queryString . append ( URL_FIELD_STR ) ; queryString . append ( COMA_CHAR ) ; queryString . append ( ID_WEB_RESOURCE_FIELD_STR ) ; queryString . append ( COMA_CHAR ) ; queryString . append ( INVALID_TEST_STR ) ; queryString . append ( COMA_CHAR ) ; queryString . append ( FAILED_OCCURRENCES_STR ) ; queryString . append ( TOP_N_INVALID_URL_QUERY ) ; queryString . append ( ORDER_BY_STR ) ; queryString . append ( FAILED_OCCURRENCES_STR ) ; queryString . append ( DESC_STR ) ; queryString . append ( COMA_CHAR ) ; queryString . append ( INVALID_TEST_STR ) ; queryString . append ( DESC_STR ) ; queryString . append ( PARAMETRABLE_LIMIT_STR ) ; Query query = entityManager . createNativeQuery ( queryString . toString ( ) ) ; query . setParameter ( "idAudit" , audit . getId ( ) ) ; query . setParameter ( "nbOfResult" , nbOfResults ) ; try { List < Object [ ] > result = ( List < Object [ ] > ) query . getResultList ( ) ; if ( result . isEmpty ( ) ) { return Collections . EMPTY_SET ; } return convertRawResultAsFailedPageInfo ( result ) ; } catch ( NoResultException e ) { return Collections . EMPTY_SET ; } } 
public Complex multiply ( Complex c ) { Complex a = copy ( ) ; r = a . r * c . r - a . i * c . i ; i = a . r * c . i + a . i * c . r ; return this ; } 
public static String trim ( CharSequence s ) { if ( s == null ) { return null ; } return trimWhitespace ( s ) . toString ( ) ; } 
public static long getFreeDiskSpace ( boolean checkInternal ) { String status = Environment . getExternalStorageState ( ) ; long freeSpace = 0 ; if ( status . equals ( Environment . MEDIA_MOUNTED ) ) { freeSpace = freeSpaceCalculation ( Environment . getExternalStorageDirectory ( ) . getPath ( ) ) ; } else if ( checkInternal ) { freeSpace = freeSpaceCalculation ( "/" ) ; } else { return - 1 ; } return freeSpace ; } 
public List < VehicleSearchRequest > getRequest ( ) { if ( request == null ) { request = new ArrayList < VehicleSearchRequest > ( ) ; } return this . request ; } 
public OutputStream getOutputStream ( ) throws IOException { checkOpenAndCreate ( false ) ; if ( isOutputShutdown ( ) ) { throw new SocketException ( "Socket-output-is-shutdown" ) ; } return impl . getOutputStream ( ) ; } 
public Object readDimension ( Element node ) throws Exception { Object result ; Vector children ; Element child ; int i ; double width ; double height ; String name ; if ( DEBUG ) trace ( new Throwable ( ) , node . getAttribute ( ATT_NAME ) ) ; m_CurrentNode = node ; result = null ; children = XMLDocument . getChildTags ( node ) ; width = 0 ; height = 0 ; for ( i = 0 ; i < children . size ( ) ; i ++ ) { child = ( Element ) children . get ( i ) ; name = child . getAttribute ( ATT_NAME ) ; if ( name . equals ( VAL_WIDTH ) ) width = readDoubleFromXML ( child ) ; else if ( name . equals ( VAL_HEIGHT ) ) height = readDoubleFromXML ( child ) ; else System . out . println ( Messages . getInstance ( ) . getString ( "XMLBeans_ReadDimension_Text_First" ) + name + Messages . getInstance ( ) . getString ( "XMLBeans_ReadDimension_Text_Second" ) + node . getAttribute ( ATT_NAME ) + Messages . getInstance ( ) . getString ( "XMLBeans_ReadDimension_Text_Third" ) ) ; } result = new Dimension ( ) ; ( ( Dimension ) result ) . setSize ( width , height ) ; return result ; } 
public void insertInOrder ( int value ) { for ( int i = 0 ; i < m_firstFree ; i ++ ) { if ( value < m_map [ i ] ) { insertElementAt ( value , i ) ; return ; } } addElement ( value ) ; } 
public ObjectInputStream ( InputStream input ) throws StreamCorruptedException , IOException { this . input = ( input instanceof DataInputStream ) ? ( DataInputStream ) input : new DataInputStream ( input ) ; primitiveTypes = new DataInputStream ( this ) ; enableResolve = false ; this . subclassOverridingImplementation = false ; resetState ( ) ; nestedLevels = 0 ; primitiveData = this . input ; readStreamHeader ( ) ; primitiveData = emptyStream ; } 
private void pruneIfNeeded ( int neededSpace ) { if ( ( mTotalSize + neededSpace ) < mMaxCacheSizeInBytes ) { return ; } if ( VolleyLog . DEBUG ) { VolleyLog . v ( "Pruning-old-cache-entries." ) ; } long before = mTotalSize ; int prunedFiles = 0 ; long startTime = SystemClock . elapsedRealtime ( ) ; Iterator < Map . Entry < String , CacheHeader >> iterator = mEntries . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , CacheHeader > entry = iterator . next ( ) ; CacheHeader e = entry . getValue ( ) ; boolean deleted = getFileForKey ( e . key ) . delete ( ) ; if ( deleted ) { mTotalSize -= e . size ; } else { VolleyLog . d ( "Could-not-delete-cache-entry-for-key=%s,-filename=%s" , e . key , getFilenameForKey ( e . key ) ) ; } iterator . remove ( ) ; prunedFiles ++ ; if ( ( mTotalSize + neededSpace ) < mMaxCacheSizeInBytes * HYSTERESIS_FACTOR ) { break ; } } if ( VolleyLog . DEBUG ) { VolleyLog . v ( "pruned-%d-files,-%d-bytes,-%d-ms" , prunedFiles , ( mTotalSize - before ) , SystemClock . elapsedRealtime ( ) - startTime ) ; } } 
public static String format ( String format , Object ... args ) { if ( args != null ) { for ( int i = 0 ; i < args . length ; i ++ ) { if ( args [ i ] == null ) { args [ i ] = "null" ; } } } return new MessageFormat ( format ) . format ( args ) ; } 
public List < SearchColumnStringField > getIsInactive ( ) { if ( isInactive == null ) { isInactive = new ArrayList < SearchColumnStringField > ( ) ; } return this . isInactive ; } 
public static ImageDescriptor getImageDescriptor ( String path ) { return imageDescriptorFromPlugin ( PLUGIN_ID , path ) ; } 
private static String spacesForString ( String s ) { if ( s == null || s . length ( ) == 0 ) { return "" ; } return String . format ( "%1$-" + s . length ( ) + "s" , "" ) ; } 
@ Override public final SelectableChannel configureBlocking ( boolean blockingMode ) throws IOException { if ( isOpen ( ) ) { synchronized ( blockingLock ) { if ( isBlocking == blockingMode ) { return this ; } if ( blockingMode && containsValidKeys ( ) ) { throw new IllegalBlockingModeException ( ) ; } implConfigureBlocking ( blockingMode ) ; isBlocking = blockingMode ; } return this ; } throw new ClosedChannelException ( ) ; } 
public byte [ ] mock ( ) throws IOException { final File outdir = Files . createTempDir ( ) ; final File input = File . createTempFile ( "input" , ".java" ) ; FileUtils . writeStringToFile ( input , this . source ) ; final ProcessBuilder builder = new ProcessBuilder ( "javac" , "-d" , outdir . getPath ( ) , input . getPath ( ) ) ; final Process process = builder . start ( ) ; try { process . waitFor ( ) ; } catch ( final InterruptedException ex ) { throw new IllegalStateException ( ex ) ; } finally { input . delete ( ) ; } if ( process . exitValue ( ) != 0 ) { throw new IllegalStateException ( String . format ( "Failed-to-compile-'%s':%n%s" , this . source , IOUtils . toString ( process . getErrorStream ( ) ) ) ) ; } final byte [ ] bytes = this . findIn ( outdir ) ; Logger . debug ( this , "#mock():-produced-%d-bytes-in-bytecode-for-'%s'" , bytes . length , this . source ) ; FileUtils . deleteDirectory ( outdir ) ; return bytes ; } 
protected void enterFullscreenForVideoLayer ( int layerId , String url ) { if ( mWebView == null ) return ; Message message = Message . obtain ( mWebView . mPrivateHandler , WebView . ENTER_FULLSCREEN_VIDEO , layerId , 0 ) ; message . obj = url ; message . sendToTarget ( ) ; } 
public DatabaseConnection ( ) throws Exception { m_DatabaseURL = PROPERTIES . getProperty ( "jdbcURL" , "jdbc:idb=experiments.prp" ) ; String uctn = PROPERTIES . getProperty ( "checkUpperCaseNames" ) ; if ( uctn . equals ( "true" ) ) { m_checkForUpperCaseNames = true ; } else { m_checkForUpperCaseNames = false ; } uctn = PROPERTIES . getProperty ( "setAutoCommit" ) ; if ( uctn . equals ( "true" ) ) { m_setAutoCommit = true ; } else { m_setAutoCommit = false ; } uctn = PROPERTIES . getProperty ( "createIndex" ) ; if ( uctn . equals ( "true" ) ) { m_createIndex = true ; } else { m_createIndex = false ; } } 
public Object getPropertyValue ( String name ) { return collection . get ( name ) ; } 
@ Override public int length ( ) { return back . length ( ) ; } 
public static void main ( String [ ] args ) { final String DEFAULT_TITLE = "Java-Native-Access-(JNA)" ; final String DEFAULT_VERSION = VERSION ; final String DEFAULT_BUILD = VERSION + "-(package-information-missing)" ; Package pkg = Native . class . getPackage ( ) ; String title = pkg != null ? pkg . getSpecificationTitle ( ) : DEFAULT_TITLE ; if ( title == null ) title = DEFAULT_TITLE ; String version = pkg != null ? pkg . getSpecificationVersion ( ) : DEFAULT_VERSION ; if ( version == null ) version = DEFAULT_VERSION ; title += "-API-Version-" + version ; System . out . println ( title ) ; version = pkg != null ? pkg . getImplementationVersion ( ) : DEFAULT_BUILD ; if ( version == null ) version = DEFAULT_BUILD ; System . out . println ( "Version:-" + version ) ; System . out . println ( "-Native:-" + getNativeVersion ( ) + "-(" + getAPIChecksum ( ) + ")" ) ; System . out . println ( "-Prefix:-" + Platform . RESOURCE_PREFIX ) ; } 
static String cidFromCodePath ( String fullCodePath ) { int eidx = fullCodePath . lastIndexOf ( "/" ) ; String subStr1 = fullCodePath . substring ( 0 , eidx ) ; int sidx = subStr1 . lastIndexOf ( "/" ) ; return subStr1 . substring ( sidx + 1 , eidx ) ; } 
void constructNode ( String nodeName , String prefix , String nodeNamespace , TransformerImpl transformer ) throws TransformerException { boolean shouldAddAttrs ; try { SerializationHandler rhandler = transformer . getResultTreeHandler ( ) ; if ( null == nodeName ) { shouldAddAttrs = false ; } else { if ( null != prefix ) { rhandler . startPrefixMapping ( prefix , nodeNamespace , true ) ; } rhandler . startElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; super . execute ( transformer ) ; shouldAddAttrs = true ; } transformer . executeChildTemplates ( this , shouldAddAttrs ) ; if ( null != nodeName ) { rhandler . endElement ( nodeNamespace , QName . getLocalPart ( nodeName ) , nodeName ) ; if ( null != prefix ) { rhandler . endPrefixMapping ( prefix ) ; } } } catch ( SAXException se ) { throw new TransformerException ( se ) ; } } 
public Color getGroupLabelForegroundColor ( ) { Color color = UIManager . getColor ( CHANNELLABELS_GROUPLABEL_FOREGROUND_COLOR ) ; if ( color == null ) { color = Color . WHITE ; } return color ; } 
void updateColor ( ) { if ( fg == null ) fg = Color . BLACK ; cairoSetRGBAColor ( nativePointer , fg . getRed ( ) / 255.0 , fg . getGreen ( ) / 255.0 , fg . getBlue ( ) / 255.0 , fg . getAlpha ( ) / 255.0 ) ; } 
InvocationHandlerImpl ( URI serverURI ) throws MalformedURLException { serverURL = serverURI . toURL ( ) ; } 
public Node getTail ( ) { return head . getPrev ( ) ; } 
static void insertBooleanParameter ( String paramName , String paramValue ) { boolean val = false ; if ( paramValue . equals ( "true" ) ) val = true ; try { Parameters param = new Parameters ( ) ; java . lang . reflect . Field f = Parameters . class . getField ( paramName ) ; f . setBoolean ( param , val ) ; } catch ( Exception e ) { System . err . println ( "Cannot-set-param-" + paramName ) ; System . exit ( 1 ) ; } } 
public static void addActionListener ( ActionListener l ) { listenerList . add ( ActionListener . class , l ) ; } 
public String getSize ( ) { String s32 = ( String ) WrapperGenerator . sizeTable32bit . get ( getName ( ) ) ; String s64 = ( String ) WrapperGenerator . sizeTable64bit . get ( getName ( ) ) ; if ( s32 == null || s64 == null ) { return ( s32 == null ) ? ( s64 ) : ( s32 ) ; } if ( s32 . equals ( s64 ) ) { return s32 ; } else { return MessageFormat . format ( "((XlibWrapper.dataModel-==-32)?({0}):({1}))" , new Object [ ] { s32 , s64 } ) ; } } 
public Set < String > names ( ) { TreeSet < String > result = new TreeSet < String > ( String . CASE_INSENSITIVE_ORDER ) ; for ( int i = 0 ; i < length ( ) ; i ++ ) { result . add ( getFieldName ( i ) ) ; } return Collections . unmodifiableSet ( result ) ; } 
private static byte [ ] readClass ( final InputStream is , boolean close ) throws IOException { if ( is == null ) { throw new IOException ( "Class-not-found" ) ; } try { byte [ ] b = new byte [ is . available ( ) ] ; int len = 0 ; while ( true ) { int n = is . read ( b , len , b . length - len ) ; if ( n == - 1 ) { if ( len < b . length ) { byte [ ] c = new byte [ len ] ; System . arraycopy ( b , 0 , c , 0 , len ) ; b = c ; } return b ; } len += n ; if ( len == b . length ) { int last = is . read ( ) ; if ( last < 0 ) { return b ; } byte [ ] c = new byte [ b . length + 1000 ] ; System . arraycopy ( b , 0 , c , 0 , len ) ; c [ len ++ ] = ( byte ) last ; b = c ; } } } finally { if ( close ) { is . close ( ) ; } } } 
public static void main ( String [ ] args ) { JFrame frame = new JFrame ( ) ; GJLabelPanel gjp = new GJLabelPanel ( ) ; frame . getContentPane ( ) . add ( gjp ) ; gjp . setText ( "30?Ž" ) ; frame . setDefaultCloseOperation ( WindowConstants . DISPOSE_ON_CLOSE ) ; frame . pack ( ) ; frame . setVisible ( true ) ; } 
public void setLocation ( Point2D p ) { setLocation ( p . getX ( ) , p . getY ( ) ) ; } 
private void notifyOfRemoval ( Node node ) { for ( ChangeListener listener : listeners ) { listener . nodeRemoved ( node ) ; } } 
private static byte [ ] readBytesFromInputStream ( InputStream input , int byteLength ) { try { byte [ ] bytes = new byte [ byteLength ] ; int byteOffset = 0 ; while ( byteOffset < byteLength ) { int bytesReadCount = input . read ( bytes , byteOffset , byteLength - byteOffset ) ; if ( bytesReadCount == - 1 ) { return null ; } byteOffset += bytesReadCount ; } return bytes ; } catch ( IOException e ) { } return null ; } 
public static int copy ( InputStream in , OutputStream out ) throws IOException { int total = 0 ; byte [ ] buffer = new byte [ 8192 ] ; int c ; while ( ( c = in . read ( buffer ) ) != - 1 ) { total += c ; out . write ( buffer , 0 , c ) ; } return total ; } 
public static String setProcessValidity ( String process , String startTime , String endTime ) { Process processElement = ( Process ) Entity . fromString ( EntityType . PROCESS , process ) ; for ( int i = 0 ; i < processElement . getClusters ( ) . getClusters ( ) . size ( ) ; i ++ ) { processElement . getClusters ( ) . getClusters ( ) . get ( i ) . getValidity ( ) . setStart ( TimeUtil . oozieDateToDate ( startTime ) . toDate ( ) ) ; processElement . getClusters ( ) . getClusters ( ) . get ( i ) . getValidity ( ) . setEnd ( TimeUtil . oozieDateToDate ( endTime ) . toDate ( ) ) ; } return processElement . toString ( ) ; } 
private JTextArea addTextArea ( String text , JPanel panel , int gridx , int gridy , int alignment , boolean addToPanel ) { JTextArea textArea = new JTextArea ( text , 1 , 25 ) ; textArea . setEditable ( false ) ; textArea . setLineWrap ( true ) ; textArea . setWrapStyleWord ( true ) ; textArea . setBorder ( new EmptyBorder ( 5 , 5 , 5 , 5 ) ) ; textArea . setBackground ( ( Color ) UIManager . get ( "Label.background" ) ) ; textArea . setForeground ( ( Color ) UIManager . get ( "Label.foreground" ) ) ; textArea . setFont ( new Font ( null , Font . PLAIN , 13 ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; c . gridx = gridx ; c . gridy = gridy ; c . anchor = alignment ; if ( addToPanel ) { panel . add ( textArea , c ) ; } return textArea ; } 
public static AppConfigurationEntry [ ] validateContext ( String context ) { if ( context == null ) { throw new RuntimeException ( "Null-context-argument" ) ; } if ( context . isEmpty ( ) ) { throw new RuntimeException ( "Empty-context-argument" ) ; } javax . security . auth . login . Configuration configuration = javax . security . auth . login . Configuration . getConfiguration ( ) ; AppConfigurationEntry [ ] entries = configuration . getAppConfigurationEntry ( context ) ; if ( entries == null ) { throw new RuntimeException ( String . format ( "Entry-"%s"-not-found;-" + "JAAS-config-=-%s" , context , describeProperty ( Environment . JAAS_CONF_KEY ) ) ) ; } return entries ; } 
public static boolean checkSecurityToken ( Object name , Object token ) { Object refToken = securityTokens . get ( name ) ; return ( refToken == null || refToken . equals ( token ) ) ; } 
private static Canvas deduceContainer ( EObject source , EObject target ) { for ( EObject element = source ; element != null ; element = element . eContainer ( ) ) { if ( element instanceof Canvas ) { return ( Canvas ) element ; } } return null ; } 
public PrintStream ( String fileName ) throws FileNotFoundException { this ( new File ( fileName ) ) ; } 
void removeAutopadding ( ) { unset ( ) ; for ( int counter = springs . size ( ) - 1 ; counter >= 0 ; counter -- ) { Spring spring = springs . get ( counter ) ; if ( spring instanceof AutoPreferredGapSpring ) { if ( ( ( AutoPreferredGapSpring ) spring ) . getUserCreated ( ) ) { ( ( AutoPreferredGapSpring ) spring ) . reset ( ) ; } else { springs . remove ( counter ) ; } } else if ( spring instanceof Group ) { ( ( Group ) spring ) . removeAutopadding ( ) ; } } } 
public void getInfo ( ) { try { info . setSavings ( currencyFmt . parse ( savingsField . getText ( ) ) . doubleValue ( ) ) ; info . setContrib ( currencyFmt . parse ( contribField . getText ( ) ) . doubleValue ( ) ) ; info . setIncome ( currencyFmt . parse ( incomeField . getText ( ) ) . doubleValue ( ) ) ; info . setCurrentAge ( numberFmt . parse ( currentAgeField . getText ( ) ) . intValue ( ) ) ; info . setRetireAge ( numberFmt . parse ( retireAgeField . getText ( ) ) . intValue ( ) ) ; info . setDeathAge ( numberFmt . parse ( deathAgeField . getText ( ) ) . intValue ( ) ) ; info . setInvestPercent ( percentFmt . parse ( investPercentField . getText ( ) ) . doubleValue ( ) ) ; info . setInflationPercent ( percentFmt . parse ( inflationPercentField . getText ( ) ) . doubleValue ( ) ) ; } catch ( ParseException ex ) { ex . printStackTrace ( ) ; } } 
public void setIndent ( String indent ) { if ( indent . length ( ) == 0 ) { this . indent = null ; this . separator = ":" ; } else { this . indent = indent ; this . separator = ":-" ; } } 
public E pop ( ) { return removeFirst ( ) ; } 
public void setProperty ( String par1Str , Object par2Obj ) { this . properties . setProperty ( par1Str , "" + par2Obj ) ; } 
public synchronized boolean getBroadcast ( ) throws SocketException { if ( isClosed ( ) ) throw new SocketException ( "Socket-is-closed" ) ; return ( ( Boolean ) ( getImpl ( ) . getOption ( SocketOptions . SO_BROADCAST ) ) ) . booleanValue ( ) ; } 
public static int getLayer ( JComponent c ) { Integer i ; if ( ( i = ( Integer ) c . getClientProperty ( LAYER_PROPERTY ) ) != null ) return i . intValue ( ) ; return DEFAULT_LAYER . intValue ( ) ; } 
private JSType getJSType ( Node n ) { JSType jsType = n . getJSType ( ) ; if ( jsType == null ) { return getNativeType ( UNKNOWN_TYPE ) ; } else { return jsType ; } } 
public javax . xml . stream . XMLStreamReader getPullParser ( javax . xml . namespace . QName qName ) throws org . apache . axis2 . databinding . ADBException { java . util . ArrayList elementList = new java . util . ArrayList ( ) ; java . util . ArrayList attribList = new java . util . ArrayList ( ) ; elementList . add ( new javax . xml . namespace . QName ( "urn:partner.soap.sforce.com" , "deletedDate" ) ) ; if ( localDeletedDate != null ) { elementList . add ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( localDeletedDate ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "deletedDate-cannot-be-null!!" ) ; } elementList . add ( new javax . xml . namespace . QName ( "urn:partner.soap.sforce.com" , "id" ) ) ; if ( localId == null ) { throw new org . apache . axis2 . databinding . ADBException ( "id-cannot-be-null!!" ) ; } elementList . add ( localId ) ; return new org . apache . axis2 . databinding . utils . reader . ADBXMLStreamReaderImpl ( qName , elementList . toArray ( ) , attribList . toArray ( ) ) ; } 
public String getContributor ( ) { return ( ( _contributors != null ) && ( _contributors . size ( ) > 0 ) ) ? ( String ) _contributors . get ( 0 ) : null ; } 
private int draw ( double [ ] cumulativeFrequencies ) { double r = Random . nextDouble ( ) ; int state = - 1 ; for ( int j = 0 ; j < cumulativeFrequencies . length ; j ++ ) { if ( r < cumulativeFrequencies [ j ] ) { state = j ; break ; } } assert ( state != - 1 ) ; return state ; } 
public List < AnswerFileStatusResult > getAnswerFileStatusResult ( ) { if ( answerFileStatusResult == null ) { answerFileStatusResult = new ArrayList < AnswerFileStatusResult > ( ) ; } return this . answerFileStatusResult ; } 
void createEntry ( int hash , K key , V value , int bucketIndex ) { Entry < K , V > e = table [ bucketIndex ] ; table [ bucketIndex ] = new Entry < K , V > ( hash , key , value , e ) ; size ++ ; } 
public void setJMenuBar ( JMenuBar menubar ) { getRootPane ( ) . setMenuBar ( menubar ) ; } 
FixedDecimal getFixedDecimal ( double number ) { return getFixedDecimal ( number , digitList ) ; } 
public static BuglePrefs getSubscriptionPrefs ( final int subId ) { return Factory . get ( ) . getSubscriptionPrefs ( subId ) ; } 
public void handleNotification ( Notification pNotification , Object pHandback ) { synchronized ( mList ) { if ( mList . size ( ) <= mMaximumSize ) { mList . add ( pNotification ) ; } } } 
private boolean checkParents ( Node node , HashMap < Node , Object > set ) { if ( set . get ( node ) != null ) { return false ; } set . put ( node , this ) ; for ( ; ; ) { node = node . getParentNode ( ) ; if ( node == null ) { return true ; } if ( set . put ( node , node ) == this ) { return false ; } } } 
public static String toString ( long x ) { if ( x == MIN_VALUE ) { return String . wrap ( "-9223372036854775808" ) ; } char [ ] ch = new char [ 30 ] ; int i = 30 - 1 , count = 0 ; boolean negative ; if ( x < 0 ) { negative = true ; x = - x ; } else { negative = false ; } for ( ; i >= 0 ; i -- ) { ch [ i ] = ( char ) ( '0' + ( x % 10 ) ) ; x /= 10 ; count ++ ; if ( x == 0 ) { break ; } } if ( negative ) { ch [ -- i ] = '-' ; count ++ ; } return new String ( ch , i , count ) ; } 
public void translate ( int deltaX , int deltaY ) { for ( int i = 0 ; i < npoints ; i ++ ) { xpoints [ i ] += deltaX ; ypoints [ i ] += deltaY ; } if ( bounds != null ) { bounds . translate ( deltaX , deltaY ) ; } } 
public static String getMethodDescriptor ( final Type returnType , final Type [ ] argumentTypes ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( '(' ) ; for ( int i = 0 ; i < argumentTypes . length ; ++ i ) { argumentTypes [ i ] . getDescriptor ( buf ) ; } buf . append ( ')' ) ; returnType . getDescriptor ( buf ) ; return buf . toString ( ) ; } 
public List < EndpointStudyRecord . ScientificPart . ECSOILDWELLINGTOX . AD . Set > getSet ( ) { if ( set == null ) { set = new ArrayList < EndpointStudyRecord . ScientificPart . ECSOILDWELLINGTOX . AD . Set > ( ) ; } return this . set ; } 
DOMStringListImpl ( String [ ] params ) { fStrings = new Vector ( ) ; if ( params != null ) { for ( int i = 0 ; i < params . length ; i ++ ) { fStrings . add ( params [ i ] ) ; } } } 
public World load ( World world , Map map ) { if ( ! ignoreMapUnitScale ) unitScale = ( Float ) getProperty ( map . getProperties ( ) , aliases . unitScale , unitScale , Float . class ) ; tileWidth = ( Integer ) getProperty ( map . getProperties ( ) , "tilewidth" , tileWidth , Integer . class ) ; tileHeight = ( Integer ) getProperty ( map . getProperties ( ) , "tileheight" , tileHeight , Integer . class ) ; for ( MapLayer mapLayer : map . getLayers ( ) ) load ( world , mapLayer ) ; return world ; } 
public void addFocusables ( ArrayList < View > views , @ FocusDirection int direction ) { addFocusables ( views , direction , FOCUSABLES_TOUCH_MODE ) ; } 
private int find ( int first ) { int s = 0 ; int e = ranges . size ( ) - 1 ; while ( s <= e ) { int m = ( s + e ) / 2 ; Range r = ranges . get ( m ) ; if ( r . first < first ) { s = m + 1 ; } else if ( r . first > first ) { e = m - 1 ; } else { return m ; } } return s ; } 
public MiniAdmin ( java . sql . Connection conn ) throws SQLException { if ( conn == null ) { throw SQLError . createSQLException ( Messages . getString ( "MiniAdmin.0" ) , SQLError . SQL_STATE_GENERAL_ERROR , null ) ; } if ( ! ( conn instanceof Connection ) ) { throw SQLError . createSQLException ( Messages . getString ( "MiniAdmin.1" ) , SQLError . SQL_STATE_GENERAL_ERROR , ( ( com . mysql . jdbc . ConnectionImpl ) conn ) . getExceptionInterceptor ( ) ) ; } this . conn = ( Connection ) conn ; } 
public URL getResource ( String resName ) { URL resource = parent . getResource ( resName ) ; if ( resource == null ) { resource = findResource ( resName ) ; } return resource ; } 
final boolean apparentlyFirstQueuedIsExclusive ( ) { Node h , s ; return ( h = head ) != null && ( s = h . next ) != null && ! s . isShared ( ) && s . thread != null ; } 
public void setReuseAddress ( boolean reuse ) throws SocketException { checkOpenAndCreate ( true ) ; impl . setOption ( SocketOptions . SO_REUSEADDR , Boolean . valueOf ( reuse ) ) ; } 
public void setDecomposition ( int decomposition ) { if ( isFrozen ( ) ) { throw new UnsupportedOperationException ( "Attempt-to-modify-frozen-object" ) ; } internalSetDecomposition ( decomposition ) ; } 
public void setVector ( double magnitude , double angle ) { x = magnitude * Math . cos ( angle ) ; y = magnitude * Math . sin ( angle ) ; } 
public static void checkDir ( File dir ) throws DiskErrorException { if ( ! mkdirsWithExistsCheck ( dir ) ) throw new DiskErrorException ( "can-not-create-directory:-" + dir . toString ( ) ) ; if ( ! dir . isDirectory ( ) ) throw new DiskErrorException ( "not-a-directory:-" + dir . toString ( ) ) ; if ( ! dir . canRead ( ) ) throw new DiskErrorException ( "directory-is-not-readable:-" + dir . toString ( ) ) ; if ( ! dir . canWrite ( ) ) throw new DiskErrorException ( "directory-is-not-writable:-" + dir . toString ( ) ) ; } 
private static void loadClasses ( ) { if ( IJ . isMacOSX ( ) && ! IJ . isJava16 ( ) && IJ . getApplet ( ) == null ) { try { if ( new File ( "/System/Library/Java/com/apple/cocoa/application/NSWorkspace.class" ) . exists ( ) ) { ClassLoader classLoader = new URLClassLoader ( new URL [ ] { new File ( "/System/Library/Java" ) . toURL ( ) } ) ; mrjFileUtilsClass = Class . forName ( "com.apple.cocoa.application.NSWorkspace" , true , classLoader ) ; } else mrjFileUtilsClass = Class . forName ( "com.apple.cocoa.application.NSWorkspace" ) ; openURL = mrjFileUtilsClass . getDeclaredMethod ( "openURL" , new Class [ ] { java . net . URL . class } ) ; } catch ( Exception e ) { IJ . log ( "BrowserLauncher" + e ) ; error = true ; } } } 
public static void mostrar ( String mensaje ) { JOptionPane . showMessageDialog ( null , mensaje ) ; } 
@ Override public String getTagName ( ) { return ( ( Element ) current ) . getTagName ( ) ; } 
@ Override public void recycle ( boolean socketClosing ) { super . recycle ( socketClosing ) ; inputBuffer . clear ( ) ; inputBuffer . limit ( 0 ) ; outputBuffer . clear ( ) ; } 
public void close ( ) throws NetworkException { channel . close ( ) ; } 
public static void setFileTimestamps ( Configuration conf , String timestamps ) { conf . set ( CACHE_FILES_TIMESTAMPS , timestamps ) ; } 
public final Scheme get ( String name ) { if ( name == null ) throw new IllegalArgumentException ( "Name-must-not-be-null." ) ; Scheme found = registeredSchemes . get ( name ) ; return found ; } 
@ Override public Node clone ( ) { return doClone ( null ) ; } 
@ Override public Value evalCopy ( Env env ) { Value obj = _objExpr . eval ( env ) ; return obj . getField ( env , _name ) . copy ( ) ; } 
public E remove ( ) { return removeFirst ( ) ; } 
private void hideTab ( IFeaturePanel currentTab ) { if ( currentTab != null ) { Composite tabComposite = tabToComposite . get ( currentTab ) ; if ( tabComposite != null ) { currentTab . aboutToBeHidden ( ) ; tabComposite . setVisible ( false ) ; } } } 
private Element updateEnumerationKey ( Document document , String keyType , String oldKey , String newKey ) throws TransformerException { String attributesXPath = "/xs:schema/xs:simpleType[@name-=-'" + keyType + "']/xs:restriction/xs:enumeration[@value='" + oldKey + "']" ; NodeList anl = XPathAPI . selectNodeList ( document . getDocumentElement ( ) , attributesXPath ) ; if ( anl != null && anl . getLength ( ) > 0 ) { Element enumeration = ( Element ) anl . item ( 0 ) ; enumeration . setAttribute ( "value" , newKey ) ; return enumeration ; } return null ; } 
public static Object create ( final Method listenerMethod , final Object target , final Method targetMethod ) { InvocationHandler handler = new DefaultInvoker ( ) { public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( listenerMethod . equals ( method ) ) { return targetMethod . invoke ( target , args ) ; } else { return super . invoke ( proxy , method , args ) ; } } } ; Class cls = listenerMethod . getDeclaringClass ( ) ; ClassLoader cl = cls . getClassLoader ( ) ; return Proxy . newProxyInstance ( cl , new Class [ ] { cls } , handler ) ; } 
static byte [ ] passwordHashStage2 ( byte [ ] hashedPassword , byte [ ] salt ) throws NoSuchAlgorithmException { MessageDigest md = MessageDigest . getInstance ( "SHA-1" ) ; md . update ( salt , 0 , 4 ) ; md . update ( hashedPassword , 0 , SHA1_HASH_SIZE ) ; return md . digest ( ) ; } 
public void setChannelListener ( ChannelListener channel_listener ) { addChannelListener ( channel_listener ) ; } 
public static BufferedImage toCompatibleImage ( BufferedImage image ) { GraphicsConfiguration gfx_config = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) . getDefaultScreenDevice ( ) . getDefaultConfiguration ( ) ; if ( image . getColorModel ( ) . equals ( gfx_config . getColorModel ( ) ) ) return image ; BufferedImage newImage = gfx_config . createCompatibleImage ( image . getWidth ( ) , image . getHeight ( ) , image . getTransparency ( ) ) ; Graphics2D g2d = ( Graphics2D ) newImage . getGraphics ( ) ; g2d . drawImage ( image , 0 , 0 , null ) ; g2d . dispose ( ) ; return newImage ; } 
public ScriptGroup create ( String name , Future ... outputs ) { if ( name == null || name . isEmpty ( ) || name . length ( ) > 100 || ! name . equals ( name . replaceAll ( "[^a-zA-Z0-9-]" , "_" ) ) ) { throw new RSIllegalArgumentException ( "invalid-script-group-name" ) ; } ScriptGroup ret = new ScriptGroup ( mRS , name , mClosures , mInputs , outputs ) ; return ret ; } 
String inprogressZNode ( long startTxid ) { return ledgerPath + "/inprogress_" + Long . toString ( startTxid , 16 ) ; } 
public void add ( XMLX509Certificate xmlX509Certificate ) { this . _constructionElement . appendChild ( xmlX509Certificate . getElement ( ) ) ; XMLUtils . addReturnToElement ( this . _constructionElement ) ; } 
public void or ( Criteria criteria ) { oredCriteria . add ( criteria ) ; } 
public static ItemStack readItemStack ( DataInputStream par0DataInputStream ) throws IOException { ItemStack var1 = null ; short var2 = par0DataInputStream . readShort ( ) ; if ( var2 >= 0 ) { byte var3 = par0DataInputStream . readByte ( ) ; short var4 = par0DataInputStream . readShort ( ) ; var1 = new ItemStack ( var2 , var3 , var4 ) ; var1 . damageable = true ; var1 . stackTagCompound = readNBTTagCompound ( par0DataInputStream ) ; } return var1 ; } 
protected void stopAnimationTimer ( ) { if ( animator != null ) { animator . stop ( ) ; } } 
private static String processFormatPattern ( String f ) { String t = f . replaceAll ( "MMMMM" , MMMMM_START_SYMBOL + "MMM" + MMMMM_TRUNCATE_SYMBOL ) ; t = t . replaceAll ( "|[H|]" , String . valueOf ( H_BRACKET_SYMBOL ) ) ; t = t . replaceAll ( "|[HH|]" , String . valueOf ( HH_BRACKET_SYMBOL ) ) ; t = t . replaceAll ( "|[m|]" , String . valueOf ( M_BRACKET_SYMBOL ) ) ; t = t . replaceAll ( "|[mm|]" , String . valueOf ( MM_BRACKET_SYMBOL ) ) ; t = t . replaceAll ( "|[s|]" , String . valueOf ( S_BRACKET_SYMBOL ) ) ; t = t . replaceAll ( "|[ss|]" , String . valueOf ( SS_BRACKET_SYMBOL ) ) ; t = t . replaceAll ( "s.000" , "s.S" ) ; t = t . replaceAll ( "s.00" , "s." + LL_BRACKET_SYMBOL ) ; t = t . replaceAll ( "s.0" , "s." + L_BRACKET_SYMBOL ) ; return t ; } 
public static void println ( Object x ) { out . println ( x ) ; } 
public Long getJvmMemPoolInitSize ( ) throws SnmpStatusException { final long val = getMemoryUsage ( ) . getInit ( ) ; if ( val > - 1 ) return new Long ( val ) ; else return JvmMemoryImpl . Long0 ; } 
short [ ] getTRC ( int tagSignature ) { short [ ] dataTRC = null ; getGammaOrTRC ( tagSignature , dataTRC ) ; if ( dataTRC == null ) { throw new ProfileDataException ( Messages . getString ( "awt.167" ) ) ; } return dataTRC ; } 
public static boolean doesFileExist ( String filename ) { if ( null == filename ) { return false ; } File file = new File ( filename ) ; return file . exists ( ) && file . isFile ( ) ; } 
private byte [ ] handleContinueRecords ( byte [ ] data ) { int continuedData = data . length - ( maxRecordLength - 4 ) ; int numContinueRecords = continuedData / ( maxRecordLength - 4 ) + 1 ; byte [ ] newdata = new byte [ data . length + numContinueRecords * 4 ] ; System . arraycopy ( data , 0 , newdata , 0 , maxRecordLength - 4 ) ; int oldarraypos = maxRecordLength - 4 ; int newarraypos = maxRecordLength - 4 ; for ( int i = 0 ; i < numContinueRecords ; i ++ ) { int length = Math . min ( data . length - oldarraypos , maxRecordLength - 4 ) ; IntegerHelper . getTwoBytes ( Type . CONTINUE . value , newdata , newarraypos ) ; IntegerHelper . getTwoBytes ( length , newdata , newarraypos + 2 ) ; System . arraycopy ( data , oldarraypos , newdata , newarraypos + 4 , length ) ; oldarraypos += length ; newarraypos += length + 4 ; } return newdata ; } 
private static void printOpcodes ( PrintWriter out , List < Instruction > list , String comment ) { out . println ( "-/**-" + comment + ".-*/" ) ; out . println ( "-public-final-static-int" ) ; for ( Iterator < Instruction > iterator = list . iterator ( ) ; iterator . hasNext ( ) ; ) { Instruction instruction = iterator . next ( ) ; out . print ( pad ( "-" + instruction . mnemonic . toUpperCase ( ) , 30 ) + "-=-" + instruction . opcode ) ; if ( iterator . hasNext ( ) ) { out . println ( "," ) ; } else { out . println ( ";" ) ; } } } 
public void printSymbols ( ) { System . out . println ( "Symbol-Table:" ) ; for ( String key : symKeys ) { Object value = symbols . get ( key ) ; System . out . println ( key + "-=-" + value ) ; } } 
public static < E extends ASTNode > NodeList < E > create ( ASTNode owner ) { return new NodeList < E > ( owner ) ; } 
public static URL makeDAVURL ( String endpoint , String davURI , String packager ) throws MalformedURLException { int s = endpoint . lastIndexOf ( '/' ) ; if ( s < 0 ) { throw new MalformedURLException ( "Illegal-LNI-SOAP-endpoint,-no-path-separators-(/)-found:-" + endpoint ) ; } String result = endpoint . substring ( 0 , s ) ; if ( davURI != null ) { result += davURI ; if ( packager != null ) { result += "?package=" + packager ; } } return new URL ( result ) ; } 
public Iterator getReferenceInsertionEventHandlers ( ) { return referenceHandlers . size ( ) == 0 ? null : referenceHandlers . iterator ( ) ; } 
public ProcessBuilder redirectError ( File file ) { return redirectError ( Redirect . to ( file ) ) ; } 
public void initNodeTest ( int whatToShow , String namespace , String name ) { m_whatToShow = whatToShow ; m_namespace = namespace ; m_name = name ; calcScore ( ) ; } 
public int hashCode ( ) { return ( major << 24 ) + ( minor << 16 ) + ( micro << 8 ) + qualifier . hashCode ( ) ; } 
public void close ( ) throws IOException { synchronized ( this ) { if ( mHandler != null ) { mHandler . obtainMessage ( mMessage ) . sendToTarget ( ) ; } } mSocket . close ( ) ; } 
public void removeAttribute ( String name ) { synchronized ( names ) { names . remove ( name ) ; } } 
public K getXByIndex ( int index ) { return indexList . get ( index ) ; } 
public String toString ( ) { String sProfile = pName + "-(" + pStatus + "):-" ; Iterator < String > it = pFriends . iterator ( ) ; while ( it . hasNext ( ) ) { sProfile = sProfile + it . next ( ) + ",-" ; } return sProfile ; } 
private String encode ( String value ) { StringBuffer encoded = new StringBuffer ( ) ; for ( int i = 0 ; i < value . length ( ) ; i ++ ) { encoded . append ( String . valueOf ( ( char ) ( value . charAt ( i ) + 1 ) ) ) ; } return encoded . reverse ( ) . toString ( ) ; } 
public void playSound ( ) { String strFilename = this . filename ; try { soundFile = new File ( strFilename ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } try { this . audioStream = AudioSystem . getAudioInputStream ( soundFile ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } this . audioFormat = this . audioStream . getFormat ( ) ; DataLine . Info info = new DataLine . Info ( SourceDataLine . class , audioFormat ) ; try { sourceLine = ( SourceDataLine ) AudioSystem . getLine ( info ) ; sourceLine . open ( audioFormat ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } sourceLine . start ( ) ; int nBytesRead = 0 ; byte [ ] abData = new byte [ BUFFER_SIZE ] ; while ( nBytesRead != - 1 ) { try { nBytesRead = audioStream . read ( abData , 0 , abData . length ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( nBytesRead >= 0 ) { int nBytesWritten = sourceLine . write ( abData , 0 , nBytesRead ) ; } } sourceLine . drain ( ) ; sourceLine . close ( ) ; } 
@ Override public void valueChanged ( ListSelectionEvent event ) { if ( ! event . getValueIsAdjusting ( ) ) { Source s = ( Source ) sourceList . getSelectedValue ( ) ; sourcePanel . setSource ( projectFile . getParentFile ( ) , project , s ) ; deleteSourceAction . setEnabled ( s != null ) ; } } 
protected int addUniqueLeafNode ( String elementName ) { int contentSpecIndex = createContentSpec ( ) ; fContentSpec . setValues ( XMLContentSpec . CONTENTSPECNODE_LEAF , elementName , null ) ; setContentSpec ( contentSpecIndex , fContentSpec ) ; return contentSpecIndex ; } 
public void setCurcyConvRateType ( JAXBElement < String > value ) { this . curcyConvRateType = ( ( JAXBElement < String > ) value ) ; } 
public static String rowToString ( JSONArray ja ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < ja . length ( ) ; i += 1 ) { if ( i > 0 ) { sb . append ( ',' ) ; } Object object = ja . opt ( i ) ; if ( object != null ) { String string = object . toString ( ) ; if ( string . length ( ) > 0 && ( string . indexOf ( ',' ) >= 0 || string . indexOf ( '|n' ) >= 0 || string . indexOf ( '|r' ) >= 0 || string . indexOf ( 0 ) >= 0 || string . charAt ( 0 ) == '"' ) ) { sb . append ( '"' ) ; int length = string . length ( ) ; for ( int j = 0 ; j < length ; j += 1 ) { char c = string . charAt ( j ) ; if ( c >= '-' && c != '"' ) { sb . append ( c ) ; } } sb . append ( '"' ) ; } else { sb . append ( string ) ; } } } sb . append ( '|n' ) ; return sb . toString ( ) ; } 
public void addExternalEndpoint ( Endpoint endpoint ) { Preconditions . checkArgument ( endpoint != null ) ; endpoint . validate ( ) ; external . add ( endpoint ) ; } 
public Element prependElement ( String tagName ) { Element child = new Element ( Tag . valueOf ( tagName ) , baseUri ( ) ) ; prependChild ( child ) ; return child ; } 
public static String writeDateTime ( Calendar cal , boolean zulu ) { StringBuilder sb = new StringBuilder ( ) ; sb . ensureCapacity ( 16 ) ; if ( zulu ) { sb . setLength ( 16 ) ; sb . setCharAt ( 15 , 'Z' ) ; } else { sb . setLength ( 15 ) ; } return writeDateTime ( cal , sb ) ; } 
public String answer ( ) { long rest = input ; long largestKnown = input ; int primeFactor = 2 ; while ( rest != 1 ) { while ( rest % primeFactor == 0 ) { rest = rest / primeFactor ; largestKnown = primeFactor ; } primeFactor ++ ; } return Long . toString ( largestKnown ) ; } 
public void setInputStream ( InputStream ins ) throws IOException { int bytes_read = 0 ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; byte data [ ] = new byte [ 1024 ] ; while ( ( bytes_read = ins . read ( data ) ) > 0 ) baos . write ( data , 0 , bytes_read ) ; ins . close ( ) ; text_buffer = baos . toString ( ) ; text_area . setText ( text_buffer ) ; } 
public void setReadOnly ( ) { checkPermission ( _READ_ONLY ) ; readOnly = true ; } 
public void populate ( ResultSet info ) { palls . clear ( ) ; try { if ( info . first ( ) ) { boolean blocked , delivered ; int pNbr ; String pName , pDate , pTime ; do { pNbr = info . getInt ( 1 ) ; pName = info . getString ( 2 ) ; String temp = info . getString ( 3 ) ; pDate = temp . substring ( 0 , 10 ) ; pTime = temp . substring ( 10 , 16 ) ; blocked = info . getBoolean ( 4 ) ; if ( info . getDate ( 5 ) == null ) delivered = false ; else delivered = true ; palls . add ( new Pallet ( pNbr , pName , pDate , pTime , blocked , delivered ) ) ; } while ( info . next ( ) ) ; } } catch ( SQLException e ) { e . printStackTrace ( ) ; } } 
public Collection < Agent > getAgents ( Group group ) { final Set < Agent > set = new HashSet < Agent > ( ) ; for ( JID jid : group . getMembers ( ) ) { Agent agent ; try { agent = getAgent ( jid ) ; } catch ( AgentNotFoundException e ) { agent = createAgent ( jid ) ; } set . add ( agent ) ; } return set ; } 
public void recycle ( Connection connection ) { if ( connection . isSpdy ( ) ) { return ; } if ( ! connection . isAlive ( ) ) { Util . closeQuietly ( connection ) ; return ; } try { Platform . get ( ) . untagSocket ( connection . getSocket ( ) ) ; } catch ( SocketException e ) { Platform . get ( ) . logW ( "Unable-to-untagSocket():-" + e ) ; Util . closeQuietly ( connection ) ; return ; } synchronized ( this ) { connections . addFirst ( connection ) ; connection . resetIdleStartTime ( ) ; } executorService . submit ( connectionsCleanupCallable ) ; } 
public static DescribeKeyPairsResponse parse ( javax . xml . stream . XMLStreamReader reader ) throws java . lang . Exception { DescribeKeyPairsResponse object = new DescribeKeyPairsResponse ( ) ; int event ; java . lang . String nillableValue = null ; java . lang . String prefix = "" ; java . lang . String namespaceuri = "" ; try { while ( ! reader . isStartElement ( ) && ! reader . isEndElement ( ) ) reader . next ( ) ; java . util . Vector handledAttributes = new java . util . Vector ( ) ; while ( ! reader . isEndElement ( ) ) { if ( reader . isStartElement ( ) ) { if ( reader . isStartElement ( ) && new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2012-08-15/" , "DescribeKeyPairsResponse" ) . equals ( reader . getName ( ) ) ) { object . setDescribeKeyPairsResponse ( DescribeKeyPairsResponseType . Factory . parse ( reader ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "Unexpected-subelement-" + reader . getLocalName ( ) ) ; } } else { reader . next ( ) ; } } } catch ( javax . xml . stream . XMLStreamException e ) { throw new java . lang . Exception ( e ) ; } return object ; } 
public static MBeanServer newMBeanServer ( String defaultDomain , MBeanServer outer , MBeanServerDelegate delegate , boolean interceptors ) { final boolean fairLock = DEFAULT_FAIR_LOCK_POLICY ; checkNewMBeanServerPermission ( ) ; return new JmxMBeanServer ( defaultDomain , outer , delegate , null , interceptors , fairLock ) ; } 
private void addFolderDivision ( List < DrawerItem > destination , List < DrawerItem > source , int headerStringResource ) { if ( source . size ( ) > 0 ) { if ( headerStringResource != NO_HEADER_RESOURCE ) { destination . add ( DrawerItem . ofHeader ( mActivity , headerStringResource , mBidiFormatter ) ) ; } destination . addAll ( source ) ; } } 
public static String getProperty ( String propName , Hashtable env , Context ctx , boolean concat ) throws NamingException { String val1 = ( env != null ) ? ( String ) env . get ( propName ) : null ; if ( ( ctx == null ) || ( ( val1 != null ) && ! concat ) ) { return val1 ; } String val2 = ( String ) getProviderResource ( ctx ) . get ( propName ) ; if ( val1 == null ) { return val2 ; } else if ( ( val2 == null ) || ! concat ) { return val1 ; } else { return ( val1 + ":" + val2 ) ; } } 
public PedFile removeIncompleteTrios ( ) { final Iterator < Map . Entry < String , PedTrio >> iterator = entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { if ( ! iterator . next ( ) . getValue ( ) . hasBothParents ( ) ) iterator . remove ( ) ; } return this ; } 
private static Credentials matchCredentials ( final Map < AuthScope , Credentials > map , final AuthScope authscope ) { Credentials creds = map . get ( authscope ) ; if ( creds == null ) { int bestMatchFactor = - 1 ; AuthScope bestMatch = null ; for ( AuthScope current : map . keySet ( ) ) { int factor = authscope . match ( current ) ; if ( factor > bestMatchFactor ) { bestMatchFactor = factor ; bestMatch = current ; } } if ( bestMatch != null ) { creds = map . get ( bestMatch ) ; } } return creds ; } 
private String buildOptionalCommandLine ( ) { StringBuffer commandLineBuf = new StringBuffer ( ) ; if ( this . serverProps != null ) { for ( Iterator iter = this . serverProps . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String key = ( String ) iter . next ( ) ; String value = this . serverProps . getProperty ( key ) ; if ( ! isNonCommandLineArgument ( key ) ) { if ( value != null && value . length ( ) > 0 ) { commandLineBuf . append ( "-"" ) ; commandLineBuf . append ( "--" ) ; commandLineBuf . append ( key ) ; commandLineBuf . append ( "=" ) ; commandLineBuf . append ( value ) ; commandLineBuf . append ( """ ) ; } else { commandLineBuf . append ( "---" ) ; commandLineBuf . append ( key ) ; } } } } return commandLineBuf . toString ( ) ; } 
public void addArg ( Object arg ) { _args . add ( arg ) ; } 
public void checkAwtEventQueueAccess ( ) { checkPermission ( SecurityConstants . AWT . CHECK_AWT_EVENTQUEUE_PERMISSION ) ; } 
public void setForeground ( Color fg ) { if ( textField != null ) { textField . setForeground ( fg ) ; } } 
private static void setMaxLogFileSize ( String asMaxLogFileSize ) { try { siMaxLogFileSize = Integer . parseInt ( asMaxLogFileSize . trim ( ) ) ; } catch ( Throwable aeThrowable ) { siMaxLogFileSize = DEFAULTMAXLOGFILESIZE ; System . out . println ( DEFAULT_MAXLOGFILESIZE_MSG ) ; } } 
protected boolean isInToolBar ( JComponent c ) { return inToolBarState . isInState ( c ) ; } 
public ArrayList < Object > getValue ( int key ) { return nextT . get ( key ) ; } 
boolean doFind ( String s , boolean ignoreCase , boolean wrap ) { int docLength = document . getLength ( ) ; int startPosition = currentTextPane . getCaretPosition ( ) ; int endPos = docLength ; boolean found = false ; boolean finished = false ; int start = startPosition ; Element line = getLineAt ( start ) ; int lineEnd = Math . min ( line . getEndOffset ( ) , endPos ) ; try { while ( ! found && ! finished ) { String lineText = document . getText ( start , lineEnd - start ) ; if ( lineText != null && lineText . length ( ) > 0 ) { int foundPos = findSubstring ( lineText , s , ignoreCase , false ) ; if ( foundPos != - 1 ) { currentTextPane . select ( start + foundPos , start + foundPos + s . length ( ) ) ; currentTextPane . getCaret ( ) . setSelectionVisible ( true ) ; found = true ; } } if ( lineEnd >= endPos ) { if ( wrap ) { endPos = startPosition ; line = document . getParagraphElement ( 0 ) ; start = line . getStartOffset ( ) ; lineEnd = Math . min ( line . getEndOffset ( ) , endPos ) ; wrap = false ; } else { finished = true ; } } else { line = document . getParagraphElement ( lineEnd + 1 ) ; start = line . getStartOffset ( ) ; lineEnd = Math . min ( line . getEndOffset ( ) , endPos ) ; } } } catch ( BadLocationException ex ) { Debug . reportError ( "Error-in-editor-find-operation" , ex ) ; } return found ; } 
public NBTInputStream ( InputStream is , final boolean gzipped ) throws IOException { if ( gzipped ) { is = new GZIPInputStream ( is ) ; } this . is = new DataInputStream ( is ) ; } 
public static KeyStore initializeKeyStore ( ) { try { keyStore = KeyStore . getInstance ( storeType ) ; keyStore . load ( null , keypass . toCharArray ( ) ) ; } catch ( Exception e ) { Log . error ( "Unable-to-initialize-keystore:-" , e ) ; } return keyStore ; } 
public Formatter ( OutputStream os , String csn , Locale l ) throws UnsupportedEncodingException { out = new BufferedWriter ( new OutputStreamWriter ( os , csn ) ) ; locale = l ; } 
@ Override protected void serializeWSSecurityHeaders ( XMLStreamWriter xmlWriter ) throws XMLStreamException { EwsUtilities . EwsAssert ( this . securityToken != null , "WSSecurityBasedCredentials.SerializeWSSecurityHeaders" , "Security-token-cannot-be-null!" ) ; String timestamp = null ; if ( this . addTimestamp ) { Calendar utcNow = Calendar . getInstance ( ) ; utcNow . add ( Calendar . MINUTE , 5 ) ; timestamp = String . format ( WSSecurityBasedCredentials . wsuTimeStampFormat , utcNow , utcNow ) ; } String wsSecurityHeader = String . format ( WSSecurityBasedCredentials . wsSecurityHeaderFormat , timestamp + this . securityToken ) ; xmlWriter . writeCharacters ( wsSecurityHeader ) ; } 
public void set ( int bitIndex ) { if ( bitIndex < 0 ) throw new IndexOutOfBoundsException ( "bitIndex-<-0:-" + bitIndex ) ; int wordIndex = wordIndex ( bitIndex ) ; expandTo ( wordIndex ) ; words [ wordIndex ] |= ( 1L << bitIndex ) ; checkInvariants ( ) ; } 
public void close ( ) throws IOException { closed = true ; if ( depth == 0 ) { clear ( ) ; } bin . close ( ) ; } 
public final void removeScrollListener ( ScrollListener listener ) { listenerList . remove ( ScrollListener . class , listener ) ; } 
private void reportInterruptAfterWait ( int interruptMode ) throws InterruptedException { if ( interruptMode == THROW_IE ) throw new InterruptedException ( ) ; else if ( interruptMode == REINTERRUPT ) Thread . currentThread ( ) . interrupt ( ) ; } 
public void addPathMap ( String sourcePath , String targetPath ) { writeLock . lock ( ) ; try { if ( locked ) { throw new IllegalStateException ( "The-PathMapper-has-been-locked-against-further-changes" ) ; } derivedPathMaps . clear ( ) ; derivedPathMapsPartial . clear ( ) ; Set < String > targetPaths = pathMaps . get ( sourcePath ) ; if ( targetPaths == null ) { targetPaths = new HashSet < String > ( 5 ) ; pathMaps . put ( sourcePath , targetPaths ) ; } targetPaths . add ( targetPath ) ; } finally { writeLock . unlock ( ) ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Added-path-map:-" + sourcePath + "--->-" + targetPath ) ; } } 
public void invincible ( ) { GamePanel . invincible = true ; class InvincibleTimer implements ActionListener { public void actionPerformed ( ActionEvent e ) { GamePanel . invincible = false ; } } Timer repaintFrame = new Timer ( 5000 , new InvincibleTimer ( ) ) ; repaintFrame . setRepeats ( false ) ; repaintFrame . start ( ) ; } 
public void removeRosterListener ( RosterListener rosterListener ) { rosterListeners . remove ( rosterListener ) ; } 
private static List < Challenge > parseChallenges ( RawHeaders responseHeaders , String challengeHeader ) { List < Challenge > result = new ArrayList < Challenge > ( ) ; for ( int h = 0 ; h < responseHeaders . length ( ) ; h ++ ) { if ( ! challengeHeader . equalsIgnoreCase ( responseHeaders . getFieldName ( h ) ) ) { continue ; } String value = responseHeaders . getValue ( h ) ; int pos = 0 ; while ( pos < value . length ( ) ) { int tokenStart = pos ; pos = HeaderParser . skipUntil ( value , pos , "-" ) ; String scheme = value . substring ( tokenStart , pos ) . trim ( ) ; pos = HeaderParser . skipWhitespace ( value , pos ) ; if ( ! value . regionMatches ( true , pos , "realm="" , 0 , "realm="" . length ( ) ) ) { break ; } pos += "realm="" . length ( ) ; int realmStart = pos ; pos = HeaderParser . skipUntil ( value , pos , """ ) ; String realm = value . substring ( realmStart , pos ) ; pos ++ ; pos = HeaderParser . skipUntil ( value , pos , "," ) ; pos ++ ; pos = HeaderParser . skipWhitespace ( value , pos ) ; result . add ( new Challenge ( scheme , realm ) ) ; } } return result ; } 
public OutputStream newOutputStream ( int index ) throws IOException { synchronized ( DiskLruCache . this ) { if ( entry . currentEditor != this ) { throw new IllegalStateException ( ) ; } if ( ! entry . readable ) { written [ index ] = true ; } File dirtyFile = entry . getDirtyFile ( index ) ; FileOutputStream outputStream ; try { outputStream = new FileOutputStream ( dirtyFile ) ; } catch ( FileNotFoundException e ) { directory . mkdirs ( ) ; try { outputStream = new FileOutputStream ( dirtyFile ) ; } catch ( FileNotFoundException e2 ) { return NULL_OUTPUT_STREAM ; } } return new FaultHidingOutputStream ( outputStream ) ; } } 
public String toStringVerbose ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( groupName ) . append ( ":-" ) ; sb . append ( groupDescription ) . append ( "-" ) ; Map < StatDefinition , Stat < ? >> sortedStats = new TreeMap < StatDefinition , Stat < ? >> ( stats ) ; for ( Stat < ? > s : sortedStats . values ( ) ) { sb . append ( "-" ) . append ( s . toStringVerbose ( ) ) . append ( "-" ) ; } return sb . toString ( ) ; } 
public int getRowCount ( ) { if ( validateIfNecessary ( ) ) { return grid . length ; } return 0 ; } 
public void setDefaultColors ( String ... colors ) { options . colors . clear ( ) ; if ( colors != null ) { options . colors . addAll ( Arrays . asList ( colors ) ) ; } } 
@ Override public XYItemRendererState initialise ( Graphics2D g2 , Rectangle2D dataArea , XYPlot plot , XYDataset data , PlotRenderingInfo info ) { return new State ( info ) ; } 
public XObject execute ( XPathContext xctxt ) throws javax . xml . transform . TransformerException { return new XNumber ( getArg0AsString ( xctxt ) . length ( ) ) ; } 
public Class < ? > getListenerType ( ) { return ( this . listenerTypeRef != null ) ? this . listenerTypeRef . get ( ) : null ; } 
protected void printResults ( PrintStream out ) { log . debug ( "printResults()" ) ; StringBuilder line = new StringBuilder ( ) ; out . println ( line ) ; out . println ( ) ; } 
public boolean hasSameRules ( TimeZone other ) { return other != null && getRawOffset ( ) == other . getRawOffset ( ) && useDaylightTime ( ) == other . useDaylightTime ( ) ; } 
public static String getPast ( String infinitive ) { String result = infinitive ; char first = infinitive . charAt ( infinitive . length ( ) - 1 ) ; char second = infinitive . charAt ( infinitive . length ( ) - 2 ) ; if ( isConsonantVowelConsonant ( infinitive ) ) { result += first ; } else if ( first == 'y' && ! isVowel ( second ) ) { result = result . substring ( 0 , result . length ( ) - 1 ) + "i" ; } else if ( first == 'e' ) { result = result . substring ( 0 , result . length ( ) - 1 ) ; } return result + "ed" ; } 
public void kill ( ) throws IOException { _running . set ( false ) ; _clients . killall ( ) ; _socket . close ( ) ; } 
void read ( ) throws IOException { if ( keyType == 0 ) { file . read ( keyBytes ) ; data = new String ( keyBytes ) . trim ( ) ; } else { data = new Double ( file . readDouble ( ) ) ; } } 
public void setParameters ( Object [ ] params ) throws CDKException { if ( params . length != 1 ) { throw new CDKException ( "PiContactDetectionDescriptor-expects-1-parameters" ) ; } if ( ! ( params [ 0 ] instanceof Boolean ) ) { throw new CDKException ( "The-first-parameter-must-be-of-type-Boolean" ) ; } checkAromaticity = ( Boolean ) params [ 0 ] ; } 
public Iterator < K > keyIterator ( K from ) { return new Cursor < K , V > ( this , root , from ) ; } 
private int getValidIntInput ( int min , int max ) { int response ; while ( true ) { try { response = input . nextInt ( ) ; input . nextLine ( ) ; if ( response >= min && response <= max ) { return response ; } } catch ( InputMismatchException ex ) { } output . println ( "*-Sorry,-I-didn't-understand-your-response.-Please-try-again." ) ; } } 
public static String getAPILocaleFormatted ( ) { StringBuffer formatted = new StringBuffer ( ) ; if ( APILocale . getLanguage ( ) != null && ! APILocale . getLanguage ( ) . equals ( "" ) ) { formatted . append ( APILocale . getLanguage ( ) ) ; } if ( APILocale . getCountry ( ) != null && ! APILocale . getCountry ( ) . equals ( "" ) ) { formatted . append ( "-" ) . append ( APILocale . getCountry ( ) ) ; } return formatted . toString ( ) ; } 
public void removeListener ( AnimatorListener listener ) { if ( mListeners == null ) { return ; } mListeners . remove ( listener ) ; if ( mListeners . size ( ) == 0 ) { mListeners = null ; } } 
public synchronized void finalizeConnections ( ) throws SQLException { if ( enablePooling ) { Connection c = null ; while ( ! freeConnections . isEmpty ( ) ) { c = ( Connection ) freeConnections . pop ( ) ; c . close ( ) ; } } } 
public TrackEntry setAnimation ( int trackIndex , Animation animation , boolean loop ) { TrackEntry current = expandToIndex ( trackIndex ) ; if ( current != null ) freeAll ( current . next ) ; TrackEntry entry = trackEntryPool . obtain ( ) ; entry . animation = animation ; entry . loop = loop ; entry . endTime = animation . getDuration ( ) ; setCurrent ( trackIndex , entry ) ; return entry ; } 
protected void damageLineRange ( int line0 , int line1 , Shape a , Component host ) { if ( a == null ) return ; Rectangle rec0 = lineToRect ( a , line0 ) ; Rectangle rec1 = lineToRect ( a , line1 ) ; if ( rec0 == null || rec1 == null ) host . repaint ( ) ; else { Rectangle repaintRec = SwingUtilities . computeUnion ( rec0 . x , rec0 . y , rec0 . width , rec0 . height , rec1 ) ; host . repaint ( repaintRec . x , repaintRec . y , repaintRec . width , repaintRec . height ) ; } } 
public int indexOf ( Object elem ) { return delegate . indexOf ( elem ) ; } 
public static String classNamesToString ( Collection < Class < ? >> classes ) { if ( CollectionUtils . isEmpty ( classes ) ) { return "[]" ; } StringBuilder sb = new StringBuilder ( "[" ) ; for ( Iterator < Class < ? >> it = classes . iterator ( ) ; it . hasNext ( ) ; ) { Class < ? > clazz = it . next ( ) ; sb . append ( clazz . getName ( ) ) ; if ( it . hasNext ( ) ) { sb . append ( ",-" ) ; } } sb . append ( "]" ) ; return sb . toString ( ) ; } 
public void getChars ( int srcBegin , int srcEnd , char dst [ ] , int dstBegin ) { str ( ) . getChars ( srcBegin , srcEnd , dst , dstBegin ) ; } 
@ SuppressWarnings ( "deprecation" ) public static String urlUnescape ( String s ) { try { return URLDecoder . decode ( s , "UTF8" ) ; } catch ( UnsupportedEncodingException e ) { return URLDecoder . decode ( s ) ; } } 
public static void setEnumDocumentation ( Configuration configuration , ClassDoc classDoc ) { MethodDoc [ ] methods = classDoc . methods ( ) ; for ( int j = 0 ; j < methods . length ; j ++ ) { MethodDoc currentMethod = methods [ j ] ; if ( currentMethod . name ( ) . equals ( "values" ) && currentMethod . parameters ( ) . length == 0 ) { currentMethod . setRawCommentText ( configuration . getText ( "doclet.enum_values_doc" , classDoc . name ( ) ) ) ; } else if ( currentMethod . name ( ) . equals ( "valueOf" ) && currentMethod . parameters ( ) . length == 1 ) { Type paramType = currentMethod . parameters ( ) [ 0 ] . type ( ) ; if ( paramType != null && paramType . qualifiedTypeName ( ) . equals ( String . class . getName ( ) ) ) { currentMethod . setRawCommentText ( configuration . getText ( "doclet.enum_valueof_doc" ) ) ; } } } } 
private void relayoutMeasuredItem ( View child ) { final int w = child . getMeasuredWidth ( ) ; final int h = child . getMeasuredHeight ( ) ; final int childLeft = mListPadding . left ; final int childRight = childLeft + w ; final int childTop = child . getTop ( ) ; final int childBottom = childTop + h ; child . layout ( childLeft , childTop , childRight , childBottom ) ; } 
public static String numberToString ( Number number ) throws JSONException { if ( number == null ) { throw new JSONException ( "Null-pointer" ) ; } testValidity ( number ) ; String string = number . toString ( ) ; if ( string . indexOf ( '.' ) > 0 && string . indexOf ( 'e' ) < 0 && string . indexOf ( 'E' ) < 0 ) { while ( string . endsWith ( "0" ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } if ( string . endsWith ( "." ) ) { string = string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; } 
public void clear ( ) { _queue . clear ( ) ; } 
@ Override public Number parse ( String string , ParsePosition position ) { Number number = dform . parse ( string , position ) ; if ( null == number ) { return null ; } if ( this . isParseBigDecimal ( ) ) { if ( number instanceof Long ) { return new BigDecimal ( number . longValue ( ) ) ; } if ( ( number instanceof Double ) && ! ( ( Double ) number ) . isInfinite ( ) && ! ( ( Double ) number ) . isNaN ( ) ) { return new BigDecimal ( number . doubleValue ( ) ) ; } if ( number instanceof BigInteger ) { return new BigDecimal ( number . doubleValue ( ) ) ; } if ( number instanceof IcuBigDecimal ) { return new BigDecimal ( number . toString ( ) ) ; } return number ; } if ( ( number instanceof IcuBigDecimal ) || ( number instanceof BigInteger ) ) { return new Double ( number . doubleValue ( ) ) ; } if ( this . isParseIntegerOnly ( ) && number . equals ( NEGATIVE_ZERO_DOUBLE ) ) { return new Long ( 0 ) ; } return number ; } 
@ Override public int compareTo ( Request < T > other ) { Priority left = this . getPriority ( ) ; Priority right = other . getPriority ( ) ; return left == right ? this . mSequence - other . mSequence : right . ordinal ( ) - left . ordinal ( ) ; } 
public void awaitCall ( final int callCount ) throws InterruptedException { sem . acquire ( callCount ) ; } 
public Set < String > getSupportedAnnotationTypes ( ) { SupportedAnnotationTypes sat = this . getClass ( ) . getAnnotation ( SupportedAnnotationTypes . class ) ; if ( sat == null ) { if ( isInitialized ( ) ) processingEnv . getMessager ( ) . printMessage ( Diagnostic . Kind . WARNING , "No-SupportedAnnotationTypes-annotation-" + "found-on-" + this . getClass ( ) . getName ( ) + ",-returning-an-empty-set." ) ; return Collections . emptySet ( ) ; } else return arrayToSet ( sat . value ( ) ) ; } 
private BorderPainter getBorderPainter ( int side ) { Value style = getBorderStyle ( side ) ; return borderPainters . get ( style ) ; } 
public String getDisplayLanguage ( Locale locale ) { if ( languageCode . isEmpty ( ) ) { return "" ; } String localeString = toString ( ) ; if ( languageCode . equals ( "tl" ) ) { localeString = toNewString ( "fil" , countryCode , variantCode ) ; } String result = ICU . getDisplayLanguageNative ( localeString , locale . toString ( ) ) ; if ( result == null ) { result = ICU . getDisplayLanguageNative ( localeString , Locale . getDefault ( ) . toString ( ) ) ; } return result ; } 
@ Override public boolean isRunning ( ) { for ( Node node : mNodes ) { if ( node . animation . isRunning ( ) ) { return true ; } } return false ; } 
public boolean empty ( ) { return changes . isEmpty ( ) || changesOntologies . isEmpty ( ) ; } 
public boolean isVarargs ( ) { return testAllFlags ( VARARGS ) && isInvocable ( ) ; } 
public int getRowCount ( ) { return list . size ( ) ; } 
public void endElement ( String uri , String localName , String qName ) throws SAXException { if ( contentHandler != null ) { contentHandler . endElement ( uri , localName , qName ) ; } } 
public void removeAllUpdateListeners ( ) { if ( mUpdateListeners == null ) { return ; } mUpdateListeners . clear ( ) ; mUpdateListeners = null ; } 
public synchronized java . io . InputStream getBinaryStream ( ) throws SQLException { checkClosed ( ) ; return new ByteArrayInputStream ( getBinaryData ( ) ) ; } 
public String toString ( ) { if ( sourceString != null ) return sourceString ; else { StringBuffer buffer = new StringBuffer ( ) ; appendOutputString ( progCt - 1 , buffer ) ; return buffer . toString ( ) ; } } 
public int getDefaultKeyboardBrightness ( ) { return mContext . getResources ( ) . getInteger ( com . android . internal . R . integer . config_keyboardBrightnessSettingDefault ) ; } 
public List < String > getCategory ( ) { if ( category == null ) { category = new ArrayList < String > ( ) ; } return this . category ; } 
@ SuppressWarnings ( "unused" ) public static PtNode findWordInTree ( PtNodeArray nodeArray , final String string ) { int index = 0 ; final StringBuilder checker = DBG ? new StringBuilder ( ) : null ; final int [ ] codePoints = getCodePoints ( string ) ; PtNode currentPtNode ; do { int indexOfGroup = findIndexOfChar ( nodeArray , codePoints [ index ] ) ; if ( CHARACTER_NOT_FOUND_INDEX == indexOfGroup ) return null ; currentPtNode = nodeArray . mData . get ( indexOfGroup ) ; if ( codePoints . length - index < currentPtNode . mChars . length ) return null ; int newIndex = index ; while ( newIndex < codePoints . length && newIndex - index < currentPtNode . mChars . length ) { if ( currentPtNode . mChars [ newIndex - index ] != codePoints [ newIndex ] ) return null ; newIndex ++ ; } index = newIndex ; if ( DBG ) { checker . append ( new String ( currentPtNode . mChars , 0 , currentPtNode . mChars . length ) ) ; } if ( index < codePoints . length ) { nodeArray = currentPtNode . mChildren ; } } while ( null != nodeArray && index < codePoints . length ) ; if ( index < codePoints . length ) return null ; if ( ! currentPtNode . isTerminal ( ) ) return null ; if ( DBG && ! string . equals ( checker . toString ( ) ) ) return null ; return currentPtNode ; } 
public boolean hasFeature ( int feature ) { return ( getFeatures ( ) & ( 1 << feature ) ) != 0 ; } 
public void set_invoke ( boolean invoke ) throws Exception { this . invoke = new Boolean ( invoke ) ; } 
public static Uri decryptFile ( Uri sourceUri , PrivateKey privateKey , ProgressListener progressListener ) throws Exception { File sourceFile = new File ( new URI ( sourceUri . toString ( ) ) ) ; DataInputStream cryptedInputStream = new DataInputStream ( new FileInputStream ( sourceFile ) ) ; int keyLength = cryptedInputStream . readInt ( ) ; byte [ ] encryptedKey = new byte [ keyLength ] ; int readed = 0 ; while ( readed < keyLength ) readed += cryptedInputStream . read ( encryptedKey , readed , keyLength - readed ) ; SecretKey secretKey = decryptSecretKey ( privateKey , encryptedKey ) ; long contentLength = sourceFile . length ( ) - keyLength ; File outputFile = decryptFileContent ( secretKey , cryptedInputStream , contentLength , sourceUri , progressListener ) ; cryptedInputStream . close ( ) ; return Uri . fromFile ( outputFile ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public static List < Integer > getTerminalEvents ( EFG efg ) { List < Integer > terminalEvents = new ArrayList < Integer > ( ) ; List < RowType > eventMatrix = efg . getEventGraph ( ) . getRow ( ) ; for ( RowType row : eventMatrix ) { for ( int i = 0 ; i < eventMatrix . size ( ) ; i ++ ) { if ( row . getE ( ) . get ( i ) == 3 && terminalEvents . indexOf ( i ) == - 1 ) { terminalEvents . add ( i ) ; } } } return terminalEvents ; } 
protected void configureEnclosingScrollPane ( ) { Container parent = SwingUtilities . getUnwrappedParent ( this ) ; if ( parent instanceof JViewport ) { JViewport port = ( JViewport ) parent ; Container gp = port . getParent ( ) ; if ( gp instanceof JScrollPane ) { JScrollPane scrollPane = ( JScrollPane ) gp ; JViewport viewport = scrollPane . getViewport ( ) ; if ( viewport == null || SwingUtilities . getUnwrappedView ( viewport ) != this ) { return ; } scrollPane . setColumnHeaderView ( getTableHeader ( ) ) ; configureEnclosingScrollPaneUI ( ) ; } } } 
public final int hashCode ( ) { return name ( ) . hashCode ( ) ; } 
private void rotateLeft ( final Node node , final int index ) { Node rightChild = node . getRight ( index ) ; node . setRight ( rightChild . getLeft ( index ) , index ) ; if ( rightChild . getLeft ( index ) != null ) { rightChild . getLeft ( index ) . setParent ( node , index ) ; } rightChild . setParent ( node . getParent ( index ) , index ) ; if ( node . getParent ( index ) == null ) { rootNode [ index ] = rightChild ; } else if ( node . getParent ( index ) . getLeft ( index ) == node ) { node . getParent ( index ) . setLeft ( rightChild , index ) ; } else { node . getParent ( index ) . setRight ( rightChild , index ) ; } rightChild . setLeft ( node , index ) ; node . setParent ( rightChild , index ) ; } 
public static String formatTokenName ( String tokenName ) { if ( tokenName . length ( ) > 0 && tokenName . startsWith ( "'" ) ) { tokenName = tokenName . substring ( 1 , tokenName . length ( ) ) ; } if ( tokenName . length ( ) > 0 && tokenName . endsWith ( "'" ) ) { tokenName = tokenName . substring ( 0 , tokenName . length ( ) - 1 ) ; } return tokenName ; } 
public void styleChannel ( String channel , Style style ) { if ( this . channelStyles == null ) { this . channelStyles = new HashMap < String , Style > ( ) ; } this . channelStyles . put ( channel . toLowerCase ( ) , style ) ; } 
protected void updateExporter ( ) { exporter . setActivated ( ! shapes . isEmpty ( ) ) ; } 
public static Timestamp from ( Instant instant ) { try { Timestamp stamp = new Timestamp ( instant . getEpochSecond ( ) * MILLIS_PER_SECOND ) ; stamp . nanos = instant . getNano ( ) ; return stamp ; } catch ( ArithmeticException ex ) { throw new IllegalArgumentException ( ex ) ; } } 
public String sectionToString ( int i ) { if ( i > 3 ) return null ; StringBuffer sb = new StringBuffer ( ) ; Record [ ] records = getSectionArray ( i ) ; for ( int j = 0 ; j < records . length ; j ++ ) { Record rec = records [ j ] ; if ( i == Section . QUESTION ) { sb . append ( ";;-" + rec . name ) ; sb . append ( ",-type-=-" + Type . string ( rec . type ) ) ; sb . append ( ",-class-=-" + DClass . string ( rec . dclass ) ) ; } else sb . append ( rec ) ; sb . append ( "-" ) ; } return sb . toString ( ) ; } 
@ Override public int getMergeCost ( ) { return wrappedResultSet . getMergeCost ( ) ; } 
public Status ( List < String > code , String message , StatusDetail detail ) throws IllegalArgumentException { if ( detail != null ) { String c = ( String ) ( code . iterator ( ) . next ( ) ) ; if ( c . equals ( STATUS_OK ) || c . equals ( STATUS_SYNTAX_ERROR ) || c . equals ( STATUS_PROCESSING_ERROR ) ) throw new IllegalArgumentException ( "status-detail-cannot-be-" + "included-with-" + c ) ; } this . code = Collections . unmodifiableList ( new ArrayList < String > ( code ) ) ; this . message = message ; this . detail = detail ; } 
static void setAccessibleWorkaround ( AccessibleObject o ) { if ( ( o == null ) || o . isAccessible ( ) ) { return ; } final Member m = ( Member ) o ; if ( Modifier . isPublic ( m . getModifiers ( ) ) && isPackage ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( true ) ; } catch ( final SecurityException e ) { } } } 
public final Iterator < AuthorityEntry > authoritiesIterator ( ) { return mDataAuthorities != null ? mDataAuthorities . iterator ( ) : null ; } 
public synchronized void setMaxSize ( long maxSize ) { this . maxSize = maxSize ; executorService . submit ( cleanupCallable ) ; } 
public double timeSec ( ) { long time = time ( ) ; return time / 1000000000d ; } 
public void onParsedJavaClass ( final JavaClass jClass ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { getProgressBar ( ) . setValue ( getProgressBar ( ) . getValue ( ) + 1 ) ; } } ) ; } 
private void doSignalAll ( Node first ) { lastWaiter = firstWaiter = null ; do { Node next = first . nextWaiter ; first . nextWaiter = null ; transferForSignal ( first ) ; first = next ; } while ( first != null ) ; } 
void doReps ( ObjectOutputStream oout , ObjectInputStream oin , StreamBuffer sbuf , String [ ] strs , int nbatches , int ncycles ) throws Exception { for ( int i = 0 ; i < nbatches ; i ++ ) { sbuf . reset ( ) ; oout . reset ( ) ; for ( int j = 0 ; j < ncycles ; j ++ ) { oout . writeObject ( strs [ j ] ) ; } oout . flush ( ) ; for ( int j = 0 ; j < ncycles ; j ++ ) { oin . readObject ( ) ; } } } 
public boolean gTest ( final double [ ] expected , final long [ ] observed , final double alpha ) throws NotPositiveException , NotStrictlyPositiveException , DimensionMismatchException , OutOfRangeException , MaxCountExceededException { if ( ( alpha <= 0 ) || ( alpha > 0.5 ) ) { throw new OutOfRangeException ( LocalizedFormats . OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , 0 , 0.5 ) ; } return gTest ( expected , observed ) < alpha ; } 
protected MouseListener createMouseListener ( ) { return getHandler ( ) ; } 
public String findLibrary ( String libraryName ) { String fileName = System . mapLibraryName ( libraryName ) ; for ( File directory : nativeLibraryDirectories ) { String path = new File ( directory , fileName ) . getPath ( ) ; if ( IoUtils . canOpenReadOnly ( path ) ) { return path ; } } return null ; } 
static void exhaustInputStream ( InputStream inStream ) throws IOException { byte buffer [ ] = new byte [ 1024 ] ; while ( inStream . read ( buffer ) >= 0 ) { ; } } 
public double weightedRF ( Tree t ) throws TreeException { double rf = 0.0 ; for ( Split s : getSplits ( ) ) { Split es = t . getEquivilantSplit ( s ) ; rf = ( es == null ) ? rf + s . getLength ( ) : rf + Math . abs ( s . getLength ( ) - es . getLength ( ) ) ; } for ( Split s : t . getSplits ( ) ) { Split es = getEquivilantSplit ( s ) ; rf = ( es == null ) ? rf + s . getLength ( ) : rf + Math . abs ( s . getLength ( ) - es . getLength ( ) ) ; } return rf ; } 
public static String [ ] searchRestName ( String restName ) { try { Statement stmt = conn . createStatement ( ) ; ResultSet rs = stmt . executeQuery ( "Select-RestName-from-Restaurant-" + "WHERE-RestName-Like-"" + restName + "%" + """ ) ; int rowcount = 0 ; if ( ! rs . next ( ) ) { String [ ] wrong = new String [ ] { "wrong" } ; return wrong ; } if ( rs . last ( ) ) { rowcount = rs . getRow ( ) ; rs . beforeFirst ( ) ; } name = new String [ rowcount ] ; int i = 0 ; while ( rs . next ( ) ) { name [ i ] = rs . getString ( "RestName" ) ; i ++ ; } close ( stmt ) ; } catch ( Exception e ) { System . err . println ( e . getMessage ( ) ) ; } return name ; } 
boolean newPage ( ) { return document . newPage ( ) ; } 
@ Deprecated public void setHours ( int hour ) { GregorianCalendar cal = new GregorianCalendar ( milliseconds ) ; cal . set ( Calendar . HOUR_OF_DAY , hour ) ; milliseconds = cal . getTimeInMillis ( ) ; } 
public void onEntityCollidedWithBlock ( World par1World , int par2 , int par3 , int par4 , Entity par5Entity ) { par5Entity . attackEntityFrom ( DamageSource . cactus , 1 ) ; } 
protected String getUrl ( ) { String str = source ; str = str . replaceFirst ( "imagedata" , "text" ) ; int indx = str . indexOf ( "VERSION" ) ; str = str . substring ( 0 , indx ) ; str = str . concat ( "file=SATBAND" ) ; return str ; } 
protected boolean canAdd ( V value , Collection < V > values ) { return value != null && ! values . contains ( value ) ; } 
public static void decodeFileToFile ( String infile , String outfile ) { byte [ ] decoded = Base64 . decodeFromFile ( infile ) ; java . io . OutputStream out = null ; try { out = new java . io . BufferedOutputStream ( new java . io . FileOutputStream ( outfile ) ) ; out . write ( decoded ) ; } catch ( java . io . IOException ex ) { ex . printStackTrace ( ) ; } finally { try { out . close ( ) ; } catch ( Exception ex ) { } } } 
public Map < String , UserPersonal > gatherPersonalInformation ( final Collection < String > usernames ) throws ServiceException { try { Map < String , UserPersonal > result = new HashMap < String , UserPersonal > ( usernames . size ( ) ) ; for ( String username : usernames ) { result . put ( username , userQueries . getPersonalInfoForUser ( username ) ) ; } return result ; } catch ( DataAccessException e ) { throw new ServiceException ( e ) ; } } 
public String getTableName ( int column ) throws SQLException { if ( this . useOldAliasBehavior ) { return getField ( column ) . getTableName ( ) ; } return getField ( column ) . getTableNameNoAliases ( ) ; } 
public void invokeCancel ( ) { cancelAction . actionPerformed ( null ) ; } 
protected File getLocation ( String location , String defaultFolder ) throws MalformedURLException , URISyntaxException { URL locationURL ; try { locationURL = new URI ( location ) . toURL ( ) ; } catch ( IllegalArgumentException e ) { if ( location . startsWith ( File . separator ) || location . startsWith ( ":" + File . separator , 1 ) ) locationURL = new File ( location ) . toURI ( ) . toURL ( ) ; else locationURL = new File ( defaultFolder , location ) . toURI ( ) . toURL ( ) ; } return new File ( locationURL . toURI ( ) ) ; } 
private final static boolean isMixedCaseWord ( String word , boolean startsSentance ) { int strLen = word . length ( ) ; boolean isUpper = Character . isUpperCase ( word . charAt ( 0 ) ) ; if ( ( startsSentance ) && isUpper && ( strLen > 1 ) ) isUpper = Character . isUpperCase ( word . charAt ( 1 ) ) ; if ( isUpper ) { for ( int i = word . length ( ) - 1 ; i > 0 ; i -- ) { if ( Character . isLowerCase ( word . charAt ( i ) ) ) { return true ; } } } else { for ( int i = word . length ( ) - 1 ; i > 0 ; i -- ) { if ( Character . isUpperCase ( word . charAt ( i ) ) ) { return true ; } } } return false ; } 
public synchronized void discardMostRecentElements ( int i ) { discardExtremeElements ( i , false ) ; } 
public void updateMaxTimeRemaining ( int m ) { timeRemaining . setMaximum ( m ) ; } 
public boolean dispatchKeyShortcutEvent ( KeyEvent event ) { return onKeyShortcut ( event . getKeyCode ( ) , event ) ; } 
protected String add1ToBits ( String bin_num ) { String r = "" ; boolean end_flag = false ; for ( int i = bin_num . length ( ) - 1 ; 0 <= i ; i -- ) { if ( end_flag == false ) { if ( bin_num . charAt ( i ) == '1' ) { r = "0" + r ; } else { r = "1" + r ; end_flag = true ; } } else { r = bin_num . charAt ( i ) + r ; } } return r ; } 
public int getUnscaledWidth ( ) { if ( displayImage == null ) return 0 ; return displayImage . getWidth ( ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public synchronized String makeEscapedCompactString ( ) { String [ ] groupsArray = new String [ counters . size ( ) ] ; int i = 0 ; int length = 0 ; for ( Group group : this ) { String escapedString = group . makeEscapedCompactString ( ) ; groupsArray [ i ++ ] = escapedString ; length += escapedString . length ( ) ; } StringBuilder builder = new StringBuilder ( length ) ; for ( String group : groupsArray ) { builder . append ( group ) ; } return builder . toString ( ) ; } 
public void onWindowHidden ( ) { if ( mAnimationExitIndex == 0 ) { mWindow . getWindow ( ) . setWindowAnimations ( android . R . style . Animation_InputMethod ) ; return ; } final Dialog dialog = this . getWindow ( ) ; mWindowIme = dialog . getWindow ( ) ; mWindowIme . setWindowAnimations ( - 1 ) ; final Handler handler = new Handler ( ) ; final Runnable runnable = new Runnable ( ) { @ Override public void run ( ) { dialog . hide ( ) ; } } ; Animation anim = retrieveAnimation ( false ) ; if ( anim != null ) { anim . setAnimationListener ( new AnimationListener ( ) { @ Override public void onAnimationStart ( Animation animation ) { } @ Override public void onAnimationRepeat ( Animation animation ) { } @ Override public void onAnimationEnd ( Animation animation ) { handler . removeCallbacks ( runnable ) ; dialog . hide ( ) ; } } ) ; dialog . show ( ) ; mRootView . startAnimation ( anim ) ; if ( mAnimationDuration > 0 ) { handler . postDelayed ( runnable , ( mAnimationDuration * 2 ) ) ; } else { handler . postDelayed ( runnable , 1000 ) ; } } } 
public void show ( ) { LayoutParams lp = ( LayoutParams ) mContentView . getLayoutParams ( ) ; lp . height = LayoutParams . WRAP_CONTENT ; mContentView . setLayoutParams ( lp ) ; } 
public static List findAdvisorsThatCanApply ( List candidateAdvisors , Class clazz ) { if ( candidateAdvisors . isEmpty ( ) ) { return candidateAdvisors ; } List eligibleAdvisors = new LinkedList ( ) ; for ( Iterator it = candidateAdvisors . iterator ( ) ; it . hasNext ( ) ; ) { Advisor candidate = ( Advisor ) it . next ( ) ; if ( candidate instanceof IntroductionAdvisor && canApply ( candidate , clazz ) ) { eligibleAdvisors . add ( candidate ) ; } } boolean hasIntroductions = ! eligibleAdvisors . isEmpty ( ) ; for ( Iterator it = candidateAdvisors . iterator ( ) ; it . hasNext ( ) ; ) { Advisor candidate = ( Advisor ) it . next ( ) ; if ( candidate instanceof IntroductionAdvisor ) { continue ; } if ( canApply ( candidate , clazz , hasIntroductions ) ) { eligibleAdvisors . add ( candidate ) ; } } return eligibleAdvisors ; } 
public BitmapWorkerTask getBitmapWorkerTask ( ) { return bitmapWorkerReference . get ( ) ; } 
public static boolean isHashCodeMethod ( Method method ) { return ( method != null && method . getName ( ) . equals ( "hashCode" ) && method . getParameterTypes ( ) . length == 0 ) ; } 
@ LiveRead @ SnapshotRead public Iterable < V > getValues ( ) { LinkedHashSet < V > values = new LinkedHashSet < > ( snapshot . size ( ) ) ; synchronized ( live ) { values . addAll ( Arrays . asList ( live . values ( ) ) ) ; } values . addAll ( Arrays . asList ( snapshot . values ( ) ) ) ; return values ; } 
public void addGlobalGroupDecl ( XSGroupDecl decl ) { fGlobalGroupDecls . put ( decl . fName , decl ) ; decl . setNamespaceItem ( this ) ; } 
public static long parseLockTimeStr ( String lockTimeStr ) throws ParseException { if ( lockTimeStr . indexOf ( "/" ) != - 1 ) { SimpleDateFormat format = new SimpleDateFormat ( "yyyy/MM/dd" ) ; Date date = format . parse ( lockTimeStr ) ; return date . getTime ( ) / 1000 ; } return Long . parseLong ( lockTimeStr ) ; } 
public static IAeFaultFactory getFactory ( String aNamespace ) { if ( IAeBPELConstants . WSBPEL_2_0_NAMESPACE_URI . equals ( aNamespace ) ) return WSBPEL ; else return BPEL4WS ; } 
public void setWeeklyWorkHours ( JAXBElement < BigDecimal > value ) { this . weeklyWorkHours = ( ( JAXBElement < BigDecimal > ) value ) ; } 
public boolean isSortable ( int column ) { checkColumn ( column ) ; return ( isSortable == null ) ? true : isSortable [ column ] ; } 
public static void addConfigurationListener ( ConfigurationListener listener ) { CONFIGURATION_LISTENERS . add ( listener ) ; } 
protected void updateUndoPositions ( Vector positions ) { for ( int counter = positions . size ( ) - 1 ; counter >= 0 ; counter -- ) { UndoPosRef ref = ( UndoPosRef ) positions . elementAt ( counter ) ; if ( ref . rec . unused ) { positions . removeElementAt ( counter ) ; } else ref . resetLocation ( ) ; } } 
public static Data tan ( Data data ) throws VisADException , RemoteException { return data . tan ( ) ; } 
public final TextBuilder append ( String str , int start , int end ) { if ( str == null ) return append ( "null" ) ; if ( ( start < 0 ) || ( end < 0 ) || ( start > end ) || ( end > str . length ( ) ) ) throw new IndexOutOfBoundsException ( "start:-" + start + ",-end:-" + end + ",-str.length():-" + str . length ( ) ) ; int newLength = _length + end - start ; while ( _capacity < newLength ) { increaseCapacity ( ) ; } for ( int i = start , j = _length ; i < end ; ) { char [ ] chars = _high [ j >> B1 ] ; int dstBegin = j & M1 ; int inc = Math . min ( C1 - dstBegin , end - i ) ; str . getChars ( i , ( i += inc ) , chars , dstBegin ) ; j += inc ; } _length = newLength ; return this ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
protected static final void logWarnings ( final List warningsToLog , final String message ) { if ( ( warningsToLog != null ) && ( ! warningsToLog . isEmpty ( ) ) ) { final IStatus status = new MultiStatus ( WorkbenchPlugin . PI_WORKBENCH , 0 , ( IStatus [ ] ) warningsToLog . toArray ( new IStatus [ warningsToLog . size ( ) ] ) , message , null ) ; WorkbenchPlugin . log ( status ) ; } } 
public String toString ( ) { CharArrayBuffer buffer = new CharArrayBuffer ( 16 ) ; buffer . append ( this . protocol ) ; buffer . append ( '/' ) ; buffer . append ( Integer . toString ( this . major ) ) ; buffer . append ( '.' ) ; buffer . append ( Integer . toString ( this . minor ) ) ; return buffer . toString ( ) ; } 
public Region createFromParcel ( Parcel p ) { int ni = nativeCreateFromParcel ( p ) ; if ( ni == 0 ) { throw new RuntimeException ( ) ; } return new Region ( ni ) ; } 
@ XmlElementDecl ( namespace = "http://webservice.uts.umls.nlm.nih.gov/" , name = "resolveValueSetDefinition" ) public JAXBElement < ResolveValueSetDefinition > createResolveValueSetDefinition ( ResolveValueSetDefinition value ) { return new JAXBElement < ResolveValueSetDefinition > ( _ResolveValueSetDefinition_QNAME , ResolveValueSetDefinition . class , null , value ) ; } 
public static Method getMethod ( java . lang . reflect . Method m ) { return new Method ( m . getName ( ) , Type . getMethodDescriptor ( m ) ) ; } 
public void clear ( ) { predraw ( ) ; GL . glClear ( SGL . GL_COLOR_BUFFER_BIT ) ; postdraw ( ) ; } 
public List < Dimension > getDimensions ( ) { if ( dimensions == null ) { dimensions = new ArrayList < Dimension > ( ) ; } return this . dimensions ; } 
@ XmlElementDecl ( namespace = "http://www.opengis.net/gml/3.2" , name = "CategoryList" , substitutionHeadNamespace = "http://www.opengis.net/gml/3.2" , substitutionHeadName = "AbstractScalarValueList" ) public JAXBElement < CodeOrNilReasonListType > createCategoryList ( CodeOrNilReasonListType value ) { return new JAXBElement < CodeOrNilReasonListType > ( _CategoryList_QNAME , CodeOrNilReasonListType . class , null , value ) ; } 
public static String readFully ( Reader reader ) throws IOException { try { StringWriter writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , count ) ; } return writer . toString ( ) ; } finally { reader . close ( ) ; } } 
public synchronized void setState ( int state ) { int current = getExtendedState ( ) ; if ( state == ICONIFIED && ( current & ICONIFIED ) == 0 ) { setExtendedState ( current | ICONIFIED ) ; } else if ( state == NORMAL && ( current & ICONIFIED ) != 0 ) { setExtendedState ( current & ~ ICONIFIED ) ; } } 
public Object getBroadcastCookie ( int index ) { return ( ( Callback ) mActiveBroadcast [ index ] ) . mCookie ; } 
private String createFlagList ( Flags flags ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( "(" ) ; Flags . Flag [ ] sf = flags . getSystemFlags ( ) ; boolean first = true ; for ( int i = 0 ; i < sf . length ; i ++ ) { String s ; Flags . Flag f = sf [ i ] ; if ( f == Flags . Flag . ANSWERED ) s = "|Answered" ; else if ( f == Flags . Flag . DELETED ) s = "|Deleted" ; else if ( f == Flags . Flag . DRAFT ) s = "|Draft" ; else if ( f == Flags . Flag . FLAGGED ) s = "|Flagged" ; else if ( f == Flags . Flag . RECENT ) s = "|Recent" ; else if ( f == Flags . Flag . SEEN ) s = "|Seen" ; else continue ; if ( first ) first = false ; else sb . append ( '-' ) ; sb . append ( s ) ; } String [ ] uf = flags . getUserFlags ( ) ; for ( int i = 0 ; i < uf . length ; i ++ ) { if ( first ) first = false ; else sb . append ( '-' ) ; sb . append ( uf [ i ] ) ; } sb . append ( ")" ) ; return sb . toString ( ) ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public Enumeration listOptions ( ) { Vector < Option > result ; result = new Vector < Option > ( ) ; Enumeration en = super . listOptions ( ) ; while ( en . hasMoreElements ( ) ) result . addElement ( ( Option ) en . nextElement ( ) ) ; result . addElement ( new Option ( "-The-class-index-(first-and-last-are-valid-as-well).-" + "-(default:-last)" , "C" , 1 , "-C-<class-index>" ) ) ; result . addElement ( new Option ( "-Compresses-the-data-(uses-'" + JSONLoader . FILE_EXTENSION_COMPRESSED + "'-as-extension-instead-of-'" + JSONLoader . FILE_EXTENSION + "')-" + "-(default:-off)" , "compress" , 0 , "-compress" ) ) ; return result . elements ( ) ; } 
@ Override public void write ( DataOutput dataOutput , Map < K , V > object ) throws IOException { dataOutput . writeInt ( object . size ( ) ) ; for ( Map . Entry < K , V > me : object . entrySet ( ) ) mapEntryConverter . write ( dataOutput , me ) ; } 
static LabelNode [ ] clone ( final List < LabelNode > labels , final Map < LabelNode , LabelNode > map ) { LabelNode [ ] clones = new LabelNode [ labels . size ( ) ] ; for ( int i = 0 ; i < clones . length ; ++ i ) { clones [ i ] = map . get ( labels . get ( i ) ) ; } return clones ; } 
public String getValue ( String name ) { return ( String ) get ( new Attributes . Name ( name ) ) ; } 
static void test1 ( SocketChannel client , SocketChannel server ) throws Exception { assert server . socket ( ) . getOOBInline ( ) ; ByteBuffer bb = ByteBuffer . allocate ( 100 ) ; for ( int i = 0 ; i < 1000 ; i ++ ) { int b1 = - 127 + rand . nextInt ( 384 ) ; client . socket ( ) . sendUrgentData ( b1 ) ; bb . clear ( ) ; if ( server . read ( bb ) != 1 ) throw new RuntimeException ( "One-byte-expected" ) ; bb . flip ( ) ; byte b2 = bb . get ( ) ; if ( ( byte ) b1 != b2 ) throw new RuntimeException ( "Unexpected-byte" ) ; } } 
public void setShareFromQQAuthSupport ( boolean shareFromQQLogin ) { reqMap . put ( "isShareTencentWeibo" , shareFromQQLogin ) ; } 
private final void setValue ( SharedPreferences prefs , boolean old , int position , String value ) { if ( old ) { final String key = String . format ( "TEXT%dOLD" , position ) ; changeValues . put ( key , value ) ; prefs . edit ( ) . putString ( key , value ) . commit ( ) ; } else { final String key = String . format ( "TEXT%dNEW" , position ) ; changeValues . put ( key , value ) ; prefs . edit ( ) . putString ( key , value ) . commit ( ) ; } } 
public void run ( ) { long tm = System . currentTimeMillis ( ) ; while ( Thread . currentThread ( ) == animator ) { repaint ( ) ; try { tm += delay ; Thread . sleep ( Math . max ( 0 , tm - System . currentTimeMillis ( ) ) ) ; } catch ( InterruptedException e ) { break ; } } } 
public boolean hasVaryAll ( ) { return varyFields . contains ( "*" ) ; } 
@ XmlElementDecl ( namespace = "http://www.w3.org/2000/09/xmldsig#" , name = "PGPData" ) public JAXBElement < PGPDataType > createPGPData ( PGPDataType value ) { return new JAXBElement < PGPDataType > ( _PGPData_QNAME , PGPDataType . class , null , value ) ; } 
protected boolean score ( Collector collector , int max , int firstDocID ) throws IOException { collector . setScorer ( this ) ; while ( currentDoc < max ) { collector . collect ( currentDoc ) ; if ( nextDoc ( ) == NO_MORE_DOCS ) { return false ; } } return true ; } 
public void setChildren ( List < Node > children ) { if ( children == null ) { throw new IllegalArgumentException ( "children-must-be-a-non-null-List" ) ; } for ( Node child : this . children ) { child . setParent ( null ) ; } this . children = new ArrayList < Node > ( children ) ; for ( Node child : this . children ) { child . setParent ( this ) ; } } 
public static double heading ( double lat1 , double lon1 , double lat2 , double lon2 ) { double h ; lat1 = Math . toRadians ( lat1 ) ; lat2 = Math . toRadians ( lat2 ) ; lon1 = Math . toRadians ( lon1 ) ; lon2 = Math . toRadians ( lon2 ) ; if ( Math . cos ( lat1 ) < 0.0001 ) { if ( lat1 > 0 ) h = 180 ; else h = 0 ; return h ; } double b = Math . atan2 ( Math . sin ( lon2 - lon1 ) * Math . cos ( lat2 ) , Math . cos ( lat1 ) * Math . sin ( lat2 ) - Math . sin ( lat1 ) * Math . cos ( lat2 ) * Math . cos ( lon2 - lon1 ) ) ; if ( b < 0 ) b = Math . PI * 2 + b ; return b ; } 
private static String getUriForViewId ( Object viewId ) { Iterator < String > it = instance . get ( ) . uriMap . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { String uri = it . next ( ) ; if ( instance . get ( ) . uriMap . get ( uri ) . equals ( viewId ) ) { return uri ; } } return null ; } 
protected I_CmsRequestHandler getRequestHandler ( String name ) { return m_requestHandlers . get ( name ) ; } 
protected void performFiltering ( CharSequence text , int start , int end , int keyCode ) { getFilter ( ) . filter ( text . subSequence ( start , end ) , this ) ; } 
private boolean overlap ( Set ruleRoles , Set userRoles ) { if ( ruleRoles . contains ( "any" ) ) { return true ; } Iterator i = userRoles . iterator ( ) ; while ( i . hasNext ( ) ) { String role = ( String ) i . next ( ) ; if ( ruleRoles . contains ( role ) ) { return true ; } } return false ; } 
public static void addHiddenNodeForNetwork ( CyNetwork net , int nodeIdx ) { List < Integer > hiddenNodesList = networkHiddenNodesMap . get ( net ) ; if ( hiddenNodesList == null ) { hiddenNodesList = new ArrayList < Integer > ( ) ; } hiddenNodesList . add ( new Integer ( nodeIdx ) ) ; networkHiddenNodesMap . put ( net , hiddenNodesList ) ; } 
public String toString ( ) { try { StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( query + "-" ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { buffer . append ( i + "-" + list . get ( i ) . length + "-" ) ; } return buffer . toString ( ) ; } catch ( Exception e ) { } return "<" + list . size ( ) + ">-" + query . toString ( ) ; } 
private boolean checkUser ( String userID , X509Certificate cert ) { Set < BigInteger > numSet = certsMap . get ( userID ) ; if ( numSet == null ) { LOG . info ( "User-" + userID + "-is-not-configured-in-the-user-certs-file" ) ; return false ; } if ( ! numSet . contains ( cert . getSerialNumber ( ) ) ) { LOG . info ( "Cert-with-serial-number-" + cert . getSerialNumber ( ) + "-is-not-listed-for-user-" + userID ) ; return false ; } return true ; } 
public void and ( BitSet set ) { if ( this == set ) return ; int oldUnitsInUse = unitsInUse ; unitsInUse = Math . min ( unitsInUse , set . unitsInUse ) ; int i ; for ( i = 0 ; i < unitsInUse ; i ++ ) bits [ i ] &= set . bits [ i ] ; for ( ; i < oldUnitsInUse ; i ++ ) bits [ i ] = 0 ; if ( unitsInUse > 0 && bits [ unitsInUse - 1 ] == 0 ) recalculateUnitsInUse ( ) ; } 
public String get ( int key ) { return mCapabilities . get ( key ) ; } 
public synchronized void setMBeanServer ( MBeanServer newMBS ) throws IllegalArgumentException , IllegalStateException { synchronized ( stateLock ) { if ( state == ONLINE || state == STARTING ) throw new IllegalStateException ( "Stop-server-before-" + "carrying-out-this-operation" ) ; } final String error = "MBeanServer-argument-must-be-MBean-server-where-this-" + "server-is-registered,-or-an-MBeanServerForwarder-" + "leading-to-that-server" ; Vector seenMBS = new Vector ( ) ; for ( MBeanServer mbs = newMBS ; mbs != bottomMBS ; mbs = ( ( MBeanServerForwarder ) mbs ) . getMBeanServer ( ) ) { if ( ! ( mbs instanceof MBeanServerForwarder ) ) throw new IllegalArgumentException ( error ) ; if ( seenMBS . contains ( mbs ) ) throw new IllegalArgumentException ( "MBeanServerForwarder-" + "loop" ) ; seenMBS . addElement ( mbs ) ; } topMBS = newMBS ; } 
public void draw ( Graphics g , Shape s ) { if ( s != null ) { ( ( Graphics2D ) g ) . draw ( s ) ; } } 
@ Override public double solve ( int maxEval , final UnivariateRealFunction f , final double min , final double max , final double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { setMaximalIterationCount ( maxEval ) ; return solve ( f , min , max , initial ) ; } 
public void onCancelContractDetails ( Contract contract ) { if ( m_client . isConnected ( ) ) { for ( Integer reqId : m_contractRequests . keySet ( ) ) { Contract value = m_contractRequests . get ( reqId ) ; if ( contract . equals ( value ) ) { m_contractRequests . remove ( reqId ) ; break ; } } } } 
public Builder contentLength ( int length ) { if ( length <= 0 ) { throw new IllegalStateException ( "Length-must-be-greater-than-zero." ) ; } isNotZero ( headerLength , "Length-header-already-set." ) ; headerLength = length ; return this ; } 
public void restoreVariableValues ( ) { restoreParameterValues ( ) ; } 
public double valueToJava2D ( double value , Rectangle2D area , RectangleEdge edge ) { Range range = getRange ( ) ; double axisMin = range . getLowerBound ( ) ; double axisMax = range . getUpperBound ( ) ; double min = 0.0 ; double max = 0.0 ; if ( RectangleEdge . isTopOrBottom ( edge ) ) { min = area . getX ( ) ; max = area . getMaxX ( ) ; } else if ( RectangleEdge . isLeftOrRight ( edge ) ) { max = area . getMinY ( ) ; min = area . getMaxY ( ) ; } if ( isInverted ( ) ) { return max - ( ( value - axisMin ) / ( axisMax - axisMin ) ) * ( max - min ) ; } else { return min + ( ( value - axisMin ) / ( axisMax - axisMin ) ) * ( max - min ) ; } } 
public final void dispose ( final boolean ok ) { if ( disposing || disposed ) { return ; } disposing = true ; try { log . info ( "OK=" + ok ) ; m_ok = ok ; stopWorker ( ) ; if ( ok ) { saveSelection ( ) ; } if ( _window != null ) { _window . removeAll ( ) ; _window . dispose ( ) ; } _window = null ; if ( localWindowNo ) { Env . clearWinContext ( getCtx ( ) , p_WindowNo ) ; } } finally { disposing = false ; disposed = true ; } } 
public int combine ( int firstIndex , int secondIndex , int opIndex ) throws CombineException { if ( firstIndex == secondIndex ) throw new CombineException ( "Can't-use-same-operand-twice!" ) ; int first = pieces [ firstIndex ] ; int second = pieces [ secondIndex ] ; Operation op = ops [ opIndex ] ; int result = op . operate ( first , second ) ; pieces [ secondIndex ] = result ; for ( int i = firstIndex + 1 ; i < numPieces ; i ++ ) pieces [ i - 1 ] = pieces [ i ] ; numPieces -- ; if ( ! opsReusable ) { for ( int i = opIndex + 1 ; i < numOps ; i ++ ) ops [ i - 1 ] = ops [ i ] ; numOps -- ; } return result ; } 
private static void writeHeader ( File file , OutputStream out ) throws IOException { String header = "***-" + file . toString ( ) + "-" ; out . write ( header . getBytes ( ) ) ; } 
public Socket connectSocketOnly ( ) throws IOException { if ( openSocket != null ) return openSocket ; return openSocket = new Socket ( host , port ) ; } 
public Widget removeChild ( Location location ) { if ( location == null ) { throw new NullPointerException ( "location-is-null" ) ; } Widget w = widgets . remove ( location ) ; if ( w != null ) { removeChild ( w ) ; } return w ; } 
@ Override public String getMessage ( ) { if ( nested != null ) return super . getMessage ( ) + "-(" + nested . getMessage ( ) + ")" ; else return super . getMessage ( ) ; } 
public String toString ( ) { LongArrayList theKeys = keys ( ) ; StringBuilder buf = new StringBuilder ( ) ; buf . append ( '[' ) ; int maxIndex = theKeys . size ( ) - 1 ; for ( int i = 0 ; i <= maxIndex ; i ++ ) { long key = theKeys . get ( i ) ; buf . append ( String . valueOf ( key ) ) ; buf . append ( "->" ) ; buf . append ( String . valueOf ( get ( key ) ) ) ; if ( i < maxIndex ) { buf . append ( ",-" ) ; } } buf . append ( ']' ) ; return buf . toString ( ) ; } 
public int indexOfIgnoreCase ( String s ) { Parser par = new Parser ( str , index ) ; while ( par . hasMore ( ) ) { if ( par . startsWithIgnoreCase ( s ) ) return par . getPos ( ) ; else par . skipChar ( ) ; } return - 1 ; } 
public boolean equals ( Object o ) { if ( o == this ) return true ; if ( ! ( o instanceof MBeanFeatureInfo ) ) return false ; MBeanFeatureInfo p = ( MBeanFeatureInfo ) o ; return ( p . getName ( ) . equals ( getName ( ) ) && p . getDescription ( ) . equals ( getDescription ( ) ) && p . getDescriptor ( ) . equals ( getDescriptor ( ) ) ) ; } 
public void showStatistics ( Canvas canvas , int width ) { long endTime = mTimes [ mTimesIdx ] = System . currentTimeMillis ( ) ; mTimesIdx = ( mTimesIdx + 1 ) % mFramesFPS ; float th = mPaint . getTextSize ( ) ; if ( mDisplayFPS ) { long startTime = mTimes [ mTimesIdx ] ; String fps = "" + ( 1000.0f * mFramesFPS / ( endTime - startTime ) ) ; if ( fps . indexOf ( "." ) == 1 ) { fps = "-" + fps ; } int len = fps . length ( ) ; if ( len == 2 ) { fps += ".00" ; } else if ( len == 4 ) { fps += "0" ; } else if ( len > 5 ) { fps = fps . substring ( 0 , 5 ) ; } canvas . drawText ( fps + "-fps" , width - 60.0f , 10.0f , mPaint ) ; } if ( mDisplayCounts ) { canvas . drawText ( mTriangles + "-triangles" , width - 100.0f , 10.0f + th + 5 , mPaint ) ; } } 
public static void opReadBlock ( DataOutputStream out , long blockId , long blockGs , long blockOffset , long blockLen , String clientName , BlockAccessToken accessToken ) throws IOException { op ( out , Op . READ_BLOCK ) ; out . writeLong ( blockId ) ; out . writeLong ( blockGs ) ; out . writeLong ( blockOffset ) ; out . writeLong ( blockLen ) ; Text . writeString ( out , clientName ) ; accessToken . write ( out ) ; out . flush ( ) ; } 
private void processJournal ( ) throws IOException { deleteIfExists ( journalFileTmp ) ; for ( Iterator < Entry > i = lruEntries . values ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Entry entry = i . next ( ) ; if ( entry . currentEditor == null ) { for ( int t = 0 ; t < valueCount ; t ++ ) { size += entry . lengths [ t ] ; } } else { entry . currentEditor = null ; for ( int t = 0 ; t < valueCount ; t ++ ) { deleteIfExists ( entry . getCleanFile ( t ) ) ; deleteIfExists ( entry . getDirtyFile ( t ) ) ; } i . remove ( ) ; } } } 
public static boolean equal ( String s1 , String s2 ) { return equal ( s1 , s2 , 0 ) ; } 
public void preprocess ( String in_path , String out_path ) { try { init ( ) ; File in_file = new File ( in_path ) ; source_path = in_file . getParentFile ( ) ; input = new BufferedReader ( new FileReader ( in_file ) ) ; if ( out_path != null ) { output = new PrintWriter ( new FileWriter ( out_path ) ) ; } else { output = new PrintWriter ( System . out ) ; } output . println ( "#-" + 1 + "-"" + in_file . getCanonicalPath ( ) + ""-" ) ; CopyClass copyClass = new CopyClass ( ) ; copyClass . last_line_number = 1 ; copyClass . copyName = in_file . getCanonicalPath ( ) ; copyStack . push ( copyClass ) ; preprocessMainline ( ) ; input . close ( ) ; if ( out_path != null ) output . close ( ) ; } catch ( Exception ex ) { if ( line_number > 0 ) System . err . println ( "Exception-at-line-" + line_number + "-:-" + line ) ; ex . printStackTrace ( ) ; return ; } } 
public void startStatisticsTimer ( int interval ) { _timer = new java . util . Timer ( ) ; _task = new TimerTask ( ) { public void run ( ) { try { reportStatistics ( ) ; } catch ( Throwable e ) { logger . warn ( "Statistics-reporting-failed-:-" + MDFUtil . getStackInfo ( e ) ) ; } } } ; _timer . scheduleAtFixedRate ( _task , interval * 1000 , interval * 1000 ) ; return ; } 
public static boolean isSameInstant ( Date date1 , Date date2 ) { if ( date1 == null || date2 == null ) { throw new IllegalArgumentException ( "The-date-must-not-be-null" ) ; } return date1 . getTime ( ) == date2 . getTime ( ) ; } 
@ Override public int indexOf ( Object o ) { Integer index = indexes . get ( o ) ; if ( index == null ) return - 1 ; return index ; } 
private static Calendar getCalendarForLocale ( Calendar oldCalendar , Locale locale ) { if ( oldCalendar == null ) { return Calendar . getInstance ( locale ) ; } else { final long currentTimeMillis = oldCalendar . getTimeInMillis ( ) ; Calendar newCalendar = Calendar . getInstance ( locale ) ; newCalendar . setTimeInMillis ( currentTimeMillis ) ; return newCalendar ; } } 
@ Deprecated public static String getServerAddress ( Configuration conf , String oldBindAddressName , String oldPortName , String newBindAddressName ) { String oldAddr = conf . get ( oldBindAddressName ) ; String oldPort = conf . get ( oldPortName ) ; String newAddrPort = conf . get ( newBindAddressName ) ; if ( oldAddr == null && oldPort == null ) { return newAddrPort ; } String [ ] newAddrPortParts = newAddrPort . split ( ":" , 2 ) ; if ( newAddrPortParts . length != 2 ) { throw new IllegalArgumentException ( "Invalid-address/port:-" + newAddrPort ) ; } if ( oldAddr == null ) { oldAddr = newAddrPortParts [ 0 ] ; } else { LOG . warn ( "Configuration-parameter-" + oldBindAddressName + "-is-deprecated.-Use-" + newBindAddressName + "-instead." ) ; } if ( oldPort == null ) { oldPort = newAddrPortParts [ 1 ] ; } else { LOG . warn ( "Configuration-parameter-" + oldPortName + "-is-deprecated.-Use-" + newBindAddressName + "-instead." ) ; } return oldAddr + ":" + oldPort ; } 
public void shuffle ( ) { Random r = new Random ( ) ; int num = count ; while ( num > 1 ) { int value = r . nextInt ( num ) ; num -- ; int temp = data [ num ] ; data [ num ] = data [ value ] ; data [ value ] = temp ; } } 
public static DateTime now ( Chronology chronology ) { if ( chronology == null ) { throw new NullPointerException ( "Chronology-must-not-be-null" ) ; } return new DateTime ( chronology ) ; } 
public List < String > getAvailableTypes ( ) { List < String > availableKeystoreTypes = new ArrayList < String > ( ) ; availableKeystoreTypes . add ( KEYSTORE_TYPE_JKS ) ; availableKeystoreTypes . add ( KEYSTORE_TYPE_JCEKS ) ; availableKeystoreTypes . add ( KEYSTORE_TYPE_PKCS12 ) ; if ( ! availableKeystoreTypes . contains ( getDefaultType ( ) ) ) { availableKeystoreTypes . add ( getDefaultType ( ) ) ; } return availableKeystoreTypes ; } 
@ SuppressWarnings ( "unchecked" ) protected < T extends ResCloudlet > List < T > getCloudletExecList ( ) { return ( List < T > ) cloudletExecList ; } 
protected void removeNotesFrame ( ) { m_NotesFrame . setVisible ( false ) ; } 
public List < String > getFreeText ( ) { if ( freeText == null ) { freeText = new ArrayList < String > ( ) ; } return this . freeText ; } 
public static Relation binary ( String name ) { return new Relation ( name , 2 ) ; } 
public static String getConfigDescriptor ( int ntfu , int ntfo , int mastau , int rastau , int raastip , int ourPlayerIndex , GameStatus gameStatus ) { StringBuffer sb = new StringBuffer ( ":" ) ; sb . append ( "rastau=" ) ; sb . append ( rastau ) ; sb . append ( ":mastau=" ) ; sb . append ( mastau ) ; sb . append ( ":ntfu=" ) ; sb . append ( ntfu ) ; sb . append ( ":ntfo=" ) ; sb . append ( ntfo ) ; sb . append ( ":raastip=" ) ; sb . append ( raastip ) ; return sb . toString ( ) ; } 
public final void forEach ( final Action1 < ? super T > onNext ) { subscribe ( onNext ) ; } 
public RealVector mapDivideToSelf ( double d ) { return mapToSelf ( FunctionUtils . fix2ndArgument ( new Divide ( ) , d ) ) ; } 
public static Object [ ] trimToCapacity ( Object [ ] array , int maxCapacity ) { if ( array . length > maxCapacity ) { Object [ ] oldArray = array ; array = new Object [ maxCapacity ] ; System . arraycopy ( oldArray , 0 , array , 0 , maxCapacity ) ; } return array ; } 
void clear ( ) { directivesById . clear ( ) ; directivesByPath . clear ( ) ; cachePools . clear ( ) ; nextDirectiveId = 1 ; } 
public void setShort ( int parameterIndex , short x ) throws SQLException { setInternal ( parameterIndex , String . valueOf ( x ) ) ; this . parameterTypes [ parameterIndex - 1 + getParameterIndexOffset ( ) ] = Types . SMALLINT ; } 
public void send ( double d ) { if ( s != null ) { try { dos . writeByte ( LiteServer . DOUBLE_CONST ) ; dos . writeDouble ( d ) ; if ( autoFlush ) { dos . flush ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { } } 
private boolean overlap ( Set ruleRoles , Set userRoles ) { if ( ruleRoles . contains ( "any" ) ) { return true ; } Iterator i = userRoles . iterator ( ) ; while ( i . hasNext ( ) ) { String role = ( String ) i . next ( ) ; if ( ruleRoles . contains ( role ) ) { return true ; } } return false ; } 
public String [ ] getOptions ( ) { Vector result = new Vector ( ) ; if ( m_Debug ) result . add ( "-D" ) ; result . add ( "-F" ) ; result . add ( "" + m_Limit ) ; if ( m_MEstimates ) { result . add ( "-M" ) ; result . add ( "-W" ) ; result . add ( "" + m_Weight ) ; } return ( String [ ] ) result . toArray ( new String [ result . size ( ) ] ) ; } 
public static void timeStats ( String msg ) { long time = System . currentTimeMillis ( ) ; if ( initialTimeStamp == - 1 ) { writeLogMessage ( PROFILING , "PROFILING-TIME" , msg + ":-0-[msec]" ) ; initialTimeStamp = time ; } else { long currentTime = time - initialTimeStamp ; writeLogMessage ( PROFILING , "PROFILING-TIME" , msg + ":-" + currentTime + "[msec]" ) ; } } 
private JComponent getCommandRow ( ) { JButton ok = new JButton ( "OK" ) ; ok . addActionListener ( new ActionListener ( ) { @ Override public void actionPerformed ( ActionEvent event ) { okAction ( ) ; } } ) ; fDialog . getRootPane ( ) . setDefaultButton ( ok ) ; JButton cancel = new JButton ( "Cancel" ) ; cancel . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent event ) { closeDialog ( ) ; } } ) ; List < JComponent > buttons = new ArrayList < > ( ) ; buttons . add ( ok ) ; buttons . add ( cancel ) ; return UiUtil . getCommandRow ( buttons ) ; } 
public void buildTrapEntries ( Hashtable < InetAddress , Vector < String >> dest ) { if ( children != null ) { for ( int i = 0 ; i < children . length ; ++ i ) { SimpleNode n = ( SimpleNode ) children [ i ] ; if ( n != null ) { n . buildTrapEntries ( dest ) ; } } } } 
public static void print ( double x ) { out . print ( x ) ; out . flush ( ) ; } 
@ Override public Object evaluate ( ) { return variable . getValue ( ) ; } 
private static < E > Collection < E > toCollection ( Iterable < E > iterable ) { return ( iterable instanceof Collection ) ? ( Collection < E > ) iterable : Lists . newArrayList ( iterable . iterator ( ) ) ; } 
Values ( Values fromParent ) { this . table = fromParent . table . clone ( ) ; this . mask = fromParent . mask ; this . size = fromParent . size ; this . tombstones = fromParent . tombstones ; this . maximumLoad = fromParent . maximumLoad ; this . clean = fromParent . clean ; inheritValues ( fromParent ) ; } 
public void writeWindow ( byte [ ] pattern ) { synchronized ( this ) { writeBuffer = pattern ; } mHandler . sendEmptyMessage ( MSG_WRITE ) ; } 
public static void setExternalSchemaURL ( XMLReader xr , String namespace , String u ) throws SAXNotRecognizedException , SAXNotSupportedException { xr . setFeature ( NAMESPACES_SAXF , true ) ; if ( namespace != null && namespace . length ( ) > 0 ) { xr . setProperty ( EXTERNAL_SCHEMA_LOC_XERCESP , namespace + "-" + u ) ; } else { xr . setProperty ( EXTERNAL_SCHEMA_NNS_LOC_XERCESP , u ) ; } xr . setFeature ( VALIDATION_SAXF , true ) ; xr . setFeature ( SCHEMA_V_XERCESF , true ) ; } 
public StringBuilder appendTo ( StringBuilder builder ) { builder . append ( SEPARATOR ) ; builder . append ( jtIdentifier ) ; builder . append ( SEPARATOR ) ; builder . append ( idFormat . format ( id ) ) ; return builder ; } 
public void setStyle ( Style style ) { native_setStyle ( mNativePaint , style . nativeInt ) ; } 
public static File getExternalStoragePublicDirectory ( String type ) { return new File ( getExternalStorageDirectory ( ) , type ) ; } 
public JavaClass findClass ( String className ) { return ( JavaClass ) _loadedClasses . get ( className ) ; } 
public void register ( Character command , AtCommandHandler handler ) { mBasicHandlers . put ( command , handler ) ; } 
public String toString ( ) { try { Iterator keys = keys ( ) ; StringBuffer sb = new StringBuffer ( "{" ) ; while ( keys . hasNext ( ) ) { if ( sb . length ( ) > 1 ) { sb . append ( ',' ) ; } Object o = keys . next ( ) ; sb . append ( quote ( o . toString ( ) ) ) ; sb . append ( ':' ) ; sb . append ( valueToString ( this . map . get ( o ) ) ) ; } sb . append ( '}' ) ; return sb . toString ( ) ; } catch ( Exception e ) { return null ; } } 
public void validate ( ) { this . schema . validate ( this ) ; } 
public InputSplit [ ] getSplits ( JobConf job , int numSplits ) throws IOException { setFormat ( job ) ; job . setLong ( "mapred.min.split.size" , Long . MAX_VALUE ) ; return root . getSplits ( job , numSplits ) ; } 
public void addModification ( Modification mod ) { mods . add ( mod ) ; } 
public void deleteTemplate ( final UUID project , final String templateId ) { final UUID locationId = UUID . fromString ( "e884571e-7f92-4d6a-9274-3f5649900835" ) ; final ApiResourceVersion apiVersion = new ApiResourceVersion ( "2.1" ) ; final Map < String , Object > routeValues = new HashMap < String , Object > ( ) ; routeValues . put ( "project" , project ) ; routeValues . put ( "templateId" , templateId ) ; final Object httpRequest = super . createRequest ( HttpMethod . DELETE , locationId , routeValues , apiVersion , APPLICATION_JSON_TYPE ) ; super . sendRequest ( httpRequest ) ; } 
public int hashCode ( ) { return numberFormat . hashCode ( ) ; } 
protected final static VersionInfo fromMap ( String pckg , Map info , ClassLoader clsldr ) { if ( pckg == null ) { throw new IllegalArgumentException ( "Package-identifier-must-not-be-null." ) ; } String module = null ; String release = null ; String timestamp = null ; if ( info != null ) { module = ( String ) info . get ( PROPERTY_MODULE ) ; if ( ( module != null ) && ( module . length ( ) < 1 ) ) module = null ; release = ( String ) info . get ( PROPERTY_RELEASE ) ; if ( ( release != null ) && ( ( release . length ( ) < 1 ) || ( release . equals ( "${pom.version}" ) ) ) ) release = null ; timestamp = ( String ) info . get ( PROPERTY_TIMESTAMP ) ; if ( ( timestamp != null ) && ( ( timestamp . length ( ) < 1 ) || ( timestamp . equals ( "${mvn.timestamp}" ) ) ) ) timestamp = null ; } String clsldrstr = null ; if ( clsldr != null ) clsldrstr = clsldr . toString ( ) ; return new VersionInfo ( pckg , module , release , timestamp , clsldrstr ) ; } 
@ AccessTimeout ( unit = TimeUnit . SECONDS , value = 0 ) public String noTimeout ( String value ) { try { Thread . sleep ( PROCESSING_TIME / 2 ) ; } catch ( InterruptedException e ) { } return value ; } 
public Builder addVertexType ( Type t ) throws IllegalStateException { if ( mVertexTypeCount >= mVertexTypes . length ) { throw new IllegalStateException ( "Max-vertex-types-exceeded." ) ; } mVertexTypes [ mVertexTypeCount ] = new Entry ( ) ; mVertexTypes [ mVertexTypeCount ] . t = t ; mVertexTypes [ mVertexTypeCount ] . e = null ; mVertexTypeCount ++ ; return this ; } 
public Object transform ( Class input ) { try { Constructor con = input . getConstructor ( iParamTypes ) ; return con . newInstance ( iArgs ) ; } catch ( NoSuchMethodException ex ) { throw new FunctorException ( "InstantiateTransformer:-The-constructor-must-exist-and-be-public-" ) ; } catch ( InstantiationException ex ) { throw new FunctorException ( "InstantiateTransformer:-InstantiationException" , ex ) ; } catch ( IllegalAccessException ex ) { throw new FunctorException ( "InstantiateTransformer:-Constructor-must-be-public" , ex ) ; } catch ( InvocationTargetException ex ) { throw new FunctorException ( "InstantiateTransformer:-Constructor-threw-an-exception" , ex ) ; } } 
public static void encodeToFile ( byte [ ] dataToEncode , String filename ) throws java . io . IOException { if ( dataToEncode == null ) { throw new NullPointerException ( "Data-to-encode-was-null." ) ; } Base64 . OutputStream bos = null ; try { bos = new Base64 . OutputStream ( new java . io . FileOutputStream ( filename ) , Base64 . ENCODE ) ; bos . write ( dataToEncode ) ; } catch ( java . io . IOException e ) { throw e ; } finally { try { bos . close ( ) ; } catch ( Exception e ) { } } } 
public void testPlusNegative ( ) { String a = "-92948782094488478231212478987482988429808779810457634781384756794987" ; int aScale = 41 ; String c = "-92948782094488478231212478987482988429808779810457634781384756794987" ; int cScale = 41 ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal cNumber = new BigDecimal ( new BigInteger ( c ) , cScale ) ; assertEquals ( "incorrect-value" , cNumber , aNumber . plus ( ) ) ; } 
protected String reformatDateString ( String info , String oldFormat ) { DateFormat df = new SimpleDateFormat ( oldFormat ) ; Date date = new Date ( ) ; DateFormat eventFormat = new SimpleDateFormat ( PropertyResourceBundle . getBundle ( "myProperties" ) . getString ( "dateFormat" ) ) ; try { date = df . parse ( info ) ; } catch ( ParseException e ) { System . out . println ( info ) ; System . out . println ( oldFormat ) ; e . printStackTrace ( ) ; throw new TivooSystemError ( "reformatDateString-failed" ) ; } return eventFormat . format ( date ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public static Attribute getInstance ( Object o ) { if ( o instanceof Attribute ) { return ( Attribute ) o ; } if ( o != null ) { return new Attribute ( ASN1Sequence . getInstance ( o ) ) ; } return null ; } 
protected String reload ( ContextName cn , StringManager smClient ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter printWriter = new PrintWriter ( stringWriter ) ; super . reload ( printWriter , cn , smClient ) ; return stringWriter . toString ( ) ; } 
public int receiveFromDataSocket ( byte [ ] buf ) { int bytesRead ; if ( dataSocket == null ) { myLog . l ( Log . INFO , "Can't-receive-from-null-dataSocket" ) ; return - 2 ; } if ( ! dataSocket . isConnected ( ) ) { myLog . l ( Log . INFO , "Can't-receive-from-unconnected-socket" ) ; return - 2 ; } InputStream in ; try { in = dataSocket . getInputStream ( ) ; while ( ( bytesRead = in . read ( buf , 0 , buf . length ) ) == 0 ) { } if ( bytesRead == - 1 ) { return - 1 ; } } catch ( IOException e ) { myLog . l ( Log . INFO , "Error-reading-data-socket" ) ; return 0 ; } dataSocketFactory . reportTraffic ( bytesRead ) ; return bytesRead ; } 
public static long [ ] queryAllSongs ( ContentResolver resolver ) { sAllSongsIdx = 0 ; sRandomCacheEnd = - 1 ; Uri media = MediaStore . Audio . Media . EXTERNAL_CONTENT_URI ; String selection = MediaStore . Audio . Media . IS_MUSIC + "!=0" ; Cursor cursor = resolver . query ( media , Song . EMPTY_PROJECTION , selection , null , null ) ; if ( cursor == null || cursor . getCount ( ) == 0 ) { sSongCount = 0 ; return null ; } int count = cursor . getCount ( ) ; long [ ] ids = new long [ count ] ; for ( int i = 0 ; i != count ; ++ i ) { if ( ! cursor . moveToNext ( ) ) return null ; ids [ i ] = cursor . getLong ( 0 ) ; } sSongCount = count ; cursor . close ( ) ; shuffle ( ids ) ; return ids ; } 
@ XmlElementDecl ( namespace = "http://xmlns.oracle.com/apps/cdm/foundation/parties/personService/" , name = "Status" , scope = EmploymentHistory . class ) public JAXBElement < String > createEmploymentHistoryStatus ( String value ) { return new JAXBElement < String > ( _CitizenshipStatus_QNAME , String . class , EmploymentHistory . class , value ) ; } 
@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( "User-username="" ) ; sb . append ( RequestUtil . filter ( username ) ) ; sb . append ( """ ) ; if ( fullName != null ) { sb . append ( ",-fullName="" ) ; sb . append ( RequestUtil . filter ( fullName ) ) ; sb . append ( """ ) ; } synchronized ( groups ) { if ( groups . size ( ) > 0 ) { sb . append ( ",-groups="" ) ; int n = 0 ; Iterator < Group > values = groups . iterator ( ) ; while ( values . hasNext ( ) ) { if ( n > 0 ) { sb . append ( ',' ) ; } n ++ ; sb . append ( RequestUtil . filter ( values . next ( ) . getGroupname ( ) ) ) ; } sb . append ( """ ) ; } } synchronized ( roles ) { if ( roles . size ( ) > 0 ) { sb . append ( ",-roles="" ) ; int n = 0 ; Iterator < Role > values = roles . iterator ( ) ; while ( values . hasNext ( ) ) { if ( n > 0 ) { sb . append ( ',' ) ; } n ++ ; sb . append ( RequestUtil . filter ( values . next ( ) . getRolename ( ) ) ) ; } sb . append ( """ ) ; } } return ( sb . toString ( ) ) ; } 
private static void mergeSort ( Object [ ] src , Object [ ] dest , int low , int high , int off , Comparator c ) { int length = high - low ; if ( length < INSERTIONSORT_THRESHOLD ) { for ( int i = low ; i < high ; i ++ ) for ( int j = i ; j > low && c . compare ( dest [ j - 1 ] , dest [ j ] ) > 0 ; j -- ) swap ( dest , j , j - 1 ) ; return ; } int destLow = low ; int destHigh = high ; low += off ; high += off ; int mid = ( low + high ) >>> 1 ; mergeSort ( dest , src , low , mid , - off , c ) ; mergeSort ( dest , src , mid , high , - off , c ) ; if ( c . compare ( src [ mid - 1 ] , src [ mid ] ) <= 0 ) { System . arraycopy ( src , low , dest , destLow , length ) ; return ; } for ( int i = destLow , p = low , q = mid ; i < destHigh ; i ++ ) { if ( q >= high || p < mid && c . compare ( src [ p ] , src [ q ] ) <= 0 ) dest [ i ] = src [ p ++ ] ; else dest [ i ] = src [ q ++ ] ; } } 
AccessibleStateSet getAccessibleStateSet ( ) { AccessibleStateSet states = new AccessibleStateSet ( ) ; return states ; } 
public static File getSecureDataDirectory ( ) { if ( isEncryptedFilesystemEnabled ( ) ) { return SECURE_DATA_DIRECTORY ; } else { return DATA_DIRECTORY ; } } 
public void setTexture ( Texture texture ) { setTexture ( texture , 1 , 1 , true ) ; } 
protected PendingRoleRequestEntry checkFirstPendingRoleRequestCookie ( IOFSwitch sw , long cookie ) { LinkedList < PendingRoleRequestEntry > pendingRoleRequests = pendingRequestMap . get ( sw ) ; if ( pendingRoleRequests == null ) { return null ; } synchronized ( pendingRoleRequests ) { PendingRoleRequestEntry head = pendingRoleRequests . peek ( ) ; if ( head == null ) return null ; if ( head . cookie == cookie ) { return pendingRoleRequests . poll ( ) ; } } return null ; } 
public void putAll ( Map map ) { for ( Iterator it = map . entrySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; if ( entry . getKey ( ) == null || entry . getValue ( ) == null ) { throw new NullPointerException ( "null-entities-and-copies-are-not-supported-by-" + getClass ( ) . getName ( ) ) ; } entityToCopyMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; entityToOperatedOnFlagMap . put ( entry . getKey ( ) , Boolean . FALSE ) ; } } 
private static boolean ensureFileExists ( String path ) { File file = new File ( path ) ; if ( file . exists ( ) ) { return true ; } else { int secondSlash = path . indexOf ( '/' , 1 ) ; if ( secondSlash < 1 ) return false ; String directoryPath = path . substring ( 0 , secondSlash ) ; File directory = new File ( directoryPath ) ; if ( ! directory . exists ( ) ) return false ; file . getParentFile ( ) . mkdirs ( ) ; try { return file . createNewFile ( ) ; } catch ( IOException ioe ) { Log . w ( TAG , "File-creation-failed" , ioe ) ; } return false ; } } 
public void stopGame ( ) { timer . stop ( ) ; gameActive = false ; } 
public void setPixel ( int x , int y , int iArray [ ] , DataBuffer data ) { if ( ( x < 0 ) || ( y < 0 ) || ( x >= width ) || ( y >= height ) ) { throw new ArrayIndexOutOfBoundsException ( "Coordinate-out-of-bounds!" ) ; } int pixelOffset = y * scanlineStride + x ; for ( int i = 0 ; i < numBands ; i ++ ) { data . setElem ( bankIndices [ i ] , pixelOffset + bandOffsets [ i ] , iArray [ i ] ) ; } } 
public static void clear ( ) { sRefreshables . clear ( ) ; sRefreshables . trimToSize ( ) ; } 
void dispatchCollectViewAttributes ( AttachInfo attachInfo , int visibility ) { performCollectViewAttributes ( attachInfo , visibility ) ; } 
@ CallerSensitive public static synchronized void deregisterDriver ( Driver driver ) throws SQLException { if ( driver == null ) { return ; } println ( "DriverManager.deregisterDriver:-" + driver ) ; DriverInfo aDriver = new DriverInfo ( driver ) ; if ( registeredDrivers . contains ( aDriver ) ) { if ( isDriverAllowed ( driver , Reflection . getCallerClass ( ) ) ) { registeredDrivers . remove ( aDriver ) ; } else { throw new SecurityException ( ) ; } } else { println ( "-couldn't-find-driver-to-unload" ) ; } } 
public Configuration copy ( ) { ObjectOutputStream oos = null ; ObjectInputStream ois = null ; Configuration copyConfiguration = null ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; try { oos = new ObjectOutputStream ( bos ) ; oos . writeObject ( this ) ; oos . flush ( ) ; ByteArrayInputStream bin = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; ois = new ObjectInputStream ( bin ) ; copyConfiguration = ( Configuration ) ois . readObject ( ) ; } catch ( Exception e ) { throw new DigiDoc4JException ( e ) ; } finally { IOUtils . closeQuietly ( oos ) ; IOUtils . closeQuietly ( ois ) ; IOUtils . closeQuietly ( bos ) ; } return copyConfiguration ; } 
private Result pDeclarators$1 ( final int yyStart ) throws IOException { Result yyResult ; Node yyValue ; ParseError yyError = ParseError . DUMMY ; yyResult = pDeclarator ( yyStart ) ; yyError = yyResult . select ( yyError ) ; if ( yyResult . hasValue ( ) ) { final Node v$g$1 = yyResult . semanticValue ( ) ; yyResult = pDeclarators$$Star1 ( yyResult . index ) ; yyError = yyResult . select ( yyError ) ; if ( yyResult . hasValue ( ) ) { final Pair < Node > v$g$2 = yyResult . semanticValue ( ) ; yyValue = GNode . createFromPair ( "Declarators" , v$g$1 , v$g$2 ) ; yyValue . setLocation ( location ( yyStart ) ) ; return yyResult . createValue ( yyValue , yyError ) ; } } return yyError ; } 
public static IOException close ( final Closeable closeable ) { try { closeable . close ( ) ; } catch ( IOException e ) { return e ; } return null ; } 
public static final boolean checkParameter ( final Map < String , Object > map , final String key , final Class < ? > expectedClass , final StringBuilder errorHolder ) { final Object obj = map . get ( key ) ; if ( null == obj ) { errorHolder . append ( "Parameter-" + key + "-could-not-be-found-in-settings-map,-or-is-null.-" ) ; return false ; } if ( ! expectedClass . isInstance ( obj ) ) { errorHolder . append ( "Value-for-parameter-" + key + "-is-not-of-the-right-class.-Expected-" + expectedClass . getName ( ) + ",-got-" + obj . getClass ( ) . getName ( ) + ".-" ) ; return false ; } return true ; } 
protected void err ( String message ) { errorCount ++ ; indent ( indentLevel + 1 ) ; log . print ( message ) ; log . flush ( ) ; if ( ! nothrow ) { throw new RuntimeException ( message ) ; } } 
public final boolean sendEmptyMessageDelayed ( int what , long delayMillis ) { Message msg = Message . obtain ( ) ; msg . what = what ; return sendMessageDelayed ( msg , delayMillis ) ; } 
public void keyPressed ( KeyEvent evt ) { int keyCode = evt . getKeyCode ( ) ; int modifiers = evt . getModifiers ( ) ; if ( keyCode == KeyEvent . VK_CONTROL || keyCode == KeyEvent . VK_SHIFT || keyCode == KeyEvent . VK_ALT || keyCode == KeyEvent . VK_META ) return ; if ( ( modifiers & ~ KeyEvent . SHIFT_MASK ) != 0 || evt . isActionKey ( ) || keyCode == KeyEvent . VK_BACK_SPACE || keyCode == KeyEvent . VK_DELETE || keyCode == KeyEvent . VK_ENTER || keyCode == KeyEvent . VK_TAB || keyCode == KeyEvent . VK_ESCAPE ) { if ( grabAction != null ) { handleGrabAction ( evt ) ; return ; } KeyStroke keyStroke = KeyStroke . getKeyStroke ( keyCode , modifiers ) ; Object o = currentBindings . get ( keyStroke ) ; if ( o == null ) { if ( currentBindings != bindings ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; repeatCount = 0 ; repeat = false ; evt . consume ( ) ; } currentBindings = bindings ; return ; } else if ( o instanceof ActionListener ) { currentBindings = bindings ; executeAction ( ( ( ActionListener ) o ) , evt . getSource ( ) , null ) ; evt . consume ( ) ; return ; } else if ( o instanceof Hashtable ) { currentBindings = ( Hashtable ) o ; evt . consume ( ) ; return ; } } } 
public static String get ( String code ) { return stringCollection . get ( code ) ; } 
public Component getFocusOwner ( ) { return ( isFocused ( ) ) ? KeyboardFocusManager . getCurrentKeyboardFocusManager ( ) . getFocusOwner ( ) : null ; } 
private static BigInteger alloc ( int nwords ) { BigInteger result = new BigInteger ( ) ; if ( nwords > 1 ) result . words = new int [ nwords ] ; return result ; } 
public static boolean equals ( Object [ ] a , Object [ ] a2 ) { if ( a == a2 ) return true ; if ( a == null || a2 == null ) return false ; int length = a . length ; if ( a2 . length != length ) return false ; for ( int i = 0 ; i < length ; i ++ ) { Object o1 = a [ i ] ; Object o2 = a2 [ i ] ; if ( ! ( o1 == null ? o2 == null : o1 . equals ( o2 ) ) ) return false ; } return true ; } 
@ Deprecated public EmailListEntry retrieveEmailList ( String emailList ) throws AppsForYourDomainException , ServiceException , IOException { LOGGER . log ( Level . INFO , "Retrieving-email-list-'" + emailList + "'." ) ; URL retrieveUrl = new URL ( domainUrlBase + "emailList/" + SERVICE_VERSION + "/" + emailList ) ; return emailListService . getEntry ( retrieveUrl , EmailListEntry . class ) ; } 
private static FloatBuffer setColorBuffer ( float par0 , float par1 , float par2 , float par3 ) { colorBuffer . clear ( ) ; colorBuffer . put ( par0 ) . put ( par1 ) . put ( par2 ) . put ( par3 ) ; colorBuffer . flip ( ) ; return colorBuffer ; } 
private void signalNotEmpty ( ) { final ReentrantLock takeLock = this . takeLock ; takeLock . lock ( ) ; try { notEmpty . signal ( ) ; } finally { takeLock . unlock ( ) ; } } 
@ RequestMapping ( value = "/" , method = RequestMethod . GET ) public String home ( Locale locale , Model model ) { logger . info ( "Welcome-home!-The-client-locale-is-{}." , locale ) ; Date date = new Date ( ) ; DateFormat dateFormat = DateFormat . getDateTimeInstance ( DateFormat . LONG , DateFormat . LONG , locale ) ; String formattedDate = dateFormat . format ( date ) ; List < DmSex > list = testService . getDmSexAll ( ) ; model . addAttribute ( "serverTime" , formattedDate ) ; return "home" ; } 
private String convertName ( String name ) { return ( name . indexOf ( WM_EXT ) < 0 ) ? name : name . substring ( 0 , name . indexOf ( WM_EXT ) ) + VM_EXT ; } 
public static Factory remove ( final URI functionURI ) { return factories . remove ( functionURI ) ; } 
private void writeBackCache ( ) throws BackingStoreException { try { AccessController . doPrivileged ( new PrivilegedExceptionAction < Void > ( ) { public Void run ( ) throws BackingStoreException { try { if ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) throw new BackingStoreException ( dir + "-create-failed." ) ; try ( FileOutputStream fos = new FileOutputStream ( tmpFile ) ) { XmlSupport . exportMap ( fos , prefsCache ) ; } if ( ! tmpFile . renameTo ( prefsFile ) ) throw new BackingStoreException ( "Can't-rename-" + tmpFile + "-to-" + prefsFile ) ; } catch ( Exception e ) { if ( e instanceof BackingStoreException ) throw ( BackingStoreException ) e ; throw new BackingStoreException ( e ) ; } return null ; } } ) ; } catch ( PrivilegedActionException e ) { throw ( BackingStoreException ) e . getException ( ) ; } } 
@ Override public int compare ( byte [ ] b1 , int s1 , int l1 , byte [ ] b2 , int s2 , int l2 ) { int rc = 0 ; if ( b1 [ s1 ] == 0 && b2 [ s2 ] == 0 ) { rc = mWrappedComp . compare ( b1 , s1 + 1 , l1 - 2 , b2 , s2 + 1 , l2 - 2 ) ; } else { if ( b1 [ s1 ] != 0 && b2 [ s2 ] != 0 ) { rc = b1 [ s1 + 1 ] - b2 [ s2 + 1 ] ; } else if ( b1 [ s1 ] != 0 ) rc = - 1 ; else rc = 1 ; } if ( ! mAsc [ 0 ] ) rc *= - 1 ; return rc ; } 
public List < Address > findByParentAsList ( String parentId , String parentType ) { log . debug ( "getting-Address-instances-by-userId-" + parentId ) ; Session session = sessionFactory . getCurrentSession ( ) ; Query qry = session . createQuery ( "from-org.openiam.idm.srvc.continfo.dto.Address-a-" + "-where-a.parentId-=-:parentId-and-" + "-a.parentType-=-:parentType" ) ; qry . setString ( "parentId" , parentId ) ; qry . setString ( "parentType" , parentType ) ; List < Address > result = ( List < Address > ) qry . list ( ) ; if ( result == null || result . size ( ) == 0 ) return null ; return result ; } 
public int processDrmInfo ( DrmInfo drmInfo ) { if ( null == drmInfo || ! drmInfo . isValid ( ) ) { throw new IllegalArgumentException ( "Given-drmInfo-is-invalid/null" ) ; } int result = ERROR_UNKNOWN ; if ( null != mEventHandler ) { Message msg = mEventHandler . obtainMessage ( ACTION_PROCESS_DRM_INFO , drmInfo ) ; result = ( mEventHandler . sendMessage ( msg ) ) ? ERROR_NONE : result ; } return result ; } 
public Reference getReference ( ) { return getRequest ( ) == null ? null : getRequest ( ) . getResourceRef ( ) ; } 
public boolean isValid ( float [ ] array , ConstraintValidatorContext constraintValidatorContext ) { if ( array == null ) { return true ; } int length = Array . getLength ( array ) ; return length >= min && length <= max ; } 
public static < I , O > Predicate < I > getInstance ( Transformer < ? super I , ? extends O > transformer , Predicate < ? super O > predicate ) { if ( transformer == null ) { throw new IllegalArgumentException ( "The-transformer-to-call-must-not-be-null" ) ; } if ( predicate == null ) { throw new IllegalArgumentException ( "The-predicate-to-call-must-not-be-null" ) ; } return new TransformedPredicate < I , O > ( transformer , predicate ) ; } 
public final int arrayCopyFrom ( double [ ] a , int startingArrayLocation ) { System . arraycopy ( a , startingArrayLocation , values , 0 , values . length ) ; return startingArrayLocation + values . length ; } 
public static String encode ( String s ) { final StringBuffer out = new StringBuffer ( s . length ( ) ) ; final ByteArrayOutputStream buf = new ByteArrayOutputStream ( 32 ) ; final OutputStreamWriter writer = new OutputStreamWriter ( buf ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int c = s . charAt ( i ) ; if ( CHARACHTERS_DONT_NEED_ECNODING . get ( c ) ) { out . append ( ( char ) c ) ; } else { try { writer . write ( c ) ; writer . flush ( ) ; } catch ( IOException e ) { buf . reset ( ) ; continue ; } byte [ ] ba = buf . toByteArray ( ) ; for ( int j = 0 ; j < ba . length ; j ++ ) { out . append ( '%' ) ; char ch = Character . forDigit ( ( ba [ j ] >> 4 ) & 0xF , 16 ) ; if ( Character . isLetter ( ch ) ) { ch -= CHARACTER_CASE_DIFF ; } out . append ( ch ) ; ch = Character . forDigit ( ba [ j ] & 0xF , 16 ) ; if ( Character . isLetter ( ch ) ) { ch -= CHARACTER_CASE_DIFF ; } out . append ( ch ) ; } buf . reset ( ) ; } } return out . toString ( ) ; } 
public void subdivide ( QuadCurve2D left , QuadCurve2D right ) { subdivide ( this , left , right ) ; } 
public int getAndDecrement ( ) { return myValue . getAndDecrement ( ) ; } 
public List < AtomTreePositionDTO > getReturn ( ) { if ( _return == null ) { _return = new ArrayList < AtomTreePositionDTO > ( ) ; } return this . _return ; } 
public Builder before ( Animator anim ) { Node node = mNodeMap . get ( anim ) ; if ( node == null ) { node = new Node ( anim ) ; mNodeMap . put ( anim , node ) ; mNodes . add ( node ) ; } Dependency dependency = new Dependency ( mCurrentNode , Dependency . AFTER ) ; node . addDependency ( dependency ) ; return this ; } 
public final static AvroBSPMessageBundle . Builder newBuilder ( ) { return new AvroBSPMessageBundle . Builder ( ) ; } 
public void firePopupMenuWillBecomeInvisible ( ) { Object [ ] listeners = listenerList . getListenerList ( ) ; PopupMenuEvent e = null ; for ( int i = listeners . length - 2 ; i >= 0 ; i -= 2 ) { if ( listeners [ i ] == PopupMenuListener . class ) { if ( e == null ) e = new PopupMenuEvent ( this ) ; ( ( PopupMenuListener ) listeners [ i + 1 ] ) . popupMenuWillBecomeInvisible ( e ) ; } } } 
public long getElapsedNanos ( boolean snapshotTime ) { switch ( status ) { case INITIALIZED : throw new IllegalStateException ( "Timer-has-not-been-started" ) ; case RUNNING : return snapshotTime ? System . nanoTime ( ) - startTimeNanos : - 1 ; default : return stopTimeNanos - startTimeNanos ; } } 
public void freeze ( ) { if ( treeSet instanceof TreeSet < ? > ) { treeSet = Collections . unmodifiableSortedSet ( treeSet ) ; } } 
@ Override public Matrix store ( FloatBuffer buf ) { buf . put ( m00 ) ; buf . put ( m01 ) ; buf . put ( m02 ) ; buf . put ( m10 ) ; buf . put ( m11 ) ; buf . put ( m12 ) ; buf . put ( m20 ) ; buf . put ( m21 ) ; buf . put ( m22 ) ; return this ; } 
int getCurrentStackFrameSize ( ) { return m_variableNames . size ( ) ; } 
public static final TrustManagerFactory getInstance ( String algorithm , String provider ) throws NoSuchAlgorithmException , NoSuchProviderException { if ( ( provider == null ) || ( provider . length ( ) == 0 ) ) { throw new IllegalArgumentException ( "Provider-is-null-oe-empty" ) ; } Provider impProvider = Security . getProvider ( provider ) ; if ( impProvider == null ) { throw new NoSuchProviderException ( provider ) ; } return getInstance ( algorithm , impProvider ) ; } 
public int getAD_PInstance_ID ( ) { Integer ii = ( Integer ) get_Value ( "AD_PInstance_ID" ) ; if ( ii == null ) return 0 ; return ii . intValue ( ) ; } 
public void treeExpanded ( TreeExpansionEvent event ) { getHandler ( ) . treeExpanded ( event ) ; } 
protected boolean isManagedClass ( String className ) { return managedClasses . containsKey ( className . replace ( '/' , '.' ) ) ; } 
public static byte [ ] encodeBase64Chunked ( byte [ ] binaryData ) { return encodeBase64 ( binaryData , true ) ; } 
public Font getFont ( final String key ) { final Resource value = getResource ( key ) ; if ( value instanceof Font ) { return ( Font ) value ; } else { return null ; } } 
public String getSection ( int i ) { return questions . get ( i ) . section ; } 
public Object get ( ) throws InterruptedException { synchronized ( lock ) { while ( size == 0 ) lock . wait ( ) ; Object o = elements [ head ] ; elements [ head ] = null ; if ( ++ head == maxSize ) head = 0 ; if ( size == maxSize ) lock . notifyAll ( ) ; size -- ; return o ; } } 
Enumeration getDeclaredPrefixes ( ) { return ( declarations == null ) ? EMPTY_ENUMERATION : Collections . enumeration ( declarations ) ; } 
public synchronized int write ( InputStream in ) throws IOException { int readCount = 0 ; int inBufferPos = count - filledBufferSum ; int n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; while ( n != - 1 ) { readCount += n ; inBufferPos += n ; count += n ; if ( inBufferPos == currentBuffer . length ) { needNewBuffer ( currentBuffer . length ) ; inBufferPos = 0 ; } n = in . read ( currentBuffer , inBufferPos , currentBuffer . length - inBufferPos ) ; } return readCount ; } 
public Spider clearPipeline ( ) { pipelines = new ArrayList < Pipeline > ( ) ; return this ; } 
public synchronized void flush ( ) { SoftReference s = soft ; if ( s != null ) s . clear ( ) ; soft = null ; } 
public void close ( ) { for ( Partition partition : mPartitions ) { Cursor cursor = partition . cursor ; if ( cursor != null && ! cursor . isClosed ( ) ) { cursor . close ( ) ; } } mPartitions . clear ( ) ; invalidate ( ) ; notifyDataSetChanged ( ) ; } 
@ Override public void close ( ) { cache . clear ( ) ; super . close ( ) ; } 
public void serialize ( IndentedLineBuffer buff , Syntax outSyntax ) { Serializer . serialize ( this , buff , outSyntax ) ; } 
public void write ( ObjectOutput out ) throws IOException { OutputStreamHook hook = ( OutputStreamHook ) out ; ObjectStreamField [ ] osfields = hook . getFieldsNoCopy ( ) ; for ( int i = 0 ; i < osfields . length ; i ++ ) { Object value = fields . get ( osfields [ i ] . getName ( ) ) ; hook . writeField ( osfields [ i ] , value ) ; } } 
public void ignorableWhitespace ( char ch [ ] , int start , int length ) throws SAXException { if ( documentHandler != null ) documentHandler . ignorableWhitespace ( ch , start , length ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
static public String getString ( String msg , Object arg ) { return getString ( msg , new Object [ ] { arg } ) ; } 
private void autoclick ( ) { clickThread = new Thread ( new Runnable ( ) { public void run ( ) { try { robot = new Robot ( ) ; robot . mouseMove ( xcoord , ycoord ) ; while ( running ) { robot . mousePress ( InputEvent . BUTTON1_MASK ) ; robot . mouseRelease ( InputEvent . BUTTON1_MASK ) ; robot . delay ( clickDelay ) ; } } catch ( Exception e2 ) { e2 . printStackTrace ( ) ; } } } ) ; clickThread . start ( ) ; } 
private void doAcquireInterruptibly ( long arg ) throws InterruptedException { final Node node = addWaiter ( Node . EXCLUSIVE ) ; boolean failed = true ; try { for ( ; ; ) { final Node p = node . predecessor ( ) ; if ( p == head && tryAcquire ( arg ) ) { setHead ( node ) ; p . next = null ; failed = false ; return ; } if ( shouldParkAfterFailedAcquire ( p , node ) && parkAndCheckInterrupt ( ) ) throw new InterruptedException ( ) ; } } finally { if ( failed ) cancelAcquire ( node ) ; } } 
static AxesWalker loadWalkers ( WalkingIterator lpi , Compiler compiler , int stepOpCodePos , int stepIndex ) throws javax . xml . transform . TransformerException { int stepType ; AxesWalker firstWalker = null ; AxesWalker walker , prevWalker = null ; int analysis = analyze ( compiler , stepOpCodePos , stepIndex ) ; while ( OpCodes . ENDOP != ( stepType = compiler . getOp ( stepOpCodePos ) ) ) { walker = createDefaultWalker ( compiler , stepOpCodePos , lpi , analysis ) ; walker . init ( compiler , stepOpCodePos , stepType ) ; walker . exprSetParent ( lpi ) ; if ( null == firstWalker ) { firstWalker = walker ; } else { prevWalker . setNextWalker ( walker ) ; walker . setPrevWalker ( prevWalker ) ; } prevWalker = walker ; stepOpCodePos = compiler . getNextStepPos ( stepOpCodePos ) ; if ( stepOpCodePos < 0 ) break ; } return firstWalker ; } 
public static java . sql . Timestamp toTimestamp ( String monthStr , String dayStr , String yearStr , String hourStr , String minuteStr , String secondStr ) { java . util . Date newDate = toDate ( monthStr , dayStr , yearStr , hourStr , minuteStr , secondStr ) ; if ( newDate != null ) { return new java . sql . Timestamp ( newDate . getTime ( ) ) ; } else { return null ; } } 
public V remove ( Object key ) { return doRemove ( key , null ) ; } 
public final void startDelete ( int token , Object cookie , Uri uri , String selection , String [ ] selectionArgs ) { Message msg = mWorkerThreadHandler . obtainMessage ( token ) ; msg . arg1 = EVENT_ARG_DELETE ; WorkerArgs args = new WorkerArgs ( ) ; args . handler = this ; args . uri = uri ; args . cookie = cookie ; args . selection = selection ; args . selectionArgs = selectionArgs ; msg . obj = args ; mWorkerThreadHandler . sendMessage ( msg ) ; } 
public void setColumnLabel ( int columnIndex , String label ) throws SQLException { checkColRange ( columnIndex ) ; if ( label != null ) { colInfo [ columnIndex ] . columnLabel = label ; } else { colInfo [ columnIndex ] . columnLabel = "" ; } } 
public int getCount ( int recursionLevel ) { if ( recursionLevel >= m_counts . size ( ) ) { return 0 ; } else { return m_counts . get ( recursionLevel ) ; } } 
public static void showException ( final Throwable exception ) { final Dialog dialog = new Dialog ( ) ; dialog . setTitle ( ResourceManager . getLabel ( ResourceManager . EXCEPTION ) ) ; final String msg = exception . getMessage ( ) ; final String className = exception . getClass ( ) . getName ( ) ; final boolean noMessage = msg == null || msg . trim ( ) . length ( ) == 0 ; dialog . getMessageArea ( ) . setTitle ( noMessage ? className : msg ) . setText ( noMessage ? "" : className ) . setIcon ( Display . getCurrent ( ) . getSystemImage ( SWT . ICON_ERROR ) ) . setException ( exception ) ; dialog . getFooterArea ( ) . setExpanded ( true ) ; dialog . setButtonType ( OpalDialogType . CLOSE ) ; dialog . show ( ) ; } 
private Result pElementValue$1 ( final int yyStart ) throws IOException { Result yyResult ; Node yyValue ; ParseError yyError = ParseError . DUMMY ; yyResult = pExpression ( yyStart ) ; yyError = yyResult . select ( yyError ) ; if ( yyResult . hasValue ( ) ) { yyValue = yyResult . semanticValue ( ) ; return yyResult . createValue ( yyValue , yyError ) ; } yyResult = pAnnotation ( yyStart ) ; yyError = yyResult . select ( yyError ) ; if ( yyResult . hasValue ( ) ) { yyValue = yyResult . semanticValue ( ) ; return yyResult . createValue ( yyValue , yyError ) ; } yyResult = pElementArrayInitializer ( yyStart ) ; yyError = yyResult . select ( yyError ) ; if ( yyResult . hasValue ( ) ) { yyValue = yyResult . semanticValue ( ) ; return yyResult . createValue ( yyValue , yyError ) ; } return yyError ; } 
public void generateReport ( Map < Transaction , List < Message >> reportErrors , List < Summary > reportSummary , Date runDate , String title , String fileprefix , String destinationDirectory ) { LOG . debug ( "generateReport()-started" ) ; List transactions = new ArrayList ( ) ; if ( reportErrors != null ) { transactions . addAll ( reportErrors . keySet ( ) ) ; } generateReport ( transactions , reportErrors , reportSummary , runDate , title , fileprefix , destinationDirectory ) ; } 
public void learnWord ( String word ) { if ( ! learnedList . contains ( word ) ) { learnedList . add ( word ) ; checker . learnWord ( word ) ; synchronized ( this ) { incorrectWordsCache . remove ( word ) ; correctWordsCache . add ( word ) ; } } } 
final void close ( boolean allMenusAreClosing ) { if ( mIsClosing ) return ; mIsClosing = true ; for ( WeakReference < MenuPresenter > ref : mPresenters ) { final MenuPresenter presenter = ref . get ( ) ; if ( presenter == null ) { mPresenters . remove ( ref ) ; } else { presenter . onCloseMenu ( this , allMenusAreClosing ) ; } } mIsClosing = false ; } 
public void removeNotificationListener ( NotificationListener listener , NotificationFilter filter , Object handback ) throws ListenerNotFoundException { broadcaster . removeNotificationListener ( listener , filter , handback ) ; } 
public final void removeElementAt ( int index ) { System . arraycopy ( m_Objects , index + 1 , m_Objects , index , m_Size - index - 1 ) ; m_Size -- ; } 
public static void w ( String tag , String s , Object ... args ) { if ( LOG . WARN >= LOGLEVEL ) Log . w ( tag , String . format ( s , args ) ) ; } 
public static int getDecodedLength ( CharBuffer encoded ) throws IllegalArgumentException { if ( encoded . hasArray ( ) ) { int numChars = encoded . limit ( ) - encoded . arrayOffset ( ) - 1 ; if ( numChars <= 0 ) { return 0 ; } else { int numFullBytesInFinalChar = encoded . charAt ( encoded . limit ( ) - 1 ) ; int numEncodedChars = numChars - 1 ; return ( numEncodedChars * 15 + 7 ) / 8 + numFullBytesInFinalChar ; } } else { throw new IllegalArgumentException ( "encoded-argument-must-have-a-backing-array" ) ; } } 
public void setQryrtnTime ( String qryrtnTime ) { this . qryrtnTime = qryrtnTime == null ? null : qryrtnTime . trim ( ) ; } 
public IProgramElement findElementForType ( String packageName , String typeName ) { synchronized ( this ) { StringBuilder keyb = ( packageName == null ) ? new StringBuilder ( ) : new StringBuilder ( packageName ) ; keyb . append ( "." ) . append ( typeName ) ; String key = keyb . toString ( ) ; IProgramElement cachedValue = typeMap . get ( key ) ; if ( cachedValue != null ) { return cachedValue ; } List < IProgramElement > packageNodes = findMatchingPackages ( packageName ) ; for ( IProgramElement pkg : packageNodes ) { for ( IProgramElement fileNode : pkg . getChildren ( ) ) { IProgramElement cNode = findClassInNodes ( fileNode . getChildren ( ) , typeName , typeName ) ; if ( cNode != null ) { typeMap . put ( key , cNode ) ; return cNode ; } } } } return null ; } 
private String generateUniquePrefix ( NamespaceContext nsCtxt ) { String prefix = NAMESPACE_PREFIX + namespaceSuffix ++ ; while ( nsCtxt . getNamespaceURI ( prefix ) != null ) { prefix = NAMESPACE_PREFIX + namespaceSuffix ++ ; } return prefix ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
protected boolean isVisibleToUser ( ) { return isVisibleToUser ( null ) ; } 
public void removeManager ( String name ) throws Exception { ObjectName oname = new ObjectName ( name ) ; String type = oname . getKeyProperty ( "type" ) ; String serviceName = oname . getKeyProperty ( "service" ) ; Server server = ServerFactory . getServer ( ) ; Service service = server . findService ( serviceName ) ; Engine engine = ( Engine ) service . getContainer ( ) ; String hostName = oname . getKeyProperty ( "host" ) ; if ( ( type != null ) && ( type . equals ( "Manager" ) ) ) { String contextName = getPathStr ( oname . getKeyProperty ( "path" ) ) ; Host host = ( Host ) engine . findChild ( hostName ) ; Context context = ( Context ) host . findChild ( contextName ) ; context . setManager ( null ) ; } else if ( ( type != null ) && ( type . equals ( "DefaultManager" ) ) ) { DefaultContext defaultContext = null ; if ( hostName == null ) { defaultContext = engine . getDefaultContext ( ) ; } else { Host host = ( Host ) engine . findChild ( hostName ) ; defaultContext = host . getDefaultContext ( ) ; } if ( defaultContext != null ) { defaultContext . setManager ( null ) ; } } } 
@ Override public synchronized void initialize ( ) { if ( ! mRootDirectory . exists ( ) ) { if ( ! mRootDirectory . mkdirs ( ) ) { VolleyLog . e ( "Unable-to-create-cache-dir-%s" , mRootDirectory . getAbsolutePath ( ) ) ; } return ; } File [ ] files = mRootDirectory . listFiles ( ) ; if ( files == null ) { return ; } for ( File file : files ) { FileInputStream fis = null ; try { fis = new FileInputStream ( file ) ; CacheHeader entry = CacheHeader . readHeader ( fis ) ; entry . size = file . length ( ) ; putEntry ( entry . key , entry ) ; } catch ( IOException e ) { if ( file != null ) { file . delete ( ) ; } } finally { try { if ( fis != null ) { fis . close ( ) ; } } catch ( IOException ignored ) { } } } } 
public void colocarPanel ( JPanel panel ) { jPanel . removeAll ( ) ; javax . swing . GroupLayout jPanelLayout = new javax . swing . GroupLayout ( jPanel ) ; jPanel . setLayout ( jPanelLayout ) ; jPanelLayout . setHorizontalGroup ( jPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( panel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) ) ; jPanelLayout . setVerticalGroup ( jPanelLayout . createParallelGroup ( javax . swing . GroupLayout . Alignment . LEADING ) . addComponent ( panel , javax . swing . GroupLayout . DEFAULT_SIZE , javax . swing . GroupLayout . DEFAULT_SIZE , Short . MAX_VALUE ) ) ; } 
private byte [ ] getBytes ( ByteBuffer bb ) { byte [ ] buf = null ; if ( bb . hasArray ( ) ) { byte [ ] tmp = bb . array ( ) ; if ( ( tmp . length == bb . capacity ( ) ) && ( tmp . length == bb . remaining ( ) ) ) { buf = tmp ; bb . position ( bb . limit ( ) ) ; } } if ( buf == null ) { buf = new byte [ bb . remaining ( ) ] ; bb . get ( buf ) ; } return buf ; } 
private static String argsToExpression ( String [ ] args ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < args . length ; i ++ ) builder . append ( args [ i ] ) ; return builder . toString ( ) ; } 
private byte [ ] getBytes ( String resource ) throws Exception { for ( int i = 0 ; embedded_jars != null && i < embedded_jars . size ( ) ; i ++ ) { String libjar_name = ( String ) embedded_jars . get ( i ) ; InputStream in = getJarAsStream ( libjar_name ) ; byte [ ] bytes = getBytes ( in , resource ) ; if ( bytes != null ) { return bytes ; } } return null ; } 
public synchronized int getConnectionCount ( ) { return connections . size ( ) ; } 
private SyntaxTreeNode findStylesheet ( SyntaxTreeNode root , String href ) { if ( root == null ) return null ; if ( root instanceof Stylesheet ) { String id = root . getAttribute ( "id" ) ; if ( id . equals ( href ) ) return root ; } Vector children = root . getContents ( ) ; if ( children != null ) { final int count = children . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SyntaxTreeNode child = ( SyntaxTreeNode ) children . elementAt ( i ) ; SyntaxTreeNode node = findStylesheet ( child , href ) ; if ( node != null ) return node ; } } return null ; } 
public void uninstallUI ( JComponent c ) { Iterator iterator = uis . iterator ( ) ; while ( iterator . hasNext ( ) ) { ComponentUI ui = ( ComponentUI ) iterator . next ( ) ; ui . uninstallUI ( c ) ; } } 
public void addRule ( Rule rule ) { rules . add ( rule ) ; NonTerm lhs = rule . getLHS ( ) ; List < Rule > lhsRules = ruleMap . get ( lhs ) ; if ( lhsRules == null ) { ruleMap . put ( lhs , lhsRules = new ArrayList < > ( ) ) ; nonTermMap . put ( lhs . getName ( ) , lhs ) ; } lhsRules . add ( rule ) ; for ( Symbol symbol : rule . getRHS ( ) ) { if ( symbol instanceof Term ) { Term term = ( Term ) symbol ; terminals . add ( term ) ; int tokenType = term . getTokenType ( ) ; if ( tokenType != 0 ) { while ( termList . size ( ) <= tokenType ) { termList . add ( null ) ; } Term oldTerm = termList . set ( tokenType , term ) ; assert oldTerm == null || oldTerm . equals ( term ) : String . format ( "Duplicate-token-'%s'-and-'%s'-with-type-%d" , oldTerm , term , tokenType ) ; } } } } 
GetFieldImpl ( ObjectStreamClass desc ) { this . desc = desc ; primVals = new byte [ desc . getPrimDataSize ( ) ] ; objVals = new Object [ desc . getNumObjFields ( ) ] ; objHandles = new int [ objVals . length ] ; } 
public void attach ( Simulation sim , List < Simulation . Node > nodes ) { for ( Simulation . Node node : nodes ) { if ( panelMap . containsKey ( nodes ) ) continue ; MonitorPanel p = AvroraGui . instance . createMonitorPanel ( monitorName + "---" + node . id ) ; SingleNodePanel snp = newPanel ( node , p ) ; panelMap . put ( node , snp ) ; node . addGuiMonitor ( this ) ; } } 
public BigInteger pow ( int exp ) { if ( exp < 0 ) { throw new ArithmeticException ( "exp-<-0:-" + exp ) ; } return new BigInteger ( BigInt . exp ( getBigInt ( ) , exp ) ) ; } 
public void addExceptions ( List exceptionList ) { for ( Iterator iter = exceptionList . iterator ( ) ; iter . hasNext ( ) ; ) { addException ( ( Date ) iter . next ( ) ) ; } } 
private byte [ ] getPhotoBytes ( String filename ) { ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; try { int bytesRead = 0 ; long totalBytesRead = 0 ; byte [ ] data = new byte [ 8192 ] ; InputStream in = getPathFromUri ( filename ) ; while ( ( bytesRead = in . read ( data , 0 , data . length ) ) != - 1 && totalBytesRead <= MAX_PHOTO_SIZE ) { buffer . write ( data , 0 , bytesRead ) ; totalBytesRead += bytesRead ; } in . close ( ) ; buffer . flush ( ) ; } catch ( FileNotFoundException e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } catch ( IOException e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return buffer . toByteArray ( ) ; } 
@ Override public String toString ( ) { return ReflectionToStringBuilder . reflectionToString ( this ) ; } 
private void addEnableControl ( String text , ItemListener listener ) { JCheckBox enableControl = new JCheckBox ( "Enable-" + text ) ; enableControl . setBounds ( 10 , offset , 200 , 20 ) ; enableControl . addItemListener ( listener ) ; add ( enableControl ) ; controlToValueName . put ( enableControl , text ) ; valueNameToControl . put ( text , enableControl ) ; offset += 25 ; } 
private TextField getT8 ( ) { if ( t8 == null ) { t8 = new TextField ( ) ; t8 . setBounds ( new Rectangle ( 330 , 70 , 40 , 25 ) ) ; } return t8 ; } 
public static String getFileExtension ( String path ) { int fsIndex = getLastSeparatorIndex ( path ) ; int index = path . lastIndexOf ( '.' ) ; if ( index == - 1 || index < fsIndex ) return "" ; else return path . substring ( index ) ; } 
public Deferred < Object > addPoint ( final String metric , final long timestamp , final float value , final Map < String , String > tags ) { if ( Float . isNaN ( value ) || Float . isInfinite ( value ) ) { throw new IllegalArgumentException ( "value-is-NaN-or-Infinite:-" + value + "-for-metric=" + metric + "-timestamp=" + timestamp ) ; } final short flags = Const . FLAG_FLOAT | 0x3 ; return addPointInternal ( metric , timestamp , Bytes . fromInt ( Float . floatToRawIntBits ( value ) ) , tags , flags ) ; } 
ReferenceEntry < K , V > getFirst ( int hash ) { AtomicReferenceArray < ReferenceEntry < K , V >> table = this . table ; return table . get ( hash & ( table . length ( ) - 1 ) ) ; } 
public OntologyAccess getOntologyAccess ( String ontologyID ) { return ontologies . get ( ontologyID ) ; } 
public Object getSecurityContext ( ) { return AccessController . getContext ( ) ; } 
private static void saveFile ( StringBuffer stringBuffer , String filename ) { String path = ( new File ( "" ) ) . getPath ( ) ; File file = new File ( path + "/" + filename ) ; FileWriter output = null ; try { output = new FileWriter ( file ) ; output . write ( stringBuffer . toString ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { output . close ( ) ; } catch ( IOException e ) { } } } 
public final int problemsSize ( ) { return problems . size ( ) ; } 
@ Override public MultiMap < K , V > clone ( ) { return new MultiMap < K , V > ( this ) ; } 
public int size ( ) { return questions . size ( ) ; } 
public void onWindowFocusChanged ( boolean aHasFocus ) { if ( aHasFocus ) { View lContent = mActivity . getWindow ( ) . findViewById ( Window . ID_ANDROID_CONTENT ) ; mScreenWidth = lContent . getWidth ( ) ; mScreenHeight = lContent . getHeight ( ) ; } } 
private double [ ] [ ] getGripAxes ( ArrayList < double [ ] > points ) { double minX = Double . MAX_VALUE ; double maxX = Double . MIN_VALUE ; double minY = Double . MAX_VALUE ; double maxY = Double . MIN_VALUE ; for ( double [ ] p : points ) { minX = Math . min ( minX , p [ 0 ] ) ; maxX = Math . max ( maxX , p [ 0 ] ) ; minY = Math . min ( minY , p [ 1 ] ) ; maxY = Math . max ( maxY , p [ 1 ] ) ; } double equalityThresh = 0.01 ; double dx = maxX - minX ; double dy = maxY - minY ; if ( Math . abs ( dx - dy ) < equalityThresh ) { return new double [ ] [ ] { { 1.0 , 0 } , { 0 , 1.0 } } ; } else if ( dx > dy ) { return new double [ ] [ ] { { 1.0 , 0 } , { 0 , 1.0 } } ; } else { return new double [ ] [ ] { { 0 , 1.0 } , { 1.0 , 0 } } ; } } 
public void draw ( Graphics2D g ) { if ( this . width <= 0 ) return ; if ( this . height <= 0 ) return ; if ( color == null ) color = new Color ( 0 , 0 , 0 ) ; Paint oldPaint = g . getPaint ( ) ; g . setPaint ( color ) ; g . draw ( new Rectangle2D . Double ( this . pinhole . x - this . width / 2 , this . pinhole . y - this . height / 2 , this . width , this . height ) ) ; g . setPaint ( oldPaint ) ; } 
@ Override public boolean isLeapYear ( long prolepticYear ) { return Math . floorMod ( prolepticYear , 4 ) == 3 ; } 
public void stateChanged ( ChangeEvent event ) { ftf . setValue ( spinner . getValue ( ) ) ; } 
public Enumeration elements ( ) { return perms . elements ( ) ; } 
public StrBuilder ensureCapacity ( final int capacity ) { if ( capacity > buffer . length ) { final char [ ] old = buffer ; buffer = new char [ capacity * 2 ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } return this ; } 
protected final void sendTraversalRequestLocked ( ) { mHandler . post ( new Runnable ( ) { @ Override public void run ( ) { mListener . onTraversalRequested ( ) ; } } ) ; } 
public void mouseEntered ( MouseEvent e ) { Component source = ( Component ) e . getSource ( ) ; if ( source . getParent ( ) instanceof MenuElement ) { MenuSelectionManager manager = MenuSelectionManager . defaultManager ( ) ; manager . setSelectedPath ( getPath ( ) ) ; manager . processMouseEvent ( e ) ; } } 
private JLabel getstcLblEmployeeId ( ) { if ( ivjstcLblEmployeeId == null ) { try { ivjstcLblEmployeeId = new JLabel ( ) ; ivjstcLblEmployeeId . setName ( "stcLblEmployeeId" ) ; ivjstcLblEmployeeId . setText ( EMP_ID ) ; ivjstcLblEmployeeId . setMaximumSize ( new Dimension ( 71 , 14 ) ) ; ivjstcLblEmployeeId . setMinimumSize ( new Dimension ( 71 , 14 ) ) ; ivjstcLblEmployeeId . setBounds ( 33 , 8 , 83 , 18 ) ; } catch ( Throwable aeIVJEx ) { handleException ( aeIVJEx ) ; } } return ivjstcLblEmployeeId ; } 
public void writeTo ( OutputStream os ) throws IOException { DataOutputStream dos = new DataOutputStream ( os ) ; dos . writeInt ( N ) ; dos . writeInt ( q ) ; dos . writeInt ( d ) ; dos . writeInt ( d1 ) ; dos . writeInt ( d2 ) ; dos . writeInt ( d3 ) ; dos . writeInt ( B ) ; dos . writeDouble ( beta ) ; dos . writeDouble ( normBound ) ; dos . writeInt ( signFailTolerance ) ; dos . writeInt ( bitsF ) ; dos . writeUTF ( hashAlg . getAlgorithmName ( ) ) ; } 
public static < E extends Enum < E >> EnumSet < E > complementOf ( Collection < E > collection , Class < E > type ) { checkNotNull ( collection ) ; return ( collection instanceof EnumSet ) ? EnumSet . complementOf ( ( EnumSet < E > ) collection ) : makeComplementByHand ( collection , type ) ; } 
public boolean synthesizeToFile ( String text , String [ ] params , String filename ) { ArrayList < String > speakingParams = new ArrayList < String > ( ) ; if ( params != null ) { speakingParams = new ArrayList < String > ( Arrays . asList ( params ) ) ; } boolean success = mSelf . synthesizeToFile ( "DEPRECATED" , text , speakingParams , filename ) ; if ( success ) { deprecatedKeepBlockingFlag = true ; while ( deprecatedKeepBlockingFlag ) try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } return success ; } 
public static String removeNonSpaceWhiteSpace ( String string ) { return string . replaceAll ( "[|t|r|n|f]" , "" ) ; } 
protected void stateChanged ( ) { stateChange . release ( ) ; } 
public final void dispatch ( ) { try { appContext = AppContext . getAppContext ( ) ; if ( getFirst ( ) != this ) { if ( EventQueue . isDispatchThread ( ) ) { EventDispatchThread edt = ( EventDispatchThread ) Thread . currentThread ( ) ; edt . pumpEvents ( SentEvent . ID , new Conditional ( ) { public boolean evaluate ( ) { return ! SequencedEvent . this . isFirstOrDisposed ( ) ; } } ) ; } else { while ( ! isFirstOrDisposed ( ) ) { synchronized ( SequencedEvent . class ) { try { SequencedEvent . class . wait ( 1000 ) ; } catch ( InterruptedException e ) { break ; } } } } } if ( ! disposed ) { Toolkit . getEventQueue ( ) . dispatchEvent ( nested ) ; } } finally { dispose ( ) ; } } 
public static Type getArrayComponentType ( Type type ) { if ( type instanceof Class < ? > ) { Class < ? > clazz = ( Class < ? > ) type ; return clazz . isArray ( ) ? clazz . getComponentType ( ) : null ; } if ( type instanceof GenericArrayType ) { return ( ( GenericArrayType ) type ) . getGenericComponentType ( ) ; } return null ; } 
public synchronized boolean isErrorID ( int id ) { MediaEntry cur = head ; while ( cur != null ) { if ( cur . getID ( ) == id && ( cur . getStatus ( false , true ) & ERRORED ) != 0 ) { return true ; } cur = cur . next ; } return false ; } 
public void cancelLongPress ( ) { removeLongPressCallback ( ) ; removeTapCallback ( ) ; } 
public static String stringifyException ( Throwable e ) { StringWriter stm = new StringWriter ( ) ; PrintWriter wrt = new PrintWriter ( stm ) ; e . printStackTrace ( wrt ) ; wrt . close ( ) ; return stm . toString ( ) ; } 
public String getCallId ( String name ) { try { int index = name . indexOf ( "//" ) ; int firstIndex = name . indexOf ( "/" , index + 2 ) ; return name . substring ( firstIndex + 1 ) ; } catch ( Exception e ) { return name ; } } 
public void removeBookmarkedConference ( BookmarkedConference bookmarkedConference ) { bookmarkedConferences . remove ( bookmarkedConference ) ; } 
Type renameTypeAsType ( Type type ) { if ( type == null ) { return null ; } if ( type . getSort ( ) == Type . OBJECT ) { String in = type . getInternalName ( ) ; String newIn = renameInternalType ( in ) ; if ( newIn != in ) { return Type . getType ( "L" + newIn + ";" ) ; } } else if ( type . getSort ( ) == Type . ARRAY ) { StringBuilder sb = new StringBuilder ( ) ; for ( int n = type . getDimensions ( ) ; n > 0 ; n -- ) { sb . append ( '[' ) ; } sb . append ( renameType ( type . getElementType ( ) ) ) ; return Type . getType ( sb . toString ( ) ) ; } return type ; } 
public int getDrawAreaLeft ( ) { return Math . round ( mViewArea . left ) ; } 
public HashSet getConstraintPath ( ) { if ( constraintPath == null ) { constraintPath = new HashSet ( ) ; } else { constraintPath . clear ( ) ; } return constraintPath ; } 
public static final void main ( String [ ] args ) { System . out . println ( "dyn4j-v" + Version . getVersion ( ) ) ; } 
private RunningQuery getQuery ( final UUID queryUuid ) { return queries2 . get ( queryUuid ) ; } 
public EncryptionType getEncryptionType ( ) { lock . lock ( ) ; try { if ( keyCrypter == null ) { return EncryptionType . UNENCRYPTED ; } else { return keyCrypter . getUnderstoodEncryptionType ( ) ; } } finally { lock . unlock ( ) ; } } 
private String getClassName ( String classname ) { int i = classname . lastIndexOf ( "." ) ; if ( i == - 1 ) { return classname . toLowerCase ( ) ; } else { return classname . substring ( i + 1 , classname . length ( ) ) . toLowerCase ( ) ; } } 
public void removeAll ( ) { mParts . clear ( ) ; } 
public static void glGetObjectPtrLabel ( long ptr , IntBuffer length , ByteBuffer label ) { if ( LWJGLUtil . CHECKS ) if ( length != null ) checkBuffer ( length , 1 ) ; nglGetObjectPtrLabel ( ptr , label . remaining ( ) , memAddressSafe ( length ) , memAddress ( label ) ) ; } 
public Object clone ( ) { CharArrayIterator c = new CharArrayIterator ( chars , begin ) ; c . pos = this . pos ; return c ; } 
public int typeIndexFromFieldIndex ( int fieldIndex ) { checkBounds ( fieldIndex , tableOfContents . fieldIds . size ) ; int position = tableOfContents . fieldIds . off + ( SizeOf . MEMBER_ID_ITEM * fieldIndex ) ; position += SizeOf . USHORT ; return data . getShort ( position ) & 0xFFFF ; } 
public static Map < String , CmsProperty > toObjectMap ( Iterable < CmsProperty > properties ) { Map < String , CmsProperty > result = new LinkedHashMap < String , CmsProperty > ( ) ; for ( CmsProperty property : properties ) { result . put ( property . getName ( ) , property ) ; } return result ; } 
public static String getObjectId ( String provider , String objectType , String objectId ) { return String . format ( "id:%s:%ss:%s" , provider , objectType , objectId ) ; } 
public static Dimension getScreenSize ( ) { return Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; } 
public void setTextArea ( RTextArea textArea ) { if ( l == null ) { l = new Listener ( ) ; } if ( this . textArea != null ) { l . uninstall ( textArea ) ; } super . setTextArea ( textArea ) ; if ( textArea != null ) { l . install ( textArea ) ; updateCellHeights ( ) ; updateCellWidths ( ) ; } } 
public static Document parseMathMLDocumentString ( final String mathmlDocument ) throws IOException , SAXException { ConstraintUtilities . ensureNotNull ( mathmlDocument , "mathmlDocument" ) ; return XMLUtilities . createNSAwareDocumentBuilder ( ) . parse ( new InputSource ( new StringReader ( mathmlDocument ) ) ) ; } 
void scheduleFade ( ) { mHandler . sendMessageDelayed ( mHandler . obtainMessage ( MSG_FADE ) , FADE_DELAY ) ; } 
public Complex sin ( ) { return new Complex ( Math . sin ( re ) * Math . cosh ( im ) , Math . cos ( re ) * Math . sinh ( im ) ) ; } 
public static Type markOptional ( Type type ) { return type . annotate ( ) . attribute ( Constants . ATT_OPTIONAL ) ; } 
public Iterator < Panel > getPanels ( ) { return wavePanels . iterator ( ) ; } 
@ Deprecated public void managedCommitUpdates ( Cursor c ) { synchronized ( mManagedCursors ) { final int N = mManagedCursors . size ( ) ; for ( int i = 0 ; i < N ; i ++ ) { ManagedCursor mc = mManagedCursors . get ( i ) ; if ( mc . mCursor == c ) { c . commitUpdates ( ) ; mc . mUpdated = true ; return ; } } throw new RuntimeException ( "Cursor-" + c + "-is-not-currently-managed" ) ; } } 
public synchronized void reset ( ) { map . clear ( ) ; members = EMPTY_MEMBERS ; } 
public static String nowDateString ( String format ) { SimpleDateFormat df = new SimpleDateFormat ( format ) ; return df . format ( new Date ( ) ) ; } 
public Enumeration enumerateRequests ( ) { Vector newVector = new Vector ( 0 ) ; if ( m_evaluateThread != null ) { newVector . addElement ( "Stop" ) ; } return newVector . elements ( ) ; } 
public void setRenderingHints ( Map hints ) { if ( hints == null ) { throw new NullPointerException ( "Null-'hints'-argument." ) ; } this . hints = new RenderingHints ( hints ) ; } 
public int parseToNode ( Source source , SourceLocator locator , XPathContext xctxt ) throws TransformerException { try { Object xowner = xctxt . getOwnerObject ( ) ; DTM dtm ; if ( null != xowner && xowner instanceof org . apache . xml . dtm . DTMWSFilter ) { dtm = xctxt . getDTM ( source , false , ( org . apache . xml . dtm . DTMWSFilter ) xowner , false , true ) ; } else { dtm = xctxt . getDTM ( source , false , null , false , true ) ; } return dtm . getDocument ( ) ; } catch ( Exception e ) { throw new TransformerException ( e . getMessage ( ) , locator , e ) ; } } 
private CallerInfoAsyncQueryHandler ( Context context ) { super ( context . getContentResolver ( ) ) ; } 
synchronized public DTM createDocumentFragment ( ) { try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; dbf . setNamespaceAware ( true ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; Document doc = db . newDocument ( ) ; Node df = doc . createDocumentFragment ( ) ; return getDTM ( new DOMSource ( df ) , true , null , false , false ) ; } catch ( Exception e ) { throw new DTMException ( e ) ; } } 
public Builder setAction ( @ Nullable final ShareOpenGraphAction action ) { this . action = ( action == null ? null : new ShareOpenGraphAction . Builder ( ) . readFrom ( action ) . build ( ) ) ; return this ; } 
protected XdrEncodingStream getXdrEncodingStream ( ) { throw ( new Error ( "OncRpcTcpServerTransport.getXdrEncodingStream()-is-abstract-" + "and-can-not-be-called." ) ) ; } 
@ Override public void onClick ( View v ) { switch ( v . getId ( ) ) { case R . id . btnbildurl : mAddLocAppLogic . changeToFilechooser ( ) ; break ; case R . id . btnAddLocationCoordination : mAddLocAppLogic . setCoordination ( ) ; break ; case R . id . btnAnlegen : mAddLocAppLogic . setOrt ( ) ; break ; } } 
public final View findViewWithTag ( Object tag ) { if ( tag == null ) { return null ; } return findViewWithTagTraversal ( tag ) ; } 
public boolean isCommandKey ( final String key ) { return cmdKeys . contains ( key ) ; } 
public boolean isFocusCycleRoot ( Container container ) { if ( isFocusCycleRoot ( ) && container == this ) { return true ; } else { return super . isFocusCycleRoot ( container ) ; } } 
public DoubleBuffer put ( double [ ] src , int srcOffset , int doubleCount ) { Arrays . checkOffsetAndCount ( src . length , srcOffset , doubleCount ) ; if ( doubleCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + doubleCount ; ++ i ) { put ( src [ i ] ) ; } return this ; } 
public void setOriginFlag ( String originFlag ) { this . originFlag = originFlag == null ? null : originFlag . trim ( ) ; } 
public static MediaType parse ( String string ) { Matcher typeSubtype = TYPE_SUBTYPE . matcher ( string ) ; if ( ! typeSubtype . lookingAt ( ) ) return null ; String type = typeSubtype . group ( 1 ) . toLowerCase ( Locale . US ) ; String subtype = typeSubtype . group ( 2 ) . toLowerCase ( Locale . US ) ; String charset = null ; Matcher parameter = PARAMETER . matcher ( string ) ; for ( int s = typeSubtype . end ( ) ; s < string . length ( ) ; s = parameter . end ( ) ) { parameter . region ( s , string . length ( ) ) ; if ( ! parameter . lookingAt ( ) ) return null ; String name = parameter . group ( 1 ) ; if ( name == null || ! name . equalsIgnoreCase ( "charset" ) ) continue ; if ( charset != null ) throw new IllegalArgumentException ( "Multiple-charsets:-" + string ) ; charset = parameter . group ( 2 ) != null ? parameter . group ( 2 ) : parameter . group ( 3 ) ; } return new MediaType ( string , type , subtype , charset ) ; } 
public boolean checkURL ( String url ) { if ( url . indexOf ( '?' ) > - 1 ) { return true ; } return false ; } 
public boolean isVarargs ( ) { return testAllFlags ( VARARGS ) && isInvocable ( ) ; } 
public void write ( char [ ] buf ) throws IOException { write ( buf , 0 , buf . length ) ; } 
public void clear ( ) { entries . clear ( ) ; mainAttributes . clear ( ) ; } 
public final void acquireSharedInterruptibly ( int arg ) throws InterruptedException { if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; if ( tryAcquireShared ( arg ) < 0 ) doAcquireSharedInterruptibly ( arg ) ; } 
public static boolean isParentWindowFocused ( Component component ) { Window window = SwingUtilities . getWindowAncestor ( component ) ; return window != null && window . isFocused ( ) ; } 
private NFSubstitution extractSubstitution ( NFRuleSet owner , NFRule predecessor ) { NFSubstitution result ; int subStart ; int subEnd ; subStart = indexOfAny ( ruleText , RULE_PREFIXES ) ; if ( subStart == - 1 ) { return NFSubstitution . makeSubstitution ( ruleText . length ( ) , this , predecessor , owner , this . formatter , "" ) ; } if ( ruleText . substring ( subStart ) . startsWith ( ">>>" ) ) { subEnd = subStart + 2 ; } else { char c = ruleText . charAt ( subStart ) ; subEnd = ruleText . indexOf ( c , subStart + 1 ) ; if ( c == '<' && subEnd != - 1 && subEnd < ruleText . length ( ) - 1 && ruleText . charAt ( subEnd + 1 ) == c ) { ++ subEnd ; } } if ( subEnd == - 1 ) { return NFSubstitution . makeSubstitution ( ruleText . length ( ) , this , predecessor , owner , this . formatter , "" ) ; } result = NFSubstitution . makeSubstitution ( subStart , this , predecessor , owner , this . formatter , ruleText . substring ( subStart , subEnd + 1 ) ) ; ruleText = ruleText . substring ( 0 , subStart ) + ruleText . substring ( subEnd + 1 ) ; return result ; } 
private T getToken ( MarketDataHandle inMarketDataHandle ) { synchronized ( mLock ) { return mTokensByHandle . get ( inMarketDataHandle ) ; } } 
public void unload ( ) { setEstimatedMajorSpan ( true ) ; removeAll ( ) ; } 
int generateBridgeSecret ( ) { SecureRandom randGen = new SecureRandom ( ) ; expectedBridgeSecret = randGen . nextInt ( Integer . MAX_VALUE ) ; return expectedBridgeSecret ; } 
public static Attribute [ ] getUndefinedAttributes ( ) { if ( undefinedAttr . size ( ) == 0 ) return null ; Attribute [ ] attr = new Attribute [ undefinedAttr . size ( ) ] ; for ( int i = 0 ; i < attr . length ; i ++ ) { attr [ i ] = ( Attribute ) undefinedAttr . elementAt ( i ) ; } return attr ; } 
public Value ( InputStream is ) throws KettleFileException { try { readObj ( new DataInputStream ( is ) ) ; } catch ( EOFException e ) { throw new KettleEOFException ( "End-of-file-reached" , e ) ; } catch ( Exception e ) { throw new KettleFileException ( "Error-reading-from-data-input-stream" , e ) ; } } 
public Matrix readFloatBuffer ( FloatBuffer fb , boolean columnMajor ) { if ( columnMajor ) { m00 = fb . get ( ) ; m10 = fb . get ( ) ; m20 = fb . get ( ) ; m30 = fb . get ( ) ; m01 = fb . get ( ) ; m11 = fb . get ( ) ; m21 = fb . get ( ) ; m31 = fb . get ( ) ; m02 = fb . get ( ) ; m12 = fb . get ( ) ; m22 = fb . get ( ) ; m32 = fb . get ( ) ; m03 = fb . get ( ) ; m13 = fb . get ( ) ; m23 = fb . get ( ) ; m33 = fb . get ( ) ; } else { m00 = fb . get ( ) ; m01 = fb . get ( ) ; m02 = fb . get ( ) ; m03 = fb . get ( ) ; m10 = fb . get ( ) ; m11 = fb . get ( ) ; m12 = fb . get ( ) ; m13 = fb . get ( ) ; m20 = fb . get ( ) ; m21 = fb . get ( ) ; m22 = fb . get ( ) ; m23 = fb . get ( ) ; m30 = fb . get ( ) ; m31 = fb . get ( ) ; m32 = fb . get ( ) ; m33 = fb . get ( ) ; } return this ; } 
public int getSectionCount ( ) { return sections . size ( ) ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public static String requestPath ( URL url ) { String fileOnly = url . getFile ( ) ; if ( fileOnly == null ) { return "/" ; } else if ( ! fileOnly . startsWith ( "/" ) ) { return "/" + fileOnly ; } else { return fileOnly ; } } 
public void dragOver ( DragSourceDragEvent dsde ) { System . out . println ( "[Source]-dragOver" ) ; changeCursor ( dsde . getDragSourceContext ( ) , dsde . getUserAction ( ) & dsde . getDropAction ( ) ) ; dropAction = dsde . getUserAction ( ) & dsde . getDropAction ( ) ; System . out . println ( "dropAction-=-" + dropAction ) ; } 
public Vector getUsages ( ) { Vector temp = new Vector ( ) ; for ( Enumeration it = usageTable . elements ( ) ; it . hasMoreElements ( ) ; ) { temp . addElement ( it . nextElement ( ) ) ; } return temp ; } 
public void putOid ( long [ ] s , int tag ) { putOidValue ( s ) ; putTag ( tag ) ; } 
public List < TParticipant > getParticipant ( ) { if ( participant == null ) { participant = new ArrayList < TParticipant > ( ) ; } return this . participant ; } 
public String getAxisPath ( Axis givenAxis ) { for ( Axis axis : this . getAxes ( ) ) { if ( axis . equals ( givenAxis ) ) { continue ; } if ( axis . getStepfunction ( ) . equals ( Stepfunctions . FILE ) ) { int lastSeperatorIndex = axis . getFile ( ) . getAbsolutePath ( ) . lastIndexOf ( File . separatorChar ) ; return axis . getFile ( ) . getAbsolutePath ( ) . substring ( 0 , lastSeperatorIndex + 1 ) ; } } return null ; } 
public final void replaceStream ( OutputStream replacementStream ) throws IOException { if ( ! isRecoverable ( ) ) { throw new IllegalStateException ( ) ; } if ( this . out == replacementStream ) { return ; } replayBuffer . writeTo ( replacementStream ) ; Util . closeQuietly ( out ) ; out = replacementStream ; } 
private void updateFrameSet ( Element element , String url ) { try { int startOffset = element . getStartOffset ( ) ; int endOffset = Math . min ( getLength ( ) , element . getEndOffset ( ) ) ; String html = "<frame" ; if ( url != null ) { html += "-src="" + url + """ ; } html += ">" ; installParserIfNecessary ( ) ; setOuterHTML ( element , html ) ; } catch ( BadLocationException e1 ) { } catch ( IOException ioe ) { } } 
private int getCRSIndex ( int row , int col ) { int i = Arrays . binarySearch ( colInd , rowPtr [ row ] , rowPtr [ row + 1 ] , col ) ; if ( i >= 0 && colInd [ i ] == col ) return i ; else throw new IndexOutOfBoundsException ( "Entry-(" + ( row + 1 ) + ",-" + ( col + 1 ) + ")-is-not-in-the-matrix-structure" ) ; } 
public void deliverError ( VolleyError error ) { if ( mErrorListener != null ) { mErrorListener . onErrorResponse ( error ) ; } } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public OutputStream getOutputStream ( int size ) throws IOException { return response . getOutputStream ( size ) ; } 
public void deleteResolver ( Resolver r ) { resolvers . removeElement ( r ) ; } 
public void removeAttribute ( String name ) { int i = names . indexOf ( name ) ; if ( i != - 1 ) { names . remove ( i ) ; types . remove ( i ) ; values . remove ( i ) ; } } 
Principal getLocalPrincipal ( ) { Principal principal ; try { principal = session . getLocalPrincipal ( ) ; } catch ( AbstractMethodError e ) { principal = null ; java . security . cert . Certificate [ ] certs = session . getLocalCertificates ( ) ; if ( certs != null ) { principal = ( X500Principal ) ( ( X509Certificate ) certs [ 0 ] ) . getSubjectX500Principal ( ) ; } } return principal ; } 
private String analyzeAgent ( String agent ) { if ( agent . contains ( "Firefox" ) ) { return agent . substring ( agent . indexOf ( "Firefox" ) ) ; } else { return agent ; } } 
public AccessibleTable getAccessibleTable ( ) { return ac . getAccessibleTable ( ) ; } 
public void start ( ) { timer . schedule ( task , periodMs , periodMs ) ; } 
public final Collection < Thread > getExclusiveQueuedThreads ( ) { ArrayList < Thread > list = new ArrayList < Thread > ( ) ; for ( Node p = tail ; p != null ; p = p . prev ) { if ( ! p . isShared ( ) ) { Thread t = p . thread ; if ( t != null ) list . add ( t ) ; } } return list ; } 
public static void clear ( ) { storages . clear ( ) ; } 
public void setCreatetime ( String createtime ) { this . createtime = createtime == null ? null : createtime . trim ( ) ; } 
private void updateCandidates ( ) { if ( ! mCompletionOn ) { if ( mComposing . length ( ) > 0 ) { ArrayList < String > list = new ArrayList < String > ( ) ; list . add ( mComposing . toString ( ) ) ; setSuggestions ( list , true , true ) ; } else { setSuggestions ( null , false , false ) ; } } } 
public static void fireMessageEvent ( String message ) { ArrayList < WeakReference < ? >> badReferences = new ArrayList < WeakReference < ? >> ( ) ; for ( WeakReference < InterfaceMessageEventReceiver > r : messageEventReceivers ) { InterfaceMessageEventReceiver receiver = r . get ( ) ; if ( receiver == null ) { badReferences . add ( r ) ; } else { receiver . onMessageEvent ( message ) ; } } messageEventReceivers . removeAll ( badReferences ) ; } 
public int readIntFromXML ( Element node ) throws Exception { if ( DEBUG ) { trace ( new Throwable ( ) , node . getAttribute ( ATT_NAME ) ) ; } m_CurrentNode = node ; return ( ( Integer ) getPrimitive ( node ) ) . intValue ( ) ; } 
public static < T > Response < T > success ( T result , Cache . Entry cacheEntry ) { return new Response < T > ( result , cacheEntry ) ; } 
public Boolean isSupposedToChangePassword ( ) { return Boolean . valueOf ( getProperties ( ) . get ( OpenmrsConstants . USER_PROPERTY_CHANGE_PASSWORD ) ) ; } 
@ Override public String getMessage ( ) { StringBuffer buffer = new StringBuffer ( super . getMessage ( ) ) ; if ( querySQL != null ) { buffer . append ( ",-SQL:-[" ) . append ( querySQL . trim ( ) ) . append ( "]" ) ; } if ( ! qualifierSnapshot . isEmpty ( ) ) { buffer . append ( ",-WHERE-clause-bindings:-[" ) ; Iterator it = qualifierSnapshot . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; buffer . append ( entry . getKey ( ) ) . append ( "=" ) ; buffer . append ( entry . getValue ( ) ) ; if ( it . hasNext ( ) ) { buffer . append ( ",-" ) ; } } buffer . append ( "]" ) ; } return buffer . toString ( ) ; } 
static < I , I > void nonNull ( Function < I , I > f ) { return in -> { I out = f . apply ( in ) ; return out == null ? in : out ; } ; } 
public static URI resolve ( final URI baseURI , URI reference ) { if ( baseURI == null ) { throw new IllegalArgumentException ( "Base-URI-may-nor-be-null" ) ; } if ( reference == null ) { throw new IllegalArgumentException ( "Reference-URI-may-nor-be-null" ) ; } String s = reference . toString ( ) ; if ( s . startsWith ( "?" ) ) { return resolveReferenceStartingWithQueryString ( baseURI , reference ) ; } boolean emptyReference = s . length ( ) == 0 ; if ( emptyReference ) { reference = URI . create ( "#" ) ; } URI resolved = baseURI . resolve ( reference ) ; if ( emptyReference ) { String resolvedString = resolved . toString ( ) ; resolved = URI . create ( resolvedString . substring ( 0 , resolvedString . indexOf ( '#' ) ) ) ; } return removeDotSegments ( resolved ) ; } 
public static java . util . Date nowDate ( ) { return new java . util . Date ( ) ; } 
private void writeObject ( ObjectOutputStream out ) throws IOException { super . writeObjectBase ( out ) ; if ( out . getClass ( ) . getName ( ) . indexOf ( "xstream" ) == - 1 ) { out . writeObject ( URL ) ; } } 
@ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( longCount / 2 ) ; sb . append ( '{' ) ; boolean comma = false ; for ( int i = 0 ; i < longCount ; ++ i ) { if ( bits [ i ] != 0 ) { for ( int j = 0 ; j < 64 ; ++ j ) { if ( ( bits [ i ] & 1L << j ) != 0 ) { if ( comma ) { sb . append ( ",-" ) ; } else { comma = true ; } sb . append ( 64 * i + j ) ; } } } } sb . append ( '}' ) ; return sb . toString ( ) ; } 
protected short _type ( int identity ) { int info = _exptype ( identity ) ; if ( NULL != info ) return m_expandedNameTable . getType ( info ) ; else return NULL ; } 
public long getMax ( String name ) { long max = - 1L ; try { Connection con = SWBUtils . DB . getConnection ( dbcon ) ; Statement st = con . createStatement ( ) ; ResultSet rs = st . executeQuery ( "SELECT-max(" + name + ")-FROM-" + tablename ) ; if ( rs . next ( ) ) max = rs . getLong ( 1 ) ; else max = 0L ; rs . close ( ) ; st . close ( ) ; con . close ( ) ; } catch ( Exception e ) { log . error ( SWBUtils . TEXT . getLocaleString ( "com.infotec.wb.resources.database.TableGeneric" , "error_TableGeneric_getMax_ReadMaxError" ) + name + SWBUtils . TEXT . getLocaleString ( "com.infotec.wb.resources.database.TableGeneric" , "error_TableGeneric_getMax_ReadMaxErrorTable" ) + "-" + tablename , e ) ; } return max ; } 
public String toString ( int indentFactor ) throws JSONException { StringWriter sw = new StringWriter ( ) ; synchronized ( sw . getBuffer ( ) ) { return this . write ( sw , indentFactor , 0 ) . toString ( ) ; } } 
public String readString ( ) { return scanner . next ( ) ; } 
public synchronized void controlFree ( final int num ) { logger . info ( "maxFree-was-=-" + maxFree . get ( ) ) ; maxFree . set ( Math . min ( Math . max ( 1 , maxFree . addAndGet ( num ) ) , totalMaxSimultanFreeDownload . get ( ) ) ) ; logger . info ( "maxFree-now-=-" + maxFree . get ( ) ) ; } 
protected static String getGlobalInfo ( Clusterer clusterer ) throws Exception { BeanInfo bi = Introspector . getBeanInfo ( clusterer . getClass ( ) ) ; MethodDescriptor [ ] methods ; methods = bi . getMethodDescriptors ( ) ; Object [ ] args = { } ; String result = "-Synopsis-for-" + clusterer . getClass ( ) . getName ( ) + ":-" ; for ( MethodDescriptor method : methods ) { String name = method . getDisplayName ( ) ; Method meth = method . getMethod ( ) ; if ( name . equals ( "globalInfo" ) ) { String globalInfo = ( String ) ( meth . invoke ( clusterer , args ) ) ; result += globalInfo ; break ; } } return result ; } 
public void clearSelection ( ) { if ( selection != null && selection . length > 0 ) { int selSize = selection . length ; boolean [ ] newness = new boolean [ selSize ] ; for ( int counter = 0 ; counter < selSize ; counter ++ ) newness [ counter ] = false ; TreeSelectionEvent event = new TreeSelectionEvent ( this , selection , newness , leadPath , null ) ; leadPath = null ; leadIndex = leadRow = - 1 ; uniquePaths . clear ( ) ; selection = null ; resetRowSelection ( ) ; fireValueChanged ( event ) ; } } 
public POAManager the_POAManager ( ) { try { lock ( ) ; return manager ; } finally { unlock ( ) ; } } 
void pause ( ) { paused . set ( true ) ; } 
public void setThisClass ( String className ) { _thisClass = className ; if ( _isWrite ) getConstantPool ( ) . addClass ( className ) ; } 
public static double chiSquaredProbability ( double x , int df ) { double a , y = 0 , s , e , c , z , val ; boolean even ; if ( x <= 0 || df < 1 ) { return ( 1 ) ; } a = 0.5 * x ; even = ( ( ( int ) ( 2 * ( df / 2 ) ) ) == df ) ; if ( df > 1 ) { y = Math . exp ( - a ) ; } s = ( even ? y : ( 2.0 * normalProbability ( - Math . sqrt ( x ) ) ) ) ; if ( df > 2 ) { x = 0.5 * ( df - 1.0 ) ; z = ( even ? 1.0 : 0.5 ) ; if ( a > bigx ) { e = ( even ? 0.0 : logSqrtPi ) ; c = Math . log ( a ) ; while ( z <= x ) { e = Math . log ( z ) + e ; val = c * z - a - e ; s += Math . exp ( val ) ; z += 1.0 ; } return ( s ) ; } else { e = ( even ? 1.0 : ( rezSqrtPi / Math . sqrt ( a ) ) ) ; c = 0.0 ; while ( z <= x ) { e = e * ( a / z ) ; c = c + e ; z += 1.0 ; } return ( c * y + s ) ; } } else { return ( s ) ; } } 
private BigDecimal [ ] preAlign ( BigDecimal lhs , BigDecimal augend , long padding , MathContext mc ) { assert padding != 0 ; BigDecimal big ; BigDecimal small ; if ( padding < 0 ) { big = lhs ; small = augend ; } else { big = augend ; small = lhs ; } long estResultUlpScale = ( long ) big . scale - big . precision ( ) + mc . precision ; long smallHighDigitPos = ( long ) small . scale - small . precision ( ) + 1 ; if ( smallHighDigitPos > big . scale + 2 && smallHighDigitPos > estResultUlpScale + 2 ) { small = BigDecimal . valueOf ( small . signum ( ) , this . checkScale ( Math . max ( big . scale , estResultUlpScale ) + 3 ) ) ; } BigDecimal [ ] result = { big , small } ; return result ; } 
public static FormEncodingType getInstance ( final String name ) { final String lowerCaseName = name . toLowerCase ( Locale . ENGLISH ) ; if ( MULTIPART . getName ( ) . equals ( lowerCaseName ) ) { return MULTIPART ; } return URL_ENCODED ; } 
public double getNextNumber ( ) { if ( numberField == null ) return - 1.0 ; TextField tf = ( TextField ) numberField . elementAt ( nfIndex ) ; String theText = tf . getText ( ) ; String label = null ; if ( macro ) { label = ( String ) labels . get ( ( Object ) tf ) ; theText = Macro . getValue ( macroOptions , label , theText ) ; } String originalText = ( String ) defaultText . elementAt ( nfIndex ) ; double defaultValue = ( ( Double ) ( defaultValues . elementAt ( nfIndex ) ) ) . doubleValue ( ) ; double value ; if ( theText . equals ( originalText ) ) value = defaultValue ; else { Double d = getValue ( theText ) ; if ( d != null ) value = d . doubleValue ( ) ; else { if ( theText . startsWith ( "&" ) ) theText = theText . substring ( 1 ) ; Interpreter interp = Interpreter . getInstance ( ) ; value = interp != null ? interp . getVariable2 ( theText ) : Double . NaN ; if ( Double . isNaN ( value ) ) { invalidNumber = true ; errorMessage = """ + theText + ""-is-an-invalid-number" ; value = Double . NaN ; if ( macro ) { IJ . error ( "Macro-Error" , "Numeric-value-expected-in-run()-function-" + "-Dialog-box-title:-"" + getTitle ( ) + ""-" + "-Key:-"" + label . toLowerCase ( Locale . US ) + ""-" + "-Value-or-variable-name:-"" + theText + """ ) ; } } } } if ( recorderOn ) recordOption ( tf , trim ( theText ) ) ; nfIndex ++ ; return value ; } 
void helpDelete ( Node < K , V > b , Node < K , V > f ) { if ( f == next && this == b . next ) { if ( f == null || f . value != f ) appendMarker ( f ) ; else b . casNext ( this , f . next ) ; } } 
private void handleValidator ( ) { Attributes attrs = validatorInfo . getAttributes ( ) ; String ln = validatorInfo . getLocalName ( ) ; boolean hasValidatorId = false ; boolean hasBinding = false ; for ( int i = 0 ; i < attrs . getLength ( ) ; i ++ ) { if ( attrs . getLocalName ( i ) . equals ( "validatorId" ) ) { hasValidatorId = true ; } if ( attrs . getLocalName ( i ) . equals ( "binding" ) ) { hasBinding = true ; } } if ( failed = ( ! hasBinding && ! hasValidatorId ) ) { Object [ ] obj = new Object [ 1 ] ; obj [ 0 ] = ln ; ResourceBundle rb = ResourceBundle . getBundle ( RIConstants . TLV_RESOURCE_LOCATION ) ; failureMessages . append ( MessageFormat . format ( rb . getString ( "TLV_VALIDATOR_ERROR" ) , obj ) ) ; failureMessages . append ( "-" ) ; } } 
public final < T extends AlgorithmParameterSpec > T getParameterSpec ( Class < T > paramSpec ) throws InvalidParameterSpecException { if ( ! initialized ) { throw new InvalidParameterSpecException ( "Parameter-has-not-been-initialized" ) ; } return spiImpl . engineGetParameterSpec ( paramSpec ) ; } 
public static boolean isTitleCase ( int codePoint ) { return isTitleCaseImpl ( codePoint ) ; } 
private static void append_or_overwrite ( String filename , String data , boolean append ) { try { File file = new File ( filename ) ; FileChannel channel = new FileOutputStream ( file , append ) . getChannel ( ) ; FileLock lock = channel . lock ( ) ; try { ByteBuffer bb = ByteBuffer . wrap ( data . getBytes ( ) ) ; int byte_written = channel . write ( bb ) ; channel . close ( ) ; } finally { lock . release ( ) ; } } catch ( Exception e ) { System . out . println ( e . getMessage ( ) ) ; } } 
@ Override protected void onFocusChanged ( boolean focused , int direction , Rect previouslyFocusedRect ) { super . onFocusChanged ( focused , direction , previouslyFocusedRect ) ; if ( mIcon != null ) { mIcon . setVisibility ( focused ? View . VISIBLE : View . GONE ) ; } } 
public static void loadLibrary ( String libName ) { Runtime . getRuntime ( ) . loadLibrary ( libName , VMStack . getCallingClassLoader ( ) ) ; } 
public QName getXMLSchemaType ( ) { boolean yearSet = isSet ( DatatypeConstants . YEARS ) ; boolean monthSet = isSet ( DatatypeConstants . MONTHS ) ; boolean daySet = isSet ( DatatypeConstants . DAYS ) ; boolean hourSet = isSet ( DatatypeConstants . HOURS ) ; boolean minuteSet = isSet ( DatatypeConstants . MINUTES ) ; boolean secondSet = isSet ( DatatypeConstants . SECONDS ) ; if ( yearSet && monthSet && daySet && hourSet && minuteSet && secondSet ) { return DatatypeConstants . DURATION ; } if ( ! yearSet && ! monthSet && daySet && hourSet && minuteSet && secondSet ) { return DatatypeConstants . DURATION_DAYTIME ; } if ( yearSet && monthSet && ! daySet && ! hourSet && ! minuteSet && ! secondSet ) { return DatatypeConstants . DURATION_YEARMONTH ; } throw new IllegalStateException ( "javax.xml.datatype.Duration#getXMLSchemaType():" + "-this-Duration-does-not-match-one-of-the-XML-Schema-date/time-datatypes:" + "-year-set-=-" + yearSet + "-month-set-=-" + monthSet + "-day-set-=-" + daySet + "-hour-set-=-" + hourSet + "-minute-set-=-" + minuteSet + "-second-set-=-" + secondSet ) ; } 
public static NodeRegisterConfiguration getConfigFromXML ( String file ) throws FileNotFoundException , IOException , NodeRegisterConfigurationException { String xml = null ; FileInputStream stream = new FileInputStream ( new File ( file ) ) ; try { FileChannel fc = stream . getChannel ( ) ; MappedByteBuffer bb = fc . map ( FileChannel . MapMode . READ_ONLY , 0 , fc . size ( ) ) ; xml = Charset . defaultCharset ( ) . decode ( bb ) . toString ( ) ; } finally { stream . close ( ) ; } if ( xml == null || xml . isEmpty ( ) ) throw new NodeRegisterConfigurationException ( "Cannot-read-file,-XML-is-empty" ) ; XStream xstream = NodeRegisterConfigurationManager . getXstream ( ) ; NodeRegisterConfiguration newConfig = ( NodeRegisterConfiguration ) xstream . fromXML ( xml ) ; if ( newConfig == null ) throw new NodeRegisterConfigurationException ( "Cannot-read-configuration,-config-object-is-empty" ) ; return newConfig ; } 
static private Class < ? > getProviderClass ( String className , ClassLoader cl , boolean doFallback , boolean useBSClsLoader ) throws ClassNotFoundException { try { if ( cl == null ) { if ( useBSClsLoader ) { return Class . forName ( className , false , FactoryFinder . class . getClassLoader ( ) ) ; } else { cl = ss . getContextClassLoader ( ) ; if ( cl == null ) { throw new ClassNotFoundException ( ) ; } else { return Class . forName ( className , false , cl ) ; } } } else { return Class . forName ( className , false , cl ) ; } } catch ( ClassNotFoundException e1 ) { if ( doFallback ) { return Class . forName ( className , false , FactoryFinder . class . getClassLoader ( ) ) ; } else { throw e1 ; } } } 
public String getCursorName ( ) throws SQLException { throw SQLError . createSQLException ( Messages . getString ( "ResultSet.Positioned_Update_not_supported" ) , SQLError . SQL_STATE_DRIVER_NOT_CAPABLE , getExceptionInterceptor ( ) ) ; } 
protected JComponent makePVTab ( ) { Box view = new Box ( HORIZONTAL ) ; Box pvBox = new Box ( VERTICAL ) ; pvBox . add ( new JLabel ( "Connected-PVs:" ) ) ; _connectedPVList = new JList < > ( ) ; pvBox . add ( new JScrollPane ( _connectedPVList , VERTICAL_SCROLLBAR_ALWAYS , HORIZONTAL_SCROLLBAR_NEVER ) ) ; view . add ( pvBox ) ; pvBox = new Box ( VERTICAL ) ; pvBox . add ( new JLabel ( "Unconnected-PVs:" ) ) ; _unconnectedPVList = new JList < > ( ) ; pvBox . add ( new JScrollPane ( _unconnectedPVList , VERTICAL_SCROLLBAR_ALWAYS , HORIZONTAL_SCROLLBAR_NEVER ) ) ; view . add ( pvBox ) ; return view ; } 
public void accept ( Visitor v ) { v . visitExceptionThrower ( this ) ; v . visitTypedInstruction ( this ) ; v . visitStackConsumer ( this ) ; v . visitReturnInstruction ( this ) ; v . visitFRETURN ( this ) ; } 
@ Override public boolean equals ( Object obj ) { if ( ! ( obj instanceof MediaType ) ) { return false ; } MediaType other = ( MediaType ) obj ; return ( this . type . equalsIgnoreCase ( other . type ) && this . subtype . equalsIgnoreCase ( other . subtype ) && this . parameters . equals ( other . parameters ) ) ; } 
final public static boolean approximately_equal ( float a , float b , float epsilon ) { return ( Math . abs ( a - b ) <= epsilon ) ; } 
public static int skipWhitespace ( String input , int pos ) { for ( ; pos < input . length ( ) ; pos ++ ) { char c = input . charAt ( pos ) ; if ( c != '-' && c != '|t' ) { break ; } } return pos ; } 
public void mouseReleased ( MouseEvent evt ) { dragging = false ; if ( SHAPE_TOOLS . contains ( currentTool ) ) { Graphics g = OSC . getGraphics ( ) ; g . setColor ( currentColor ) ; putCurrentShape ( g ) ; g . dispose ( ) ; repaint ( ) ; } } 
public List < DescRecursoAplicacion > getDescRecursoAplicacion ( ) { if ( descRecursoAplicacion == null ) { descRecursoAplicacion = new ArrayList < DescRecursoAplicacion > ( ) ; } return this . descRecursoAplicacion ; } 
public int getExtendedInterfacesCount ( ) { if ( info == null || info . extendedInterfaces == null ) { return 0 ; } return info . extendedInterfaces . size ( ) ; } 
public boolean remove ( final Object key , final Object value ) { final List v = ( List ) this . table . get ( key ) ; if ( v == null ) { return false ; } if ( ! v . remove ( value ) ) { return false ; } if ( v . size ( ) == 0 ) { this . table . remove ( key ) ; } return true ; } 
public void removeGroupName ( String groupName ) { groupNames . remove ( groupName ) ; } 
String obtenerTipo ( Element elemento ) { return elemento . getAttribute ( Constants . TIPO_ATTR ) ; } 
public final boolean awaitUntil ( Date deadline ) throws InterruptedException { if ( deadline == null ) throw new NullPointerException ( ) ; long abstime = deadline . getTime ( ) ; if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; Node node = addConditionWaiter ( ) ; long savedState = fullyRelease ( node ) ; boolean timedout = false ; int interruptMode = 0 ; while ( ! isOnSyncQueue ( node ) ) { if ( System . currentTimeMillis ( ) > abstime ) { timedout = transferAfterCancelledWait ( node ) ; break ; } LockSupport . parkUntil ( this , abstime ) ; if ( ( interruptMode = checkInterruptWhileWaiting ( node ) ) != 0 ) break ; } if ( acquireQueued ( node , savedState ) && interruptMode != THROW_IE ) interruptMode = REINTERRUPT ; if ( node . nextWaiter != null ) unlinkCancelledWaiters ( ) ; if ( interruptMode != 0 ) reportInterruptAfterWait ( interruptMode ) ; return ! timedout ; } 
private JTextField getInputTypeField ( ) { if ( inputTypeField == null ) { inputTypeField = new JTextField ( ) ; } return inputTypeField ; } 
public E token ( int n ) { return mTokens . get ( n ) ; } 
public void append ( Tree tree , double edgeLength_ ) { if ( tree . parent != null ) throw new IllegalArgumentException ( "Cannot-share-trees!" ) ; tree . edgeLength = edgeLength_ ; tree . parent = this ; children . add ( tree ) ; } 
private static void closeStream ( Closeable stream ) { if ( stream != null ) { try { stream . close ( ) ; } catch ( IOException e ) { android . util . Log . e ( TAG , "Could-not-close-stream" , e ) ; } } } 
public int getLength ( ) { return buffer . getLength ( ) ; } 
private void popCurrentDoc ( ) { assert numSubsOnDoc == 0 ; assert docIDQueue . size ( ) > 0 ; subsOnDoc [ numSubsOnDoc ++ ] = docIDQueue . pop ( ) ; docID = subsOnDoc [ 0 ] . posEnum . docID ( ) ; while ( docIDQueue . size ( ) > 0 && docIDQueue . top ( ) . posEnum . docID ( ) == docID ) { subsOnDoc [ numSubsOnDoc ++ ] = docIDQueue . pop ( ) ; } } 
public void unregister ( ) { toolkit . removeAWTEventListener ( this ) ; } 
public void addDwgClass ( DwgClass dwgClass ) { System . out . println ( "DwgFile.addDwgClass()-executed-..." ) ; dwgClasses . add ( dwgClass ) ; } 
final static private String replaceString ( String p_original , String p_caseNormalized , String p_old , String p_new ) { StringBuffer buff = new StringBuffer ( ) ; int oldStrLength = p_old . length ( ) ; int index = 0 ; int prevIndex = 0 ; while ( ( index = p_caseNormalized . indexOf ( p_old , prevIndex ) ) != - 1 ) { buff . append ( p_original . substring ( prevIndex , index ) ) ; buff . append ( p_new ) ; prevIndex = index + oldStrLength ; } buff . append ( p_original . substring ( prevIndex , p_original . length ( ) ) ) ; return buff . toString ( ) ; } 
private String cond ( Instruction instr ) { if ( instr . getCondition ( ) == Condition . AL ) return "" ; else return instr . getCondition ( ) . name ( ) ; } 
public SpellDictionaryHashMap ( Reader wordList ) throws IOException { super ( ( File ) null ) ; createDictionary ( new BufferedReader ( wordList ) ) ; } 
private static void ImportPrefs ( Preferences prefsNode , Element map ) { NodeList entries = map . getChildNodes ( ) ; for ( int i = 0 , numEntries = entries . getLength ( ) ; i < numEntries ; i ++ ) { Element entry = ( Element ) entries . item ( i ) ; prefsNode . put ( entry . getAttribute ( "key" ) , entry . getAttribute ( "value" ) ) ; } } 
public void bind ( Name arg0 , Object arg1 , Attributes arg2 ) throws NamingException { ContextNamePair pair ; try { pair = getTargetNamespaceContextNamePair ( arg0 ) ; } catch ( IllegalArgumentException e ) { throw new OperationNotSupportedException ( ) ; } if ( pair . context instanceof DirContext ) { ( ( DirContext ) pair . context ) . bind ( pair . name , arg1 , arg2 ) ; } else { throw new NotContextException ( Messages . getString ( "jndi.4A" ) ) ; } } 
protected Fieldable createField ( String name , String val , Field . Store storage , Field . Index index , Field . TermVector vec , boolean omitNorms , IndexOptions options , float boost ) { Field f = new Field ( name , val , storage , index , vec ) ; if ( index . isIndexed ( ) ) { f . setOmitNorms ( omitNorms ) ; f . setIndexOptions ( options ) ; f . setBoost ( boost ) ; } return f ; } 
public List < ExpressBusinessOperation > getOperations ( ) { if ( operations == null ) { operations = new ArrayList < ExpressBusinessOperation > ( ) ; } return this . operations ; } 
public static NumberFormat getInstance ( Locale locale ) { return getNumberInstance ( locale ) ; } 
public FiltrationContext getContext ( ) { return window . get ( currentContext ) ; } 
private boolean procLine ( String s ) { if ( s . length ( ) < 1 ) return true ; if ( s . startsWith ( MORRIGAN_EOF ) ) return false ; readStatusLine ( s ) ; return true ; } 
public long readLong ( ) throws IOException { return primitiveTypes . readLong ( ) ; } 
public double readFloatNumber ( ) { workBuffer . setLength ( 0 ) ; while ( "0123456789-.Ee" . indexOf ( curChar ) >= 0 && readState >= 0 ) { workBuffer . append ( curChar ) ; nextChar ( ) ; } return Double . parseDouble ( workBuffer . toString ( ) ) ; } 
public Model load ( String path ) { Model model = null ; FileInputStream file ; ObjectInputStream object ; try { file = new FileInputStream ( path ) ; object = new ObjectInputStream ( file ) ; model = ( Model ) object . readObject ( ) ; object . close ( ) ; file . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( NotSerializableException e ) { System . out . println ( "!-could-not-serialize-" + path ) ; e . printStackTrace ( ) ; } catch ( IOException e ) { System . out . println ( "!-io-error-" + path ) ; } catch ( ClassNotFoundException e ) { e . printStackTrace ( ) ; } catch ( ClassCastException e ) { System . out . println ( "!-class-cast-trouble-" + path ) ; } return model ; } 
public String property ( String name , Properties props ) { return props . getProperty ( name ) ; } 
public static void scanNow ( ) { if ( sReceiver != null ) { sReceiver . scanNow ( ) ; } } 
public int getC_BPartnerSR_ID ( ) { Integer ii = ( Integer ) get_Value ( COLUMNNAME_C_BPartnerSR_ID ) ; if ( ii == null ) return 0 ; return ii . intValue ( ) ; } 
public void processRequest ( HttpServletRequest request , HttpServletResponse response ) { Throwable t = ( Throwable ) request . getAttribute ( "javax.servlet.error.exception" ) ; ServletException e = null ; try { e = ( ServletException ) request . getAttribute ( "javax.servlet.error.exception" ) ; } catch ( Exception e2 ) { } String s = "" ; boolean rootcausefound = false ; if ( t != null ) { s += t . toString ( ) + "-(" + ( String ) request . getAttribute ( "javax.servlet.error.request_uri" ) + ")" ; } if ( e != null ) { if ( e . getRootCause ( ) != null ) t = e . getRootCause ( ) ; s += "<h3>StackTrace-(RootCause)</h3>" ; s += "<pre>" ; StackTraceElement [ ] stes = t . getStackTrace ( ) ; for ( int i = 0 ; i < stes . length ; i ++ ) { StackTraceElement ste = stes [ i ] ; s += ste . toString ( ) + "-" ; } s += "</pre>" ; rootcausefound = true ; } if ( t != null && ! rootcausefound ) { while ( t . getCause ( ) != null ) t = t . getCause ( ) ; s += "<h3>StackTrace</h3>" ; s += "<pre>" ; StackTraceElement [ ] stes = t . getStackTrace ( ) ; for ( int i = 0 ; i < stes . length ; i ++ ) { StackTraceElement ste = stes [ i ] ; s += ste . toString ( ) + "-" ; } s += "</pre>" ; } errorPage ( request , response , s ) ; } 
public List < KodOkec > getOKEC ( ) { if ( okec == null ) { okec = new ArrayList < KodOkec > ( ) ; } return this . okec ; } 
public boolean handleApplicationWtf ( final IBinder app , final String tag , boolean system , final ApplicationErrorReport . CrashInfo crashInfo ) { final int callingUid = Binder . getCallingUid ( ) ; final int callingPid = Binder . getCallingPid ( ) ; if ( system ) { mHandler . post ( new Runnable ( ) { @ Override public void run ( ) { handleApplicationWtfInner ( callingUid , callingPid , app , tag , crashInfo ) ; } } ) ; return false ; } final ProcessRecord r = handleApplicationWtfInner ( callingUid , callingPid , app , tag , crashInfo ) ; if ( r != null && r . pid != Process . myPid ( ) && Settings . Global . getInt ( mContext . getContentResolver ( ) , Settings . Global . WTF_IS_FATAL , 0 ) != 0 ) { crashApplication ( r , crashInfo ) ; return true ; } else { return false ; } } 
public static boolean isTablet ( Context context ) { return ( context . getResources ( ) . getConfiguration ( ) . screenLayout & Configuration . SCREENLAYOUT_SIZE_MASK ) >= Configuration . SCREENLAYOUT_SIZE_LARGE ; } 
private java . lang . String registerPrefix ( javax . xml . stream . XMLStreamWriter xmlWriter , java . lang . String namespace ) throws javax . xml . stream . XMLStreamException { java . lang . String prefix = xmlWriter . getPrefix ( namespace ) ; if ( prefix == null ) { prefix = generatePrefix ( namespace ) ; while ( xmlWriter . getNamespaceContext ( ) . getNamespaceURI ( prefix ) != null ) { prefix = org . apache . axis2 . databinding . utils . BeanUtil . getUniquePrefix ( ) ; } xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } return prefix ; } 
public Scope popScope ( ) { Scope scope = ( Scope ) ( scopes . pop ( ) ) ; return scope ; } 
public void addNoRedraw ( final Command c ) { c . executeCommand ( ) ; commands . add ( c ) ; if ( commands . size ( ) > Main . pref . getInteger ( "undo.max" , 1000 ) ) { commands . removeFirst ( ) ; } redoCommands . clear ( ) ; } 
public String findWithinHorizon ( Pattern pattern , int horizon ) { ensureOpen ( ) ; if ( pattern == null ) throw new NullPointerException ( ) ; if ( horizon < 0 ) throw new IllegalArgumentException ( "horizon-<-0" ) ; clearCaches ( ) ; while ( true ) { String token = findPatternInBuffer ( pattern , horizon ) ; if ( token != null ) { matchValid = true ; return token ; } if ( needInput ) readInput ( ) ; else break ; } return null ; } 
public List < Integer > getElements ( ) { if ( elements == null ) { elements = new ArrayList < Integer > ( ) ; } return this . elements ; } 
public static String dom2String ( Document document ) { StringWriter sw = new StringWriter ( ) ; DOMUtil . printAsXML ( document , new PrintWriter ( sw ) ) ; return sw . toString ( ) ; } 
private static Pair < String , String > unpackBody ( byte [ ] pdu , int encoding , int offset , int length , boolean hasLanguageIndicator , String language ) { String body = null ; switch ( encoding ) { case SmsConstants . ENCODING_7BIT : body = GsmAlphabet . gsm7BitPackedToString ( pdu , offset , length * 8 / 7 ) ; if ( hasLanguageIndicator && body != null && body . length ( ) > 2 ) { language = body . substring ( 0 , 2 ) ; body = body . substring ( 3 ) ; } break ; case SmsConstants . ENCODING_16BIT : if ( hasLanguageIndicator && pdu . length >= offset + 2 ) { language = GsmAlphabet . gsm7BitPackedToString ( pdu , offset , 2 ) ; offset += 2 ; length -= 2 ; } try { body = new String ( pdu , offset , ( length & 0xfffe ) , "utf-16" ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalArgumentException ( "Error-decoding-UTF-16-message" , e ) ; } break ; default : break ; } if ( body != null ) { for ( int i = body . length ( ) - 1 ; i >= 0 ; i -- ) { if ( body . charAt ( i ) != CARRIAGE_RETURN ) { body = body . substring ( 0 , i + 1 ) ; break ; } } } else { body = "" ; } return new Pair < String , String > ( language , body ) ; } 
public Set < String > getVariableNames ( ) { return m_envVars . keySet ( ) ; } 
public static < X > List < X > MoveItem ( List < X > orig , int from , int to ) { if ( orig == null ) { return null ; } List < X > ret = new ArrayList < X > ( ) ; X fromItem = orig . get ( from ) ; for ( int i = 0 ; i < orig . size ( ) ; i ++ ) { if ( i != from ) { if ( i == to && from > to ) { ret . add ( fromItem ) ; } ret . add ( orig . get ( i ) ) ; if ( i == to && from < to ) { ret . add ( fromItem ) ; } } } return ret ; } 
public synchronized static List < Command > getNewCommands ( int id , ClientType type ) { List < Command > commands = new ArrayList < > ( ) ; if ( idLastID . get ( id ) != null ) { int lastID = idLastID . get ( id ) ; Iterator it = queuedCommands . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Entry < Integer , Command > entry = ( Entry ) it . next ( ) ; if ( entry . getKey ( ) > lastID && entry . getValue ( ) . getClientType ( ) == type ) { commands . add ( entry . getValue ( ) ) ; } } } idLastID . put ( id , getLastID ( ) ) ; return commands ; } 
default Consumer < T > andThen ( Consumer < ? super T > after ) { Objects . requireNonNull ( after ) ; return ( T t ) -> { accept ( t ) ; after . accept ( t ) ; } ; } 
public final void setMemoryPool ( int [ ] pktSizes , int [ ] initAlloc , int [ ] maxAlloc ) throws InvalidConfigurationException { if ( ( pktSizes . length != initAlloc . length ) || ( pktSizes . length != maxAlloc . length ) ) throw new InvalidConfigurationException ( "Invalid-packet-size/allocation-lists,-lengths-do-not-match" ) ; if ( pktSizes . length > 1 ) { for ( int i = 1 ; i <= pktSizes . length - 1 ; i ++ ) if ( pktSizes [ i ] < pktSizes [ i - 1 ] ) throw new InvalidConfigurationException ( "Packet-size-list-is-not-in-ascending-order" ) ; } if ( m_memoryPool != null ) throw new InvalidConfigurationException ( "Memory-pool-already-configured" ) ; m_memoryPool = new ByteBufferPool ( pktSizes , initAlloc , maxAlloc ) ; } 
protected boolean isEqualKey ( Object key1 , Object key2 ) { return ( key1 == key2 || ( ( key1 != null ) && key1 . equals ( key2 ) ) ) ; } 
@ Override public List < Commit > query ( Query query ) { List < Commit > matchedCommits = new ArrayList < > ( ) ; List < Expression > expressions = query . getExpressions ( ) ; for ( Commit commit : commits . values ( ) ) { boolean matches = true ; for ( Expression expression : expressions ) { if ( ! matchesCommit ( expression , commit ) ) { matches = false ; break ; } } if ( matches ) { matchedCommits . add ( commit ) ; } } return matchedCommits ; } 
private void uninstallBorder ( JRootPane root ) { LookAndFeel . uninstallBorder ( root ) ; } 
private synchronized void replaceScheduler ( ) { scheduler . terminate ( ) ; scheduler = new Scheduler ( this ) ; scheduler . start ( ) ; } 
public final Expression override ( Expression expr ) { return compose ( OVERRIDE , expr ) ; } 
private void JoinAllThreads ( ) throws InterruptedException { clockThread . join ( ) ; receiveThread . join ( ) ; } 
public void fillRoundRect ( float x , float y , float width , float height , int cornerRadius , int segs ) { if ( cornerRadius < 0 ) throw new IllegalArgumentException ( "corner-radius-must-be->-0" ) ; if ( cornerRadius == 0 ) { fillRect ( x , y , width , height ) ; return ; } int mr = ( int ) Math . min ( width , height ) / 2 ; if ( cornerRadius > mr ) { cornerRadius = mr ; } float d = cornerRadius * 2 ; fillRect ( x + cornerRadius , y , width - d , cornerRadius ) ; fillRect ( x , y + cornerRadius , cornerRadius , height - d ) ; fillRect ( x + width - cornerRadius , y + cornerRadius , cornerRadius , height - d ) ; fillRect ( x + cornerRadius , y + height - cornerRadius , width - d , cornerRadius ) ; fillRect ( x + cornerRadius , y + cornerRadius , width - d , height - d ) ; fillArc ( x + width - d , y + height - d , d , d , segs , 0 , 90 ) ; fillArc ( x , y + height - d , d , d , segs , 90 , 180 ) ; fillArc ( x + width - d , y , d , d , segs , 270 , 360 ) ; fillArc ( x , y , d , d , segs , 180 , 270 ) ; } 
@ SuppressWarnings ( "unchecked" ) @ Override public Object clone ( ) { try { LinkedList < E > l = ( LinkedList < E > ) super . clone ( ) ; l . size = 0 ; l . voidLink = new Link < E > ( null , null , null ) ; l . voidLink . previous = l . voidLink ; l . voidLink . next = l . voidLink ; l . addAll ( this ) ; return l ; } catch ( CloneNotSupportedException e ) { throw new AssertionError ( e ) ; } } 
public double interpolateX ( int row , int col ) { double tempInterpolationXDimension ; double tempX = ( ( img . getHeight ( ) - col ) + 0 ) ; double tempY = ( ( farPixelWidth - nearPixelWidth ) / ( col - 0 ) ) ; tempInterpolationXDimension = nearPixelWidth + tempX + tempY ; return tempInterpolationXDimension ; } 
protected void fillBackground ( Graphics2D g2 , Rectangle2D area , PlotOrientation orientation ) { ParamChecks . nullNotPermitted ( orientation , "orientation" ) ; if ( this . backgroundPaint == null ) { return ; } Paint p = this . backgroundPaint ; if ( p instanceof GradientPaint ) { GradientPaint gp = ( GradientPaint ) p ; if ( orientation == PlotOrientation . VERTICAL ) { p = new GradientPaint ( ( float ) area . getCenterX ( ) , ( float ) area . getMaxY ( ) , gp . getColor1 ( ) , ( float ) area . getCenterX ( ) , ( float ) area . getMinY ( ) , gp . getColor2 ( ) ) ; } else if ( orientation == PlotOrientation . HORIZONTAL ) { p = new GradientPaint ( ( float ) area . getMinX ( ) , ( float ) area . getCenterY ( ) , gp . getColor1 ( ) , ( float ) area . getMaxX ( ) , ( float ) area . getCenterY ( ) , gp . getColor2 ( ) ) ; } } Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , this . backgroundAlpha ) ) ; g2 . setPaint ( p ) ; g2 . fill ( area ) ; g2 . setComposite ( originalComposite ) ; } 
public static String [ ] getDriverNames ( ) { String [ ] names = new String [ drivers . size ( ) ] ; for ( int i = 0 ; i < names . length ; i ++ ) { names [ i ] = ( drivers . get ( i ) ) . getName ( ) ; } return names ; } 
public void setMaxIterations ( int maxIterations ) { if ( maxIterations < 5 ) throw new IllegalArgumentException ( Messages . getString ( "collision.continuous.conservativeAdvancement.invalidMaximumIterations" ) ) ; this . maxIterations = maxIterations ; } 
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj instanceof ECFieldF2m ) { return ( ( m == ( ( ECFieldF2m ) obj ) . m ) && ( Arrays . equals ( ks , ( ( ECFieldF2m ) obj ) . ks ) ) ) ; } return false ; } 
public static String byte2hex ( byte [ ] b ) { String hs = "" ; String stmp ; for ( int n = 0 ; n < b . length ; n ++ ) { stmp = java . lang . Integer . toHexString ( b [ n ] & 0XFF ) ; if ( stmp . length ( ) == 1 ) { hs = hs + "0" + stmp ; } else { hs = hs + stmp ; } if ( n < b . length - 1 ) { hs = hs + "" ; } } return hs ; } 
public double length_6 ( ) { double d = 0.0 ; d += x_6 * x_6 ; d += y_6 * y_6 ; return Math . sqrt ( d ) ; } 
private static void usage ( ) { System . err . println ( "Usage:-java-" + Main . class . getName ( ) + "-[options]" ) ; System . err . println ( "--help-Shows-this-list-of-options" ) ; System . err . println ( "--config-configfile-Specifies-the-configuration-file-[conf/bot-config.xml]" ) ; System . exit ( - 1 ) ; } 
private static int arrayMemberHash ( final Class < ? > componentType , final Object o ) { if ( componentType . equals ( Byte . TYPE ) ) { return Arrays . hashCode ( ( byte [ ] ) o ) ; } if ( componentType . equals ( Short . TYPE ) ) { return Arrays . hashCode ( ( short [ ] ) o ) ; } if ( componentType . equals ( Integer . TYPE ) ) { return Arrays . hashCode ( ( int [ ] ) o ) ; } if ( componentType . equals ( Character . TYPE ) ) { return Arrays . hashCode ( ( char [ ] ) o ) ; } if ( componentType . equals ( Long . TYPE ) ) { return Arrays . hashCode ( ( long [ ] ) o ) ; } if ( componentType . equals ( Float . TYPE ) ) { return Arrays . hashCode ( ( float [ ] ) o ) ; } if ( componentType . equals ( Double . TYPE ) ) { return Arrays . hashCode ( ( double [ ] ) o ) ; } if ( componentType . equals ( Boolean . TYPE ) ) { return Arrays . hashCode ( ( boolean [ ] ) o ) ; } return Arrays . hashCode ( ( Object [ ] ) o ) ; } 
@ Override public void paint ( Graphics g ) { this . paint ( g , this . getPosition ( ) ) ; } 
public boolean isPartitionAEqualsToPartitionB ( Integer A , Integer B ) { return A . equals ( B ) ; } 
@ Override public void writeXref ( Writer out ) throws IOException { out . write ( Util . htmlize ( content ) ) ; } 
public List < Block . Images . Image > getImage ( ) { if ( image == null ) { image = new ArrayList < Block . Images . Image > ( ) ; } return this . image ; } 
public void setDataset ( File value ) { if ( ! value . exists ( ) ) throw new IllegalArgumentException ( "Dataset-'" + value . getAbsolutePath ( ) + "'-does-not-exist!" ) ; else m_Dataset = value ; } 
public static int skipUntil ( String input , int pos , String characters ) { for ( ; pos < input . length ( ) ; pos ++ ) { if ( characters . indexOf ( input . charAt ( pos ) ) != - 1 ) { break ; } } return pos ; } 
public static int compareToIgnoreCase ( CharSequence me , CharSequence another ) { int myLen = me . length ( ) , anotherLen = another . length ( ) ; int myPos = 0 , anotherPos = 0 , result ; int end = ( myLen < anotherLen ) ? myLen : anotherLen ; while ( myPos < end ) { if ( ( result = Character . toLowerCase ( me . charAt ( myPos ++ ) ) - Character . toLowerCase ( another . charAt ( anotherPos ++ ) ) ) != 0 ) { return result ; } } return myLen - anotherLen ; } 
public Set < String > keySet ( ) { return mValues . keySet ( ) ; } 
public void simplify ( ) { ast = ast . simplify ( ) ; } 
final boolean areBoundsValid ( ) { Container cont = getContainer ( ) ; return cont == null || cont . isValid ( ) || cont . getLayout ( ) == null ; } 
public static double parseDouble ( String text ) throws DataParseException { try { return Double . parseDouble ( text ) ; } catch ( NumberFormatException e ) { throw new DataParseException ( e ) ; } } 
private List < ColumnName > getRowName ( Node < ColumnName > row ) { List < ColumnName > result = new ArrayList < ColumnName > ( ) ; result . add ( row . head . name ) ; Node < ColumnName > node = row . right ; while ( node != row ) { result . add ( node . head . name ) ; node = node . right ; } return result ; } 
public static void e ( String tag , String s , Object ... args ) { if ( LOG . ERROR >= LOGLEVEL ) Log . e ( tag , String . format ( s , args ) ) ; } 
static Path createTempFile ( Path dir , String prefix , String suffix , FileAttribute < ? > [ ] attrs ) throws IOException { return create ( dir , prefix , suffix , false , attrs ) ; } 
public static CodecFactory addCodec ( String name , CodecFactory c ) { return REGISTERED . put ( name , c ) ; } 
private ActivityChooserModel ( Context context , String historyFileName ) { mContext = context . getApplicationContext ( ) ; if ( ! TextUtils . isEmpty ( historyFileName ) && ! historyFileName . endsWith ( HISTORY_FILE_EXTENSION ) ) { mHistoryFileName = historyFileName + HISTORY_FILE_EXTENSION ; } else { mHistoryFileName = historyFileName ; } } 
public static CreateImageResponse parse ( javax . xml . stream . XMLStreamReader reader ) throws java . lang . Exception { CreateImageResponse object = new CreateImageResponse ( ) ; int event ; java . lang . String nillableValue = null ; java . lang . String prefix = "" ; java . lang . String namespaceuri = "" ; try { while ( ! reader . isStartElement ( ) && ! reader . isEndElement ( ) ) reader . next ( ) ; java . util . Vector handledAttributes = new java . util . Vector ( ) ; while ( ! reader . isEndElement ( ) ) { if ( reader . isStartElement ( ) ) { if ( reader . isStartElement ( ) && new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2012-08-15/" , "CreateImageResponse" ) . equals ( reader . getName ( ) ) ) { object . setCreateImageResponse ( com . amazon . ec2 . CreateImageResponseType . Factory . parse ( reader ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "Unexpected-subelement-" + reader . getLocalName ( ) ) ; } } else { reader . next ( ) ; } } } catch ( javax . xml . stream . XMLStreamException e ) { throw new java . lang . Exception ( e ) ; } return object ; } 
public Location copy ( ) { return new Location ( this ) ; } 
@ android . view . RemotableViewMethod public void setAdjustViewBounds ( boolean adjustViewBounds ) { mAdjustViewBounds = adjustViewBounds ; if ( adjustViewBounds ) { setScaleType ( ScaleType . FIT_CENTER ) ; } } 
static protected DatagramPacket buildAckRelayForw ( int sequenceNumber , int trasmissionPort , int trasmissionCtrlPort , InetAddress addr , int port ) throws IOException { ByteArrayOutputStream boStream = new ByteArrayOutputStream ( ) ; DataOutputStream doStream = new DataOutputStream ( boStream ) ; String content = sequenceNumber + "_" + Parameters . ACK_RELAY_FORW + "_" + trasmissionPort + "_" + trasmissionCtrlPort ; doStream . writeUTF ( content ) ; doStream . flush ( ) ; byte [ ] data = boStream . toByteArray ( ) ; return new DatagramPacket ( data , data . length , addr , port ) ; } 
public void setGrid ( Grid < ? > gr ) { currentLocation = new Location ( 0 , 0 ) ; JViewport vp = getEnclosingViewport ( ) ; if ( vp != null ) vp . setViewPosition ( new Point ( 0 , 0 ) ) ; grid = gr ; originRow = originCol = 0 ; if ( grid . getNumRows ( ) == - 1 && grid . getNumCols ( ) == - 1 ) { numRows = numCols = 2000 ; } else { numRows = grid . getNumRows ( ) ; numCols = grid . getNumCols ( ) ; } recalculateCellSize ( MIN_CELL_SIZE ) ; } 
private int indexOf ( Object x ) { if ( x != null ) { if ( x instanceof ScheduledFutureTask ) { int i = ( ( ScheduledFutureTask ) x ) . heapIndex ; if ( i >= 0 && i < size && queue [ i ] == x ) return i ; } else { for ( int i = 0 ; i < size ; i ++ ) if ( x . equals ( queue [ i ] ) ) return i ; } } return - 1 ; } 
private void updateInLoadMenuItems ( Menu menu , Tab tab ) { if ( menu == null ) { return ; } MenuItem dest = menu . findItem ( R . id . stop_reload_menu_id ) ; MenuItem src = ( ( tab != null ) && tab . inPageLoad ( ) ) ? menu . findItem ( R . id . stop_menu_id ) : menu . findItem ( R . id . reload_menu_id ) ; if ( src != null ) { dest . setIcon ( src . getIcon ( ) ) ; dest . setTitle ( src . getTitle ( ) ) ; } } 
public static Map < Long , Set < String >> tagsByVersion ( Map < String , Long > vtags ) { Map < Long , Set < String >> result = new HashMap < Long , Set < String >> ( ) ; for ( Map . Entry < String , Long > entry : vtags . entrySet ( ) ) { Set < String > tags = result . get ( entry . getValue ( ) ) ; if ( tags == null ) { tags = new HashSet < String > ( ) ; result . put ( entry . getValue ( ) , tags ) ; } tags . add ( entry . getKey ( ) ) ; } return result ; } 
public static String getPrimaryKeyColumn ( Connection conn , String table ) throws SQLException { logger . debug ( "getPrimaryKeyColumn(conn={},-table={})---start" , conn , table ) ; DatabaseMetaData metadata = conn . getMetaData ( ) ; ResultSet rs = metadata . getPrimaryKeys ( null , null , table ) ; rs . next ( ) ; String pkColumn = rs . getString ( 4 ) ; return pkColumn ; } 
public OutputStream add ( String name , OutputStream out ) { if ( name == null || out == null ) { throw new IllegalArgumentException ( ) ; } return ( OutputStream ) streams . put ( name , out ) ; } 
public void addAfter ( CompilerInput input , CompilerInput other ) { Preconditions . checkState ( inputs . contains ( other ) ) ; inputs . add ( inputs . indexOf ( other ) , input ) ; input . setModule ( this ) ; } 
@ Override public void add ( Permission permission ) { if ( isReadOnly ( ) ) { throw new IllegalStateException ( ) ; } if ( permission instanceof FilePermission ) { permissions . addElement ( permission ) ; } else { throw new IllegalArgumentException ( permission . toString ( ) ) ; } } 
private void nap ( long sec ) { try { Thread . sleep ( sec ) ; } catch ( InterruptedException e ) { logger . error ( "Failed-to-sleep" ) ; } } 
public void setLoopbackMode ( boolean disable ) throws SocketException { getImpl ( ) . setOption ( SocketOptions . IP_MULTICAST_LOOP , Boolean . valueOf ( disable ) ) ; } 
public static String DecodeForJmx ( String input ) { return input . replace ( "&colon;" , ":" ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
@ SuppressWarnings ( "unchecked" ) public static FancyMessage deserialize ( Map < String , Object > serialized ) { FancyMessage msg = new FancyMessage ( ) ; msg . messageParts = ( List < MessagePart > ) serialized . get ( "messageParts" ) ; msg . jsonString = serialized . containsKey ( "JSON" ) ? serialized . get ( "JSON" ) . toString ( ) : null ; msg . dirty = ! serialized . containsKey ( "JSON" ) ; return msg ; } 
private boolean inSamePackage ( Class < ? > c1 , Class < ? > c2 ) { String nameC1 = c1 . getName ( ) ; String nameC2 = c2 . getName ( ) ; int indexDotC1 = nameC1 . lastIndexOf ( '.' ) ; int indexDotC2 = nameC2 . lastIndexOf ( '.' ) ; if ( indexDotC1 != indexDotC2 ) { return false ; } if ( indexDotC1 < 0 ) { return true ; } return nameC1 . substring ( 0 , indexDotC1 ) . equals ( nameC2 . substring ( 0 , indexDotC2 ) ) ; } 
public Duration newDuration ( final boolean isPositive , final BigInteger years , final BigInteger months , final BigInteger days , final BigInteger hours , final BigInteger minutes , final BigDecimal seconds ) { return new DurationImpl ( isPositive , years , months , days , hours , minutes , seconds ) ; } 
public void addHeader ( String header , String value ) { clientHeaderMap . put ( header , value ) ; } 
public static Connection getConnection ( String url , String user , String password ) throws SQLException { Properties theProperties = new Properties ( ) ; if ( null != user ) { theProperties . setProperty ( "user" , user ) ; } if ( null != password ) { theProperties . setProperty ( "password" , password ) ; } return getConnection ( url , theProperties ) ; } 
protected boolean isPersisted ( Resource resource ) { boolean result = false ; try { InputStream stream = editingDomain . getResourceSet ( ) . getURIConverter ( ) . createInputStream ( resource . getURI ( ) ) ; if ( stream != null ) { result = true ; stream . close ( ) ; } } catch ( IOException e ) { } return result ; } 
protected AbstractHashedMap ( int initialCapacity , float loadFactor ) { super ( ) ; if ( initialCapacity < 1 ) { throw new IllegalArgumentException ( "Initial-capacity-must-be-greater-than-0" ) ; } if ( loadFactor <= 0.0f || Float . isNaN ( loadFactor ) ) { throw new IllegalArgumentException ( "Load-factor-must-be-greater-than-0" ) ; } this . loadFactor = loadFactor ; this . threshold = calculateThreshold ( initialCapacity , loadFactor ) ; initialCapacity = calculateNewCapacity ( initialCapacity ) ; this . data = new HashEntry [ initialCapacity ] ; init ( ) ; } 
public WrapperGroup [ ] getGroups ( ) { WrapperGroup [ ] groups = new WrapperGroup [ m_groups . size ( ) ] ; m_groups . toArray ( groups ) ; return groups ; } 
public Builder addMetaData ( String key , String value ) { key = key . toLowerCase ( ) ; this . meta . put ( key , value ) ; return this ; } 
public int getCurrentNode ( ) { return m_xcontext . getCurrentNode ( ) ; } 
public void selectDropdownByVisibleText_ClassName ( String locator , String value ) { new Select ( findByClassname ( locator ) ) . selectByVisibleText ( value ) ; } 
public void setRequestLine ( String requestLine ) { requestLine = requestLine . trim ( ) ; this . requestLine = requestLine ; } 
public void getRandomPowerUpType ( ) { List < PowerUpType > powerUps = Collections . unmodifiableList ( Arrays . asList ( PowerUpType . values ( ) ) ) ; int size = powerUps . size ( ) ; Random random = new Random ( ) ; this . type = powerUps . get ( random . nextInt ( size ) ) ; } 
public static int readSingleByte ( InputStream in ) throws IOException { byte [ ] buffer = new byte [ 1 ] ; int result = in . read ( buffer , 0 , 1 ) ; return ( result != - 1 ) ? buffer [ 0 ] & 0xff : - 1 ; } 
public ParameterBlock set ( float f , int index ) { return set ( new Float ( f ) , index ) ; } 
@ SuppressWarnings ( "unchecked" ) public String [ ] getHosts ( int n ) { Set < Map . Entry < String , Long >> entrySet = dataDistri . entrySet ( ) ; Map . Entry < String , Long > [ ] hostSize = entrySet . toArray ( new Map . Entry [ entrySet . size ( ) ] ) ; Arrays . sort ( hostSize , new Comparator < Map . Entry < String , Long >> ( ) { @ Override public int compare ( Entry < String , Long > o1 , Entry < String , Long > o2 ) { long diff = o1 . getValue ( ) - o2 . getValue ( ) ; if ( diff < 0 ) return 1 ; if ( diff > 0 ) return - 1 ; return 0 ; } } ) ; int nHost = Math . min ( hostSize . length , n ) ; String [ ] ret = new String [ nHost ] ; for ( int i = 0 ; i < nHost ; ++ i ) { ret [ i ] = hostSize [ i ] . getKey ( ) ; } return ret ; } 
protected void fireMenuKeyReleased ( MenuKeyEvent event ) { EventListener [ ] ll = listenerList . getListeners ( MenuKeyListener . class ) ; for ( int i = 0 ; i < ll . length ; i ++ ) ( ( MenuKeyListener ) ll [ i ] ) . menuKeyTyped ( event ) ; } 
@ Override public boolean addAll ( Collection < ? extends E > collection ) { Object [ ] dumpArray = collection . toArray ( ) ; if ( dumpArray . length == 0 ) { return false ; } if ( dumpArray . length > array . length - ( firstIndex + size ) ) { growAtEnd ( dumpArray . length ) ; } System . arraycopy ( dumpArray , 0 , this . array , firstIndex + size , dumpArray . length ) ; size += dumpArray . length ; modCount ++ ; return true ; } 
@ XmlElementDecl ( namespace = "" , name = "newDialPlanName" , scope = UpdateCallingPartyTransformationPatternReq . class ) public JAXBElement < XFkType > createUpdateCallingPartyTransformationPatternReqNewDialPlanName ( XFkType value ) { return new JAXBElement < XFkType > ( new QName ( "" , "newDialPlanName" ) , XFkType . class , UpdateCallingPartyTransformationPatternReq . class , value ) ; } 
public static LineIterator lineIterator ( Reader reader ) { return new LineIterator ( reader ) ; } 
public static void runFinalization ( ) { Runtime . getRuntime ( ) . runFinalization ( ) ; } 
private static void addOID ( ObjectIdentifier oid ) { int [ ] newOid = oid . getOid ( ) ; int index = hashIntArray ( newOid ) % CAPACITY ; ObjectIdentifier [ ] list = KNOWN_OIDS [ index ] ; int i = 0 ; for ( ; list [ i ] != null ; i ++ ) { if ( Arrays . equals ( newOid , list [ i ] . getOid ( ) ) ) { throw new Error ( "ObjectIdentifier:-invalid-static-initialization;-" + "duplicate-OIDs:-" + oid . getName ( ) + "-" + list [ i ] . getName ( ) ) ; } } if ( i == ( CAPACITY - 1 ) ) { throw new Error ( "ObjectIdentifier:-invalid-static-initialization;-" + "small-OID-pool-capacity" ) ; } list [ i ] = oid ; } 
public static final Token newToken ( int ofKind ) { switch ( ofKind ) { default : return new Token ( ) ; } } 
public void clearKeyBindings ( ) { keyStrokePairs . clear ( ) ; } 
private JMenu getFileMenu ( ) { if ( fileMenu == null ) { fileMenu = new JMenu ( ) ; fileMenu . setText ( "File" ) ; fileMenu . add ( getExitMenuItem ( ) ) ; } return fileMenu ; } 
public void clear ( ) { for ( int i = 0 ; i < mInternalList . size ( ) ; i ++ ) { signal_list_event ( EventHandler . CustomMediaListItemDeleted , i , mInternalList . get ( i ) . m . getLocation ( ) ) ; } mInternalList . clear ( ) ; } 
public static void closeQuietly ( ServerSocket serverSocket ) { if ( serverSocket != null ) { try { serverSocket . close ( ) ; } catch ( RuntimeException rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } } 
private void populateVehClassComboBox ( int aiEffDt ) throws RTSException { ivjcomboVehClass . removeActionListener ( this ) ; ivjcomboVehClass . removeAllItems ( ) ; if ( aiEffDt != 0 ) { cvVehClassCombo = RegistrationClassCache . getVehClassCds ( aiEffDt ) ; if ( cvVehClassCombo == null ) { throw new RTSException ( RTSException . FAILURE_MESSAGE , TXT_NULL_VEH_CLS , TXT_ERROR ) ; } int liSize = cvVehClassCombo . size ( ) ; if ( liSize == 0 ) { throw new RTSException ( RTSException . FAILURE_MESSAGE , TXT_NULL_VEH_CLS , TXT_ERROR ) ; } for ( int i = 0 ; i < liSize ; i ++ ) { RegistrationClassData laVehCdCacheData = ( RegistrationClassData ) cvVehClassCombo . get ( i ) ; ivjcomboVehClass . addItem ( ( String ) laVehCdCacheData . getVehClassCd ( ) ) ; } } else { throw new RTSException ( RTSException . FAILURE_MESSAGE , TXT_NULL_EFF_DT , TXT_ERROR ) ; } ivjcomboVehClass . addActionListener ( this ) ; } 
public String getType ( int i ) { if ( i < 0 || i >= types . size ( ) ) { return null ; } return types . get ( i ) ; } 
public void removeView ( RemoteViewsFrameLayout rvfl ) { if ( mViewToLinkedList . containsKey ( rvfl ) ) { mViewToLinkedList . get ( rvfl ) . remove ( rvfl ) ; mViewToLinkedList . remove ( rvfl ) ; } } 
public static ImageTypeSpecifier createFromRenderedImage ( RenderedImage image ) { if ( image == null ) { throw new IllegalArgumentException ( "image-==-null!" ) ; } if ( image instanceof BufferedImage ) { int bufferedImageType = ( ( BufferedImage ) image ) . getType ( ) ; if ( bufferedImageType != BufferedImage . TYPE_CUSTOM ) { return getSpecifier ( bufferedImageType ) ; } } return new ImageTypeSpecifier ( image ) ; } 
public static Interpolator loadInterpolator ( Context context , @ InterpolatorRes int id ) throws NotFoundException { XmlResourceParser parser = null ; try { parser = context . getResources ( ) . getAnimation ( id ) ; return createInterpolatorFromXml ( context . getResources ( ) , context . getTheme ( ) , parser ) ; } catch ( XmlPullParserException ex ) { NotFoundException rnf = new NotFoundException ( "Can't-load-animation-resource-ID-#0x" + Integer . toHexString ( id ) ) ; rnf . initCause ( ex ) ; throw rnf ; } catch ( IOException ex ) { NotFoundException rnf = new NotFoundException ( "Can't-load-animation-resource-ID-#0x" + Integer . toHexString ( id ) ) ; rnf . initCause ( ex ) ; throw rnf ; } finally { if ( parser != null ) parser . close ( ) ; } } 
public static DescribeExportTasks parse ( javax . xml . stream . XMLStreamReader reader ) throws java . lang . Exception { DescribeExportTasks object = new DescribeExportTasks ( ) ; int event ; java . lang . String nillableValue = null ; java . lang . String prefix = "" ; java . lang . String namespaceuri = "" ; try { while ( ! reader . isStartElement ( ) && ! reader . isEndElement ( ) ) reader . next ( ) ; java . util . Vector handledAttributes = new java . util . Vector ( ) ; while ( ! reader . isEndElement ( ) ) { if ( reader . isStartElement ( ) ) { if ( reader . isStartElement ( ) && new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2012-08-15/" , "DescribeExportTasks" ) . equals ( reader . getName ( ) ) ) { object . setDescribeExportTasks ( com . amazon . ec2 . DescribeExportTasksType . Factory . parse ( reader ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "Unexpected-subelement-" + reader . getLocalName ( ) ) ; } } else { reader . next ( ) ; } } } catch ( javax . xml . stream . XMLStreamException e ) { throw new java . lang . Exception ( e ) ; } return object ; } 
private PermissionEntry parsePermissionEntry ( ) throws ParsingException , IOException , PropertyExpander . ExpandException { PermissionEntry e = new PermissionEntry ( ) ; match ( "Permission" ) ; e . permission = match ( "permission-type" ) ; if ( peek ( """ ) ) { e . name = expand ( match ( "quoted-string" ) ) ; } if ( ! peek ( "," ) ) { return e ; } match ( "," ) ; if ( peek ( """ ) ) { e . action = expand ( match ( "quoted-string" ) ) ; if ( ! peek ( "," ) ) { return e ; } match ( "," ) ; } if ( peekAndMatch ( "SignedBy" ) ) { e . signedBy = expand ( match ( "quoted-string" ) ) ; } return e ; } 
public final boolean isBefore ( Version v ) { Version serviceVersion = findServiceVersion ( impliedVersions , v . getServiceClass ( ) ) ; Preconditions . checkArgument ( serviceVersion != null , "No-relationship-between-versions" ) ; if ( serviceVersion . major != v . major ) { return serviceVersion . major < v . major ; } else { return serviceVersion . minor < v . minor ; } } 
private void unparkSuccessor ( Node node ) { int ws = node . waitStatus ; if ( ws < 0 ) compareAndSetWaitStatus ( node , ws , 0 ) ; Node s = node . next ; if ( s == null || s . waitStatus > 0 ) { s = null ; for ( Node t = tail ; t != null && t != node ; t = t . prev ) if ( t . waitStatus <= 0 ) s = t ; } if ( s != null ) LockSupport . unpark ( s . thread ) ; } 
public static String generateUUID ( ) { return UUID . randomUUID ( ) . toString ( ) ; } 
public static final int getWordEnd ( JTextComponent c , int offs ) throws BadLocationException { Document doc = c . getDocument ( ) ; Element line = getParagraphElement ( c , offs ) ; if ( line == null ) { throw new BadLocationException ( "No-word-at-" + offs , offs ) ; } int lineStart = line . getStartOffset ( ) ; int lineEnd = Math . min ( line . getEndOffset ( ) , doc . getLength ( ) ) ; Segment seg = SegmentCache . getSharedSegment ( ) ; doc . getText ( lineStart , lineEnd - lineStart , seg ) ; if ( seg . count > 0 ) { BreakIterator words = BreakIterator . getWordInstance ( c . getLocale ( ) ) ; words . setText ( seg ) ; int wordPosition = offs - lineStart + seg . offset ; if ( wordPosition >= words . last ( ) ) { wordPosition = words . last ( ) - 1 ; } offs = lineStart + words . following ( wordPosition ) - seg . offset ; } SegmentCache . releaseSharedSegment ( seg ) ; return offs ; } 
public JInternalFrame [ ] getAllFrames ( ) { return getAllFrames ( this ) . toArray ( new JInternalFrame [ 0 ] ) ; } 
public void setWillNotCacheDrawing ( boolean willNotCacheDrawing ) { setFlags ( willNotCacheDrawing ? WILL_NOT_CACHE_DRAWING : 0 , WILL_NOT_CACHE_DRAWING ) ; } 
public Value getBottomProducerValue ( int index ) { return producerStack . getBottom ( index ) ; } 
public static String intern ( String s ) { return s == null ? s : s . intern ( ) ; } 
public String getEncodingType ( ) { return ( String ) content . get ( FIELD_TYPE ) ; } 
public boolean getInvertSelection ( ) { return ! m_SelectCols . getInvert ( ) ; } 
public void reconnect ( ) throws SQLException { Connection con = connection . get ( ) ; if ( con != null ) { if ( temporaryTableScope == TemporaryTableScope . TRANSACTION_LOCAL ) { con . commit ( ) ; } con . close ( ) ; connection . set ( null ) ; if ( con == temporaryTableSession ) { temporaryTableSession = null ; return ; } } if ( temporaryTableSession != null ) { if ( temporaryTableScope == TemporaryTableScope . TRANSACTION_LOCAL ) { temporaryTableSession . commit ( ) ; } temporaryTableSession . close ( ) ; temporaryTableSession = null ; } } 
public URLStreamHandler createURLStreamHandler ( final String protocol ) { if ( ! protocol . equals ( "http" ) && ! protocol . equals ( "https" ) ) return null ; return new URLStreamHandler ( ) { @ Override protected URLConnection openConnection ( URL url ) { return open ( url ) ; } @ Override protected URLConnection openConnection ( URL url , Proxy proxy ) { return open ( url , proxy ) ; } @ Override protected int getDefaultPort ( ) { if ( protocol . equals ( "http" ) ) return 80 ; if ( protocol . equals ( "https" ) ) return 443 ; throw new AssertionError ( ) ; } } ; } 
private void startTask ( ) { lock . lock ( ) ; try { if ( isShutdown ( ) ) { throw new RejectedExecutionException ( "Executor-already-shutdown" ) ; } runningTasks ++ ; } finally { lock . unlock ( ) ; } } 
public static List < File > getReferenceClientBlockFileList ( ) { String defaultDataDir ; if ( System . getProperty ( "os.name" ) . toLowerCase ( ) . indexOf ( "win" ) >= 0 ) { defaultDataDir = System . getenv ( "APPDATA" ) + "|.bitcoin|blocks|" ; } else { defaultDataDir = System . getProperty ( "user.home" ) + "/.bitcoin/blocks/" ; } List < File > list = new LinkedList < File > ( ) ; for ( int i = 0 ; true ; i ++ ) { File file = new File ( defaultDataDir + String . format ( "blk%05d.dat" , i ) ) ; if ( ! file . exists ( ) ) break ; list . add ( file ) ; } return list ; } 
static void writeMillis ( DataOutput out , long millis ) throws IOException { if ( millis % ( 30 * 60000L ) == 0 ) { long units = millis / ( 30 * 60000L ) ; if ( ( ( units << ( 64 - 6 ) ) >> ( 64 - 6 ) ) == units ) { out . writeByte ( ( int ) ( units & 0x3f ) ) ; return ; } } if ( millis % 60000L == 0 ) { long minutes = millis / 60000L ; if ( ( ( minutes << ( 64 - 30 ) ) >> ( 64 - 30 ) ) == minutes ) { out . writeInt ( 0x40000000 | ( int ) ( minutes & 0x3fffffff ) ) ; return ; } } if ( millis % 1000L == 0 ) { long seconds = millis / 1000L ; if ( ( ( seconds << ( 64 - 38 ) ) >> ( 64 - 38 ) ) == seconds ) { out . writeByte ( 0x80 | ( int ) ( ( seconds >> 32 ) & 0x3f ) ) ; out . writeInt ( ( int ) ( seconds & 0xffffffff ) ) ; return ; } } out . writeByte ( millis < 0 ? 0xff : 0xc0 ) ; out . writeLong ( millis ) ; } 
public com . google . protobuf . ByteString getSrcBytes ( ) { java . lang . Object ref = src_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; src_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public int numberOfWords ( ) { return words . countTokens ( ) ; } 
public static HashSet < String > createSetFromProperty ( String property ) { HashSet < String > properties = new HashSet < String > ( ) ; if ( property != null && ! property . equals ( "null" ) ) { Pattern params = Pattern . compile ( "([|w]+)[;]*" ) ; Matcher matcher = params . matcher ( property . trim ( ) ) ; while ( matcher . find ( ) ) { properties . add ( matcher . group ( 1 ) ) ; } } return properties ; } 
public static String generateUri ( String uriPrefix ) { return new StringBuffer ( uriPrefix ) . append ( "#" ) . append ( String . valueOf ( System . currentTimeMillis ( ) ) ) . toString ( ) ; } 
public Node selectSingleNode ( Node contextNode , Node xpathnode ) throws TransformerException { return selectSingleNode ( contextNode , xpathnode , contextNode ) ; } 
public Group getParentGroup ( ) { Object o = props . get ( PROP_PARENT_CONTROL ) ; if ( o instanceof Group ) return ( Group ) o ; return null ; } 
@ SuppressWarnings ( "unchecked" ) @ Override public Object clone ( ) { try { LinkedList < E > l = ( LinkedList < E > ) super . clone ( ) ; l . size = 0 ; l . voidLink = new Link < E > ( null , null , null ) ; l . voidLink . previous = l . voidLink ; l . voidLink . next = l . voidLink ; l . addAll ( this ) ; return l ; } catch ( CloneNotSupportedException e ) { throw new AssertionError ( e ) ; } } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public long runtime ( ) { if ( running == 0 ) return 0 ; return System . currentTimeMillis ( ) - running ; } 
public String [ ] getParamHelp ( ) { return ( String [ ] ) paramHelp . toArray ( new String [ paramHelp . size ( ) ] ) ; } 
public boolean isDefined ( Object key ) { Object [ ] a = attributes ; int n = a . length ; for ( int i = 0 ; i < n ; i += 2 ) { if ( key . equals ( a [ i ] ) ) { return true ; } } return false ; } 
private void newNote ( Note note ) { mAllNotes . add ( note ) ; Collections . sort ( mAllNotes , sCompDueDateDesc ) ; mOngoingNotes . add ( note ) ; Collections . sort ( mOngoingNotes , sCompDueDateAsc ) ; notifyModelChanged ( ) ; } 
public EndpointStudyRecord . ScientificPart . TOPHOTOTRANSAIR . AD . Set createEndpointStudyRecordScientificPartTOPHOTOTRANSAIRADSet ( ) { return new EndpointStudyRecord . ScientificPart . TOPHOTOTRANSAIR . AD . Set ( ) ; } 
public String [ ] getWeekdays ( ) { return weekdays . clone ( ) ; } 
@ Deprecated public static String [ ] getUlimitMemoryCommand ( Configuration conf ) { if ( WINDOWS ) { return null ; } String ulimit = conf . get ( "mapred.child.ulimit" ) ; if ( ulimit == null ) { return null ; } int memoryLimit = Integer . valueOf ( ulimit ) ; return getUlimitMemoryCommand ( memoryLimit ) ; } 
private void addGridComponent ( Container cont , Component comp , GridBagLayout mygb , int gridx , int gridy , int gridw , int gridh , int weightx , int weighty ) { GridBagConstraints c = new GridBagConstraints ( ) ; c . gridx = gridx ; c . gridy = gridy ; c . gridwidth = gridw ; c . gridheight = gridh ; c . fill = GridBagConstraints . BOTH ; c . weighty = weighty ; c . weightx = weightx ; c . anchor = GridBagConstraints . CENTER ; mygb . setConstraints ( comp , c ) ; cont . add ( comp ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public void replace ( MemberDefinition method ) { if ( frozen ) { throw new CompilerError ( "replace()" ) ; } Identifier name = method . getName ( ) ; List methodList = ( List ) lookupMap . get ( name ) ; if ( methodList == null ) { methodList = new ArrayList ( ) ; lookupMap . put ( name , methodList ) ; } int size = methodList . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( ( ( MemberDefinition ) methodList . get ( i ) ) . getType ( ) . equalArguments ( method . getType ( ) ) ) { methodList . set ( i , method ) ; return ; } } methodList . add ( method ) ; count ++ ; } 
private void checkUnusualURLPattern ( String urlPattern ) { if ( log . isLoggable ( Level . INFO ) ) { if ( urlPattern . endsWith ( "*" ) && ( urlPattern . length ( ) < 2 || urlPattern . charAt ( urlPattern . length ( ) - 2 ) != '/' ) ) { String msg = "Suspicious-url-pattern:-"" + urlPattern + """ + "-in-context-[" + getName ( ) + "]---see" + "-section-SRV.11.2-of-the-Servlet-specification" ; log . log ( Level . INFO , msg ) ; } } } 
private void safeSleep ( long millis ) throws InterruptedException { long done = 0 ; do { long before = System . currentTimeMillis ( ) ; sleep ( millis - done ) ; long after = System . currentTimeMillis ( ) ; done += ( after - before ) ; } while ( done < millis ) ; } 
public void checkPassword ( String value ) { String digest = granteeManager . digest ( value ) ; if ( ! digest . equals ( password ) ) { throw Error . error ( ErrorCode . X_28000 ) ; } } 
public boolean equals ( Object obj ) { if ( obj != null && obj instanceof Constructor ) { Constructor < ? > other = ( Constructor < ? > ) obj ; if ( getDeclaringClass ( ) == other . getDeclaringClass ( ) ) { return equalParamTypes ( parameterTypes , other . parameterTypes ) ; } } return false ; } 
public int getDataElement ( float [ ] normComponents , int normOffset ) { int components [ ] = getUnnormalizedComponents ( normComponents , normOffset , null , 0 ) ; return getDataElement ( components , 0 ) ; } 
private boolean isDouble ( String value ) { try { Double . parseDouble ( value ) ; return true ; } catch ( NumberFormatException e ) { return false ; } } 
public List < EnclosingClosure > getEnclosingClosureStack ( ) { return Collections . unmodifiableList ( enclosingClosures ) ; } 
private Object doExchange ( Object item , boolean timed , long nanos ) { Node me = new Node ( item ) ; int index = hashIndex ( ) ; int fails = 0 ; for ( ; ; ) { Object y ; Slot slot = arena [ index ] ; if ( slot == null ) createSlot ( index ) ; else if ( ( y = slot . get ( ) ) != null && slot . compareAndSet ( y , null ) ) { Node you = ( Node ) y ; if ( you . compareAndSet ( null , item ) ) { LockSupport . unpark ( you . waiter ) ; return you . item ; } } else if ( y == null && slot . compareAndSet ( null , me ) ) { if ( index == 0 ) return timed ? awaitNanos ( me , slot , nanos ) : await ( me , slot ) ; Object v = spinWait ( me , slot ) ; if ( v != CANCEL ) return v ; me = new Node ( item ) ; int m = max . get ( ) ; if ( m > ( index >>>= 1 ) ) max . compareAndSet ( m , m - 1 ) ; } else if ( ++ fails > 1 ) { int m = max . get ( ) ; if ( fails > 3 && m < FULL && max . compareAndSet ( m , m + 1 ) ) index = m + 1 ; else if ( -- index < 0 ) index = m ; } } } 
public void addPackedSeg_idsSequence ( gov . nih . nlm . ncbi . www . soap . eutils . efetch_gene . PackedSeg_idsSequence param ) { if ( localPackedSeg_idsSequence == null ) { localPackedSeg_idsSequence = new gov . nih . nlm . ncbi . www . soap . eutils . efetch_gene . PackedSeg_idsSequence [ ] { } ; } localPackedSeg_idsSequenceTracker = true ; java . util . List list = org . apache . axis2 . databinding . utils . ConverterUtil . toList ( localPackedSeg_idsSequence ) ; list . add ( param ) ; this . localPackedSeg_idsSequence = ( gov . nih . nlm . ncbi . www . soap . eutils . efetch_gene . PackedSeg_idsSequence [ ] ) list . toArray ( new gov . nih . nlm . ncbi . www . soap . eutils . efetch_gene . PackedSeg_idsSequence [ list . size ( ) ] ) ; } 
public static int getMajorVersion ( ) { loadProperties ( ) ; try { return Integer . parseInt ( ourProperties . getProperty ( VERSION_MAJOR_PROPERTY , VERSION_MAJOR_DEFAULT ) ) ; } catch ( NumberFormatException nfe ) { } return Integer . parseInt ( VERSION_MAJOR_DEFAULT ) ; } 
public boolean permanent ( Neuron n , Hashtable < Neuron , Boolean > slice ) { assert slice . containsKey ( n ) ; return slice . get ( n ) ; } 
public Builder addSubActionView ( int resId , Context context ) { LayoutInflater inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; View view = inflater . inflate ( resId , null , false ) ; view . measure ( View . MeasureSpec . UNSPECIFIED , View . MeasureSpec . UNSPECIFIED ) ; return this . addSubActionView ( view , view . getMeasuredWidth ( ) , view . getMeasuredHeight ( ) ) ; } 
public List < OptionItem > getOptionItems ( ) { if ( optionItems == null ) { optionItems = new ArrayList < OptionItem > ( ) ; } return this . optionItems ; } 
public String getCurrentTemplateName ( ) { if ( templateNameStack . empty ( ) ) return "<undef>" ; else return ( String ) templateNameStack . peek ( ) ; } 
public static TitledBorder createTitledBorder ( Border border , String title , int titleJustification , int titlePosition ) { return new TitledBorder ( border , title , titleJustification , titlePosition ) ; } 
protected void writeTrailer ( ) { out . println ( "}" ) ; } 
public void putTable ( HTableInterface table ) { LinkedList < HTableInterface > queue = tables . get ( Bytes . toString ( table . getTableName ( ) ) ) ; synchronized ( queue ) { if ( queue . size ( ) >= maxSize ) return ; queue . add ( table ) ; } } 
public void declareUser ( String userName , String groupsList ) throws Exception { try { if ( userName == null ) userName = "" ; if ( userName . length ( ) == 0 ) throw new Exception ( "'userName'-parameter-cannot-be-null-or-empty." ) ; if ( _users . containsKey ( userName ) ) throw new Exception ( "User-'" + userName + "'-is-already-declared." ) ; _users . put ( userName , new ArrayList < String > ( ) ) ; includeUserInGroups ( userName , groupsList ) ; } catch ( Exception e ) { throw new Exception ( ParseError . parseError ( "AccessChecker.declareUser('" + userName + "','" + groupsList + "')" , e ) ) ; } } 
@ Override public void close ( ) throws IOException { synchronized ( lock ) { if ( decoder != null ) { decoder . reset ( ) ; } decoder = null ; if ( in != null ) { in . close ( ) ; in = null ; } } } 
public static < T > Iterable < T > chain ( final T [ ] ... arrays ) { LinkedList < Iterable < T >> iterables = new LinkedList < Iterable < T >> ( ) ; for ( T [ ] array : arrays ) { iterables . add ( Arrays . asList ( array ) ) ; } return chain ( iterables ) ; } 
public void useSkin ( int frame ) { skin . setFrame ( frame ) ; currentView = iv . getViewport ( ) ; } 
public boolean isMimeTypeEqual ( String mimeType ) { if ( mimeType == null ) { throw new NullPointerException ( "mimeType" ) ; } if ( this . mimeType == null ) { return false ; } try { return this . mimeType . match ( new MimeType ( mimeType ) ) ; } catch ( MimeTypeParseException mtpe ) { return false ; } } 
public void deleteChordSheet ( ChordSheet chordSheet ) { if ( chordSheets . contains ( chordSheet ) ) { chordSheets . remove ( chordSheet ) ; } } 
public static ObjectName getInstance ( String domain , String key , String value ) throws MalformedObjectNameException { return new ObjectName ( domain , key , value ) ; } 
static SNode snode ( SNode s , Object e , SNode next , int mode ) { if ( s == null ) s = new SNode ( e ) ; s . mode = mode ; s . next = next ; return s ; } 
public Element getElementById ( String elementId ) { return getIdentifier ( elementId ) ; } 
public synchronized int getSoTimeout ( ) throws SocketException { checkOpen ( ) ; return ( ( Integer ) impl . getOption ( SocketOptions . SO_TIMEOUT ) ) . intValue ( ) ; } 
public void yypushback ( int number ) { if ( number > yylength ( ) ) zzScanError ( ZZ_PUSHBACK_2BIG ) ; zzMarkedPos -= number ; } 
public static Image createDisabledImage ( Image i ) { GrayFilter filter = new GrayFilter ( true , 50 ) ; ImageProducer prod = new FilteredImageSource ( i . getSource ( ) , filter ) ; Image grayImage = Toolkit . getDefaultToolkit ( ) . createImage ( prod ) ; return grayImage ; } 
public static < E > SynchronousQueue < E > newSynchronousQueue ( ) { return new SynchronousQueue < E > ( ) ; } 
public BufferedImage grabImage ( int row , int column , int width , int height ) { return image . getSubimage ( column * colWidth , row * rowHeight , width , height ) ; } 
public static void setDependencyRelation ( Annotation annot , String relation ) { annot . set ( CoNLLDepTypeAnnotation . class , relation ) ; } 
public void addOrder ( Order order ) { orders . add ( order ) ; } 
public void installUI ( JComponent a ) { for ( int i = 0 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . installUI ( a ) ; } } 
public Map listSets ( String resumptionToken ) throws BadResumptionTokenException { Map listSetsMap = new HashMap ( ) ; ArrayList sets = new ArrayList ( ) ; purge ( ) ; StringTokenizer tokenizer = new StringTokenizer ( resumptionToken , ":" ) ; String resumptionId ; int oldCount ; try { resumptionId = tokenizer . nextToken ( ) ; oldCount = Integer . parseInt ( tokenizer . nextToken ( ) ) ; } catch ( NoSuchElementException e ) { throw new BadResumptionTokenException ( ) ; } String [ ] dbSets = ( String [ ] ) resumptionResults . remove ( resumptionId ) ; if ( dbSets == null ) { throw new BadResumptionTokenException ( ) ; } int count ; for ( count = 0 ; count < maxListSize && count + oldCount < dbSets . length ; ++ count ) { sets . add ( dbSets [ count + oldCount ] ) ; } if ( count + oldCount < dbSets . length ) { resumptionId = getResumptionId ( ) ; resumptionResults . put ( resumptionId , dbSets ) ; StringBuffer resumptionTokenSb = new StringBuffer ( ) ; resumptionTokenSb . append ( resumptionId ) ; resumptionTokenSb . append ( ":" ) ; resumptionTokenSb . append ( Integer . toString ( oldCount + count ) ) ; listSetsMap . put ( "resumptionMap" , getResumptionMap ( resumptionTokenSb . toString ( ) , dbSets . length , oldCount ) ) ; } listSetsMap . put ( "sets" , sets . iterator ( ) ) ; return listSetsMap ; } 
public void iterateDeclaredPrefixes ( PrefixCallback callback ) throws SAXException { for ( Enumeration e = nss . getDeclaredPrefixes ( ) ; e . hasMoreElements ( ) ; ) { String p = ( String ) e . nextElement ( ) ; String uri = nss . getURI ( p ) ; callback . onPrefixMapping ( p , uri ) ; } } 
public int read ( ) throws IOException { return ( read ( scratch , 0 , 1 ) != - 1 ) ? scratch [ 0 ] & 0xff : - 1 ; } 
public ExtDescriptor [ ] getExtDataRecs ( ) { return Util . arrayCopy ( extDataRecs , new ExtDescriptor [ extDataRecs . length ] ) ; } 
public List < PayloadType > getPayloads ( ) { List < PayloadType > list = new ArrayList < PayloadType > ( ) ; if ( preferredPayloadType != null ) list . add ( preferredPayloadType ) ; for ( JingleMediaManager manager : managers ) { for ( PayloadType payloadType : manager . getPayloads ( ) ) { if ( ! list . contains ( payloadType ) && ! payloadType . equals ( preferredPayloadType ) ) list . add ( payloadType ) ; } } return list ; } 
public String toString ( ) { StringBuffer str = new StringBuffer ( "Type:-" + addrType + "-" ) ; str . append ( "Content:-" + getContent ( ) + "-" ) ; return ( str . toString ( ) ) ; } 
private boolean isWellFormed ( String subpath ) { int brace = 0 , index = 0 ; while ( index < subpath . length ( ) ) { if ( brace < 0 ) return false ; if ( subpath . charAt ( index ) == '[' ) brace ++ ; if ( subpath . charAt ( index ) == ']' ) brace -- ; index ++ ; } if ( brace == 0 ) return true ; return false ; } 
@ Override public void setInterpolator ( Interpolator interpolator ) { for ( Node node : mNodes ) { node . animation . setInterpolator ( interpolator ) ; } } 
protected Map createMenuEffectiveLastIndexMap ( ) { return new HashMap ( ) ; } 
public static double scaleAccelerometer ( final int port , final int raw ) { final double result = scaleAccelerometerWithPrecision ( port , raw , ACC_MIN , ACC_MAX ) ; return new BigDecimal ( result ) . setScale ( 2 , RoundingMode . HALF_UP ) . doubleValue ( ) ; } 
public static void level01 ( String pn , String riddles [ ] , String answers [ ] ) { Random randomRiddle = new Random ( ) ; int riddleNumber ; String userAnswer ; Scanner kb = new Scanner ( System . in ) ; System . out . println ( "-You-realize-the-statue-is-holding-a-key-as-it-turns-to-you.-It-begins-to-speak.-" ) ; System . out . println ( ""I-am-a-guardian-of-the-students-at-this-university,-I-am-keeping-this-key-safe-from-" + "evil-intruders."" + "-A-little-late-for-that-you-think.-It-continues,-"I-have-been-instructed-to-give-" + "this-key-to-the-chosen-one.-If-that-is-you,-you-will-be-able-to-answer-this-riddle,-if-not-you-will-turn-to-stone."" ) ; riddleNumber = randomRiddle . nextInt ( 16 ) ; System . out . println ( """ + riddles [ riddleNumber ] + """ ) ; System . out . print ( "Please-enter-your-answer:-" ) ; userAnswer = kb . nextLine ( ) ; if ( answers [ riddleNumber ] . equalsIgnoreCase ( userAnswer ) ) { System . out . println ( "-The-statue-nods,-and-hands-you-the-key.-"Good-luck-on-your-journey-chosen-one."" ) ; System . out . println ( "You-grab-the-key-and-hurry-to-the-Cathedral." ) ; level02 ( pn , riddles , answers ) ; } else { System . out . println ( "-The-statue-looks-disappointed.-You-start-to-feel-your-body-start-to-stiffen.-" + "The-right-answer-was-" + answers [ riddleNumber ] + "You-have-answered-the-riddle-wrong-and-will-be" + "-turned-into-a-statue.-GAME-OVER" ) ; } } 
public void clear ( ) { oredCriteria . clear ( ) ; orderByClause = null ; distinct = false ; } 
@ VisibleForTesting static int chooseTableSize ( int setSize ) { if ( setSize == 1 ) { return 2 ; } int tableSize = Integer . highestOneBit ( setSize - 1 ) << 1 ; while ( tableSize * DESIRED_LOAD_FACTOR < setSize ) { tableSize <<= 1 ; } return tableSize ; } 
default void copy ( final Path from , final Path to ) throws IOException , FileNotFoundException , FileAlreadyExistsException { this . copy ( from , to , false ) ; } 
public boolean removeEntity ( Entity entity ) { for ( Entity a : entities ) { if ( a . equals ( entity ) ) { entities . remove ( a ) ; return true ; } } return false ; } 
public void setStats ( int t , int i , int b ) { timet . setText ( Integer . toString ( t ) ) ; idle . setText ( Integer . toString ( i ) ) ; busy . setText ( Integer . toString ( b ) ) ; } 
public T getSingleItem ( ) { final Entry < T , Integer > singleEntry = getSingleEntry ( ) ; return ( singleEntry != null ) && ( singleEntry . getValue ( ) . intValue ( ) == 1 ) ? singleEntry . getKey ( ) : null ; } 
private static String convertToQuotedString ( final String string ) { if ( string == null ) { return null ; } if ( TextUtils . isEmpty ( string ) ) { return "" ; } int lastPos = string . length ( ) - 1 ; if ( lastPos < 0 || ( string . charAt ( 0 ) == '"' && string . charAt ( lastPos ) == '"' ) ) { return string ; } return '|"' + string + '|"' ; } 
public boolean timedPaymentExists ( String id ) { return timedpayments . containsKey ( id ) ; } 
public void add ( Person p ) { PersonView pv = new PersonView ( context , p , ( int ) ( Math . floor ( ( SpaceView . w - 55 ) * Math . random ( ) ) ) , ( int ) ( Math . floor ( SpaceView . mainScreenH * Math . random ( ) ) ) , 55 , 55 ) ; this . people . add ( pv ) ; } 
public static String findContainingJar ( Class my_class ) { ClassLoader loader = PigContext . getClassLoader ( ) ; String class_file = my_class . getName ( ) . replaceAll ( "|." , "/" ) + ".class" ; try { Enumeration < URL > itr = null ; if ( loader instanceof URLClassLoader ) { itr = ( ( URLClassLoader ) loader ) . findResources ( class_file ) ; } if ( itr == null || ! itr . hasMoreElements ( ) ) { itr = loader . getResources ( class_file ) ; } for ( ; itr . hasMoreElements ( ) ; ) { URL url = ( URL ) itr . nextElement ( ) ; if ( "jar" . equals ( url . getProtocol ( ) ) ) { String toReturn = url . getPath ( ) ; if ( toReturn . startsWith ( "file:" ) ) { toReturn = toReturn . substring ( "file:" . length ( ) ) ; } toReturn = toReturn . replaceAll ( "|+" , "%2B" ) ; toReturn = URLDecoder . decode ( toReturn , "UTF-8" ) ; return toReturn . replaceAll ( "!.*$" , "" ) ; } } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return null ; } 
protected Command ( String name ) { args = new Vector ( ) ; args . add ( name ) ; } 
public static void removeAuthListener ( AuthListener listener ) { mAuthListeners . remove ( listener ) ; } 
protected ObjectOutputStream ( ) throws IOException , SecurityException { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPermission ( SUBCLASS_IMPLEMENTATION_PERMISSION ) ; } bout = null ; handles = null ; subs = null ; enableOverride = true ; debugInfoStack = null ; } 
private static void preMainConfig ( ) { Thread . currentThread ( ) . setName ( Executor . THREAD_PREFIX + Executor . MAIN_THREAD ) ; } 
public String toStringImpl ( ) { return new StringBuilder ( ) . append ( port ) . toString ( ) ; } 
public void unregisterOnLowMemoryListener ( OnLowMemoryListener listener ) { if ( listener != null ) { int i = 0 ; while ( i < mLowMemoryListeners . size ( ) ) { final OnLowMemoryListener l = mLowMemoryListeners . get ( i ) . get ( ) ; if ( l == null || l == listener ) { mLowMemoryListeners . remove ( i ) ; } else { i ++ ; } } } } 
public boolean intersects ( Entity target ) { return Util . inBounds ( ( int ) getLocation ( ) . getX ( ) , ( int ) getLocation ( ) . getY ( ) , getWidth ( ) , getHeight ( ) , 0 , 0 , ( int ) target . getLocation ( ) . getX ( ) , ( int ) target . getLocation ( ) . getY ( ) , target . getWidth ( ) , target . getHeight ( ) , 0 , 0 ) ; } 
public static String encodeString ( String str ) { return Base64 . encodeBytes ( ( str . getBytes ( ) ) ) . trim ( ) ; } 
public static String packCipherSuites ( String [ ] ciphers ) { String cipherSet = null ; if ( ciphers != null ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < ciphers . length ; i ++ ) { buf . append ( ciphers [ i ] ) ; if ( i < ciphers . length - 1 ) { buf . append ( ',' ) ; } } cipherSet = buf . toString ( ) ; } return cipherSet ; } 
public String getHexaAlpha ( ) { hexa = Integer . toString ( sldAlpha . getValue ( ) , 16 ) ; if ( hexa . length ( ) == 1 ) { hexa = "0" + hexa ; } return hexa . toUpperCase ( ) ; } 
public RRset [ ] findRecords ( Name name , int type ) { return findRecords ( name , type , Credibility . NORMAL ) ; } 
public static long skipByReading ( InputStream in , long byteCount ) throws IOException { if ( byteCount == 0 ) return 0L ; byte [ ] buffer = skipBuffer . getAndSet ( null ) ; if ( buffer == null ) { buffer = new byte [ 4096 ] ; } long skipped = 0 ; while ( skipped < byteCount ) { int toRead = ( int ) Math . min ( byteCount - skipped , buffer . length ) ; int read = in . read ( buffer , 0 , toRead ) ; if ( read == - 1 ) { break ; } skipped += read ; if ( read < toRead ) { break ; } } skipBuffer . set ( buffer ) ; return skipped ; } 
public synchronized Connection get ( Address address ) { Connection foundConnection = null ; for ( ListIterator < Connection > i = connections . listIterator ( connections . size ( ) ) ; i . hasPrevious ( ) ; ) { Connection connection = i . previous ( ) ; if ( ! connection . getRoute ( ) . getAddress ( ) . equals ( address ) || ! connection . isAlive ( ) || System . nanoTime ( ) - connection . getIdleStartTimeNs ( ) >= keepAliveDurationNs ) { continue ; } i . remove ( ) ; if ( ! connection . isSpdy ( ) ) { try { Platform . get ( ) . tagSocket ( connection . getSocket ( ) ) ; } catch ( SocketException e ) { Util . closeQuietly ( connection ) ; Platform . get ( ) . logW ( "Unable-to-tagSocket():-" + e ) ; continue ; } } foundConnection = connection ; break ; } if ( foundConnection != null && foundConnection . isSpdy ( ) ) { connections . addFirst ( foundConnection ) ; } executorService . submit ( connectionsCleanupCallable ) ; return foundConnection ; } 
public final void iduplicate ( Component that_ ) { Hashtable childmap_ = new Hashtable ( ) ; Hashtable portmap_ = new Hashtable ( ) ; Hashtable wiremap_ = new Hashtable ( ) ; _duplicate ( that_ , childmap_ , portmap_ , wiremap_ , false ) ; for ( Enumeration e_ = wiremap_ . keys ( ) ; e_ . hasMoreElements ( ) ; ) { Wire w_ = ( Wire ) e_ . nextElement ( ) ; Wire wclone_ = new Wire ( ) ; if ( w_ . inports != null ) wclone_ . inports = _duplicateIn ( w_ . inports , portmap_ , w_ , wclone_ ) ; if ( w_ . outports != null ) wclone_ . outports = _duplicateOut ( w_ . outports , portmap_ , w_ , wclone_ ) ; if ( w_ . shadowInports != null ) wclone_ . shadowInports = _duplicateIn ( w_ . shadowInports , portmap_ , w_ , wclone_ ) ; if ( w_ . shadowOutports != null ) wclone_ . shadowOutports = _duplicateOut ( w_ . shadowOutports , portmap_ , w_ , wclone_ ) ; if ( w_ . inEvtListeners != null ) wclone_ . inEvtListeners = _duplicatePP ( w_ . inEvtListeners , portmap_ ) ; if ( w_ . outEvtListeners != null ) wclone_ . outEvtListeners = _duplicatePP ( w_ . outEvtListeners , portmap_ ) ; } } 
void reExecutePeriodic ( RunnableScheduledFuture < ? > task ) { if ( canRunInCurrentRunState ( true ) ) { super . getQueue ( ) . add ( task ) ; if ( ! canRunInCurrentRunState ( true ) && remove ( task ) ) task . cancel ( false ) ; else prestartCoreThread ( ) ; } } 
public void setLastPoint ( float dx , float dy ) { isSimplePath = false ; native_setLastPoint ( mNativePath , dx , dy ) ; } 
public boolean needsFlush ( ) { return outBuf . position ( ) > 0 ; } 
private void writeAttribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String attName , java . lang . String attValue , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { if ( xmlWriter . getPrefix ( namespace ) == null ) { xmlWriter . writeNamespace ( prefix , namespace ) ; xmlWriter . setPrefix ( prefix , namespace ) ; } xmlWriter . writeAttribute ( namespace , attName , attValue ) ; } 
public void mapDatasetToDomainAxis ( int index , int axisIndex ) { List axisIndices = new java . util . ArrayList ( 1 ) ; axisIndices . add ( new Integer ( axisIndex ) ) ; mapDatasetToDomainAxes ( index , axisIndices ) ; } 
@ Override public synchronized void put ( String key , Entry entry ) { pruneIfNeeded ( entry . data . length ) ; File file = getFileForKey ( key ) ; try { BufferedOutputStream fos = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; CacheHeader e = new CacheHeader ( key , entry ) ; boolean success = e . writeHeader ( fos ) ; if ( ! success ) { fos . close ( ) ; VolleyLog . d ( "Failed-to-write-header-for-%s" , file . getAbsolutePath ( ) ) ; throw new IOException ( ) ; } fos . write ( entry . data ) ; fos . close ( ) ; putEntry ( key , e ) ; return ; } catch ( IOException e ) { } boolean deleted = file . delete ( ) ; if ( ! deleted ) { VolleyLog . d ( "Could-not-clean-up-file-%s" , file . getAbsolutePath ( ) ) ; } } 
public Node adoptNode ( Node node ) { if ( ! ( node instanceof NodeImpl ) ) { return null ; } NodeImpl nodeImpl = ( NodeImpl ) node ; switch ( nodeImpl . getNodeType ( ) ) { case Node . ATTRIBUTE_NODE : AttrImpl attr = ( AttrImpl ) node ; if ( attr . ownerElement != null ) { attr . ownerElement . removeAttributeNode ( attr ) ; } break ; case Node . DOCUMENT_FRAGMENT_NODE : case Node . ENTITY_REFERENCE_NODE : case Node . PROCESSING_INSTRUCTION_NODE : case Node . TEXT_NODE : case Node . CDATA_SECTION_NODE : case Node . COMMENT_NODE : case Node . ELEMENT_NODE : break ; case Node . DOCUMENT_NODE : case Node . DOCUMENT_TYPE_NODE : case Node . ENTITY_NODE : case Node . NOTATION_NODE : throw new DOMException ( DOMException . NOT_SUPPORTED_ERR , "Cannot-adopt-nodes-of-type-" + nodeImpl . getNodeType ( ) ) ; default : throw new DOMException ( DOMException . NOT_SUPPORTED_ERR , "Unsupported-node-type-" + node . getNodeType ( ) ) ; } Node parent = nodeImpl . getParentNode ( ) ; if ( parent != null ) { parent . removeChild ( nodeImpl ) ; } changeDocumentToThis ( nodeImpl ) ; notifyUserDataHandlers ( UserDataHandler . NODE_ADOPTED , node , null ) ; return nodeImpl ; } 
public void setInstancesFromFileQ ( ) { int returnVal = m_FileChooser . showOpenDialog ( this ) ; if ( returnVal == JFileChooser . APPROVE_OPTION ) { File selected = m_FileChooser . getSelectedFile ( ) ; try { java . io . Reader r = new java . io . BufferedReader ( new java . io . FileReader ( selected ) ) ; Instances i = new Instances ( r ) ; setInstances ( i ) ; String relationName = i . relationName ( ) ; String truncatedN = relationName ; if ( relationName . length ( ) > 25 ) { truncatedN = relationName . substring ( 0 , 25 ) + "..." ; } dataFileLabel . setText ( truncatedN ) ; dataFileLabel . setToolTipText ( relationName ) ; } catch ( Exception e ) { JOptionPane . showMessageDialog ( this , "Can't-load-at-this-time,-" + "currently-busy-with-other-IO" , "Load-Instances" , JOptionPane . WARNING_MESSAGE ) ; e . printStackTrace ( ) ; } } } 
private static boolean copyToFile ( InputStream inputStream , File destFile ) { try { OutputStream out = new FileOutputStream ( destFile ) ; try { byte [ ] buffer = new byte [ 4096 ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( buffer ) ) >= 0 ) { out . write ( buffer , 0 , bytesRead ) ; } } finally { out . close ( ) ; } return true ; } catch ( IOException e ) { return false ; } } 
public void setScrollOffset ( int scrollOffset ) { visibility . setValue ( scrollOffset ) ; } 
public void addFilter ( PacketFilter filter ) { if ( filter == null ) { throw new IllegalArgumentException ( "Parameter-cannot-be-null." ) ; } filters . add ( filter ) ; } 
protected List < String > parseRobotsTxt ( InputStream is ) throws IOException { List < String > disallows = new ArrayList < String > ( ) ; BufferedReader r = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; String l ; while ( ( l = r . readLine ( ) ) != null ) { String [ ] arr = l . split ( "#" ) ; if ( arr . length == 0 ) continue ; l = arr [ 0 ] . trim ( ) ; if ( l . startsWith ( DISALLOW ) ) { l = l . substring ( DISALLOW . length ( ) ) . trim ( ) ; if ( l . length ( ) == 0 ) continue ; disallows . add ( l ) ; } } is . close ( ) ; return disallows ; } 
public synchronized boolean removeMacro ( int macroPosition ) { String m = macrosses . remove ( macroPosition ) ; if ( m == null ) { logger . warn ( "Trying-to-remove-non-existing-macro." ) ; return false ; } return true ; } 
void fullyUnlock ( ) { takeLock . unlock ( ) ; putLock . unlock ( ) ; } 
public Builder addAttribute ( final String type , final String name , final String value , final Restriction restrictions ) { this . members . put ( name , new AttributeContainer . Attribute ( type , name , value , restrictions ) ) ; return this ; } 
Token parseTerm ( ) throws ParseException { int ch = this . read ( ) ; if ( ch == T_OR || ch == T_RPAREN || ch == T_EOF ) { return Token . createEmpty ( ) ; } else { Token tok = this . parseFactor ( ) ; Token concat = null ; while ( ( ch = this . read ( ) ) != T_OR && ch != T_RPAREN && ch != T_EOF ) { if ( concat == null ) { concat = Token . createConcat ( ) ; concat . addChild ( tok ) ; tok = concat ; } concat . addChild ( this . parseFactor ( ) ) ; } return tok ; } } 
static boolean isTokenExpired ( Token < BlockTokenIdentifier > token ) throws IOException { ByteArrayInputStream buf = new ByteArrayInputStream ( token . getIdentifier ( ) ) ; DataInputStream in = new DataInputStream ( buf ) ; long expiryDate = WritableUtils . readVLong ( in ) ; return isExpired ( expiryDate ) ; } 
public Panel findPanel ( PanelHolder pHolder ) { Component [ ] comps = pane_ . getComponents ( ) ; for ( int i = 0 ; i < comps . length ; i ++ ) { if ( comps [ i ] instanceof Panel ) { if ( ( ( Panel ) comps [ i ] ) . getName ( ) . equals ( pHolder . getId ( ) ) ) return ( Panel ) comps [ i ] ; } } return null ; } 
public Set < String > getComponentNames ( ) { return rawPropertyMap . keySet ( ) ; } 
public static synchronized Roster getInstanceFor ( XMPPConnection connection ) { Roster roster = INSTANCES . get ( connection ) ; if ( roster == null ) { roster = new Roster ( connection ) ; INSTANCES . put ( connection , roster ) ; } return roster ; } 
static int getIdCategoria ( BaseDatos accesoBD , String categoria ) throws SQLException { String query = "SELECT-idCategoria-FROM-Categoria-WHERE-" + "tipo='" + categoria + "'" ; ResultSet res = accesoBD . ejecutaConsulta ( query ) ; int idCat = 0 ; if ( res . next ( ) ) idCat = res . getInt ( 1 ) ; return idCat ; } 
public synchronized void setSize ( int newSize ) { modCount ++ ; ensureCapacity ( newSize ) ; if ( newSize < elementCount ) Arrays . fill ( elementData , newSize , elementCount , null ) ; elementCount = newSize ; } 
private boolean isAttributeWelcome ( String name ) { return welcomeAttributes . contains ( name ) ; } 
public void write ( int b ) throws IOException { checkThreshold ( 1 ) ; getStream ( ) . write ( b ) ; written ++ ; } 
public com . google . protobuf . ByteString getMaxValueBytes ( ) { java . lang . Object ref = maxValue_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; maxValue_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public String getToken ( int position ) { String token ; if ( tokens == null || tokens . length <= position ) { token = null ; } else { token = tokens [ position ] ; } if ( token != null ) { token = token . trim ( ) ; if ( token . length ( ) == 0 ) { token = null ; } } return token ; } 
String getParent ( String path ) { return path . substring ( 0 , path . lastIndexOf ( Path . SEPARATOR ) ) ; } 
public static String renameForFileName ( String fileString , int chars ) { fileString = removeWhiteSpace ( fileString ) ; if ( fileString != null && chars > 0 ) { if ( fileString . length ( ) > chars ) { fileString = fileString . substring ( 0 , chars ) ; } } return fileString ; } 
public void setRoleName ( JAXBElement < String > value ) { this . roleName = ( ( JAXBElement < String > ) value ) ; } 
public boolean getBroadcast ( ) throws SocketException { checkOpen ( ) ; return ( ( Boolean ) impl . getOption ( SocketOptions . SO_BROADCAST ) ) . booleanValue ( ) ; } 
public void addAlbum ( Album album ) { albums . add ( album ) ; } 
public String findLibrary ( String libraryName ) { String fileName = System . mapLibraryName ( libraryName ) ; for ( File directory : nativeLibraryDirectories ) { String path = new File ( directory , fileName ) . getPath ( ) ; if ( IoUtils . canOpenReadOnly ( path ) ) { return path ; } } return null ; } 
public void putMap ( Map < String , List < String >> m ) { for ( String key : m . keySet ( ) ) { SortedSet < String > vals = get ( key ) ; if ( vals == null ) { vals = new TreeSet < String > ( ) ; put ( key , vals ) ; } vals . addAll ( m . get ( key ) ) ; } } 
Button createDateButtonFromLongValue ( View container , Field field , long date ) { TextView fieldAlias = ( TextView ) container . findViewById ( R . id . field_alias_txt ) ; Button dateButton = ( Button ) container . findViewById ( R . id . field_date_btn ) ; fieldAlias . setText ( field . getAlias ( ) ) ; Calendar c = Calendar . getInstance ( ) ; c . setTimeInMillis ( date ) ; dateButton . setText ( formatter . format ( c . getTime ( ) ) ) ; addListenersToDatebutton ( dateButton ) ; return dateButton ; } 
public void toFront ( ) { toFront_NoClientCode ( ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public Socket ( InetAddress dstAddress , int dstPort ) throws IOException { this ( ) ; checkDestination ( dstAddress , dstPort ) ; startupSocket ( dstAddress , dstPort , null , 0 , true ) ; } 
private boolean addSaneAltitude ( double altitude ) { boolean sane = true ; double avg = 0 ; int elements = 0 ; mAltitudes . add ( altitude ) ; if ( mAltitudes . size ( ) > 3 ) { mAltitudes . poll ( ) ; } for ( Double alt : mAltitudes ) { avg += alt ; elements ++ ; } avg = avg / elements ; sane = Math . abs ( altitude - avg ) < MAX_REASONABLE_ALTITUDECHANGE ; return sane ; } 
public static String [ ] getClassMethodSignatureFromString ( String name ) { String signature = convertDotsToSlashes ( name ) ; String result [ ] = new String [ 3 ] ; int mpos = 0 , sigpos = 0 ; int i ; sigpos = signature . indexOf ( '(' ) ; if ( sigpos == - 1 ) { sigpos = 0 ; i = signature . length ( ) - 1 ; } else { i = sigpos - 1 ; } for ( ; i >= 0 ; i -- ) { if ( signature . charAt ( i ) == '/' ) { mpos = i ; break ; } } try { result [ 0 ] = signature . substring ( 0 , mpos ) ; result [ 1 ] = signature . substring ( mpos + 1 , sigpos ) ; result [ 2 ] = signature . substring ( sigpos ) ; } catch ( StringIndexOutOfBoundsException e ) { throw new IllegalArgumentException ( "malformed-method-signature-:-" + name ) ; } return result ; } 
public int getChildCount ( ) { return children == null ? 0 : children . size ( ) ; } 
public String getAuditName ( int id ) { lock . lock ( ) ; try { return idMap . get ( id ) ; } finally { lock . unlock ( ) ; } } 
public Text evaluate ( Text dateString ) { if ( dateString == null ) { return null ; } try { Date date = formatter . parse ( dateString . toString ( ) ) ; t . set ( formatter . format ( date ) ) ; return t ; } catch ( ParseException e ) { return null ; } } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
public static void setThreadCpuTimeEnabled ( boolean enable ) { threadMXBean . setThreadCpuTimeEnabled ( enable ) ; boolean checkValue = threadMXBean . isThreadCpuTimeEnabled ( ) ; if ( enable != checkValue ) { log . error ( "Could-not-set-threadCpuTimeEnabled-to-" + enable + ",-got-" + checkValue + "-instead" ) ; } } 
@ Override public void connect ( ) throws IOException { File f = new File ( fileName ) ; if ( f . isDirectory ( ) ) { isDir = true ; is = getDirectoryListing ( f ) ; } else { is = new BufferedInputStream ( new FileInputStream ( f ) , 8192 ) ; length = is . available ( ) ; } connected = true ; } 
public String encryptImage ( ImageReader imageReader ) { StringBuffer out = new StringBuffer ( ) ; for ( RGB color : imageReader ) if ( huffmanCode . containsKey ( color ) ) out . append ( huffmanCode . get ( color ) ) ; return out . toString ( ) ; } 
public static Object decodeToObject ( String encodedObject , int options , final ClassLoader loader ) throws java . io . IOException , java . lang . ClassNotFoundException { byte [ ] objBytes = decode ( encodedObject , options ) ; java . io . ByteArrayInputStream bais = null ; java . io . ObjectInputStream ois = null ; Object obj = null ; try { bais = new java . io . ByteArrayInputStream ( objBytes ) ; if ( loader == null ) { ois = new java . io . ObjectInputStream ( bais ) ; } else { ois = new java . io . ObjectInputStream ( bais ) { @ Override public Class < ? > resolveClass ( java . io . ObjectStreamClass streamClass ) throws java . io . IOException , ClassNotFoundException { @ SuppressWarnings ( "rawtypes" ) Class c = Class . forName ( streamClass . getName ( ) , false , loader ) ; if ( c == null ) { return super . resolveClass ( streamClass ) ; } else { return c ; } } } ; } obj = ois . readObject ( ) ; } catch ( java . io . IOException e ) { throw e ; } catch ( java . lang . ClassNotFoundException e ) { throw e ; } finally { try { bais . close ( ) ; } catch ( Exception e ) { } try { ois . close ( ) ; } catch ( Exception e ) { } } return obj ; } 
public Container getTopLevelAncestor ( ) { for ( Container p = this ; p != null ; p = p . getParent ( ) ) { if ( p instanceof Window || p instanceof Applet ) { return p ; } } return null ; } 
public boolean open ( XFile xf , boolean serial , boolean readOnly ) { if ( ! serial ) return false ; this . xf = xf ; try { url = new URL ( xf . toString ( ) ) ; urlConn = url . openConnection ( ) ; urlConn . setDoInput ( readOnly ) ; urlConn . setDoOutput ( ! readOnly ) ; urlConn . connect ( ) ; return true ; } catch ( IOException e ) { return false ; } } 
public void discardCard ( E card ) { discardPile . add ( card ) ; } 
public void updateItemName ( String par1Str ) { this . repairedItemName = par1Str ; if ( this . getSlot ( 2 ) . getHasStack ( ) ) { this . getSlot ( 2 ) . getStack ( ) . setItemName ( this . repairedItemName ) ; } this . updateRepairOutput ( ) ; } 
public String getIp ( ) { if ( ip == null || ip . length ( ) == 0 ) { return NULL_IP ; } else { return this . ip ; } } 
DeferredCDATASectionImpl ( DeferredDocumentImpl ownerDocument , int nodeIndex ) { super ( ownerDocument , null ) ; fNodeIndex = nodeIndex ; needsSyncData ( true ) ; } 
public synchronized void addExtension ( PacketExtension extension ) { if ( applicationExtensions == null ) { applicationExtensions = new ArrayList < PacketExtension > ( ) ; } applicationExtensions . add ( extension ) ; } 
void recordRead ( ReferenceEntry < K , V > entry , long now ) { if ( map . recordsAccess ( ) ) { entry . setAccessTime ( now ) ; } recencyQueue . add ( entry ) ; } 
public static boolean checkTkInter ( ) { if ( getPythonPath ( ) == null ) { return false ; } ProcessBuilder pb = new ProcessBuilder ( getPythonPath ( ) , "-c" , "import-Tkinter" ) ; try { Process p = pb . start ( ) ; int returnCode = p . waitFor ( ) ; if ( returnCode != 0 ) { return false ; } } catch ( Exception e ) { Base . logger . log ( Level . SEVERE , "Error-attempting-to-detect-TkInter" , e ) ; } return true ; } 
public String getModifiedString ( ) { String tmp = "" ; try { return DateFormat . getDateTimeInstance ( DateFormat . SHORT , DateFormat . LONG ) . format ( modified ) ; } catch ( NullPointerException e ) { } return tmp ; } 
public Label getLabel ( Class type ) throws Exception { return label . getLabel ( type ) ; } 
public void addErrorMessage ( ConsoleMessage consoleMessage ) { if ( mSetupComplete ) { mErrorList . addErrorMessage ( consoleMessage ) ; } else { if ( mErrorMessageCache == null ) { mErrorMessageCache = new Vector < ConsoleMessage > ( ) ; } mErrorMessageCache . add ( consoleMessage ) ; } } 
public Dimension getMinimumSize ( JComponent a ) { Dimension returnValue = ( ( ComponentUI ) ( uis . elementAt ( 0 ) ) ) . getMinimumSize ( a ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . getMinimumSize ( a ) ; } return returnValue ; } 
protected String createUnorderedList ( List < ? > list ) { StringBuilder sb = new StringBuilder ( ) ; if ( list != null ) { for ( Object o : list ) { sb . append ( "*-" ) ; sb . append ( o . toString ( ) ) ; sb . append ( Constants . LINE_SEPARATOR ) ; } } return sb . toString ( ) ; } 
public void setPayinCbsActtype ( String payinCbsActtype ) { this . payinCbsActtype = payinCbsActtype == null ? null : payinCbsActtype . trim ( ) ; } 
public ObjectInstance createMBean ( String className , ObjectName name , ObjectName loaderName ) throws ReflectionException , InstanceAlreadyExistsException , MBeanRegistrationException , MBeanException , NotCompliantMBeanException , InstanceNotFoundException , RemoteException { return server . createMBean ( className , name , loaderName ) ; } 
public static long renewDelegationToken ( String tokenStrForm ) throws IOException { return saslServer . renewDelegationToken ( tokenStrForm ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
@ Deprecated public int getMinutes ( ) { return new GregorianCalendar ( milliseconds ) . get ( Calendar . MINUTE ) ; } 
private void readLength ( ) throws IOException { remain = Utils . readVInt ( in ) ; if ( remain >= 0 ) { lastChunk = true ; } else { remain = - remain ; } } 
public static void sort ( Object [ ] array ) { if ( array . length > 1 ) { Arrays . sort ( array , INSTANCE ) ; } } 
public static String cut ( String s , String seperator , double size , FontMetrics fontMetrics , String startString , boolean addSeperatorFirst ) { String origin = s ; if ( s == null ) return s ; if ( s . equals ( "" ) ) return s ; if ( addSeperatorFirst ) size = size - fontMetrics . stringWidth ( seperator ) ; while ( fontMetrics . stringWidth ( s + startString ) > size && s . contains ( seperator ) ) { s = s . substring ( s . indexOf ( seperator ) + 1 , s . length ( ) ) ; } if ( s . equals ( origin ) ) return s ; if ( addSeperatorFirst ) s = seperator + s ; s = startString + s ; return s ; } 
public boolean doesMessageIdAlreadyExist ( String msgId ) { Cursor cursor = null ; try { cursor = cr . query ( databaseUri , new String [ ] { RichMessagingData . KEY_MESSAGE_ID } , "(" + RichMessagingData . KEY_MESSAGE_ID + "-=-"" + msgId + "")" , null , null ) ; int messagesNumber = cursor . getCount ( ) ; return messagesNumber != 0 ; } catch ( Exception e ) { return false ; } finally { if ( cursor != null ) cursor . close ( ) ; } } 
public String getAttributeValue ( final String namespaceURI , final String localName ) { if ( hasName ( ) ) { final SOAPElement currentElement = ( SOAPElement ) currentNode ; final int numAttrs = ( attributeNames == null ? 0 : attributeNames . length ) ; for ( int count = 0 ; count < numAttrs ; count ++ ) { final Name name = attributeNames [ count ] ; if ( testEquals ( namespaceURI , name . getURI ( ) ) && testEquals ( localName , name . getLocalName ( ) ) ) { return ( ( SOAPElement ) currentElement ) . getAttributeValue ( name ) ; } } } return null ; } 
private void initMenu ( int numberOfBookmarks ) { JPanel contentPanel = new JPanel ( ) ; setTitle ( "Bookmarks" ) ; setBounds ( 100 , 100 , WINDOW_INIT_WIDTH , WINDOW_INIT_HEIGHT ) ; setMinimumSize ( new Dimension ( WINDOW_INIT_WIDTH , WINDOW_INIT_HEIGHT ) ) ; getContentPane ( ) . setLayout ( new BorderLayout ( ) ) ; contentPanel . setBorder ( new EmptyBorder ( 5 , 5 , 0 , 5 ) ) ; getContentPane ( ) . add ( contentPanel , BorderLayout . CENTER ) ; contentPanel . setLayout ( new BorderLayout ( 0 , 0 ) ) ; int scrollWidth = WINDOW_INIT_WIDTH - SCROLL_CONTENT_WIDTH_DIFF ; int scrollHeight = numberOfBookmarks * ( 5 + BookmarkItemPanel . BOOKMARK_ITEM_HEIGHT ) ; Dimension scrollDi = new Dimension ( scrollWidth , scrollHeight ) ; scrollContentPanel . setPreferredSize ( scrollDi ) ; scrollContentPanel . setMaximumSize ( scrollDi ) ; JPanel titlePanel = new JPanel ( ) ; contentPanel . add ( titlePanel , BorderLayout . NORTH ) ; JLabel lblSelectABookmark = new JLabel ( "Select-a-bookmark-by-clicking-on-its-name-below:" ) ; titlePanel . add ( lblSelectABookmark ) ; scrollPane = new JScrollPane ( scrollContentPanel ) ; scrollPane . setHorizontalScrollBarPolicy ( ScrollPaneConstants . HORIZONTAL_SCROLLBAR_NEVER ) ; scrollPane . setVerticalScrollBarPolicy ( ScrollPaneConstants . VERTICAL_SCROLLBAR_ALWAYS ) ; contentPanel . add ( scrollPane ) ; addComponentListener ( new ResizeListener ( ) ) ; } 
public boolean get ( String name , boolean defvalue ) throws IOException , IllegalArgumentException { if ( defaulted ( name ) ) return defvalue ; else return ( ( Boolean ) fields . get ( name ) ) . booleanValue ( ) ; } 
public static long lap ( ) { return lap ( DEFAULT ) ; } 
public static Card [ ] dealNewArray ( SecureRandom random , int numCardsToDeal ) { Card [ ] deck = getAllCards ( ) ; for ( int i = 0 ; i < numCardsToDeal ; i ++ ) { int toSwap = random . nextInt ( DECKSIZE - i ) + i ; Card temp = deck [ i ] ; deck [ i ] = deck [ toSwap ] ; deck [ toSwap ] = temp ; } Card [ ] result = new Card [ numCardsToDeal ] ; for ( int i = 0 ; i < numCardsToDeal ; i ++ ) { result [ i ] = deck [ i ] ; } return result ; } 
public void removeClass ( JavaClass clazz ) { loadedClasses . remove ( clazz . getClassName ( ) ) ; } 
private JComboBox setUpResolutionChooser ( ) { JComboBox resolutionBox = new JComboBox ( ) ; resolutionBox . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { updateDisplayChoices ( ) ; } } ) ; return resolutionBox ; } 
public Builder getRequestBuilder ( ) { return new Builder ( ) ; } 
public void addCluster ( int dgId , int numShapedUsed , boolean sort ) { List < FileIdCluster > clusters = new ArrayList < FileIdCluster > ( Arrays . asList ( field_5_fileIdClusters ) ) ; clusters . add ( new FileIdCluster ( dgId , numShapedUsed ) ) ; if ( sort ) Collections . sort ( clusters , MY_COMP ) ; maxDgId = Math . min ( maxDgId , dgId ) ; field_5_fileIdClusters = clusters . toArray ( new FileIdCluster [ clusters . size ( ) ] ) ; } 
public Row subRow ( String prefix ) { Map < String , Object > newValues = new HashMap < String , Object > ( ) ; CollectionUtils . subMap ( this . values , newValues , prefix ) ; return new Row ( newValues ) ; } 
public String getNotificationType ( Integer id ) { Object [ ] obj = timerTable . get ( id ) ; if ( obj != null ) { return ( ( ( TimerNotification ) obj [ TIMER_NOTIF_INDEX ] ) . getType ( ) ) ; } return null ; } 
public void setScore ( int par1 ) { this . dataWatcher . updateObject ( 18 , Integer . valueOf ( par1 ) ) ; } 
private void parseMinorVersion ( String version ) throws FSMsgException { try { minorVersion = Integer . parseInt ( version ) ; } catch ( NumberFormatException e ) { if ( FSUtils . debug . messageEnabled ( ) ) { FSUtils . debug . message ( "FSNameIdentifierMappingResponse." + "parseMinorVersion:invalid-MinorVersion:" + version , e ) ; } throw new FSMsgException ( "wrongInput" , null ) ; } if ( minorVersion > IFSConstants . FF_12_PROTOCOL_MINOR_VERSION ) { if ( FSUtils . debug . messageEnabled ( ) ) { FSUtils . debug . message ( "FSNameIdentifierMappingResponse." + "parseMinorVersion:-MinorVersion-is-too-high" ) ; } throw new FSMsgException ( "requestVersionTooHigh" , null ) ; } else if ( minorVersion < IFSConstants . FF_11_PROTOCOL_MINOR_VERSION ) { if ( FSUtils . debug . messageEnabled ( ) ) { FSUtils . debug . message ( "FSNameIdentifierMappingResponse." + "parseMinorVersion:-MinorVersion-is-too-low" ) ; } throw new FSMsgException ( "requestVersionTooLow" , null ) ; } } 
public Request put ( String name , Parcelable value ) { removeFromRequestData ( name ) ; mParamList . add ( name ) ; mTypeList . add ( TYPE_PARCELABLE ) ; mBundle . putParcelable ( name , value ) ; return this ; } 
public int getAttrSize ( ) { return Util . readIntBE ( attrSize ) ; } 
protected Vector getAllReferencesFor ( CompoundType ct ) { Hashtable refHash = new Hashtable ( ) ; Hashtable spcHash = new Hashtable ( ) ; Hashtable arrHash = new Hashtable ( ) ; int refSize ; refHash . put ( ct . getQualifiedName ( ) , ct ) ; accumulateReferences ( refHash , spcHash , arrHash ) ; do { refSize = refHash . size ( ) ; accumulateReferences ( refHash , spcHash , arrHash ) ; } while ( refSize < refHash . size ( ) ) ; Vector outVec = new Vector ( ) ; Enumeration e = refHash . elements ( ) ; while ( e . hasMoreElements ( ) ) { CompoundType t = ( CompoundType ) e . nextElement ( ) ; outVec . addElement ( t ) ; } e = spcHash . elements ( ) ; while ( e . hasMoreElements ( ) ) { CompoundType t = ( CompoundType ) e . nextElement ( ) ; outVec . addElement ( t ) ; } e = arrHash . elements ( ) ; nextSequence : while ( e . hasMoreElements ( ) ) { ArrayType at = ( ArrayType ) e . nextElement ( ) ; int dim = at . getArrayDimension ( ) ; Type et = at . getElementType ( ) ; Enumeration e2 = arrHash . elements ( ) ; while ( e2 . hasMoreElements ( ) ) { ArrayType at2 = ( ArrayType ) e2 . nextElement ( ) ; if ( et == at2 . getElementType ( ) && dim < at2 . getArrayDimension ( ) ) continue nextSequence ; } outVec . addElement ( at ) ; } return outVec ; } 
public static LocationSaveable toWriteLocation ( Location l ) { return new LocationSaveable ( l . getWorld ( ) . getName ( ) , l . getBlockX ( ) , l . getBlockY ( ) , l . getBlockZ ( ) ) ; } 
public synchronized void close ( ) throws SQLException { realClose ( true , true ) ; } 
public void setTrafficClass ( int value ) throws SocketException { checkOpenAndCreate ( true ) ; if ( value < 0 || value > 255 ) { throw new IllegalArgumentException ( "Value-doesn't-fit-in-an-unsigned-byte:-" + value ) ; } impl . setOption ( SocketOptions . IP_TOS , Integer . valueOf ( value ) ) ; } 
public String getSelectedText ( ) { AccessibleText at = getNoteLabelAccessibleText ( ) ; if ( at != null ) { return at . getSelectedText ( ) ; } return null ; } 
PropertyCacheFile ( Configuration aCurrentConfig , String aFileName ) { boolean setInActive = true ; if ( aFileName != null ) { FileInputStream inStream = null ; final String currentConfigHash = getConfigHashCode ( aCurrentConfig ) ; try { inStream = new FileInputStream ( aFileName ) ; mDetails . load ( inStream ) ; final String cachedConfigHash = mDetails . getProperty ( CONFIG_HASH_KEY ) ; setInActive = false ; if ( ( cachedConfigHash == null ) || ! cachedConfigHash . equals ( currentConfigHash ) ) { mDetails . clear ( ) ; mDetails . put ( CONFIG_HASH_KEY , currentConfigHash ) ; } } catch ( final FileNotFoundException e ) { setInActive = false ; mDetails . put ( CONFIG_HASH_KEY , currentConfigHash ) ; } catch ( final IOException e ) { Utils . getExceptionLogger ( ) . debug ( "Unable-to-open-cache-file,-ignoring." , e ) ; } finally { Utils . closeQuietly ( inStream ) ; } } mDetailsFile = ( setInActive ) ? null : aFileName ; } 
public static DescribeVolumeAttribute parse ( javax . xml . stream . XMLStreamReader reader ) throws java . lang . Exception { DescribeVolumeAttribute object = new DescribeVolumeAttribute ( ) ; int event ; java . lang . String nillableValue = null ; java . lang . String prefix = "" ; java . lang . String namespaceuri = "" ; try { while ( ! reader . isStartElement ( ) && ! reader . isEndElement ( ) ) reader . next ( ) ; java . util . Vector handledAttributes = new java . util . Vector ( ) ; while ( ! reader . isEndElement ( ) ) { if ( reader . isStartElement ( ) ) { if ( reader . isStartElement ( ) && new javax . xml . namespace . QName ( "http://ec2.amazonaws.com/doc/2012-08-15/" , "DescribeVolumeAttribute" ) . equals ( reader . getName ( ) ) ) { object . setDescribeVolumeAttribute ( DescribeVolumeAttributeType . Factory . parse ( reader ) ) ; } else { throw new org . apache . axis2 . databinding . ADBException ( "Unexpected-subelement-" + reader . getLocalName ( ) ) ; } } else { reader . next ( ) ; } } } catch ( javax . xml . stream . XMLStreamException e ) { throw new java . lang . Exception ( e ) ; } return object ; } 
public static double distanceSq ( Vector1D p1 , Vector1D p2 ) { return p1 . distanceSq ( p2 ) ; } 
public final static String getString ( byte [ ] bytarray , int pos , int maxlen ) { int maxpos = pos + maxlen ; int endpos = pos ; while ( bytarray [ endpos ] != 0x00 && endpos < maxpos ) endpos ++ ; if ( endpos <= maxpos ) return new String ( bytarray , pos , endpos - pos ) ; return null ; } 
private static File locateFirefoxBinaryFromPlatform ( ) { File binary = null ; switch ( Platform . getCurrent ( ) ) { case WINDOWS : case VISTA : case XP : binary = new File ( getEnvVar ( "PROGRAMFILES" , "|Program-Files" ) + "|Mozilla-Firefox|firefox.exe" ) ; if ( ! binary . exists ( ) ) { binary = new File ( getEnvVar ( "ProgramFiles(x86)" , getEnvVar ( "SystemDrive" , "c:" ) + "|Program-Files-(x86)" ) + "|Mozilla-Firefox|firefox.exe" ) ; } break ; case MAC : binary = new File ( "/Applications/Firefox.app/Contents/MacOS/firefox-bin" ) ; break ; default : } return binary != null && binary . exists ( ) ? binary : findBinary ( "firefox3" , "firefox2" , "firefox" ) ; } 
public static void sort ( float [ ] a , int fromIndex , int toIndex ) { rangeCheck ( a . length , fromIndex , toIndex ) ; sort2 ( a , fromIndex , toIndex ) ; } 
public byte [ ] getByteCode ( ) { setPositions ( ) ; ByteArrayOutputStream b = new ByteArrayOutputStream ( ) ; DataOutputStream out = new DataOutputStream ( b ) ; try { for ( InstructionHandle ih = start ; ih != null ; ih = ih . next ) { Instruction i = ih . instruction ; i . dump ( out ) ; } } catch ( IOException e ) { System . err . println ( e ) ; return null ; } return b . toByteArray ( ) ; } 
private String generateEnterAction ( FSMState state ) { StringBuilder javaCode = new StringBuilder ( ) ; if ( state != null ) { String action = state . getEnterAction ( ) ; if ( action != null && ! action . isEmpty ( ) ) { javaCode . append ( action ) ; javaCode . append ( "();-" ) ; this . actions . add ( action ) ; } } return javaCode . toString ( ) ; } 
@ Deprecated public static RequestAsyncTask executeRestRequestAsync ( Session session , String restMethod , Bundle parameters , HttpMethod httpMethod ) { return newRestRequest ( session , restMethod , parameters , httpMethod ) . executeAsync ( ) ; } 
public static Template as ( String content ) { return new Template ( content ) ; } 
private void addExposedTypes ( Type type , Class < ? > cause ) { if ( type instanceof TypeVariable ) { logger . debug ( "Adding-exposed-types-from-{},-which-is-a-type-variable" , type ) ; addExposedTypes ( ( TypeVariable ) type , cause ) ; } else if ( type instanceof WildcardType ) { logger . debug ( "Adding-exposed-types-from-{},-which-is-a-wildcard-type" , type ) ; addExposedTypes ( ( WildcardType ) type , cause ) ; } else if ( type instanceof GenericArrayType ) { logger . debug ( "Adding-exposed-types-from-{},-which-is-a-generic-array-type" , type ) ; addExposedTypes ( ( GenericArrayType ) type , cause ) ; } else if ( type instanceof ParameterizedType ) { logger . debug ( "Adding-exposed-types-from-{},-which-is-a-parameterized-type" , type ) ; addExposedTypes ( ( ParameterizedType ) type , cause ) ; } else if ( type instanceof Class ) { logger . debug ( "Adding-exposed-types-from-{},-which-is-a-class" , type ) ; addExposedTypes ( ( Class ) type , cause ) ; } else { throw new IllegalArgumentException ( "Unknown-implementation-of-Type" ) ; } } 
public static void returnFile ( String filename , OutputStream out ) throws FileNotFoundException , IOException { FileInputStream fis = null ; try { fis = new FileInputStream ( filename ) ; byte [ ] buf = new byte [ 4 * 1024 ] ; int bytesRead ; while ( ( bytesRead = fis . read ( buf ) ) != - 1 ) { out . write ( buf , 0 , bytesRead ) ; } } finally { if ( fis != null ) fis . close ( ) ; } } 
public final void setFeatureDrawableResource ( int featureId , int resId ) { getWindow ( ) . setFeatureDrawableResource ( featureId , resId ) ; } 
static void verifyProviderJar ( URL codeBase ) throws Exception { JarVerifier jv = new JarVerifier ( codeBase , false ) ; jv . verify ( ) ; } 
private static int getOnMeasureSpec ( int measureSpecMode , int measureSpecSize , int desiredSize ) { int spec ; if ( measureSpecMode == MeasureSpec . EXACTLY ) { spec = measureSpecSize ; } else if ( measureSpecMode == MeasureSpec . AT_MOST ) { spec = Math . min ( desiredSize , measureSpecSize ) ; } else { spec = desiredSize ; } return spec ; } 
public void mouseDragged ( MouseEvent e ) { if ( dragger != null ) { if ( e . getSource ( ) == splitPane ) { dragger . continueDrag ( e . getX ( ) , e . getY ( ) ) ; } else if ( e . getSource ( ) == BasicSplitPaneDivider . this ) { Point ourLoc = getLocation ( ) ; dragger . continueDrag ( e . getX ( ) + ourLoc . x , e . getY ( ) + ourLoc . y ) ; } else if ( e . getSource ( ) == hiddenDivider ) { Point hDividerLoc = hiddenDivider . getLocation ( ) ; int ourX = e . getX ( ) + hDividerLoc . x ; int ourY = e . getY ( ) + hDividerLoc . y ; dragger . continueDrag ( ourX , ourY ) ; } e . consume ( ) ; } } 
public void addPacket ( OSCPacket packet ) { packets . add ( packet ) ; } 
static AnnotationStrategy strategyFor ( Class < ? extends Annotation > annotationType ) { checkNotNull ( annotationType , "annotation-type" ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; return new AnnotationTypeStrategy ( Annotations . canonicalizeIfNamed ( annotationType ) , null ) ; } 
public boolean hasDatabase ( String sDatabase ) throws DBProjectListException { if ( htDatabases == null ) { loadDatabaseProjects ( ) ; } for ( Enumeration e = htDatabases . elements ( ) ; e . hasMoreElements ( ) ; ) { String sName = ( String ) e . nextElement ( ) ; if ( sName . equals ( sDatabase ) ) return true ; } return false ; } 
public IBasicScope getBasicScope ( String type , String name ) { return children . get ( type + SEPARATOR + name ) ; } 
public Object getIntensity ( String name ) throws CallError , InterruptedException { return ( Object ) call ( "getIntensity" , name ) . get ( ) ; } 
public int codePointCount ( int beginIndex , int endIndex ) { if ( beginIndex < 0 || endIndex > count || beginIndex > endIndex ) { throw new IndexOutOfBoundsException ( ) ; } int s = beginIndex + offset ; return Character . codePointCount ( value , s , endIndex - beginIndex ) ; } 
public void _write ( OutputStream output ) { output . write_octet ( value ) ; } 
public List < String > getResidues ( ) { if ( residues == null ) { residues = new ArrayList < String > ( 1 ) ; } return this . residues ; } 
public void useProtocolVersion ( int version ) throws IOException { if ( ! objectsWritten . isEmpty ( ) ) { throw new IllegalStateException ( "Cannot-set-protocol-version-when-stream-in-use" ) ; } if ( version != ObjectStreamConstants . PROTOCOL_VERSION_1 && version != ObjectStreamConstants . PROTOCOL_VERSION_2 ) { throw new IllegalArgumentException ( "Unknown-protocol:-" + version ) ; } protocolVersion = version ; } 
public int rollDice ( ) { int sum = 0 ; Random randNum = new Random ( ) ; diceRoll [ 0 ] = randNum . nextInt ( 6 ) + 1 ; diceRoll [ 1 ] = randNum . nextInt ( 6 ) + 1 ; sum += diceRoll [ 0 ] ; sum += diceRoll [ 1 ] ; return sum ; } 
public RepositoryComponent lookupComponent ( List < Class < ? >> candidateClasses ) { for ( Class < ? > repoClass : candidateClasses ) { if ( repos . containsKey ( repoClass ) ) { return repos . get ( repoClass ) ; } } throw new RuntimeException ( "Unknown-Repository-classes-" + candidateClasses ) ; } 
@ Override public boolean accept ( File file ) { if ( fileFilter != null ) { return fileFilter . accept ( file ) ; } else { return super . accept ( file ) ; } } 
public static int remove ( Connection pCon , int pReturnRequestId ) throws SQLException { int n = 0 ; String sql = "DELETE-FROM-CLW_RETURN_REQUEST-WHERE-RETURN_REQUEST_ID-=-" + pReturnRequestId ; if ( log . isDebugEnabled ( ) ) { log . debug ( "SQL:-" + sql ) ; } Statement stmt = pCon . createStatement ( ) ; n = stmt . executeUpdate ( sql ) ; stmt . close ( ) ; return n ; } 
private static void waitForShutdown ( ) { try { synchronized ( s_shutdownObject ) { s_shutdownObject . wait ( ) ; } } catch ( InterruptedException ignore ) { } } 
public final void acquireShared ( int arg ) { if ( tryAcquireShared ( arg ) < 0 ) doAcquireShared ( arg ) ; } 
public void setUpdateEmpCode ( String updateEmpCode ) { this . updateEmpCode = updateEmpCode == null ? null : updateEmpCode . trim ( ) ; } 
@ SuppressWarnings ( "unchecked" ) public static void notEmpty ( Collection collection , String message ) { if ( collection == null || collection . size ( ) == 0 ) { throw new IllegalArgumentException ( message ) ; } } 
public void substract ( Vector v ) { this . x -= v . getX ( ) ; this . y -= v . getY ( ) ; this . z -= v . getZ ( ) ; } 
public static MethodType genericMethodType ( int objectArgCount ) { return genericMethodType ( objectArgCount , false ) ; } 
public Segment getText ( int p0 , int p1 ) { Segment text = SegmentCache . getSharedSegment ( ) ; try { Document doc = getDocument ( ) ; doc . getText ( p0 , p1 - p0 , text ) ; } catch ( BadLocationException bl ) { throw new StateInvariantError ( "GlyphView:-Stale-view:-" + bl ) ; } return text ; } 
public Window destroyActivity ( String id , boolean finish ) { LocalActivityRecord r = mActivities . get ( id ) ; Window win = null ; if ( r != null ) { win = performDestroy ( r , finish ) ; if ( finish ) { mActivities . remove ( id ) ; mActivityArray . remove ( r ) ; } } return win ; } 
public static Element createElement ( QName qName ) { Document doc = null ; try { doc = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . newDocument ( ) ; } catch ( ParserConfigurationException e ) { throw new RuntimeException ( e ) ; } Element elem = doc . createElementNS ( qName . getNamespaceURI ( ) , qName . getLocalPart ( ) ) ; return elem ; } 
static Engine create ( Number value ) { if ( value instanceof Float ) { return new FloatEngine ( value . floatValue ( ) ) ; } else if ( value instanceof Double ) { return new DoubleEngine ( value . doubleValue ( ) ) ; } else if ( value instanceof Long ) { return new LongEngine ( value . longValue ( ) ) ; } else { return new IntegerEngine ( value . intValue ( ) ) ; } } 
public synchronized Object clone ( ) { try { Hashtable < K , V > t = ( Hashtable < K , V > ) super . clone ( ) ; t . table = new Entry [ table . length ] ; for ( int i = table . length ; i -- > 0 ; ) { t . table [ i ] = ( table [ i ] != null ) ? ( Entry < K , V > ) table [ i ] . clone ( ) : null ; } t . keySet = null ; t . entrySet = null ; t . values = null ; t . modCount = 0 ; return t ; } catch ( CloneNotSupportedException e ) { throw new InternalError ( ) ; } } 
@ JsxGetter ( { @ WebBrowser ( value = IE , minVersion = 8 ) , @ WebBrowser ( FF ) } ) public String getQuotes ( ) { return getStyleAttribute ( QUOTES , null ) ; } 
public void clear ( ) { mValues . clear ( ) ; } 
@ XmlElementDecl ( namespace = "" , name = "description" ) @ XmlJavaTypeAdapter ( CollapsedStringAdapter . class ) public JAXBElement < String > createDescription ( String value ) { return new JAXBElement < String > ( _Description_QNAME , String . class , null , value ) ; } 
boolean hasOwnDeclaredProperty ( String name ) { return hasOwnProperty ( name ) && isPropertyTypeDeclared ( name ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
void setColumnMatrix ( final int column , final BlockRealMatrix matrix ) throws OutOfRangeException , MatrixDimensionMismatchException { MatrixUtils . checkColumnIndex ( this , column ) ; final int nRows = getRowDimension ( ) ; if ( ( matrix . getRowDimension ( ) != nRows ) || ( matrix . getColumnDimension ( ) != 1 ) ) { throw new MatrixDimensionMismatchException ( matrix . getRowDimension ( ) , matrix . getColumnDimension ( ) , nRows , 1 ) ; } final int jBlock = column / BLOCK_SIZE ; final int jColumn = column - jBlock * BLOCK_SIZE ; final int jWidth = blockWidth ( jBlock ) ; int mBlockIndex = 0 ; int mIndex = 0 ; double [ ] mBlock = matrix . blocks [ mBlockIndex ] ; for ( int iBlock = 0 ; iBlock < blockRows ; ++ iBlock ) { final int iHeight = blockHeight ( iBlock ) ; final double [ ] block = blocks [ iBlock * blockColumns + jBlock ] ; for ( int i = 0 ; i < iHeight ; ++ i ) { if ( mIndex >= mBlock . length ) { mBlock = matrix . blocks [ ++ mBlockIndex ] ; mIndex = 0 ; } block [ i * jWidth + jColumn ] = mBlock [ mIndex ++ ] ; } } } 
public static Object decodeToObject ( String encodedObject , int options , final ClassLoader loader ) throws java . io . IOException , java . lang . ClassNotFoundException { byte [ ] objBytes = decode ( encodedObject , options ) ; java . io . ByteArrayInputStream bais = null ; java . io . ObjectInputStream ois = null ; Object obj = null ; try { bais = new java . io . ByteArrayInputStream ( objBytes ) ; if ( loader == null ) { ois = new java . io . ObjectInputStream ( bais ) ; } else { ois = new java . io . ObjectInputStream ( bais ) { @ Override public Class < ? > resolveClass ( java . io . ObjectStreamClass streamClass ) throws java . io . IOException , ClassNotFoundException { Class < ? > c = Class . forName ( streamClass . getName ( ) , false , loader ) ; if ( c == null ) { return super . resolveClass ( streamClass ) ; } else { return c ; } } } ; } obj = ois . readObject ( ) ; } catch ( java . io . IOException e ) { throw e ; } catch ( java . lang . ClassNotFoundException e ) { throw e ; } finally { try { bais . close ( ) ; } catch ( Exception e ) { } try { ois . close ( ) ; } catch ( Exception e ) { } } return obj ; } 
public static List < String > buildfeaturesFromUtterance ( String utt ) throws Exception { List < String > features = new ArrayList < String > ( ) ; String [ ] tokens = ( utt ) . split ( "[|s]+" ) ; int l = tokens . length ; features . add ( "len=" + l ) ; Map < String , Integer > wordcounts = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < l ; i ++ ) { String s0 = tokens [ i ] ; if ( ! wordcounts . containsKey ( s0 ) ) { wordcounts . put ( s0 , 1 ) ; } else wordcounts . put ( s0 , wordcounts . get ( s0 ) + 1 ) ; features . add ( s0 ) ; String s1 = ( ( i + 1 ) < l ) ? tokens [ i + 1 ] : "" ; String s2 = ( ( i + 2 ) < l ) ? tokens [ i + 2 ] : "" ; features . add ( s0 + ":" + s1 ) ; features . add ( s0 + ":" + s1 + ":" + s2 ) ; } for ( String key : wordcounts . keySet ( ) ) { features . add ( key + "=" + wordcounts . get ( key ) ) ; } return features ; } 
public DTMIterator getContextNodeList ( ) { try { DTMIterator cnl = m_xcontext . getContextNodeList ( ) ; return ( cnl == null ) ? null : ( DTMIterator ) cnl . cloneWithReset ( ) ; } catch ( CloneNotSupportedException cnse ) { return null ; } } 
private InputStream createDocumentInputStream ( InputStream is ) throws IOException { BufferedInputStream bin = new BufferedInputStream ( is ) ; bin . mark ( 2 ) ; int b0 = bin . read ( ) ; int b1 = bin . read ( ) ; bin . reset ( ) ; if ( ( b1 << 8 | b0 ) == GZIPInputStream . GZIP_MAGIC ) { GZIPInputStream iis = new GZIPInputStream ( bin ) ; return iis ; } else { return bin ; } } 
public void deleteCell ( ) { if ( chosenCell . getEditable ( ) ) { chosenCell . setBackground ( Color . WHITE ) ; chosenCell . setText ( "" ) ; chosenCell . setEditable ( true ) ; chosenCell = nothingCell ; } } 
public static int getIntParameter ( HttpServletRequest request , String param ) { String val = request . getParameter ( param ) ; try { return Integer . parseInt ( val . trim ( ) ) ; } catch ( Exception e ) { return - 1 ; } } 
private Object getHashKey ( K obj ) throws IllegalArgumentException , IllegalAccessException , InvocationTargetException { Object hashKey = null ; for ( Method met : obj . getClass ( ) . getDeclaredMethods ( ) ) { if ( met . getName ( ) . equals ( "getHashKey" ) ) { Object [ ] params = null ; hashKey = met . invoke ( obj , params ) ; break ; } } return hashKey ; } 
public Matrix storeTranspose ( FloatBuffer buf ) { buf . put ( m00 ) ; buf . put ( m10 ) ; buf . put ( m20 ) ; buf . put ( m30 ) ; buf . put ( m01 ) ; buf . put ( m11 ) ; buf . put ( m21 ) ; buf . put ( m31 ) ; buf . put ( m02 ) ; buf . put ( m12 ) ; buf . put ( m22 ) ; buf . put ( m32 ) ; buf . put ( m03 ) ; buf . put ( m13 ) ; buf . put ( m23 ) ; buf . put ( m33 ) ; return this ; } 
public double getFitnessValue ( ) { if ( m_fitnessValue >= 0.000d && ! m_alwaysCalculate ) { return m_fitnessValue ; } else { return calcFitnessValue ( ) ; } } 
protected final Element createChildElement ( String childXpath ) { int index = childXpath . indexOf ( "/" ) ; String elementName = childXpath ; String subChildXpath = null ; Element element = null ; Element child = null ; if ( index > 0 ) { elementName = childXpath . substring ( 0 , index ) ; subChildXpath = childXpath . substring ( index + 1 ) ; child = createChildElement ( subChildXpath ) ; } try { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = dbf . newDocumentBuilder ( ) ; Document document = db . newDocument ( ) ; element = document . createElement ( elementName ) ; if ( child != null ) { Node importedNode = document . importNode ( child , true ) ; element . appendChild ( importedNode ) ; } } catch ( ParserConfigurationException pce ) { log . error ( "Exception-thrown-from-createChildElement():-" + pce . getMessage ( ) ) ; pce . printStackTrace ( ) ; } return element ; } 
public void flush ( ) throws IOException { if ( bufferModified ) { file . seek ( bufferStart ) ; file . write ( buffer , 0 , dataSize ) ; bufferModified = false ; } } 
public void reset ( ) { synchronized ( lock ) { declarations . clear ( ) ; parameterized . clear ( ) ; contextualized . clear ( ) ; if ( values != null ) { values . clear ( ) ; } } } 
private void signalQueueWorker ( ) { lockBoth . lock ( ) ; try { notEmptyBoth . signal ( ) ; } finally { lockBoth . unlock ( ) ; } } 
protected void recoverFile ( ) throws IOException { while ( true ) { switch ( token ) { case CLASS : case INTERFACE : return ; case LBRACE : match ( LBRACE , RBRACE ) ; scan ( ) ; break ; case LPAREN : match ( LPAREN , RPAREN ) ; scan ( ) ; break ; case LSQBRACKET : match ( LSQBRACKET , RSQBRACKET ) ; scan ( ) ; break ; case EOF : return ; default : scan ( ) ; break ; } } } 
public static String readFully ( Reader reader ) throws IOException { try { StringWriter writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , count ) ; } return writer . toString ( ) ; } finally { reader . close ( ) ; } } 
private void outputGlobalNames ( PrintWriter out , Hashtable < String , Integer > globals , String functionName ) { out . println ( "const-char*-" + functionName + "(int-index)-{" ) ; out . println ( "-switch(index)-{" ) ; for ( Map . Entry < String , Integer > entry : globals . entrySet ( ) ) { String name = entry . getKey ( ) ; int offset = entry . getValue ( ) ; name = name . replace ( '.' , '_' ) ; out . println ( "-case-" + offset + ":-return-"" + name + "";" ) ; } out . println ( "-default:-return-"" + functionName + ":-unknown-global-index";" ) ; out . println ( "-}" ) ; out . println ( "}" ) ; } 
protected void refreshTheme ( String id , boolean merge ) { UIManager manager = getUIManager ( ) ; if ( merge ) { Style unSelected = getUnselectedStyle ( ) ; setUnselectedStyle ( mergeStyle ( unSelected , manager . getComponentStyle ( id ) ) ) ; if ( selectedStyle != null ) { setSelectedStyle ( mergeStyle ( selectedStyle , manager . getComponentSelectedStyle ( id ) ) ) ; } if ( disabledStyle != null ) { setDisabledStyle ( mergeStyle ( disabledStyle , manager . getComponentCustomStyle ( id , "dis" ) ) ) ; } if ( pressedStyle != null ) { setPressedStyle ( mergeStyle ( pressedStyle , manager . getComponentCustomStyle ( id , "press" ) ) ) ; } } else { unSelectedStyle = null ; unSelectedStyle = getUnselectedStyle ( ) ; selectedStyle = null ; disabledStyle = null ; pressedStyle = null ; } checkAnimation ( ) ; manager . getLookAndFeel ( ) . bind ( this ) ; } 
public void fireIndexedPropertyChange ( String propertyName , int index , int oldValue , int newValue ) { if ( oldValue != newValue ) { fireIndexedPropertyChange ( propertyName , index , Integer . valueOf ( oldValue ) , Integer . valueOf ( newValue ) ) ; } } 
private Iterator < Map . Entry < K , V >> getOverflowIterator ( ) { if ( lazyOverflowIterator == null ) { lazyOverflowIterator = overflowEntries . entrySet ( ) . iterator ( ) ; } return lazyOverflowIterator ; } 
public static Builder newBuilder ( Descriptor type ) { return new Builder ( type ) ; } 
public static void main ( String [ ] args ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { try { DijkstraShortestPath window = new DijkstraShortestPath ( ) ; window . frame . setVisible ( true ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } ) ; } 
public static String getHostnameFromList ( String hostListString , int port ) throws IOException { Socket checkSocket = getSocket ( hostListString , port , false ) ; String host ; if ( checkSocket != null ) { host = checkSocket . getInetAddress ( ) . getHostAddress ( ) ; checkSocket . close ( ) ; } else { host = hostListString ; } return host ; } 
private BigInteger procedure_C ( BigInteger p , BigInteger q ) { BigInteger pSub1 = p . subtract ( ONE ) ; BigInteger pSub1DivQ = pSub1 . divide ( q ) ; int length = p . bitLength ( ) ; for ( ; ; ) { BigInteger d = new BigInteger ( length , init_random ) ; if ( d . compareTo ( ONE ) > 0 && d . compareTo ( pSub1 ) < 0 ) { BigInteger a = d . modPow ( pSub1DivQ , p ) ; if ( a . compareTo ( ONE ) != 0 ) { return a ; } } } } 
public void setEnvironment ( final Environment env ) { m_env = env ; Vector < String > varKeys = new Vector < String > ( env . getVariableNames ( ) ) ; DefaultComboBoxModel dm = new DefaultComboBoxModel ( varKeys ) { public Object getSelectedItem ( ) { Object item = super . getSelectedItem ( ) ; if ( item instanceof String ) { if ( env . getVariableValue ( ( String ) item ) != null ) { String newS = "${" + ( String ) item + "}" ; item = newS ; } } return item ; } } ; m_combo . setModel ( dm ) ; m_combo . setSelectedItem ( "" ) ; m_combo . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { String selected = ( String ) m_combo . getSelectedItem ( ) ; try { selected = processSelected ( selected ) ; selected = m_env . substitute ( selected ) ; } catch ( Exception ex ) { } m_combo . setToolTipText ( selected ) ; } } ) ; m_combo . getEditor ( ) . getEditorComponent ( ) . addKeyListener ( new KeyAdapter ( ) { public void keyReleased ( KeyEvent e ) { java . awt . Component theEditor = m_combo . getEditor ( ) . getEditorComponent ( ) ; if ( theEditor instanceof JTextField ) { String selected = ( ( JTextField ) theEditor ) . getText ( ) ; m_currentContents = selected ; if ( m_env != null ) { try { selected = m_env . substitute ( selected ) ; } catch ( Exception ex ) { } } m_combo . setToolTipText ( selected ) ; } } } ) ; } 
public FloatBuffer asFloatBuffer ( ) { return FloatBuffer . wrap ( this ) ; } 
public boolean add ( Solution solution ) { if ( solutionsList_ . size ( ) == capacity_ ) { Configuration . logger_ . severe ( "The-population-is-full" ) ; Configuration . logger_ . severe ( "Capacity-is-:-" + capacity_ ) ; Configuration . logger_ . severe ( "-Size-is:-" + this . size ( ) ) ; return false ; } solutionsList_ . add ( solution ) ; return true ; } 
public boolean isProbablePrime ( int certainty ) { if ( certainty <= 0 ) return true ; BigInteger w = this . abs ( ) ; if ( w . equals ( TWO ) ) return true ; if ( ! w . testBit ( 0 ) || w . equals ( ONE ) ) return false ; return w . primeToCertainty ( certainty , null ) ; } 
public static Parser makeParser ( String className ) throws ClassNotFoundException , IllegalAccessException , InstantiationException , ClassCastException { return ( Parser ) NewInstance . newInstance ( NewInstance . getClassLoader ( ) , className ) ; } 
public ZipEntry getEntry ( String entryName ) { checkNotClosed ( ) ; if ( entryName == null ) { throw new NullPointerException ( ) ; } ZipEntry ze = mEntries . get ( entryName ) ; if ( ze == null ) { ze = mEntries . get ( entryName + "/" ) ; } return ze ; } 
protected Proxy ( InvocationHandler h ) { Objects . requireNonNull ( h ) ; this . h = h ; } 
public String getVariableValue ( String key ) { return m_envVars . get ( key ) ; } 
static public String removeColon ( String origPath ) { return origPath . replaceAll ( ":" , "" ) ; } 
public void eval ( String statement ) throws ScriptException { e . eval ( statement ) ; } 
public static List < CoreLabel > taggedLeafLabels ( Tree t ) { List < CoreLabel > l = new ArrayList < CoreLabel > ( ) ; taggedLeafLabels ( t , l ) ; return l ; } 
public ExceptionConfig findException ( Class type ) { ExceptionConfig config = null ; while ( true ) { String name = type . getName ( ) ; log . debug ( "findException:-look-locally-for-" + name ) ; config = findExceptionConfig ( name ) ; if ( config != null ) { return ( config ) ; } type = type . getSuperclass ( ) ; if ( type == null ) { break ; } } return ( null ) ; } 
public List < ManagedObjectReference > getReturnval ( ) { if ( returnval == null ) { returnval = new ArrayList < ManagedObjectReference > ( ) ; } return this . returnval ; } 
public boolean showValueDialog ( final JComponent component , String description ) { ValueDialog dialog = new ValueDialog ( component , name , description ) ; dialog . setTitle ( name ) ; dialog . setLocationRelativeTo ( null ) ; EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { JComponent focusComponent = component ; if ( focusComponent instanceof JSpinner ) focusComponent = ( ( JSpinner . DefaultEditor ) ( ( JSpinner ) component ) . getEditor ( ) ) . getTextField ( ) ; focusComponent . requestFocusInWindow ( ) ; } } ) ; dialog . setVisible ( true ) ; return dialog . okPressed ; } 
@ XmlElementDecl ( namespace = "http://schemas.microsoft.com/2003/10/Serialization/" , name = "anyType" ) public JAXBElement < Object > createAnyType ( Object value ) { return new JAXBElement < Object > ( _AnyType_QNAME , Object . class , null , value ) ; } 
public boolean contains ( CharSequence s ) { return indexOf ( s . toString ( ) ) > - 1 ; } 
public boolean onKeyUp ( int keyCode , KeyEvent event ) { if ( keyCode == KeyEvent . KEYCODE_BACK && event . isTracking ( ) && ! event . isCanceled ( ) ) { onBackPressed ( ) ; return true ; } return false ; } 
public Image getIconFromState ( ) { Image icon = null ; switch ( getState ( ) ) { case Button . STATE_DEFAULT : icon = getIcon ( ) ; break ; case Button . STATE_PRESSED : icon = getPressedIcon ( ) ; if ( icon == null ) { icon = getIcon ( ) ; } break ; case Button . STATE_ROLLOVER : icon = getRolloverIcon ( ) ; if ( icon == null ) { icon = getIcon ( ) ; } break ; } return icon ; } 
public int hashCode ( ) { int result = 31 * declaringClass . hashCode ( ) + methodName . hashCode ( ) ; result = 31 * result + Objects . hashCode ( fileName ) ; result = 31 * result + lineNumber ; return result ; } 
public final InputMap getInputMap ( int condition ) { return getInputMap ( condition , true ) ; } 
public static File getDiskCacheDir ( Context context , String uniqueName ) { final String cachePath = Environment . getExternalStorageState ( ) == Environment . MEDIA_MOUNTED || ! Utils . isExternalStorageRemovable ( ) ? Utils . getExternalCacheDir ( context ) . getPath ( ) : context . getCacheDir ( ) . getPath ( ) ; return new File ( cachePath + File . separator + uniqueName ) ; } 
public void setMaximum ( int maximum ) { int oldMax = getModel ( ) . getMaximum ( ) ; getModel ( ) . setMaximum ( maximum ) ; firePropertyChange ( "maximum" , new Integer ( oldMax ) , new Integer ( maximum ) ) ; } 
public static String readContents ( File source ) throws IOException { StringBuffer result = new StringBuffer ( ) ; BufferedReader br = null ; try { br = new BufferedReader ( new FileReader ( source ) ) ; String line ; do { line = br . readLine ( ) ; if ( line != null ) { result . append ( line + "-" ) ; } } while ( line != null ) ; } finally { if ( br != null ) { br . close ( ) ; } } return result . toString ( ) . trim ( ) ; } 
public ECKey getKey ( ) { return new ECKey ( new BigInteger ( 1 , bytes ) , null , compressed ) ; } 
public void update ( byte [ ] b , int off , int len ) { if ( b == null ) { throw new NullPointerException ( ) ; } if ( off < 0 || len < 0 || off > b . length - len ) { throw new ArrayIndexOutOfBoundsException ( ) ; } crc = updateBytes ( crc , b , off , len ) ; } 
public static boolean isSign ( final char character ) { return SIGN_CHARS . contains ( character ) ; } 
public ShortBuffer put ( ShortBuffer src ) { if ( src == this ) { throw new IllegalArgumentException ( "src-==-this" ) ; } if ( src . remaining ( ) > remaining ( ) ) { throw new BufferOverflowException ( ) ; } short [ ] contents = new short [ src . remaining ( ) ] ; src . get ( contents ) ; put ( contents ) ; return this ; } 
public void setOnShowListener ( OnShowListener listener ) { if ( listener != null ) { mShowMessage = mListenersHandler . obtainMessage ( SHOW , listener ) ; } else { mShowMessage = null ; } } 
public EventRecord [ ] monitor ( ) { ArrayList < EventRecord > recs = new ArrayList < EventRecord > ( ) ; for ( String nic : nics ) { try { recs . add ( query ( nic ) ) ; } catch ( UnknownHostException e ) { e . printStackTrace ( ) ; } } EventRecord [ ] T = new EventRecord [ recs . size ( ) ] ; return recs . toArray ( T ) ; } 
private String getWhereClauseForStatusUpdatesTable ( String selection ) { mSb . setLength ( 0 ) ; mSb . append ( WHERE_CLAUSE_FOR_STATUS_UPDATES_TABLE ) ; mSb . append ( selection ) ; mSb . append ( ")" ) ; return mSb . toString ( ) ; } 
public List < String > getRequestURLFragments ( HttpServletRequest request ) { String uriWithoutFirstSlash = request . getRequestURI ( ) ; if ( uriWithoutFirstSlash . indexOf ( "/" ) == 0 ) { uriWithoutFirstSlash = uriWithoutFirstSlash . substring ( 1 , uriWithoutFirstSlash . length ( ) ) ; } List < String > fragments = Arrays . asList ( uriWithoutFirstSlash . split ( "/" ) ) ; return fragments ; } 
private void makeActions ( ) { showIncomingRelationsAction = new Action ( null , IAction . AS_CHECK_BOX ) { @ Override public void run ( ) { setShowIncomingRelations ( isChecked ( ) ) ; } } ; showIncomingRelationsAction . setText ( "Show-Incoming-Relations" ) ; showIncomingRelationsAction . setDescription ( "Show-Incoming-Relations" ) ; showIncomingRelationsAction . setToolTipText ( "Show-Incoming-Relations" ) ; showIncomingRelationsAction . setImageDescriptor ( VisualisationImageManager . DESC_INCOMING_TRANSITIONS ) ; showIncomingRelationsAction . setChecked ( DEFAULT_SHOW_INCOMING_RELATIONS ) ; showOutgoingRelationsAction = new Action ( null , IAction . AS_CHECK_BOX ) { @ Override public void run ( ) { setShowOutgoingRelations ( isChecked ( ) ) ; } } ; showOutgoingRelationsAction . setText ( "Show-Outgoing-Relations" ) ; showOutgoingRelationsAction . setDescription ( "Show-Outgoing-Relations" ) ; showOutgoingRelationsAction . setToolTipText ( "Show-Outgoing-Relations" ) ; showOutgoingRelationsAction . setImageDescriptor ( VisualisationImageManager . DESC_OUTGOING_TRANSITIONS ) ; showOutgoingRelationsAction . setChecked ( DEFAULT_SHOW_OUTGOING_RELATIONS ) ; } 
public Notification buildUnstyled ( ) { Notification n = new Notification ( ) ; n . when = mWhen ; n . icon = mSmallIcon ; n . iconLevel = mSmallIconLevel ; n . number = mNumber ; n . color = sanitizeColor ( ) ; setBuilderContentView ( n , makeContentView ( ) ) ; n . contentIntent = mContentIntent ; n . deleteIntent = mDeleteIntent ; n . fullScreenIntent = mFullScreenIntent ; n . tickerText = mTickerText ; n . tickerView = makeTickerView ( ) ; n . largeIcon = mLargeIcon ; n . sound = mSound ; n . audioStreamType = mAudioStreamType ; n . audioAttributes = mAudioAttributes ; n . vibrate = mVibrate ; n . ledARGB = mLedArgb ; n . ledOnMS = mLedOnMs ; n . ledOffMS = mLedOffMs ; n . defaults = mDefaults ; n . flags = mFlags ; setBuilderBigContentView ( n , makeBigContentView ( ) ) ; setBuilderHeadsUpContentView ( n , makeHeadsUpContentView ( ) ) ; if ( mLedOnMs != 0 || mLedOffMs != 0 ) { n . flags |= FLAG_SHOW_LIGHTS ; } if ( ( mDefaults & DEFAULT_LIGHTS ) != 0 ) { n . flags |= FLAG_SHOW_LIGHTS ; } n . category = mCategory ; n . mGroupKey = mGroupKey ; n . mSortKey = mSortKey ; n . priority = mPriority ; if ( mActions . size ( ) > 0 ) { n . actions = new Action [ mActions . size ( ) ] ; mActions . toArray ( n . actions ) ; } n . visibility = mVisibility ; if ( mPublicVersion != null ) { n . publicVersion = new Notification ( ) ; mPublicVersion . cloneInto ( n . publicVersion , true ) ; } return n ; } 
protected void addTestAccount ( Account account ) { if ( account . mId > 0 ) { mCreatedAccountIds . add ( account . mId ) ; } } 
public static String getBaseName ( String name ) { int index = name . lastIndexOf ( '.' ) ; return index == - 1 ? name : name . substring ( 0 , index ) ; } 
public static Class < ? > loadClass ( String className , Class < ? > callingClass ) throws ClassNotFoundException { try { ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( cl != null ) { return cl . loadClass ( className ) ; } } catch ( ClassNotFoundException e ) { if ( log . isDebugEnabled ( ) ) { log . debug ( e ) ; } } return loadClass2 ( className , callingClass ) ; } 
public void testCase12 ( ) { byte bBytes [ ] = { 15 , 48 , - 29 , 7 , 98 , - 1 , 39 , - 128 } ; int bSign = - 1 ; byte rBytes [ ] = { 0 } ; BigInteger aNumber = BigInteger . ZERO ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . divide ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = 0 ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( "incorrect-sign" , 0 , result . signum ( ) ) ; } 
public static Calendar getToday ( ) throws ParseException { Date today = new Date ( ) ; SimpleDateFormat df = new SimpleDateFormat ( getDatePattern ( ) ) ; String todayAsString = df . format ( today ) ; Calendar cal = new GregorianCalendar ( ) ; cal . setTime ( convertStringToDate ( todayAsString ) ) ; return cal ; } 
public void setValueIsAdjusting ( boolean b ) { BoundedRangeModel m = getModel ( ) ; boolean oldValue = m . getValueIsAdjusting ( ) ; m . setValueIsAdjusting ( b ) ; if ( ( oldValue != b ) && ( accessibleContext != null ) ) { accessibleContext . firePropertyChange ( AccessibleContext . ACCESSIBLE_STATE_PROPERTY , ( ( oldValue ) ? AccessibleState . BUSY : null ) , ( ( b ) ? AccessibleState . BUSY : null ) ) ; } } 
public static Change integrate ( Env env , Vector fents , String branch , StringBuffer sb , Change c ) throws PerforceException { FileEntry fent ; Enumeration en = fents . elements ( ) ; while ( en . hasMoreElements ( ) ) { fent = ( FileEntry ) en . nextElement ( ) ; integrate ( env , fent . getDepotPath ( ) + "#" + fent . getHeadRev ( ) , branch , sb , c ) ; } return c ; } 
protected void initView ( ) { p . setFakeBoldText ( false ) ; p . setAntiAlias ( true ) ; p . setTextSize ( MINI_DAY_NUMBER_TEXT_SIZE ) ; p . setStyle ( Style . FILL ) ; mMonthNumPaint = new Paint ( ) ; mMonthNumPaint . setFakeBoldText ( true ) ; mMonthNumPaint . setAntiAlias ( true ) ; mMonthNumPaint . setTextSize ( MINI_DAY_NUMBER_TEXT_SIZE ) ; mMonthNumPaint . setColor ( mFocusMonthColor ) ; mMonthNumPaint . setStyle ( Style . FILL ) ; mMonthNumPaint . setTextAlign ( Align . CENTER ) ; } 
public Object [ ] getElements ( Object inputElement ) { if ( inputElement instanceof Object [ ] ) { List < ViewPrototype > result = new ArrayList < ViewPrototype > ( ) ; for ( Object next : ( Object [ ] ) inputElement ) { if ( next instanceof String ) { String diagramCategory = ( String ) next ; result . addAll ( getPrototypes ( diagramCategory ) ) ; } } Collections . sort ( result , new ViewPrototype . Comp ( ) ) ; return result . toArray ( new Object [ result . size ( ) ] ) ; } if ( inputElement instanceof String ) { String diagramCategory = ( String ) inputElement ; List < ViewPrototype > result = getPrototypes ( diagramCategory ) ; return result . toArray ( new Object [ result . size ( ) ] ) ; } return null ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public void setHiddenLayers ( String h ) { String tmp = "" ; StringTokenizer tok = new StringTokenizer ( h , "," ) ; if ( tok . countTokens ( ) == 0 ) { return ; } double dval ; int val ; String c ; boolean first = true ; while ( tok . hasMoreTokens ( ) ) { c = tok . nextToken ( ) . trim ( ) ; if ( c . equals ( "a" ) || c . equals ( "i" ) || c . equals ( "o" ) || c . equals ( "t" ) ) { tmp += c ; } else { dval = Double . valueOf ( c ) . doubleValue ( ) ; val = ( int ) dval ; if ( ( val == dval && ( val != 0 || ( tok . countTokens ( ) == 0 && first ) ) && val >= 0 ) ) { tmp += val ; } else { return ; } } first = false ; if ( tok . hasMoreTokens ( ) ) { tmp += ",-" ; } } m_hiddenLayers = tmp ; } 
public boolean getBoolean ( int index ) throws JSONException { Object o = get ( index ) ; if ( o . equals ( Boolean . FALSE ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "false" ) ) ) { return false ; } else if ( o . equals ( Boolean . TRUE ) || ( o instanceof String && ( ( String ) o ) . equalsIgnoreCase ( "true" ) ) ) { return true ; } throw new JSONException ( "JSONArray[" + index + "]-is-not-a-Boolean." ) ; } 
public String toString ( ) { StringBuffer str = new StringBuffer ( ) ; str . append ( '|'' ) ; for ( int x = 0 ; x < bits . length ; x ++ ) { str . append ( bits [ x ] ? '1' : '0' ) ; } str . append ( "'B" ) ; return str . toString ( ) ; } 
public ArrayList < View > getTouchables ( ) { ArrayList < View > result = new ArrayList < View > ( ) ; addTouchables ( result ) ; return result ; } 
static int runManyCommands ( String script ) throws FileNotFoundException , IOException { Reader input ; if ( "-" . equals ( script ) ) { input = new InputStreamReader ( System . in ) ; } else { input = new FileReader ( script ) ; } StreamTokenizer tokenizer = new StreamTokenizer ( input ) ; tokenizer . eolIsSignificant ( true ) ; tokenizer . ordinaryChar ( '-' ) ; tokenizer . wordChars ( '-' , '-' ) ; tokenizer . ordinaryChars ( '0' , '9' ) ; tokenizer . wordChars ( '0' , '9' ) ; tokenizer . ordinaryChar ( '.' ) ; tokenizer . wordChars ( '.' , '.' ) ; tokenizer . ordinaryChar ( '@' ) ; tokenizer . wordChars ( '@' , '@' ) ; int status = 0 ; List < String > tokens = new ArrayList < String > ( ) ; while ( StreamTokenizer . TT_EOF != tokenizer . nextToken ( ) ) { if ( StreamTokenizer . TT_EOL == tokenizer . ttype ) { if ( tokens . size ( ) > 0 ) { status = ScriptLauncher . runOneCommand ( tokens . toArray ( new String [ tokens . size ( ) ] ) ) ; if ( status > 0 ) { break ; } tokens . clear ( ) ; } } else { tokens . add ( tokenizer . sval ) ; } } return status ; } 
public double ptSegDist ( Point2D pt ) { return ptSegDist ( getX1 ( ) , getY1 ( ) , getX2 ( ) , getY2 ( ) , pt . getX ( ) , pt . getY ( ) ) ; } 
public boolean contains ( String name ) { return ( properties . containsKey ( name ) || defaultProperties . containsKey ( name ) ) ; } 
public void firePropertyChange ( String propertyName , int oldValue , int newValue ) { if ( oldValue != newValue ) { firePropertyChange ( propertyName , Integer . valueOf ( oldValue ) , Integer . valueOf ( newValue ) ) ; } } 
boolean getSelection ( ) { return button . getSelection ( ) ; } 
public static String prepad ( String s , int length , char c ) { int needed = length - s . length ( ) ; if ( needed <= 0 ) { return s ; } char padding [ ] = new char [ needed ] ; java . util . Arrays . fill ( padding , c ) ; StringBuffer sb = new StringBuffer ( length ) ; sb . append ( padding ) ; sb . append ( s ) ; return sb . toString ( ) ; } 
public void map ( WritableComparable key , Text value , OutputCollector < Text , Text > output , Reporter reporter ) throws IOException { this . output = output ; this . reporter = reporter ; prefixString = value ; StringTokenizer itr = new StringTokenizer ( prefixString . toString ( ) , "," ) ; int [ ] prefix = new int [ depth ] ; int idx = 0 ; while ( itr . hasMoreTokens ( ) ) { String num = itr . nextToken ( ) ; prefix [ idx ++ ] = Integer . parseInt ( num ) ; } pent . solve ( prefix ) ; } 
public synchronized int findColumn ( String columnName ) throws SQLException { Integer index ; if ( ! this . hasBuiltIndexMapping ) { buildIndexMapping ( ) ; } index = ( Integer ) this . columnNameToIndex . get ( columnName ) ; if ( index == null ) { index = ( Integer ) this . fullColumnNameToIndex . get ( columnName ) ; } if ( index != null ) { return index . intValue ( ) + 1 ; } for ( int i = 0 ; i < this . fields . length ; i ++ ) { if ( this . fields [ i ] . getName ( ) . equalsIgnoreCase ( columnName ) ) { return i + 1 ; } else if ( this . fields [ i ] . getFullName ( ) . equalsIgnoreCase ( columnName ) ) { return i + 1 ; } } throw SQLError . createSQLException ( Messages . getString ( "ResultSet.Column____112" ) + columnName + Messages . getString ( "ResultSet.___not_found._113" ) , SQLError . SQL_STATE_COLUMN_NOT_FOUND ) ; } 
public void showDistFor ( String var ) throws BayesError { if ( cached || approx ) { if ( ! qmap . containsKey ( var ) ) throw new BayesError ( "variable-'" + var + "'-was-not-queried" ) ; qmap . get ( var ) . print ( ) ; } else System . out . printf ( "no-solution-or-approximation-cached" ) ; } 
static public boolean isZero ( float value ) { return Math . abs ( value ) <= FLOAT_ROUNDING_ERROR ; } 
public List < IdentifierType > getGroupID ( ) { if ( groupID == null ) { groupID = new ArrayList < IdentifierType > ( ) ; } return this . groupID ; } 
private void readObject ( java . io . ObjectInputStream s ) throws java . io . IOException , ClassNotFoundException { s . defaultReadObject ( ) ; readHolds = new ThreadLocalHoldCounter ( ) ; setState ( 0 ) ; } 
public Object removeFirst ( ) { Object first = header . next . element ; remove ( header . next ) ; return first ; } 
private BasicStroke toStroke ( String style ) { BasicStroke result = null ; if ( style != null ) { float lineWidth = 2f ; float dash [ ] = { 5.0f } ; float dot [ ] = { lineWidth } ; if ( style . equalsIgnoreCase ( STYLE_LINE ) ) { result = new BasicStroke ( lineWidth ) ; } else if ( style . equalsIgnoreCase ( STYLE_DASH ) ) { result = new BasicStroke ( lineWidth , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , 10.0f , dash , 0.0f ) ; } else if ( style . equalsIgnoreCase ( STYLE_DOT ) ) { result = new BasicStroke ( lineWidth , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , 2.0f , dot , 0.0f ) ; } } return result ; } 
public int getC_UOM_ID ( ) { Integer ii = ( Integer ) get_Value ( "C_UOM_ID" ) ; if ( ii == null ) return 0 ; return ii . intValue ( ) ; } 
private Attribute findNextUndeclaredAttribute ( ) { if ( attributeIterator != null ) { while ( attributeIterator . hasNext ( ) ) { Entry < QName , Attribute > entry = attributeIterator . next ( ) ; Attribute attribute = entry . getValue ( ) ; if ( isUndeclared ( attribute . getAttributeKey ( ) ) ) { return entry . getValue ( ) ; } } attributeIterator = null ; } mode = metadataIterator != null && metadataIterator . hasNext ( ) ? Mode . DECLARED : Mode . DONE ; return null ; } 
public List < ClassificationNodeQueryType > getChildrenQuery ( ) { if ( childrenQuery == null ) { childrenQuery = new ArrayList < ClassificationNodeQueryType > ( ) ; } return this . childrenQuery ; } 
public Future < AllocateAddressResult > allocateAddressAsync ( final AllocateAddressRequest allocateAddressRequest ) throws AmazonServiceException , AmazonClientException { return executorService . submit ( new Callable < AllocateAddressResult > ( ) { public AllocateAddressResult call ( ) throws Exception { return allocateAddress ( allocateAddressRequest ) ; } } ) ; } 
public void count ( MidiEvent event ) { MidiMessage message = event . getMessage ( ) ; if ( message instanceof ShortMessage ) { int command = ( ( ShortMessage ) message ) . getCommand ( ) ; switch ( command ) { case ShortMessage . NOTE_ON : noteOn ++ ; break ; case ShortMessage . NOTE_OFF : noteOff ++ ; break ; default : other ++ ; } } else { other ++ ; } } 
public String getConstraintValue ( ) { return getConstraintType ( ) == XSConstants . VC_NONE ? null : fDefault . stringValue ( ) ; } 
public boolean logout ( ) throws LoginException { if ( subject . isReadOnly ( ) ) { throw new LoginException ( "Subject-is-ReadOnly" ) ; } Set principals = subject . getPrincipals ( ) ; if ( principals . contains ( userPrincipal ) ) { principals . remove ( userPrincipal ) ; } if ( principals . contains ( userSID ) ) { principals . remove ( userSID ) ; } if ( principals . contains ( userDomain ) ) { principals . remove ( userDomain ) ; } if ( principals . contains ( domainSID ) ) { principals . remove ( domainSID ) ; } if ( principals . contains ( primaryGroup ) ) { principals . remove ( primaryGroup ) ; } for ( int i = 0 ; groups != null && i < groups . length ; i ++ ) { if ( principals . contains ( groups [ i ] ) ) { principals . remove ( groups [ i ] ) ; } } Set pubCreds = subject . getPublicCredentials ( ) ; if ( pubCreds . contains ( iToken ) ) { pubCreds . remove ( iToken ) ; } succeeded = false ; commitSucceeded = false ; userPrincipal = null ; userDomain = null ; userSID = null ; domainSID = null ; groups = null ; primaryGroup = null ; iToken = null ; ntSystem = null ; if ( debug ) { System . out . println ( "-[NTLoginModule]-" + "completed-logout-processing" ) ; } return true ; } 
public void setAccessibleName ( String s ) { String oldName = accessibleName ; accessibleName = s ; firePropertyChange ( ACCESSIBLE_NAME_PROPERTY , oldName , accessibleName ) ; } 
public static final String [ ] getKeywordValuesForLocale ( String key , ULocale locale , boolean commonlyUsed ) { String baseLoc = locale . getBaseName ( ) ; LinkedList < String > values = new LinkedList < String > ( ) ; UResourceBundle bundle = UResourceBundle . getBundleInstance ( ICUResourceBundle . ICU_BASE_NAME + "/coll" , baseLoc ) ; String defcoll = null ; while ( bundle != null ) { UResourceBundle collations = bundle . get ( "collations" ) ; Enumeration < String > collEnum = collations . getKeys ( ) ; while ( collEnum . hasMoreElements ( ) ) { String collkey = collEnum . nextElement ( ) ; if ( collkey . equals ( "default" ) ) { if ( defcoll == null ) { defcoll = collations . getString ( "default" ) ; } } else if ( ! values . contains ( collkey ) ) { values . add ( collkey ) ; } } bundle = ( ( ICUResourceBundle ) bundle ) . getParent ( ) ; } Iterator < String > itr = values . iterator ( ) ; String [ ] result = new String [ values . size ( ) ] ; result [ 0 ] = defcoll ; int idx = 1 ; while ( itr . hasNext ( ) ) { String collKey = itr . next ( ) ; if ( ! collKey . equals ( defcoll ) ) { result [ idx ++ ] = collKey ; } } return result ; } 
public Link getLinkByPortId ( String portId ) { List < Link > links = daos . getLinkDAO ( ) . getAll ( ) ; for ( Link l : links ) { if ( l . getEndPort ( ) . getBodID ( ) . equals ( portId ) ) return l ; } return null ; } 
public String buildLabelForGroupAuthorityPerm ( String authority , String role ) { StringBuilder buf = new StringBuilder ( 100 ) ; buf . append ( authority . substring ( PermissionService . GROUP_PREFIX . length ( ) ) ) . append ( "-(" ) . append ( Application . getMessage ( FacesContext . getCurrentInstance ( ) , role ) ) . append ( ")" ) ; return buf . toString ( ) ; } 
public void setExtraFields ( Collection < String > fields ) { extraFields = new HashSet < String > ( ) ; if ( fields != null ) { extraFields . addAll ( fields ) ; } } 
public Collection < ApnContext > rspApnList ( Message response ) { Collection < ApnContext > retVal = ( Collection < ApnContext > ) response . obj ; if ( retVal == null ) retVal = new ArrayList < ApnContext > ( ) ; return retVal ; } 
public JavaWriter emitField ( String type , String name , Set < Modifier > modifiers ) throws IOException { return emitField ( type , name , modifiers , null ) ; } 
public void printAccess ( String [ ] accflags ) { for ( int j = 0 ; j < accflags . length ; j ++ ) { out . print ( accflags [ j ] + "-" ) ; } } 
public void setOutput ( OutputStream stream , String encoding ) throws UnsupportedEncodingException { if ( encoding == null ) { encoding = "UTF8" ; } java . io . Writer writer = new OutputStreamWriter ( stream , encoding ) ; fOut = new PrintWriter ( writer ) ; } 
public void setMergeValueRange ( String range ) { m_MergeRange . setRanges ( range ) ; } 
public boolean isAlwaysOnTopSupported ( ) { return Toolkit . getDefaultToolkit ( ) . isAlwaysOnTopSupported ( ) ; } 
public String get ( String fieldName ) { for ( int i = namesAndValues . size ( ) - 2 ; i >= 0 ; i -= 2 ) { if ( fieldName . equalsIgnoreCase ( namesAndValues . get ( i ) ) ) { return namesAndValues . get ( i + 1 ) ; } } return null ; } 
public ArrayList < Arc > getDependences ( Statement stmt1 , Statement stmt2 ) { ArrayList < Arc > arcSet = new ArrayList < Arc > ( ) ; int depArcs_size = depArcs . size ( ) ; for ( int i = 0 ; i < depArcs_size ; i ++ ) { Arc arc = depArcs . get ( i ) ; if ( arc . getSourceStatement ( ) == stmt1 ) { if ( arc . getSinkStatement ( ) == stmt2 ) { arcSet . add ( arc ) ; } } else if ( arc . getSourceStatement ( ) == stmt2 ) { if ( arc . getSinkStatement ( ) == stmt1 ) { arcSet . add ( arc ) ; } } } return arcSet ; } 
public Iterator < Item > getItems ( ) { synchronized ( items ) { return Collections . unmodifiableList ( new ArrayList < Item > ( items ) ) . iterator ( ) ; } } 
private void writeDurationField ( String fieldName , Object value ) throws IOException { if ( value instanceof String ) { m_writer . writeNameValuePair ( fieldName + "_text" , ( String ) value ) ; } else { Duration val = ( Duration ) value ; if ( val . getDuration ( ) != 0 ) { Duration minutes = val . convertUnits ( TimeUnit . MINUTES , m_projectFile . getProjectProperties ( ) ) ; long seconds = ( long ) ( minutes . getDuration ( ) * 60.0 ) ; m_writer . writeNameValuePair ( fieldName , seconds ) ; } } } 
public final Key translateKey ( Key key ) throws InvalidKeyException { return spiImpl . engineTranslateKey ( key ) ; } 
protected void insertJposEntriesInDoc ( Document doc , Enumeration entries ) { while ( entries . hasMoreElements ( ) ) { JposEntry jposEntry = ( JposEntry ) entries . nextElement ( ) ; if ( JposEntryUtility . isValidJposEntry ( jposEntry ) ) { doc . getDocumentElement ( ) . appendChild ( doc . createTextNode ( "-" + "-" ) ) ; Element jposEntryElement = doc . createElement ( "JposEntry" ) ; Attr logicalNameAttr = doc . createAttribute ( "logicalName" ) ; logicalNameAttr . setValue ( ( String ) jposEntry . getPropertyValue ( "logicalName" ) ) ; jposEntryElement . setAttributeNode ( logicalNameAttr ) ; jposEntryElement . appendChild ( doc . createTextNode ( "-" ) ) ; insertJposEntryInDoc ( doc , jposEntryElement , jposEntry ) ; } } } 
public void loadWithoutEvents ( PopCan ... pops ) throws SimulationException { if ( maxCapacity < chute . size ( ) + pops . length ) throw new SimulationException ( "Capacity-exceeded-by-attempt-to-load" ) ; for ( PopCan pop : pops ) { chute . add ( pop ) ; } } 
@ XmlElementDecl ( namespace = "http://www.opengis.net/kml/2.2" , name = "viewRefreshMode" , defaultValue = "never" ) public JAXBElement < ViewRefreshModeEnumType > createViewRefreshMode ( ViewRefreshModeEnumType value ) { return new JAXBElement < ViewRefreshModeEnumType > ( _ViewRefreshMode_QNAME , ViewRefreshModeEnumType . class , null , value ) ; } 
public CellFormatResult apply ( JLabel label , Object value ) { CellFormatResult result = apply ( value ) ; label . setText ( result . text ) ; if ( result . textColor != null ) { label . setForeground ( result . textColor ) ; } return result ; } 
private static boolean waitForBackgroundSaveJob ( final Saveable model ) { List models = new ArrayList ( ) ; models . add ( model ) ; return waitForBackgroundSaveJobs ( models ) ; } 
public Dimension preferredLayoutSize ( Container target ) { Dimension dim = new Dimension ( ) ; for ( int i = 0 ; i < target . countComponents ( ) ; i ++ ) { Component comp = target . getComponent ( i ) ; if ( comp . isVisible ( ) ) { Dimension d = comp . preferredSize ( ) ; dim . width += d . width + hgap ; dim . height = Math . max ( dim . height , d . height ) ; } } Insets insets = target . insets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; } 
public synchronized void addPropertyChangeListener ( PropertyChangeListener listener ) { pceListeners . addPropertyChangeListener ( listener ) ; } 
@ XmlElementDecl ( namespace = "http://mgt.webapp.carbon.wso2.org/xsd" , name = "webappFileName" , scope = SessionsWrapper . class ) public JAXBElement < String > createSessionsWrapperWebappFileName ( String value ) { return new JAXBElement < String > ( _SessionsWrapperWebappFileName_QNAME , String . class , SessionsWrapper . class , value ) ; } 
FormatToken parseFormatToken ( int offset ) { this . startIndex = offset ; this . i = offset ; return parseArgumentIndexAndFlags ( new FormatToken ( ) ) ; } 
void addFillComponents ( Container panel , int [ ] cols , int [ ] rows ) { Dimension filler = new Dimension ( 10 , 10 ) ; boolean filled_cell_11 = false ; CellConstraints cc = new CellConstraints ( ) ; if ( cols . length > 0 && rows . length > 0 ) { if ( cols [ 0 ] == 1 && rows [ 0 ] == 1 ) { panel . add ( Box . createRigidArea ( filler ) , cc . xy ( 1 , 1 ) ) ; filled_cell_11 = true ; } } for ( int index = 0 ; index < cols . length ; index ++ ) { if ( cols [ index ] == 1 && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( cols [ index ] , 1 ) ) ; } for ( int index = 0 ; index < rows . length ; index ++ ) { if ( rows [ index ] == 1 && filled_cell_11 ) { continue ; } panel . add ( Box . createRigidArea ( filler ) , cc . xy ( 1 , rows [ index ] ) ) ; } } 
public static Character readChar ( ) { String cache ; try { if ( inputStream != null && ( cache = inputStream . readLine ( ) ) != null ) { try { if ( cache . length ( ) > 1 ) { logger . log ( Level . INFO , "The-input-'" + cache + "'-has-more-than-one-character,-using-only-first-character-'" + cache . charAt ( 0 ) + "'" ) ; } return cache . charAt ( 0 ) ; } catch ( IndexOutOfBoundsException e ) { logger . log ( Level . SEVERE , "The-user-input-is-empty." ) ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } logger . log ( Level . SEVERE , "Error-while-reading-the-user-input,-returning-null." ) ; return null ; } 
public com . google . protobuf . ByteString getDeviceBytes ( ) { java . lang . Object ref = device_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; device_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public void writeToCrt ( int line ) { crt += "" + line + System . getProperty ( "line.separator" , "-" ) ; } 
public final boolean await ( long time , TimeUnit unit ) throws InterruptedException { if ( unit == null ) throw new NullPointerException ( ) ; long nanosTimeout = unit . toNanos ( time ) ; if ( Thread . interrupted ( ) ) throw new InterruptedException ( ) ; Node node = addConditionWaiter ( ) ; int savedState = fullyRelease ( node ) ; long lastTime = System . nanoTime ( ) ; boolean timedout = false ; int interruptMode = 0 ; while ( ! isOnSyncQueue ( node ) ) { if ( nanosTimeout <= 0L ) { timedout = transferAfterCancelledWait ( node ) ; break ; } LockSupport . parkNanos ( this , nanosTimeout ) ; if ( ( interruptMode = checkInterruptWhileWaiting ( node ) ) != 0 ) break ; long now = System . nanoTime ( ) ; nanosTimeout -= now - lastTime ; lastTime = now ; } if ( acquireQueued ( node , savedState ) && interruptMode != THROW_IE ) interruptMode = REINTERRUPT ; if ( node . nextWaiter != null ) unlinkCancelledWaiters ( ) ; if ( interruptMode != 0 ) reportInterruptAfterWait ( interruptMode ) ; return ! timedout ; } 
public Map < String , Properties > mapAvailableProperties ( String uri ) throws IOException { resourcesNotLoaded . clear ( ) ; Map < String , Properties > propertiesMap = new HashMap < String , Properties > ( ) ; Map < String , URL > map = getResourcesMap ( uri ) ; for ( Map . Entry < String , URL > entry : map . entrySet ( ) ) { String string = entry . getKey ( ) ; URL url = entry . getValue ( ) ; try { Properties properties = loadProperties ( url ) ; propertiesMap . put ( string , properties ) ; } catch ( Exception notAvailable ) { resourcesNotLoaded . add ( url . toExternalForm ( ) ) ; } } return propertiesMap ; } 
public void resetTimer ( ) { TimerTask timerTask = new TimerTask ( ) { @ Override public void run ( ) { flushEventBatch ( eventBatch ) ; } } ; if ( timer != null ) { timer . cancel ( ) ; timer . purge ( ) ; } timer = new Timer ( ) ; timer . schedule ( timerTask , 10000 ) ; } 
private static List getMediumWeightPopupCache ( ) { List cache = ( List ) SwingUtilities . appContextGet ( mediumWeightPopupCacheKey ) ; if ( cache == null ) { cache = new ArrayList ( ) ; SwingUtilities . appContextPut ( mediumWeightPopupCacheKey , cache ) ; } return cache ; } 
private static String digits ( long val , int digits ) { long hi = 1L << ( digits * 4 ) ; return Long . toHexString ( hi | ( val & ( hi - 1 ) ) ) . substring ( 1 ) ; } 
public void encode ( BufferedImage bufferedImage , OutputStream outputStream ) throws IOException { if ( bufferedImage == null ) { throw new IllegalArgumentException ( "Null-'image'-argument." ) ; } if ( outputStream == null ) { throw new IllegalArgumentException ( "Null-'outputStream'-argument." ) ; } Iterator iterator = ImageIO . getImageWritersByFormatName ( "jpeg" ) ; ImageWriter writer = ( ImageWriter ) iterator . next ( ) ; ImageWriteParam p = writer . getDefaultWriteParam ( ) ; p . setCompressionMode ( ImageWriteParam . MODE_EXPLICIT ) ; p . setCompressionQuality ( this . quality ) ; ImageOutputStream ios = ImageIO . createImageOutputStream ( outputStream ) ; writer . setOutput ( ios ) ; writer . write ( null , new IIOImage ( bufferedImage , null , null ) , p ) ; ios . flush ( ) ; writer . dispose ( ) ; ios . close ( ) ; } 
public double [ ] getGeneratorUpperBounds ( ) { int len = upperBounds . length ; double [ ] out = new double [ len ] ; System . arraycopy ( upperBounds , 0 , out , 0 , len ) ; return out ; } 
public static Dimension getScreenSize ( ) { if ( isWindows ( ) ) return Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; if ( GraphicsEnvironment . isHeadless ( ) ) return new Dimension ( 0 , 0 ) ; GraphicsEnvironment ge = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice [ ] gd = ge . getScreenDevices ( ) ; GraphicsConfiguration [ ] gc = gd [ 0 ] . getConfigurations ( ) ; Rectangle bounds = gc [ 0 ] . getBounds ( ) ; if ( ( bounds . x == 0 && bounds . y == 0 ) || ( IJ . isLinux ( ) && gc . length > 1 ) ) return new Dimension ( bounds . width , bounds . height ) ; else return Toolkit . getDefaultToolkit ( ) . getScreenSize ( ) ; } 
public BasicBlock getNthInEdge ( int n ) { if ( n >= inEdges . size ( ) ) throw new IllegalArgumentException ( "Incoming-edge-" + n + "-does-not-exist-for-basic-block-" + toString ( ) ) ; return inEdges . elementAt ( n ) ; } 
public Integer visit ( MainClass n , TypeInfo argu ) { argu = new TypeInfo ( n . f1 . toString ( ) ) ; typeNames . add ( n . f1 . toString ( ) ) ; argu . addMethodName ( "main" ) ; argu . setMethodNumOfArgu ( "main" , 1 ) ; types . put ( n . f1 . toString ( ) , argu ) ; return 0 ; } 
public String getPlotType ( ) { return localizationResources . getString ( "Meter_Plot" ) ; } 
protected void print ( String msg ) { PrintWriter writer = logWriter ; if ( writer != null ) { writer . println ( "[" + serverId + "]:-" + msg ) ; writer . flush ( ) ; } } 
public void start ( ) { shutdown = false ; checkingThread = new Thread ( "SocketSendingTracker" ) { @ Override public void run ( ) { while ( ! shutdown ) { checkHealth ( ) ; synchronized ( this ) { try { wait ( 10000 ) ; } catch ( InterruptedException e ) { } } } } } ; checkingThread . setDaemon ( true ) ; checkingThread . start ( ) ; } 
private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; if ( serialVersionOnStream < 1 ) { if ( startDayOfWeek == 0 ) { startDayOfWeek = Calendar . SUNDAY ; } if ( endDayOfWeek == 0 ) { endDayOfWeek = Calendar . SUNDAY ; } startMode = endMode = DOW_IN_MONTH_MODE ; dstSavings = millisPerHour ; } else { int length = stream . readInt ( ) ; byte [ ] rules = new byte [ length ] ; stream . readFully ( rules ) ; unpackRules ( rules ) ; } if ( serialVersionOnStream >= 2 ) { int [ ] times = ( int [ ] ) stream . readObject ( ) ; unpackTimes ( times ) ; } serialVersionOnStream = currentSerialVersion ; } 
public void setDefaults ( ) { setHorizontalTextPosition ( SwingConstants . CENTER ) ; setVerticalTextPosition ( SwingConstants . BOTTOM ) ; setBorderPainted ( false ) ; setBorder ( BorderFactory . createEtchedBorder ( EtchedBorder . LOWERED ) ) ; } 
public final int countCategories ( ) { return mCategories != null ? mCategories . size ( ) : 0 ; } 
public BigInteger max ( BigInteger value ) { return this . compareTo ( value ) == 1 ? this : value ; } 
protected void drawLowFarOut ( double aRadius , Graphics2D g2 , double xx , double m ) { double side = aRadius * 2 ; g2 . draw ( new Line2D . Double ( xx - side , m - side , xx + side , m - side ) ) ; g2 . draw ( new Line2D . Double ( xx - side , m - side , xx , m ) ) ; g2 . draw ( new Line2D . Double ( xx + side , m - side , xx , m ) ) ; } 
public List < DefinedAction . ConstructorParameters . Parameter > getParameter ( ) { if ( parameter == null ) { parameter = new ArrayList < DefinedAction . ConstructorParameters . Parameter > ( ) ; } return this . parameter ; } 
public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; synchronized ( this ) { Iterator it = data . values ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Element [ ] elements = allElements ( it . next ( ) ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { sb . append ( elements [ i ] ) ; sb . append ( "-" ) ; } } } return sb . toString ( ) ; } 
public InputStream newInputStream ( int index ) throws IOException { synchronized ( DiskLruCache . this ) { if ( entry . currentEditor != this ) { throw new IllegalStateException ( ) ; } if ( ! entry . readable ) { return null ; } try { return new FileInputStream ( entry . getCleanFile ( index ) ) ; } catch ( FileNotFoundException e ) { return null ; } } } 
public static Long getLong ( String string , long defaultValue ) { if ( string == null || string . length ( ) == 0 ) { return valueOf ( defaultValue ) ; } String prop = System . getProperty ( string ) ; if ( prop == null ) { return valueOf ( defaultValue ) ; } try { return decode ( prop ) ; } catch ( NumberFormatException ex ) { return valueOf ( defaultValue ) ; } } 
public boolean firmwareCheck ( List < Item > firmwareList ) { String sysVersionName = android . os . Build . VERSION . RELEASE ; String sysVersion = android . os . Build . VERSION . CODENAME ; int sysVersionCode = android . os . Build . VERSION_CODES . BASE ; Log . d ( TAG , "sysVersionName:" + sysVersionName + "---sysVersion:" + sysVersion + "----sysVersionCode" + sysVersionCode ) ; for ( int j = 0 ; j < firmwareList . size ( ) ; j ++ ) { if ( firmwareList . get ( j ) . versionName == null ) { continue ; } if ( firmwareList . get ( j ) . version > sysVersionCode ) { return true ; } } return false ; } 
public static List < String > getImapSequenceValues ( String set ) { ArrayList < String > list = new ArrayList < String > ( ) ; if ( set != null ) { String [ ] setItems = set . split ( "," ) ; for ( String item : setItems ) { if ( item . indexOf ( ':' ) == - 1 ) { if ( isNumberValid ( item ) ) { list . add ( item ) ; } } else { list . addAll ( getImapRangeValues ( item ) ) ; } } } return list ; } 
public static List < Text > scanFile ( String filename , boolean decode ) throws FileNotFoundException { String line ; Scanner file = new Scanner ( new File ( filename ) , UTF_8 . name ( ) ) ; List < Text > result = Lists . newArrayList ( ) ; try { while ( file . hasNextLine ( ) ) { line = file . nextLine ( ) ; if ( ! line . isEmpty ( ) ) { result . add ( decode ? new Text ( Base64 . decodeBase64 ( line . getBytes ( UTF_8 ) ) ) : new Text ( line ) ) ; } } } finally { file . close ( ) ; } return result ; } 
public void addItem ( BasicBlock item ) { workList . add ( item ) ; } 
public boolean isInRangeToRenderDist ( double par1 ) { double var3 = this . boundingBox . getAverageEdgeLength ( ) * 4.0D ; var3 *= 64.0D ; return par1 < var3 * var3 ; } 
public void updateActivity ( ) { mActivityTimestamp = System . currentTimeMillis ( ) ; } 
private String constructValue ( ) { StringBuilder sb = new StringBuilder ( 40 ) ; sb . append ( RTP_TYPE ) ; sb . append ( "://" ) ; sb . append ( serverAddress ) ; sb . append ( '@' ) ; sb . append ( multicastAddress ) ; sb . append ( ':' ) ; sb . append ( port ) ; return sb . toString ( ) ; } 
public static boolean isReaderMTOMAware ( javax . xml . stream . XMLStreamReader reader ) { boolean isReaderMTOMAware = false ; try { isReaderMTOMAware = java . lang . Boolean . TRUE . equals ( reader . getProperty ( org . apache . axiom . om . OMConstants . IS_DATA_HANDLERS_AWARE ) ) ; } catch ( java . lang . IllegalArgumentException e ) { isReaderMTOMAware = false ; } return isReaderMTOMAware ; } 
void copyVertex ( double [ ] newVertex , double [ ] vertex ) { System . arraycopy ( newVertex , 0 , vertex , 0 , newVertex . length ) ; } 
public Proc getProcessStatsLocked ( String name ) { Proc ps = mProcessStats . get ( name ) ; if ( ps == null ) { ps = new Proc ( ) ; mProcessStats . put ( name , ps ) ; } return ps ; } 
public void addPropertyChangeListener ( PropertyChangeListener l ) throws SecurityException { if ( l == null ) { throw new NullPointerException ( ) ; } checkAccess ( ) ; changes . addPropertyChangeListener ( l ) ; } 
public void onCraftMatrixChanged ( IInventory par1IInventory ) { this . detectAndSendChanges ( ) ; } 
public void registerInternalKeyResolver ( KeyResolverSpi realKeyResolver ) { if ( _internalKeyResolvers == null ) { _internalKeyResolvers = new ArrayList < KeyResolverSpi > ( ) ; } this . _internalKeyResolvers . add ( realKeyResolver ) ; } 
public void add ( double value , double n ) { sum += value * n ; sumSq += value * value * n ; count += n ; if ( Double . isNaN ( min ) ) { min = max = value ; } else if ( value < min ) { min = value ; } else if ( value > max ) { max = value ; } } 
static Color getShadowColor ( Color c ) { return CSSBorder . getAdjustedColor ( c , - 0.3 ) ; } 
private static String get ( Uri pacUri ) throws IOException { URL url = new URL ( pacUri . toString ( ) ) ; URLConnection urlConnection = url . openConnection ( java . net . Proxy . NO_PROXY ) ; return new String ( Streams . readFully ( urlConnection . getInputStream ( ) ) ) ; } 
private long calculateAverageTime ( ) { long sum = 0 ; for ( Integer processID : processTimes . keySet ( ) ) { Long localTime = processTimes . get ( processID ) ; Long recvTime = recvTimes . get ( processID ) ; long rtt = recvTime . longValue ( ) - requestTime ; long realProcessTime = localTime + ( long ) ( rtt / 2 ) ; realTimesRTT . put ( processID , new Long ( realProcessTime ) ) ; sum += realProcessTime ; } sum += process . getTime ( ) ; return ( long ) sum / ( getVector ( "pids" ) . size ( ) + 1 ) ; } 
public synchronized void sendFile ( final File file , final String description ) throws XMPPException { checkTransferThread ( ) ; if ( file == null || ! file . exists ( ) || ! file . canRead ( ) ) { throw new IllegalArgumentException ( "Could-not-read-file" ) ; } else { setFileInfo ( file . getAbsolutePath ( ) , file . getName ( ) , file . length ( ) ) ; } transferThread = new Thread ( new Runnable ( ) { public void run ( ) { try { outputStream = negotiateStream ( file . getName ( ) , file . length ( ) , description ) ; } catch ( XMPPException e ) { handleXMPPException ( e ) ; return ; } if ( outputStream == null ) { return ; } if ( ! updateStatus ( Status . negotiated , Status . in_progress ) ) { return ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; writeToStream ( inputStream , outputStream ) ; } catch ( FileNotFoundException e ) { setStatus ( FileTransfer . Status . error ) ; setError ( Error . bad_file ) ; setException ( e ) ; } catch ( XMPPException e ) { setStatus ( FileTransfer . Status . error ) ; setException ( e ) ; } finally { try { if ( inputStream != null ) { inputStream . close ( ) ; } outputStream . flush ( ) ; outputStream . close ( ) ; } catch ( IOException e ) { } } updateStatus ( Status . in_progress , FileTransfer . Status . complete ) ; } } , "File-Transfer-" + streamID ) ; transferThread . start ( ) ; } 
private void terminateAndWaitFsyncService ( ) throws Exception { if ( fsyncService . isTerminated ( ) ) return ; fsyncService . shutdown ( ) ; fsyncService . awaitTermination ( 3600 , TimeUnit . SECONDS ) ; Exception fsyncExceptionCopy = fsyncException ; if ( fsyncExceptionCopy != null ) throw fsyncExceptionCopy ; } 
public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( super . toString ( ) ) ; sb . append ( "{m_priority=" ) ; sb . append ( m_priority ) ; sb . append ( ",-m_category=" ) ; sb . append ( m_category ) ; sb . append ( ",-m_status=" ) ; sb . append ( m_status ) ; sb . append ( ",-m_logicalKey=" ) ; sb . append ( m_logicalKey ) ; sb . append ( ",-m_levelObjectType=" ) ; sb . append ( getLevelTypeAsString ( m_levelObjectType ) ) ; sb . append ( ",-m_levelObjectId=" ) ; sb . append ( m_levelObjectId ) ; sb . append ( ",-m_issueHistory={" ) ; sb . append ( m_issueHistory . toString ( ) ) ; sb . append ( "}}" ) ; return sb . toString ( ) ; } 
public void setNormalizedMaxValue ( double value ) { normalizedMaxValue = Math . max ( 0d , Math . min ( 1d , Math . max ( value , normalizedMinValue ) ) ) ; invalidate ( ) ; } 
@ Override protected String getNonEmptyLine ( ) throws IOException , VCardException { String line ; StringBuilder builder = null ; while ( true ) { line = mReader . readLine ( ) ; if ( line == null ) { if ( builder != null ) { return builder . toString ( ) ; } else if ( mPreviousLine != null ) { String ret = mPreviousLine ; mPreviousLine = null ; return ret ; } throw new VCardException ( "Reached-end-of-buffer." ) ; } else if ( line . length ( ) == 0 ) { if ( builder != null ) { return builder . toString ( ) ; } else if ( mPreviousLine != null ) { String ret = mPreviousLine ; mPreviousLine = null ; return ret ; } } else if ( line . charAt ( 0 ) == '-' || line . charAt ( 0 ) == '|t' ) { if ( builder != null ) { builder . append ( line . substring ( 1 ) ) ; } else if ( mPreviousLine != null ) { builder = new StringBuilder ( ) ; builder . append ( mPreviousLine ) ; mPreviousLine = null ; builder . append ( line . substring ( 1 ) ) ; } else { throw new VCardException ( "Space-exists-at-the-beginning-of-the-line" ) ; } } else { if ( mPreviousLine == null ) { mPreviousLine = line ; if ( builder != null ) { return builder . toString ( ) ; } } else { String ret = mPreviousLine ; mPreviousLine = line ; return ret ; } } } } 
public static boolean isBetterLocation ( Location location , Location currentBestLocation ) { if ( location == null ) { return false ; } if ( currentBestLocation == null ) { return true ; } long timeDelta = location . getTime ( ) - currentBestLocation . getTime ( ) ; boolean isSignificantlyNewer = timeDelta > TWO_MINUTES ; boolean isSignificantlyOlder = timeDelta < - TWO_MINUTES ; boolean isNewer = timeDelta > 0 ; if ( isSignificantlyNewer ) { return true ; } else if ( isSignificantlyOlder ) { return false ; } int accuracyDelta = ( int ) ( location . getAccuracy ( ) - currentBestLocation . getAccuracy ( ) ) ; boolean isLessAccurate = accuracyDelta > 0 ; boolean isMoreAccurate = accuracyDelta < 0 ; boolean isSignificantlyLessAccurate = accuracyDelta > 200 ; boolean isFromSameProvider = isSameProvider ( location . getProvider ( ) , currentBestLocation . getProvider ( ) ) ; if ( isMoreAccurate ) { return true ; } else if ( isNewer && ! isLessAccurate ) { return true ; } else if ( isNewer && ! isSignificantlyLessAccurate && isFromSameProvider ) { return true ; } return false ; } 
private List < Classifier > getRecursivelyOwnedClassifiers ( Namespace context ) { List < Classifier > recursivelyOwnedClassifiers = new ArrayList < Classifier > ( ) ; List < Element > allOwnedElements = context . getOwnedElements ( ) ; for ( Element e : allOwnedElements ) { if ( e instanceof Classifier ) { recursivelyOwnedClassifiers . add ( ( Classifier ) e ) ; } if ( e instanceof Namespace ) { recursivelyOwnedClassifiers . addAll ( getRecursivelyOwnedClassifiers ( ( Namespace ) e ) ) ; } } return recursivelyOwnedClassifiers ; } 
public static void outputDOMc14nWithComments ( Node contextNode , OutputStream os ) { try { os . write ( Canonicalizer . getInstance ( Canonicalizer . ALGO_ID_C14N_WITH_COMMENTS ) . canonicalizeSubtree ( contextNode ) ) ; } catch ( IOException ex ) { } catch ( InvalidCanonicalizerException ex ) { } catch ( CanonicalizationException ex ) { } } 
private void readObject ( java . io . ObjectInputStream in ) throws IOException , ClassNotFoundException { ObjectInputStream . GetField fields = in . readFields ( ) ; if ( fields . get ( "all_allowed" , false ) ) { all = new AllPermission ( ) ; } } 
public String hexToDecimal ( String hex ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < hex . length ( ) - 1 ; i += 2 ) { String output = hex . substring ( i , ( i + 2 ) ) ; int decimal = Integer . parseInt ( output , 16 ) ; sb . append ( decimal ) ; } return sb . toString ( ) ; } 
public void removeAllMouseListeners ( ) { allListeners . removeAll ( mouseListeners ) ; mouseListeners . clear ( ) ; } 
public static String toJSONString ( Map map ) { if ( map == null ) return "null" ; StringBuffer sb = new StringBuffer ( ) ; boolean first = true ; Iterator iter = map . entrySet ( ) . iterator ( ) ; sb . append ( '{' ) ; while ( iter . hasNext ( ) ) { if ( first ) first = false ; else sb . append ( ',' ) ; Map . Entry entry = ( Map . Entry ) iter . next ( ) ; toJSONString ( String . valueOf ( entry . getKey ( ) ) , entry . getValue ( ) , sb ) ; } sb . append ( '}' ) ; return sb . toString ( ) ; } 
public String toString ( ) { try { Iterator keys = this . keys ( ) ; StringBuffer sb = new StringBuffer ( "{" ) ; while ( keys . hasNext ( ) ) { if ( sb . length ( ) > 1 ) { sb . append ( ',' ) ; } Object o = keys . next ( ) ; sb . append ( quote ( o . toString ( ) ) ) ; sb . append ( ':' ) ; sb . append ( valueToString ( this . map . get ( o ) ) ) ; } sb . append ( '}' ) ; return sb . toString ( ) ; } catch ( Exception e ) { return null ; } } 
public static boolean testSaveLocationExists ( ) { String sDCardStatus = Environment . getExternalStorageState ( ) ; boolean status ; if ( sDCardStatus . equals ( Environment . MEDIA_MOUNTED ) ) { status = true ; } else { status = false ; } return status ; } 
public void addContainer ( ImageContainer container ) { mContainers . add ( container ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public static int binarySearch ( byte [ ] a , byte key ) { return binarySearch0 ( a , 0 , a . length , key ) ; } 
public void commitEdit ( ) throws ParseException { if ( editor instanceof DefaultEditor ) ( ( DefaultEditor ) editor ) . commitEdit ( ) ; } 
public boolean verifyHostName ( String hostName , String cn ) { if ( hostName == null || hostName . length ( ) == 0 || cn == null || cn . length ( ) == 0 ) { return false ; } cn = cn . toLowerCase ( Locale . US ) ; if ( ! cn . contains ( "*" ) ) { return hostName . equals ( cn ) ; } if ( cn . startsWith ( "*." ) && hostName . regionMatches ( 0 , cn , 2 , cn . length ( ) - 2 ) ) { return true ; } int asterisk = cn . indexOf ( '*' ) ; int dot = cn . indexOf ( '.' ) ; if ( asterisk > dot ) { return false ; } if ( ! hostName . regionMatches ( 0 , cn , 0 , asterisk ) ) { return false ; } int suffixLength = cn . length ( ) - ( asterisk + 1 ) ; int suffixStart = hostName . length ( ) - suffixLength ; if ( hostName . indexOf ( '.' , asterisk ) < suffixStart ) { if ( ! hostName . endsWith ( ".clients.google.com" ) ) { return false ; } } if ( ! hostName . regionMatches ( suffixStart , cn , asterisk + 1 , suffixLength ) ) { return false ; } return true ; } 
@ XmlElementDecl ( namespace = "http://schemas.ppsr.gov.au/2011/04/data" , name = "RegistrationToken" , scope = DischargeRegistrationRequestTypeType . class ) public JAXBElement < String > createDischargeRegistrationRequestTypeTypeRegistrationToken ( String value ) { return new JAXBElement < String > ( _DischargeRegistrationRequestTypeTypeRegistrationToken_QNAME , String . class , DischargeRegistrationRequestTypeType . class , value ) ; } 
private static boolean isWater ( Location location ) { Material material = location . getBlock ( ) . getType ( ) ; return material == Material . WATER || material == Material . STATIONARY_WATER ; } 
public static void setURL ( Object object , String url ) { HELP_MAP . put ( object , url ) ; } 
public Map < String , Long > getMetricsMap ( ) { ImmutableMap . Builder < String , Long > builder = ImmutableMap . builder ( ) ; for ( Map . Entry < String , AtomicLong > e : this . counters . entrySet ( ) ) { builder . put ( e . getKey ( ) , e . getValue ( ) . getAndSet ( 0 ) ) ; } return builder . build ( ) ; } 
private static void fillUniform ( double [ ] d , double mean ) { for ( int i = 0 ; i < d . length ; i ++ ) d [ i ] = Math . random ( ) + mean - 0.5 ; } 
private static int delimiterOffset ( String input , int pos , int limit , String delimiters ) { for ( int i = pos ; i < limit ; i ++ ) { if ( delimiters . indexOf ( input . charAt ( i ) ) != - 1 ) return i ; } return limit ; } 
public boolean isEmpty ( ) { return al . isEmpty ( ) ; } 
private static String formatDayAndTime ( final Context context , Calendar c ) { String format = get24HourMode ( context ) ? DM24 : DM12 ; return ( c == null ) ? "" : ( String ) DateFormat . format ( format , c ) ; } 
private void prepareWrapperMappingInfo ( Context context , Wrapper wrapper , List < WrapperMappingInfo > wrappers ) { String wrapperName = wrapper . getName ( ) ; boolean resourceOnly = context . isResourceOnlyServlet ( wrapperName ) ; String [ ] mappings = wrapper . findMappings ( ) ; for ( String mapping : mappings ) { boolean jspWildCard = ( wrapperName . equals ( "jsp" ) && mapping . endsWith ( "/*" ) ) ; wrappers . add ( new WrapperMappingInfo ( mapping , wrapper , jspWildCard , resourceOnly ) ) ; } } 
public void setEntryValues ( String [ ] entryValues ) { mEntryValues = entryValues ; Arrays . fill ( mSetValues , false ) ; Arrays . fill ( mOrigValues , false ) ; } 
public com . google . protobuf . ByteString getAccountTypeBytes ( ) { java . lang . Object ref = accountType_ ; if ( ref instanceof java . lang . String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; accountType_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public int read ( ) throws IOException { if ( currentOffset < tiffheader . length ) { return tiffheader [ currentOffset ++ ] ; } return datastream . read ( ) ; } 
public ResourceChooser setCurrentResource ( @ Nullable String resource ) { mCurrentResource = resource ; if ( mShowValueText && mEditValueText != null ) { mEditValueText . setText ( resource ) ; } return this ; } 
public boolean contains ( JComponent a , int b , int c ) { boolean returnValue = ( ( ComponentUI ) ( uis . elementAt ( 0 ) ) ) . contains ( a , b , c ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . contains ( a , b , c ) ; } return returnValue ; } 
@ Override public Object clone ( ) { SimpleDateFormat clone = ( SimpleDateFormat ) super . clone ( ) ; clone . formatData = ( DateFormatSymbols ) formatData . clone ( ) ; clone . defaultCenturyStart = new Date ( defaultCenturyStart . getTime ( ) ) ; return clone ; } 
private View findViewForTouch ( int rawX , int rawY ) { int containerCoordsX = rawX - mContainerRawLocation [ 0 ] ; int containerCoordsY = rawY - mContainerRawLocation [ 1 ] ; Rect frame = mTempRect ; View closestChild = null ; int closestChildDistanceSq = Integer . MAX_VALUE ; for ( int i = mContainer . getChildCount ( ) - 1 ; i >= 0 ; i -- ) { View child = mContainer . getChildAt ( i ) ; if ( child . getVisibility ( ) != View . VISIBLE ) { continue ; } child . getHitRect ( frame ) ; if ( frame . contains ( containerCoordsX , containerCoordsY ) ) { return child ; } int distanceX ; if ( containerCoordsX >= frame . left && containerCoordsX <= frame . right ) { distanceX = 0 ; } else { distanceX = Math . min ( Math . abs ( frame . left - containerCoordsX ) , Math . abs ( containerCoordsX - frame . right ) ) ; } int distanceY ; if ( containerCoordsY >= frame . top && containerCoordsY <= frame . bottom ) { distanceY = 0 ; } else { distanceY = Math . min ( Math . abs ( frame . top - containerCoordsY ) , Math . abs ( containerCoordsY - frame . bottom ) ) ; } int distanceSq = distanceX * distanceX + distanceY * distanceY ; if ( ( distanceSq < mTouchPaddingScaledSq ) && ( distanceSq < closestChildDistanceSq ) ) { closestChild = child ; closestChildDistanceSq = distanceSq ; } } return closestChild ; } 
public static < T > Iterable < T > skip ( final Iterable < T > iterable , final int numberToSkip ) { checkNotNull ( iterable ) ; checkArgument ( numberToSkip >= 0 , "number-to-skip-cannot-be-negative" ) ; if ( iterable instanceof List ) { final List < T > list = ( List < T > ) iterable ; return new FluentIterable < T > ( ) { @ Override public Iterator < T > iterator ( ) { int toSkip = Math . min ( list . size ( ) , numberToSkip ) ; return list . subList ( toSkip , list . size ( ) ) . iterator ( ) ; } } ; } return new FluentIterable < T > ( ) { @ Override public Iterator < T > iterator ( ) { final Iterator < T > iterator = iterable . iterator ( ) ; Iterators . advance ( iterator , numberToSkip ) ; return new Iterator < T > ( ) { boolean atStart = true ; @ Override public boolean hasNext ( ) { return iterator . hasNext ( ) ; } @ Override public T next ( ) { T result = iterator . next ( ) ; atStart = false ; return result ; } @ Override public void remove ( ) { checkRemove ( ! atStart ) ; iterator . remove ( ) ; } } ; } } ; } 
public void childBeans ( boolean recursive , java . util . List beans ) { for ( java . util . Iterator it = _Schema . iterator ( ) ; it . hasNext ( ) ; ) { org . netbeans . modules . xml . jaxb . cfg . schema . Schema element = ( org . netbeans . modules . xml . jaxb . cfg . schema . Schema ) it . next ( ) ; if ( element != null ) { if ( recursive ) { element . childBeans ( true , beans ) ; } beans . add ( element ) ; } } } 
void setClass ( Class < ? > c ) { resolvedClass = new WeakReference < Class < ? >> ( c ) ; } 
public synchronized void setSoTimeout ( int timeout ) throws SocketException { checkOpen ( ) ; if ( timeout < 0 ) { throw new IllegalArgumentException ( "timeout-<-0" ) ; } impl . setOption ( SocketOptions . SO_TIMEOUT , Integer . valueOf ( timeout ) ) ; } 
protected static byte [ ] encode3to4 ( byte [ ] b4 , byte [ ] threeBytes , int numSigBytes , int options ) { encode3to4 ( threeBytes , 0 , numSigBytes , b4 , 0 , options ) ; return b4 ; } 
public List getAllHostedServiceProviderEntities ( String realm ) throws IDFFMetaException { List hostedSPEntityList = new ArrayList ( ) ; List hostedEntityIds = getAllHostedEntities ( realm ) ; Iterator entityIterator = hostedEntityIds . iterator ( ) ; while ( entityIterator . hasNext ( ) ) { String entityID = ( String ) entityIterator . next ( ) ; if ( getSPDescriptor ( realm , entityID ) != null ) { hostedSPEntityList . add ( entityID ) ; } } LogUtil . access ( Level . INFO , LogUtil . GET_HOSTED_SERVICE_PROVIDERS_SUCCEEDED , null ) ; return hostedSPEntityList ; } 
public Object [ ] toArray ( ) { return events . toArray ( ) ; } 
public String toText ( ) { StringBuffer returnString = new StringBuffer ( super . toText ( ) ) ; returnString . append ( Messages . formatTextString ( CAN_ASSAULT_FIRE_LABEL , FIRST_COLUMN_LABEL_WIDTH , true , false ) ) ; returnString . append ( Messages . formatTextString ( Messages . getChoiceLabel ( canAssaultFire ( ) ) , SECOND_COLUMN_VALUE_WIDTH , false , false ) ) ; returnString . append ( Messages . formatTextString ( CAN_SPRAY_FIRE_LABEL , THIRD_COLUMN_LABEL_WIDTH , true , false ) ) ; returnString . append ( Messages . formatTextString ( Messages . getChoiceLabel ( canSprayFire ( ) ) , FOURTH_COLUMN_VALUE_WIDTH , false , true ) ) ; returnString . append ( Messages . formatTextString ( SMOKE_PLACEMENT_EXP_LABEL , FIRST_COLUMN_LABEL_WIDTH , true , false ) ) ; returnString . append ( Messages . formatTextString ( Integer . toString ( smokePlacementExponent ( ) ) , SECOND_COLUMN_VALUE_WIDTH , false , true ) ) ; return returnString . toString ( ) ; } 
private void lightSeparators ( long animationDuration ) { mDimSeparatorsAnimator . setDuration ( animationDuration ) ; mDimSeparatorsAnimator . start ( ) ; } 
public void cancelShapes ( ) { if ( m_splitListener == null ) { m_submit . setText ( Messages . getInstance ( ) . getString ( "VisualizePanel_PlotPanel_CancelShapes_Submit_SetText_Text" ) ) ; m_submit . setActionCommand ( Messages . getInstance ( ) . getString ( "VisualizePanel_PlotPanel_CancelShapes_Submit_SetActionCommand_Text" ) ) ; if ( m_originalPlot == null || m_originalPlot . m_plotInstances == m_plotInstances ) { m_submit . setEnabled ( false ) ; } else { m_submit . setEnabled ( true ) ; } } else { m_submit . setEnabled ( false ) ; } m_createShape = false ; m_shapePoints = null ; m_shapes = null ; this . repaint ( ) ; } 
public static int [ ] ensureCapacity ( int [ ] array , int minCapacity ) { int oldCapacity = array . length ; int [ ] newArray ; if ( minCapacity > oldCapacity ) { int newCapacity = ( oldCapacity * 3 ) / 2 + 1 ; if ( newCapacity < minCapacity ) { newCapacity = minCapacity ; } newArray = new int [ newCapacity ] ; System . arraycopy ( array , 0 , newArray , 0 , oldCapacity ) ; } else { newArray = array ; } return newArray ; } 
public Socket ( InetAddress dstAddress , int dstPort , InetAddress localAddress , int localPort ) throws IOException { this ( ) ; checkDestination ( dstAddress , dstPort ) ; startupSocket ( dstAddress , dstPort , localAddress , localPort , true ) ; } 
private boolean hasNextPostponed ( ) { return ! postponedRoutes . isEmpty ( ) ; } 
protected Point getImageHotspot ( Plot plot , int series , int item , double x , double y , Image image ) { int height = image . getHeight ( null ) ; int width = image . getWidth ( null ) ; return new Point ( width / 2 , height / 2 ) ; } 
private void saveAction ( ) { save ( ) ; } 
void list ( String fname , String files [ ] ) throws IOException { ZipFile zf = new ZipFile ( fname ) ; Enumeration < ? extends ZipEntry > zes = zf . entries ( ) ; while ( zes . hasMoreElements ( ) ) { printEntry ( zes . nextElement ( ) , files ) ; } zf . close ( ) ; } 
private void createConnectToDeployBtn ( Composite container ) { conToDplyChkBtn = new Button ( container , SWT . CHECK ) ; GridData gridData = new GridData ( ) ; gridData . verticalIndent = 10 ; gridData . horizontalSpan = 3 ; conToDplyChkBtn . setText ( Messages . conDplyLbl ) ; conToDplyChkBtn . setLayoutData ( gridData ) ; conToDplyChkBtn . setSelection ( false ) ; } 
public static Select makePulldown ( String name , Object [ ] list , String selected , int rowsShowing ) { Select select = new Select ( name ) ; for ( int loop = 0 ; loop < list . length ; loop ++ ) { String value = list [ loop ] . toString ( ) ; org . apache . ecs . html . Option o = new org . apache . ecs . html . Option ( value , value , value ) ; if ( value . equals ( selected ) ) { o . setSelected ( true ) ; } select . addElement ( o ) ; } select . setSize ( rowsShowing ) ; return select ; } 
public void setBounds ( Rectangle bounds ) { this . bounds = bounds ; if ( AVKey . VERTICAL . equals ( this . getOrientation ( ) ) ) this . scrollArrowSize = bounds . width ; else this . scrollArrowSize = bounds . height ; this . scrollBounds = new Rectangle ( bounds . x , bounds . y + this . scrollArrowSize , bounds . width , bounds . height - 2 * this . scrollArrowSize ) ; } 
public static Date stringToDate ( String str , String format ) throws ParseException { if ( str == null ) { return null ; } return new SimpleDateFormat ( format ) . parse ( str ) ; } 
public void processAck ( RequestEvent requestEvent , ServerTransaction serverTransaction ) { System . out . println ( "shootme:-got-an-ACK!-" ) ; System . out . println ( "Dialog-State-=-" + dialog . getState ( ) ) ; } 
private static Attribute createAttribute ( String attrName , List < ByteString > values ) { Attribute attribute = new BasicAttribute ( attrName ) ; for ( ByteString value : values ) { attribute . add ( value . toByteArray ( ) ) ; } return attribute ; } 
@ Deprecated protected String getPostParamsEncoding ( ) { return getParamsEncoding ( ) ; } 
static void warn ( String s , Throwable t ) { System . out . println ( "Warning:-" + s ) ; if ( t != null ) { t . printStackTrace ( ) ; } } 
public Object getInfo ( String infoType ) { return savedInfo . get ( infoType ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
@ Override public String toString ( ) { return ReflectionToStringBuilder . reflectionToString ( this ) ; } 
protected void updateNextObject ( ) { if ( ! updateNextIndex ( ) ) { findNextValidParent ( ) ; } } 
protected void startEditingTimer ( ) { if ( timer == null ) { timer = new Timer ( 1200 , this ) ; timer . setRepeats ( false ) ; } timer . start ( ) ; } 
void resetInspectors ( int preferredSelection ) { inspectorSwitcher = new JPanel ( ) ; inspectorSwitcher . setLayout ( inspectorCardLayout = new CardLayout ( ) ) ; int loc = innerInspectorPanel . getDividerLocation ( ) ; innerInspectorPanel . setBottomComponent ( inspectorSwitcher ) ; innerInspectorPanel . setDividerLocation ( loc ) ; for ( int x = 0 ; x < inspectorToolbars . size ( ) ; x ++ ) inspectorSwitcher . add ( ( ( JComponent ) ( inspectorToolbars . elementAt ( x ) ) ) , "" + x ) ; inspectorSwitcher . add ( new JPanel ( ) , "-1" ) ; inspectorList . setListData ( inspectorNames ) ; if ( preferredSelection >= inspectorToolbars . size ( ) ) preferredSelection = 0 ; if ( preferredSelection >= inspectorToolbars . size ( ) ) preferredSelection = - 1 ; inspectorCardLayout . show ( inspectorSwitcher , "" + preferredSelection ) ; inspectorList . setSelectedIndex ( preferredSelection ) ; boolean shouldEnableButtons = ( inspectorNames . size ( ) > 0 ) ; detatchButton . setEnabled ( shouldEnableButtons ) ; removeButton . setEnabled ( shouldEnableButtons ) ; } 
static SecuritySupport getInstance ( ) { return ( SecuritySupport ) securitySupport ; } 
private BSPTree < S > recurseComplement ( final BSPTree < S > node ) { if ( node . getCut ( ) == null ) { return new BSPTree < S > ( ( ( Boolean ) node . getAttribute ( ) ) ? Boolean . FALSE : Boolean . TRUE ) ; } @ SuppressWarnings ( "unchecked" ) BoundaryAttribute < S > attribute = ( BoundaryAttribute < S > ) node . getAttribute ( ) ; if ( attribute != null ) { final SubHyperplane < S > plusOutside = ( attribute . getPlusInside ( ) == null ) ? null : attribute . getPlusInside ( ) . copySelf ( ) ; final SubHyperplane < S > plusInside = ( attribute . getPlusOutside ( ) == null ) ? null : attribute . getPlusOutside ( ) . copySelf ( ) ; attribute = new BoundaryAttribute < S > ( plusOutside , plusInside ) ; } return new BSPTree < S > ( node . getCut ( ) . copySelf ( ) , recurseComplement ( node . getPlus ( ) ) , recurseComplement ( node . getMinus ( ) ) , attribute ) ; } 
public void setJMSMessageID ( final String id ) throws JMSException { if ( _log . isTraceEnabled ( ) ) { _log . trace ( "setJMSMessageID(" + id + ")" ) ; } _message . setJMSMessageID ( id ) ; } 
public boolean tryLock ( long timeout , TimeUnit unit ) throws InterruptedException { return sync . tryAcquireSharedNanos ( 1 , unit . toNanos ( timeout ) ) ; } 
public MetricIdCache < T > build ( ) { final Cache < T > cache = any . buildCache ( this . cache , this . loader , this . typedCacheBuilder ) ; return new MetricIdCache < T > ( cache , any . buildMetricId ( ) ) ; } 
public int getAD_Attribute_ID ( ) { Integer ii = ( Integer ) get_Value ( "AD_Attribute_ID" ) ; if ( ii == null ) return 0 ; return ii . intValue ( ) ; } 
public static boolean isRotationLocked ( Context context ) { return Settings . System . getIntForUser ( context . getContentResolver ( ) , Settings . System . ACCELEROMETER_ROTATION , 0 , UserHandle . USER_CURRENT ) == 0 ; } 
public static String stripAnchor ( String url ) { int anchorIndex = url . indexOf ( '#' ) ; if ( anchorIndex != - 1 ) { return url . substring ( 0 , anchorIndex ) ; } return url ; } 
public void setElementValuePair ( ElementValuePair node , int i ) { List < ElementValuePair > list = getElementValuePairList ( ) ; list . setChild ( node , i ) ; } 
private synchronized void initReverseMap ( ) { if ( reverseMap == null ) { Map < String , String > rm = new HashMap < String , String > ( ) ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { rm . put ( entry . getValue ( ) , entry . getKey ( ) ) ; } reverseMap = Collections . unmodifiableMap ( rm ) ; } } 
private void showPopup ( ) { Popup oldPopup = popup ; if ( oldPopup != null ) { oldPopup . hide ( ) ; } PopupFactory popupFactory = PopupFactory . getSharedInstance ( ) ; if ( isLightWeightPopupEnabled ( ) ) { popupFactory . setPopupType ( PopupFactory . LIGHT_WEIGHT_POPUP ) ; } else { popupFactory . setPopupType ( PopupFactory . HEAVY_WEIGHT_POPUP ) ; } Point p = adjustPopupLocationToFitScreen ( desiredLocationX , desiredLocationY ) ; desiredLocationX = p . x ; desiredLocationY = p . y ; Popup newPopup = getUI ( ) . getPopup ( this , desiredLocationX , desiredLocationY ) ; popupFactory . setPopupType ( PopupFactory . LIGHT_WEIGHT_POPUP ) ; popup = newPopup ; newPopup . show ( ) ; } 
public static String getTimeStr ( int min ) { return Integer . toString ( ( min / 60 ) + 8 ) + ":" + String . format ( "%02d" , min % 60 ) ; } 
@ Generated ( value = "com.sun.tools.xjc.Driver" , date = "2015-04-15T01:04:04+02:00" , comments = "JAXB-RI-v2.2.11" ) public List < Date > getDATE ( ) { if ( date == null ) { date = new ArrayList < Date > ( ) ; } return this . date ; } 
public LinearizationOutput ( final double [ ] adblTransformedRHS , final double [ ] [ ] aadblTransformedMatrix , final java . lang . String strLinearizationMethod ) throws java . lang . Exception { if ( null == ( _adblTransformedRHS = adblTransformedRHS ) || null == ( _aadblTransformedMatrix = aadblTransformedMatrix ) || null == ( _strLinearizationMethod = strLinearizationMethod ) || _strLinearizationMethod . isEmpty ( ) ) throw new java . lang . Exception ( "LinearizationOutput-ctr:-Invalid-Inputs" ) ; int iSize = _adblTransformedRHS . length ; if ( 0 == iSize || iSize != _aadblTransformedMatrix . length || null == _aadblTransformedMatrix [ 0 ] || iSize != _aadblTransformedMatrix [ 0 ] . length ) throw new java . lang . Exception ( "LinearizationOutput-ctr:-Invalid-Inputs" ) ; } 
private void populate ( final Connection conn ) throws SQLException , IdentifierGenerationException { final PreparedStatement ips = conn . prepareStatement ( insert ) ; try { ips . executeUpdate ( ) ; } catch ( final SQLException sqle ) { final String err = "could-not-populate-initiale-hi-value-in:-" + tableName ; log . error ( err , sqle ) ; throw new IdentifierGenerationException ( err ) ; } finally { ips . close ( ) ; } } 
public static final ProcessStartResult start ( final String processClass , final String niceName , int uid , int gid , int [ ] gids , int debugFlags , int mountExternal , int targetSdkVersion , String seInfo , String abi , String [ ] zygoteArgs ) { try { return startViaZygote ( processClass , niceName , uid , gid , gids , debugFlags , mountExternal , targetSdkVersion , seInfo , abi , zygoteArgs ) ; } catch ( ZygoteStartFailedEx ex ) { Log . e ( LOG_TAG , "Starting-VM-process-through-Zygote-failed" ) ; throw new RuntimeException ( "Starting-VM-process-through-Zygote-failed" , ex ) ; } } 
public JSONArray put ( int index , Object value ) throws JSONException { if ( value instanceof Number ) { JSON . checkDouble ( ( ( Number ) value ) . doubleValue ( ) ) ; } while ( values . size ( ) <= index ) { values . add ( null ) ; } values . set ( index , value ) ; return this ; } 
public void unloadImages ( ) { int n = drawables . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) drawables . get ( i ) . unload ( ) ; } 
public Builder withSelectionBackReference ( int selectionArgIndex , int previousResult ) { if ( mType != TYPE_UPDATE && mType != TYPE_DELETE && mType != TYPE_ASSERT ) { throw new IllegalArgumentException ( "only-updates,-deletes,-and-asserts-" + "can-have-selection-back-references" ) ; } if ( mSelectionArgsBackReferences == null ) { mSelectionArgsBackReferences = new HashMap < Integer , Integer > ( ) ; } mSelectionArgsBackReferences . put ( selectionArgIndex , previousResult ) ; return this ; } 
public synchronized Set < Long > keySet ( ) { HashSet < Long > set = new HashSet < Long > ( ) ; for ( Segment < V > s : segments ) { set . addAll ( s . keySet ( ) ) ; } return set ; } 
public static void writeBytes ( DataOutputStream os , byte [ ] bytes , int bytesToWrite ) throws CommandException { try { os . writeInt ( bytesToWrite ) ; os . write ( bytes , 0 , bytesToWrite ) ; } catch ( Exception e ) { throw new UnexpectedExceptionCommandException ( false , e ) ; } } 
protected Stack < ILayoutContainerElement > getContainersStack ( ) { if ( containersStack == null ) { containersStack = new Stack < ILayoutContainerElement > ( ) ; } return containersStack ; } 
@ Override protected void onDraw ( Canvas canvas ) { if ( adaptedImage != null ) canvas . drawBitmap ( adaptedImage , 0 , 0 , paint ) ; } 
public Transform getCombinedTransform ( Vector3f position , Quaternion rotation ) { rotation . mult ( localPos , tmpTransform . getTranslation ( ) ) . addLocal ( position ) ; tmpTransform . setRotation ( rotation ) . getRotation ( ) . multLocal ( localRot ) ; return tmpTransform ; } 
protected int getRowHeight ( ) { if ( rowHeight == 0 ) { FontMetrics metrics = getFontMetrics ( getFont ( ) ) ; rowHeight = metrics . getHeight ( ) ; } return rowHeight ; } 
public void removeSliderListener ( SliderListener l ) { if ( mListeners . contains ( l ) ) { mListeners . remove ( l ) ; } } 
public void keyPressed ( KeyEvent e ) { synchronized ( keyLock ) { keysDown . add ( e . getKeyCode ( ) ) ; } } 
private void doSignal ( Node first ) { do { if ( ( firstWaiter = first . nextWaiter ) == null ) lastWaiter = null ; first . nextWaiter = null ; } while ( ! transferForSignal ( first ) && ( first = firstWaiter ) != null ) ; } 
public List < Extension > getExtension ( ) { if ( extension == null ) { extension = new ArrayList < Extension > ( ) ; } return this . extension ; } 
@ XmlElementDecl ( namespace = "http://www.cisco.com/AXL/API/8.0" , name = "updateCcdAdvertisingService" ) public JAXBElement < UpdateCcdAdvertisingServiceReq > createUpdateCcdAdvertisingService ( UpdateCcdAdvertisingServiceReq value ) { return new JAXBElement < UpdateCcdAdvertisingServiceReq > ( new QName ( "http://www.cisco.com/AXL/API/8.0" , "updateCcdAdvertisingService" ) , UpdateCcdAdvertisingServiceReq . class , null , value ) ; } 
public String getDatabasePath ( ) { if ( dbPath != null ) { return dbPath . toString ( ) ; } else { return null ; } } 
private void drain ( ) { lock . writeLock ( ) . lock ( ) ; try { dispatchesWithoutDrain = 0 ; threadPool . purge ( ) ; for ( Iterator < Entry < Long , SubmittedTask >> it = this . currentPool . entrySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { if ( it . next ( ) . getValue ( ) . future . isDone ( ) ) { it . remove ( ) ; } } } finally { lock . writeLock ( ) . unlock ( ) ; } } 
public static Result newPrepareStatementRequest ( ) { return newResult ( ResultConstants . PREPARE ) ; } 
public static Body create ( final MediaType contentType , final File file ) { if ( contentType == null ) throw new NullPointerException ( "contentType-==-null" ) ; if ( file == null ) throw new NullPointerException ( "content-==-null" ) ; return new Body ( ) { @ Override public MediaType contentType ( ) { return contentType ; } @ Override public long contentLength ( ) { return file . length ( ) ; } @ Override public void writeTo ( OutputStream out ) throws IOException { long length = contentLength ( ) ; if ( length == 0 ) return ; InputStream in = null ; try { in = new FileInputStream ( file ) ; byte [ ] buffer = new byte [ ( int ) Math . min ( 8192 , length ) ] ; for ( int c ; ( c = in . read ( buffer ) ) != - 1 ; ) { out . write ( buffer , 0 , c ) ; } } finally { Util . closeQuietly ( in ) ; } } } ; } 
public SymbolTable analyze ( Node unit , SymbolTable table ) { this . table = table ; isTopLevel = true ; isStmtAsExpr = false ; loops . clear ( ) ; switches . clear ( ) ; checks . clear ( ) ; dispatch ( unit ) ; return table ; } 
private int parseStringToAnInt ( String s ) { if ( s == null ) return 0 ; int result = 0 ; boolean negative = false ; int radix = 10 , i = 0 , max = s . length ( ) ; int limit , multmin , digit ; if ( max > 0 ) { if ( s . charAt ( 0 ) == '-' ) { negative = true ; limit = Integer . MIN_VALUE ; i ++ ; } else { limit = - Integer . MAX_VALUE ; } multmin = limit / radix ; if ( i < max ) { digit = Character . digit ( s . charAt ( i ++ ) , radix ) ; if ( digit < 0 ) return 0 ; else result = - digit ; } while ( i < max ) { digit = Character . digit ( s . charAt ( i ++ ) , radix ) ; if ( digit < 0 ) return 0 ; if ( result < multmin ) return 0 ; result *= radix ; if ( result < limit + digit ) return 0 ; result -= digit ; } } else { return 0 ; } if ( negative ) { if ( i > 1 ) return result ; else return 0 ; } else { return - result ; } } 
public boolean tryTransfer ( E e , long timeout , TimeUnit unit ) throws InterruptedException { if ( xfer ( e , true , TIMED , unit . toNanos ( timeout ) ) == null ) return true ; if ( ! Thread . interrupted ( ) ) return false ; throw new InterruptedException ( ) ; } 
private Set < String > readWhiteListFromFile ( FileReader fr ) throws IOException { Set < String > hashSet = new HashSet < String > ( ) ; BufferedReader br = new BufferedReader ( fr ) ; String str = null ; while ( ( str = br . readLine ( ) ) != null ) { str = str . trim ( ) ; if ( str . startsWith ( "#" ) ) { continue ; } String splits [ ] = str . split ( "-" ) ; if ( splits . length > 1 && ApiChange . contains ( splits [ 1 ] ) ) { String identifier = splits [ 0 ] + ApiDiffGenerator . DELIMITER + splits [ 1 ] ; hashSet . add ( identifier . trim ( ) ) ; } } return hashSet ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
@ XmlElementDecl ( namespace = "http://demo.rules.openl.org/" , name = "DriverRiskResponse" ) public JAXBElement < DriverRiskResponse > createDriverRiskResponse ( DriverRiskResponse value ) { return new JAXBElement < DriverRiskResponse > ( _DriverRiskResponse_QNAME , DriverRiskResponse . class , null , value ) ; } 
private void add ( JClassType type , JMethod method ) { String signature = createSignature ( method ) ; Set < JClassType > declaringClasses = signatureToDeclaringClasses . get ( signature ) ; if ( declaringClasses == null ) { declaringClasses = new HashSet < JClassType > ( ) ; signatureToDeclaringClasses . put ( signature , declaringClasses ) ; } declaringClasses . add ( type ) ; } 
public void add ( PdfNumber number ) { arrayList . add ( new Float ( number . doubleValue ( ) ) ) ; } 
@ Override public Iterator < Locator > iterator ( ) { return m_locators . iterator ( ) ; } 
public static Scanner creaLettore ( ) { Scanner in = new Scanner ( System . in ) ; in . useDelimiter ( System . getProperty ( "line.separator" ) ) ; return in ; } 
public Number asNumber ( String code ) throws ConstantException { Object obj = asObject ( code ) ; if ( ! ( obj instanceof Number ) ) { throw new ConstantException ( this . className , code , "not-a-Number" ) ; } return ( Number ) obj ; } 
public static long getOnProgressThreshold ( ) { return onProgressThreshold . get ( ) ; } 
public int getCurrentWorld ( ) { int world = 0 ; if ( methods . game . isLoggedIn ( ) ) { if ( methods . game . getTab ( ) != Game . Tab . FRIENDS ) { methods . game . openTab ( Game . Tab . FRIENDS ) ; } world = Integer . parseInt ( methods . interfaces . getComponent ( 550 , 19 ) . getText ( ) . replaceAll ( "Friends-List<br>RuneScape-" , "" ) ) ; } else if ( methods . game . getClientState ( ) == Game . INDEX_LOBBY_SCREEN ) { world = methods . lobby . getSelectedWorld ( ) ; } return world ; } 
@ Override public boolean equals ( Object object ) { if ( object == this ) return true ; if ( ! ( object instanceof Monitor ) ) return false ; Monitor monitor = ( Monitor ) object ; return handle == monitor . handle ; } 
public static Request newStatusUpdateRequest ( Session session , String message , Callback callback ) { return newStatusUpdateRequest ( session , message , ( String ) null , null , callback ) ; } 
public static Pair < IFile , IRegion > createXmlFile ( IProject project , IFile file , ResourceFolderType folderType ) { TypeInfo type = NewXmlFileCreationPage . getTypeInfo ( folderType ) ; String xmlns = type . getXmlns ( ) ; String root = type . getDefaultRoot ( project ) ; if ( root == null ) { root = type . getRootSeed ( ) . toString ( ) ; } String attrs = type . getDefaultAttrs ( project , root ) ; return createXmlFile ( file , xmlns , root , attrs , null , folderType ) ; } 
@ XmlElementDecl ( namespace = "urn:ebay:apis:eBLBaseComponents" , name = "GetDisputeResponse" ) public JAXBElement < GetDisputeResponseType > createGetDisputeResponse ( GetDisputeResponseType value ) { return new JAXBElement < GetDisputeResponseType > ( _GetDisputeResponse_QNAME , GetDisputeResponseType . class , null , value ) ; } 
public com . google . protobuf . ByteString getSideBytes ( ) { java . lang . Object ref = side_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; side_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
private void initializeBackupID ( ) { SimpleDateFormat dateFormat = new SimpleDateFormat ( ServerConstants . DATE_FORMAT_COMPACT_LOCAL_TIME ) ; final String id = dateFormat . format ( new Date ( ) ) ; backupID . setText ( id ) ; } 
private void writeQNameAttribute ( java . lang . String namespace , java . lang . String attName , javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String attributeNamespace = qname . getNamespaceURI ( ) ; java . lang . String attributePrefix = xmlWriter . getPrefix ( attributeNamespace ) ; if ( attributePrefix == null ) { attributePrefix = registerPrefix ( xmlWriter , attributeNamespace ) ; } java . lang . String attributeValue ; if ( attributePrefix . trim ( ) . length ( ) > 0 ) { attributeValue = attributePrefix + ":" + qname . getLocalPart ( ) ; } else { attributeValue = qname . getLocalPart ( ) ; } if ( namespace . equals ( "" ) ) { xmlWriter . writeAttribute ( attName , attributeValue ) ; } else { registerPrefix ( xmlWriter , namespace ) ; xmlWriter . writeAttribute ( namespace , attName , attributeValue ) ; } } 
public boolean isPrivate ( ) { return java . lang . reflect . Modifier . isPrivate ( member ( ) . getModifiers ( ) ) ; } 
public ParseException generateParseException ( ) { jj_expentries . clear ( ) ; boolean [ ] la1tokens = new boolean [ 71 ] ; if ( jj_kind >= 0 ) { la1tokens [ jj_kind ] = true ; jj_kind = - 1 ; } for ( int i = 0 ; i < 33 ; i ++ ) { if ( jj_la1 [ i ] == jj_gen ) { for ( int j = 0 ; j < 32 ; j ++ ) { if ( ( jj_la1_0 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ j ] = true ; } if ( ( jj_la1_1 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 32 + j ] = true ; } if ( ( jj_la1_2 [ i ] & ( 1 << j ) ) != 0 ) { la1tokens [ 64 + j ] = true ; } } } } for ( int i = 0 ; i < 71 ; i ++ ) { if ( la1tokens [ i ] ) { jj_expentry = new int [ 1 ] ; jj_expentry [ 0 ] = i ; jj_expentries . add ( jj_expentry ) ; } } int [ ] [ ] exptokseq = new int [ jj_expentries . size ( ) ] [ ] ; for ( int i = 0 ; i < jj_expentries . size ( ) ; i ++ ) { exptokseq [ i ] = ( int [ ] ) jj_expentries . get ( i ) ; } return new ParseException ( token , exptokseq , tokenImage ) ; } 
private static void listTests ( ) { System . out . println ( "Availible-Tests-for-" + userName ) ; System . out . println ( "0:-Exit" ) ; System . out . println ( "1:-Multi-phone-enable-/-disable" ) ; System . out . println ( "2:-Inbox-paging" ) ; System . out . println ( "3:-Call-Announcement-Settings-(Presentation)" ) ; System . out . println ( "4:-Set-Default-Voicemail-Greeting" ) ; System . out . println ( "5:-Change-do-not-disturb-setting." ) ; System . out . println ( "6:-Change-Group-settings." ) ; System . out . println ( "7:-Read-all-settings-and-print-them-(cached)" ) ; System . out . println ( "8:-Read-all-settings-and-print-them-(uncached)" ) ; System . out . println ( "9:-Read-all-settings---pure-json-driven---flat-data" ) ; System . out . println ( "10:-Read-all-settings---pure-json-driven---actual-account-data" ) ; System . out . println ( "11:-Update-Group-Settings" ) ; System . out . println ( "12:-Group-settings-isPhoneEnabled-tests" ) ; System . out . println ( "13:-List-Default-Phones-and-Enabled/Disabled-Setting" ) ; System . out . println ( "14:-Send-SMS" ) ; System . out . println ( "15:-Check-SMS" ) ; System . out . println ( "16:-Captcha-Test" ) ; int testNr = 0 ; try { testNr = Integer . parseInt ( br . readLine ( ) ) ; } catch ( Exception e ) { System . out . println ( "Error-trying-to-read-the-testNr!" + e . getMessage ( ) ) ; System . exit ( 1 ) ; } runTest ( userName , pass , testNr ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public int [ ] getWinners ( long [ ] scores ) { int [ ] indices = new int [ scores . length ] ; if ( indices . length == 0 ) return indices ; indices [ 0 ] = 0 ; int lastIndex = - 1 ; for ( int i = 0 ; i < scores . length ; i ++ ) { if ( scores [ i ] > 0 ) if ( scores [ i ] > scores [ indices [ 0 ] ] ) { indices [ 0 ] = i ; lastIndex = 0 ; } else if ( scores [ i ] == scores [ indices [ 0 ] ] ) { indices [ ++ lastIndex ] = i ; } } int [ ] ret = new int [ lastIndex + 1 ] ; if ( ret . length > 0 ) System . arraycopy ( indices , 0 , ret , 0 , lastIndex + 1 ) ; return ret ; } 
public static String formatSTR_MESSAGEBOX_TITLE ( Object ... arguments ) { return format ( STR_MESSAGEBOX_TITLE , arguments ) ; } 
public byte [ ] getEncoded ( ) throws IOException { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; ASN1OutputStream aOut = new ASN1OutputStream ( bOut ) ; aOut . writeObject ( req ) ; return bOut . toByteArray ( ) ; } 
public static String getTempDirectoryPath ( Context ctx ) { File cache = null ; if ( Environment . getExternalStorageState ( ) . equals ( Environment . MEDIA_MOUNTED ) ) { cache = new File ( Environment . getExternalStorageDirectory ( ) . getAbsolutePath ( ) + "/Android/data/" + ctx . getPackageName ( ) + "/cache/" ) ; } else { cache = ctx . getCacheDir ( ) ; } if ( ! cache . exists ( ) ) { cache . mkdirs ( ) ; } return cache . getAbsolutePath ( ) ; } 
public static final char [ ] getAlphabet ( ) { char [ ] clone = new char [ ALPHABET . length ] ; System . arraycopy ( ALPHABET , 0 , clone , 0 , ALPHABET . length ) ; return clone ; } 
@ XmlElementDecl ( namespace = "http://www.i2b2.org/xsd/cell/ont/1.1/" , name = "get_dirty_state" ) public JAXBElement < GetReturnType > createGetDirtyState ( GetReturnType value ) { return new JAXBElement < GetReturnType > ( _GetDirtyState_QNAME , GetReturnType . class , null , value ) ; } 
public static Status createStatus ( Object item , Map status , List children ) { return createStatus ( item , new Vector ( status . keySet ( ) ) , children ) ; } 
public void suspendEncoding ( ) throws java . io . IOException { flushBase64 ( ) ; this . suspendEncoding = true ; } 
private void socksConnect ( InetAddress applicationServerAddress , int applicationServerPort , int timeout ) throws IOException { try { IoBridge . connect ( fd , socksGetServerAddress ( ) , socksGetServerPort ( ) , timeout ) ; } catch ( Exception e ) { throw new SocketException ( "SOCKS-connection-failed" , e ) ; } socksRequestConnection ( applicationServerAddress , applicationServerPort ) ; lastConnectedAddress = applicationServerAddress ; lastConnectedPort = applicationServerPort ; } 
public static int offsetByCodePoints ( char [ ] seq , int start , int count , int index , int codePointOffset ) { if ( seq == null ) { throw new NullPointerException ( ) ; } int end = start + count ; if ( start < 0 || count < 0 || end > seq . length || index < start || index > end ) { throw new IndexOutOfBoundsException ( ) ; } if ( codePointOffset == 0 ) { return index ; } if ( codePointOffset > 0 ) { int codePoints = codePointOffset ; int i = index ; while ( codePoints > 0 ) { codePoints -- ; if ( i >= end ) { throw new IndexOutOfBoundsException ( ) ; } if ( isHighSurrogate ( seq [ i ] ) ) { int next = i + 1 ; if ( next < end && isLowSurrogate ( seq [ next ] ) ) { i ++ ; } } i ++ ; } return i ; } assert codePointOffset < 0 ; int codePoints = - codePointOffset ; int i = index ; while ( codePoints > 0 ) { codePoints -- ; i -- ; if ( i < start ) { throw new IndexOutOfBoundsException ( ) ; } if ( isLowSurrogate ( seq [ i ] ) ) { int prev = i - 1 ; if ( prev >= start && isHighSurrogate ( seq [ prev ] ) ) { i -- ; } } } return i ; } 
private void mergeForceCollapse ( ) { while ( stackSize > 1 ) { int n = stackSize - 2 ; if ( n > 0 && runLen [ n - 1 ] < runLen [ n + 1 ] ) n -- ; mergeAt ( n ) ; } } 
synchronized void dump ( ) { HttpLog . v ( "dump()" ) ; StringBuilder dump = new StringBuilder ( ) ; int count = 0 ; Iterator < Map . Entry < HttpHost , LinkedList < Request >>> iter ; if ( ! mPending . isEmpty ( ) ) { iter = mPending . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < HttpHost , LinkedList < Request >> entry = iter . next ( ) ; String hostName = entry . getKey ( ) . getHostName ( ) ; StringBuilder line = new StringBuilder ( "p" + count ++ + "-" + hostName + "-" ) ; LinkedList < Request > reqList = entry . getValue ( ) ; ListIterator reqIter = reqList . listIterator ( 0 ) ; while ( iter . hasNext ( ) ) { Request request = ( Request ) iter . next ( ) ; line . append ( request + "-" ) ; } dump . append ( line ) ; dump . append ( "-" ) ; } } HttpLog . v ( dump . toString ( ) ) ; } 
private String updateValueInCommaSeparatedList ( String list , String key , String newValue ) { StringBuilder newPrefList = new StringBuilder ( ) ; if ( TextUtils . isEmpty ( list ) ) { newPrefList . append ( key ) . append ( ':' ) . append ( newValue ) ; } else { String [ ] prefValues = list . split ( "," ) ; boolean first = true ; boolean found = false ; for ( String value : prefValues ) { final int delimiter = value . indexOf ( ':' ) ; if ( delimiter > 0 ) { if ( key . equals ( value . substring ( 0 , delimiter ) ) ) { if ( first ) { first = false ; } else { newPrefList . append ( ',' ) ; } found = true ; newPrefList . append ( key ) . append ( ':' ) . append ( newValue ) ; } else { if ( first ) { first = false ; } else { newPrefList . append ( ',' ) ; } newPrefList . append ( value ) ; } } } if ( ! found ) { newPrefList . append ( ',' ) ; newPrefList . append ( key ) . append ( ':' ) . append ( newValue ) ; } } return newPrefList . toString ( ) ; } 
public String getAttributeIndices ( ) { return m_SelectedCols . getRanges ( ) ; } 
public int getEntriesCount ( ) { return entries . size ( ) ; } 
public int hashCode ( ) { int code = 17 ; code = 37 * code + name . hashCode ( ) ; code = 37 * code + phone . hashCode ( ) ; code = 37 * code + address . hashCode ( ) ; return code ; } 
private JScrollPane getJScrollPane ( ) { if ( jScrollPane == null ) { jScrollPane = new JScrollPane ( ) ; jScrollPane . setViewportView ( getJTextArea ( ) ) ; } return jScrollPane ; } 
protected Rectangle parseRect ( Map < String , Object > cdata , String name , Rectangle def ) { String value = ( String ) cdata . get ( name ) ; Rectangle rect = parseRect ( name , value ) ; return ( rect == null ) ? def : rect ; } 
public String pToConsole ( Process p ) throws Exception { String line = null ; BufferedReader br = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; StringBuffer strBuf = new StringBuffer ( ) ; while ( ( line = br . readLine ( ) ) != null ) { strBuf . append ( line ) ; strBuf . append ( "-" ) ; } br . close ( ) ; return strBuf . toString ( ) ; } 
public void addImage ( File file , int workspaceID ) { myWorkspaces . get ( workspaceID ) . addImage ( file . getName ( ) ) ; } 
public static void replaceUIInputMap ( JComponent component , int type , InputMap uiInputMap ) { InputMap map = component . getInputMap ( type , ( uiInputMap != null ) ) ; while ( map != null ) { InputMap parent = map . getParent ( ) ; if ( parent == null || ( parent instanceof UIResource ) ) { map . setParent ( uiInputMap ) ; return ; } map = parent ; } } 
public static int getContentWidth ( ) { return mFrame . getContentPane ( ) . getWidth ( ) ; } 
protected void appendSerializableType ( StringBuilder sb , FieldType fieldType , int fieldWidth ) { sb . append ( "BLOB" ) ; } 
private synchronized void rebuildJournal ( ) throws IOException { if ( journalWriter != null ) { journalWriter . close ( ) ; } Writer writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( journalFileTmp ) , Util . US_ASCII ) ) ; try { writer . write ( MAGIC ) ; writer . write ( "-" ) ; writer . write ( VERSION_1 ) ; writer . write ( "-" ) ; writer . write ( Integer . toString ( appVersion ) ) ; writer . write ( "-" ) ; writer . write ( Integer . toString ( valueCount ) ) ; writer . write ( "-" ) ; writer . write ( "-" ) ; for ( Entry entry : lruEntries . values ( ) ) { if ( entry . currentEditor != null ) { writer . write ( DIRTY + '-' + entry . key + '|n' ) ; } else { writer . write ( CLEAN + '-' + entry . key + entry . getLengths ( ) + '|n' ) ; } } } finally { writer . close ( ) ; } if ( journalFile . exists ( ) ) { renameTo ( journalFile , journalFileBackup , true ) ; } renameTo ( journalFileTmp , journalFile , false ) ; journalFileBackup . delete ( ) ; journalWriter = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( journalFile , true ) , Util . US_ASCII ) ) ; } 
public Object getAttribute ( String name ) throws IllegalArgumentException { if ( name . equals ( FEATURE_INCREMENTAL ) ) { return new Boolean ( m_incremental ) ; } else if ( name . equals ( FEATURE_OPTIMIZE ) ) { return new Boolean ( m_optimize ) ; } else if ( name . equals ( FEATURE_SOURCE_LOCATION ) ) { return new Boolean ( m_source_location ) ; } else throw new IllegalArgumentException ( XSLMessages . createMessage ( XSLTErrorResources . ER_ATTRIB_VALUE_NOT_RECOGNIZED , new Object [ ] { name } ) ) ; } 
private final void dispatachChars ( int node ) throws org . xml . sax . SAXException { m_dtm . dispatchCharactersEvents ( node , m_contentHandler , false ) ; } 
public String toReplacerPattern ( boolean escapeUnprintable ) { StringBuffer rule = new StringBuffer ( "$" ) ; Utility . appendNumber ( rule , segmentNumber , 10 , 1 ) ; return rule . toString ( ) ; } 
private int [ ] createEmptySetOfIntegers ( int max ) { firstWordNotUsed = 0 ; int [ ] arr = new int [ arrayIndex ( max - 1 ) + 1 ] ; return arr ; } 
public int getUnitIncrement ( int direction ) { JViewport vp = getViewport ( ) ; if ( ! unitIncrementSet && ( vp != null ) && ( vp . getView ( ) instanceof Scrollable ) ) { Scrollable view = ( Scrollable ) ( vp . getView ( ) ) ; Rectangle vr = vp . getViewRect ( ) ; return view . getScrollableUnitIncrement ( vr , getOrientation ( ) , direction ) ; } else { return super . getUnitIncrement ( direction ) ; } } 
public static void disposeAll ( ) { for ( Font font : fontMap . values ( ) ) { font . dispose ( ) ; } fontMap . clear ( ) ; } 
private Integer getIntegerObject ( String timeString ) { Integer rv = null ; int max_length = Integer . valueOf ( Integer . MAX_VALUE ) . toString ( ) . length ( ) ; if ( timeString . length ( ) > max_length ) { timeString = timeString . substring ( 0 , max_length ) ; } try { rv = Integer . parseInt ( timeString ) ; } catch ( Exception e ) { log . warn ( this + ":getIntegerObject-" + e . getMessage ( ) ) ; } return rv ; } 
protected Response createResponse ( Request request ) { return new Response ( request ) ; } 
private String [ ] parseTypeName ( String qualifiedName ) { String [ ] names = new String [ 2 ] ; String pkgName ; String fname ; int idx = qualifiedName . lastIndexOf ( '.' ) ; if ( idx > 0 ) { pkgName = qualifiedName . substring ( 0 , idx ) ; fname = qualifiedName . substring ( idx + 1 , qualifiedName . length ( ) ) + ".java" ; } else { pkgName = "" ; fname = qualifiedName + ".java" ; } names [ 0 ] = pkgName ; names [ 1 ] = fname ; return names ; } 
public static void saveZoomWindow ( Mandelbrot horse , File file ) throws FileNotFoundException , IOException { Stack < ZoomWindow > tzsq = new Stack < ZoomWindow > ( ) ; tzsq . push ( horse . getZoomWindow ( ) ) ; ObjectOutputStream oos = new ObjectOutputStream ( new FileOutputStream ( file ) ) ; oos . writeObject ( tzsq ) ; oos . writeObject ( horse . getFormulaContainer ( ) ) ; oos . writeInt ( horse . getIter ( ) ) ; oos . writeDouble ( horse . getBailout ( ) ) ; oos . close ( ) ; } 
protected boolean isUnsafe ( char ch ) { return UNSAFE_CHARS . indexOf ( ch ) >= 0 ; } 
public static Session getMyGmailSession ( ) { Properties props = new Properties ( ) ; props . put ( "mail.smtp.host" , "smtp.gmail.com" ) ; props . put ( "mail.smtp.socketFactory.port" , "465" ) ; props . put ( "mail.smtp.socketFactory.class" , "javax.net.ssl.SSLSocketFactory" ) ; props . put ( "mail.smtp.auth" , "true" ) ; props . put ( "mail.smtp.port" , "465" ) ; Session session = Session . getDefaultInstance ( props , new javax . mail . Authenticator ( ) { protected javax . mail . PasswordAuthentication getPasswordAuthentication ( ) { return new javax . mail . PasswordAuthentication ( ApplicationConstants . GMAIL_SESSION_USERNAME , ApplicationConstants . GMAIL_SESSION_PASSWORD ) ; } } ) ; return session ; } 
public void addListener ( PrivacyListEventListener listener ) { if ( listener == null ) { throw new NullPointerException ( ) ; } listeners . add ( listener ) ; } 
public void LoadFromFile ( String fileName ) throws ParserConfigurationException , IOException , SAXException { URL u = this . getClass ( ) . getClassLoader ( ) . getResource ( fileName ) ; InputStream is = u . openStream ( ) ; DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; factory . setNamespaceAware ( true ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; _doc = builder . parse ( is ) ; } 
public boolean removeConnectionFactory ( ConnectionFactory vConnectionFactory ) { boolean removed = _connectionFactoryList . remove ( vConnectionFactory ) ; return removed ; } 
@ XmlElementDecl ( namespace = "http://server.webservice.javaee.tp.m1/" , name = "joinEchiquier" ) public JAXBElement < JoinEchiquier > createJoinEchiquier ( JoinEchiquier value ) { return new JAXBElement < JoinEchiquier > ( _JoinEchiquier_QNAME , JoinEchiquier . class , null , value ) ; } 
public static View getInstance ( Controller ins ) { if ( ! exist ) { controller = ins ; } if ( controller != null ) { exist = true ; instance = new View ( ) ; return instance ; } return null ; } 
public void setLine ( String [ ] words , int line ) { ArrayList current_line = ( ArrayList ) lines_ . get ( line ) ; current_line . clear ( ) ; for ( int i = 0 ; i < words . length ; i ++ ) current_line . add ( words [ i ] ) ; } 
private Route nextPostponed ( ) { return postponedRoutes . remove ( 0 ) ; } 
public static void minus ( float [ ] a , float [ ] b , float [ ] result ) { float [ ] res = ( result == null ) ? a : result ; for ( int i = 0 ; i < Math . min ( a . length , b . length ) ; i ++ ) res [ i ] = a [ i ] - b [ i ] ; } 
public URI ( URI p_base , String p_uriSpec ) throws MalformedURIException { initialize ( p_base , p_uriSpec ) ; } 
public com . google . protobuf . ByteString getNameBytes ( ) { java . lang . Object ref = name_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; name_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } } 
public KJUScriptObject eval ( Context context ) throws KJUScriptException { if ( receiver == null && arguments == null && context . hasLocal ( method ) ) { return context . getLocal ( method ) ; } KJUScriptObject evaledReceiver ; if ( receiver == null ) { evaledReceiver = context . getCurrentSelf ( ) ; } else { evaledReceiver = receiver . eval ( context ) ; } ArrayList < KJUScriptObject > evaledArguments = new ArrayList < KJUScriptObject > ( ) ; if ( arguments != null ) { for ( Node arg : arguments ) evaledArguments . add ( arg . eval ( context ) ) ; } return evaledReceiver . call ( method , ( KJUScriptObject [ ] ) evaledArguments . toArray ( new KJUScriptObject [ 0 ] ) ) ; } 
public static List getConstructors ( final Class cl , final int params ) { final List result = new LinkedList ( ) ; final Constructor [ ] ms = cl . getDeclaredConstructors ( ) ; for ( int i = 0 ; i < ms . length ; i ++ ) { if ( ms [ i ] . getParameterTypes ( ) . length == params ) { result . add ( ms [ i ] ) ; } } return result ; } 
public void selectAll ( ) { if ( isEditing ( ) ) { removeEditor ( ) ; } if ( getRowCount ( ) > 0 && getColumnCount ( ) > 0 ) { int oldLead ; int oldAnchor ; ListSelectionModel selModel ; selModel = selectionModel ; selModel . setValueIsAdjusting ( true ) ; oldLead = getAdjustedIndex ( selModel . getLeadSelectionIndex ( ) , true ) ; oldAnchor = getAdjustedIndex ( selModel . getAnchorSelectionIndex ( ) , true ) ; setRowSelectionInterval ( 0 , getRowCount ( ) - 1 ) ; SwingUtilities2 . setLeadAnchorWithoutSelection ( selModel , oldLead , oldAnchor ) ; selModel . setValueIsAdjusting ( false ) ; selModel = columnModel . getSelectionModel ( ) ; selModel . setValueIsAdjusting ( true ) ; oldLead = getAdjustedIndex ( selModel . getLeadSelectionIndex ( ) , false ) ; oldAnchor = getAdjustedIndex ( selModel . getAnchorSelectionIndex ( ) , false ) ; setColumnSelectionInterval ( 0 , getColumnCount ( ) - 1 ) ; SwingUtilities2 . setLeadAnchorWithoutSelection ( selModel , oldLead , oldAnchor ) ; selModel . setValueIsAdjusting ( false ) ; } } 
@ XmlElementDecl ( namespace = "urn:uddi-org:api_v2" , name = "save_tModel" ) public JAXBElement < SaveTModel > createSaveTModel ( SaveTModel value ) { return new JAXBElement < SaveTModel > ( _SaveTModel_QNAME , SaveTModel . class , null , value ) ; } 
